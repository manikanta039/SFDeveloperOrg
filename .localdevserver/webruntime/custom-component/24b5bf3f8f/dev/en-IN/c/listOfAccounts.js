Webruntime.define('lwc/listOfAccounts', ['lwc', 'lightning/configProvider', 'c/accountModal', 'wire-service', 'instrumentation/service', 'aura', 'logger', 'aura-storage'], function (lwc, configProvider, _cAccountModal, wireService, service, aura, logger, auraStorage) { 'use strict';

    _cAccountModal = _cAccountModal && Object.prototype.hasOwnProperty.call(_cAccountModal, 'default') ? _cAccountModal['default'] : _cAccountModal;
    auraStorage = auraStorage && Object.prototype.hasOwnProperty.call(auraStorage, 'default') ? auraStorage['default'] : auraStorage;

    function stylesheet(hostSelector, shadowSelector, nativeShadow) {
      return ".THIS" + shadowSelector + " .table-test" + shadowSelector + " thead" + shadowSelector + " tr" + shadowSelector + " th" + shadowSelector + " span" + shadowSelector + " {background-color: #16325c;color: white}\n";
    }
    var _implicitStylesheets = [stylesheet];

    function stylesheet$1(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n[dir=\"rtl\"] input[type=\"tel\"]" + shadowSelector + " {direction: ltr;text-align: right;unicode-bidi: embed;}\n";
    }
    var _implicitStylesheets$1 = [stylesheet$1];

    function stylesheet$2(hostSelector, shadowSelector, nativeShadow) {
      return "_:-ms-lang(x)" + shadowSelector + ", svg" + shadowSelector + " {pointer-events: none;}\n";
    }
    var _implicitStylesheets$2 = [stylesheet$2];

    function tmpl($api, $cmp, $slotset, $ctx) {
      const {
        fid: api_scoped_frag_id,
        h: api_element
      } = $api;
      return [api_element("svg", {
        className: $cmp.computedClass,
        attrs: {
          "focusable": "false",
          "data-key": $cmp.name,
          "aria-hidden": "true"
        },
        key: 1
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", api_scoped_frag_id($cmp.href))
        },
        key: 0
      }, [])])];
    }

    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];

    if (_implicitStylesheets$2) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets$2);
    }
    tmpl.stylesheetTokens = {
      hostAttribute: "lightning-primitiveIcon_primitiveIcon-host",
      shadowAttribute: "lightning-primitiveIcon_primitiveIcon"
    };

    var dir = 'ltr';

    const proto = {
      add(className) {
        if (typeof className === 'string') {
          this[className] = true;
        } else {
          Object.assign(this, className);
        }

        return this;
      },

      invert() {
        Object.keys(this).forEach(key => {
          this[key] = !this[key];
        });
        return this;
      },

      toString() {
        return Object.keys(this).filter(key => this[key]).join(' ');
      }

    };
    function classSet(config) {
      if (typeof config === 'string') {
        const key = config;
        config = {};
        config[key] = true;
      }

      return Object.assign(Object.create(proto), config);
    }

    const inputableNode = /input|select|textarea|button|object/;

    function visible(element) {
      const {
        width,
        height
      } = element.getBoundingClientRect();
      const noZeroSize = width > 0 || height > 0;
      return noZeroSize && window.getComputedStyle(element).visibility !== 'hidden';
    }

    function focusable(element) {
      const nodeName = element.tagName.toLowerCase();
      const res = inputableNode.test(nodeName) && !element.disabled || nodeName === 'a' && element.href;
      return res && visible(element);
    }

    function tabbable(element) {
      const isDataActionable = element.getAttribute('data-navigation') === 'enable';
      const tabIndex = element.tabIndex;
      return tabIndex >= 0 && focusable(element) || isDataActionable;
    }

    function queryFocusable(element) {
      return [].slice.call(element.querySelectorAll('*'), 0).filter(tabbable);
    }

    function assert(condition, message) {
      {
        if (!condition) {
          throw new Error(message);
        }
      }
    }

    /**
     * Create a deep copy of an object or array
     * @param {object|array} obj - item to be copied
     * @returns {object|array} copy of the item
     */
    function deepCopy(obj) {
      if (Object(obj) !== obj) {
        // primitives
        return obj;
      }

      if (obj instanceof Set) {
        return new Set(obj);
      }

      if (obj instanceof Date) {
        return new Date(obj);
      }

      if (typeof obj === 'function') {
        return obj.bind({});
      }

      if (Array.isArray(obj)) {
        const obj2 = [];
        const len = obj.length;

        for (let i = 0; i < len; i++) {
          obj2.push(deepCopy(obj[i]));
        }

        return obj2;
      }

      const result = Object.create({});
      let keys = Object.keys(obj);

      if (obj instanceof Error) {
        // Error properties are non-enumerable
        keys = Object.getOwnPropertyNames(obj);
      }

      const len = keys.length;

      for (let i = 0; i < len; i++) {
        const key = keys[i];
        result[key] = deepCopy(obj[key]);
      }

      return result;
    }
    const ArraySlice = Array.prototype.slice;

    /**
    An emitter implementation based on the Node.js EventEmitter API:
    https://nodejs.org/dist/latest-v6.x/docs/api/events.html#events_class_eventemitter
    **/

    class EventEmitter {
      constructor() {
        this.registry = {};
      }
      /**
      Registers a listener on the emitter
      @method EventEmitter#on
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      on(name, listener) {
        this.registry[name] = this.registry[name] || [];
        this.registry[name].push(listener);
        return this;
      }
      /**
      Registers a listener on the emitter that only executes once
      @method EventEmitter#once
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      once(name, listener) {
        const doOnce = function () {
          listener.apply(null, arguments);
          this.removeListener(name, doOnce);
        }.bind(this);

        this.on(name, doOnce);
        return this;
      }
      /**
      Synchronously calls each listener registered with the specified event
      @method EventEmitter#emit
      @param {String} name - The name of the event
      @return {Boolean} - Returns `true` if the event had listeners, `false` otherwise
      **/


      emit(name) {
        const args = ArraySlice.call(arguments, 1);
        const listeners = this.registry[name];
        let count = 0;

        if (listeners) {
          listeners.forEach(listener => {
            count += 1;
            listener.apply(null, args);
          });
        }

        return count > 0;
      }
      /**
      Removes the specified `listener` from the listener array for the event named `name`
      @method EventEmitter#removeListener
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      removeListener(name, listener) {
        const listeners = this.registry[name];

        if (listeners) {
          for (let i = 0, len = listeners.length; i < len; i += 1) {
            if (listeners[i] === listener) {
              listeners.splice(i, 1);
              return this;
            }
          }
        }

        return this;
      }

    }

    var locale = 'en-US';

    const NA_PHONE_NUMBER = '($1) $2-$3';
    const IS_TEN_DIGITS = /^\d{10}$/;
    const TEN_TO_NA = /(\d{3})(\d{3})(\d{4})/;
    const IS_ELEVEN_DIGITS = /^1\d{10}/;
    const ELEVEN_TO_NA = /1(\d{3})(\d{3})(\d{4})$/; // The locale argument has been added for tests since there's currently no clean way of mocking the locale

    function toNorthAmericanPhoneNumber(value, userLocale) {
      if (!isNorthAmericanCountry(userLocale || locale)) {
        return value;
      }

      if (IS_TEN_DIGITS.test(value)) {
        return value.replace(TEN_TO_NA, NA_PHONE_NUMBER);
      } else if (IS_ELEVEN_DIGITS.test(value)) {
        return value.replace(ELEVEN_TO_NA, NA_PHONE_NUMBER);
      }

      return value || '';
    }

    function isNorthAmericanCountry(userLocale) {
      const localeCountry = getLocaleCountry(userLocale);

      if (localeCountry === 'US' || localeCountry === 'CA') {
        return true;
      }

      return false;
    }

    function getLocaleCountry(userLocale) {
      if (!userLocale) {
        // just adding a guard in case locale is undefined
        return null;
      }

      const [, country] = userLocale.split('-');
      return country;
    }

    const urlRegexString = "((?:(?:https?|ftp):\\/\\/(?:[\\w\\-\\|=%~#\\/+*@\\.,;:\\?!']|&){0,2047}(?:[\\(\\)\\.\\w=\\/+#-]*)[^\\s()\\.<>,;\\[\\]`'\"])|(?:\\b(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW)(?!@(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW))(?:/[\\w\\-=?/.&;:%~,+@#*]{0,2048}(?:[\\w=/+#-]|\\([^\\s()]*\\)))?(?:$|(?=\\.$)|(?=\\.\\s)|(?=[^\\w\\.]))))";
    const emailRegexString = '([\\w-\\.\\+_]{1,64}@(?:[\\w-]){1,255}(?:\\.[\\w-]{1,255}){1,10})';
    const newLineRegexString = '(\r\n|\r|\n)';
    const createHttpHref = function (url) {
      let href = url;

      if (url.toLowerCase().lastIndexOf('http', 0) !== 0 && url.toLowerCase().lastIndexOf('ftp', 0) !== 0) {
        href = `http://${href}`;
      }

      return href;
    };
    const createEmailHref = function (email) {
      return `mailto:${email}`;
    };

    /**
     * Utility function to generate an unique guid.
     * used on state objects to provide a performance aid when iterating
     * through the items and marking them for render
     * @returns {String} an unique string ID
     */
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }

      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }

    function classListMutation(classList, config) {
      Object.keys(config).forEach(key => {
        if (typeof key === 'string' && key.length) {
          if (config[key]) {
            classList.add(key);
          } else {
            classList.remove(key);
          }
        }
      });
    }

    /**
    A string normalization utility for attributes.
    @param {String} value - The value to normalize.
    @param {Object} config - The optional configuration object.
    @param {String} [config.fallbackValue] - The optional fallback value to use if the given value is not provided or invalid. Defaults to an empty string.
    @param {Array} [config.validValues] - An optional array of valid values. Assumes all input is valid if not provided.
    @return {String} - The normalized value.
    **/
    function normalizeString(value, config = {}) {
      const {
        fallbackValue = '',
        validValues,
        toLowerCase = true
      } = config;
      let normalized = typeof value === 'string' && value.trim() || '';
      normalized = toLowerCase ? normalized.toLowerCase() : normalized;

      if (validValues && validValues.indexOf(normalized) === -1) {
        normalized = fallbackValue;
      }

      return normalized;
    }
    /**
    A boolean normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/

    function normalizeBoolean(value) {
      return typeof value === 'string' || !!value;
    }
    /**
    A aria attribute normalization utility.
    @param {Any} value - A single aria value or an array of aria values
    @return {String} - A space separated list of aria values
    **/

    function normalizeAriaAttribute(value) {
      let arias = Array.isArray(value) ? value : [value];
      arias = arias.map(ariaValue => {
        if (typeof ariaValue === 'string') {
          return ariaValue.replace(/\s+/g, ' ').trim();
        }

        return '';
      }).filter(ariaValue => !!ariaValue);
      return arias.length > 0 ? arias.join(' ') : null;
    }

    const keyCodes = {
      tab: 9,
      backspace: 8,
      enter: 13,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      delete: 46,
      shift: 16
    }; // Acceptable values are defined here: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
    // remove this function when IE11 support is dropped

    function normalizeKeyValue(value) {
      switch (value) {
        case 'Spacebar':
          return ' ';

        case 'Esc':
          return 'Escape';

        case 'Del':
          return 'Delete';

        case 'Left':
          return 'ArrowLeft';

        case 'Right':
          return 'ArrowRight';

        case 'Down':
          return 'ArrowDown';

        case 'Up':
          return 'ArrowUp';

        default:
          return value;
      }
    }
    const buffer = {};
    function isShiftMetaOrControlKey(event) {
      return event.shiftKey || event.metaKey || event.ctrlKey;
    }
    /**
     * Runs an action and passes the string of buffered keys typed within a short time period.
     * Use for type-ahead like functionality in menus, lists, comboboxes, and similar components.
     *
     * @param {CustomEvent} event A keyboard event
     * @param {Function} action function to run, it's passed the buffered text
     */

    function runActionOnBufferedTypedCharacters(event, action) {
      const letter = event.key;

      if (letter.length > 1) {
        // Not an individual character/letter, but rather a special code (like Shift, Backspace, etc.)
        return;
      } // If we were going to clear what keys were typed, don't yet.


      if (buffer._clearBufferId) {
        clearTimeout(buffer._clearBufferId);
      }

      buffer._keyBuffer = buffer._keyBuffer || [];

      buffer._keyBuffer.push(letter);

      const matchText = buffer._keyBuffer.join('').toLowerCase();

      action(matchText); // eslint-disable-next-line @lwc/lwc/no-async-operation

      buffer._clearBufferId = setTimeout(() => {
        buffer._keyBuffer = [];
      }, 700);
    }

    function raf(fn) {
      let ticking = false;
      return function (event) {
        if (!ticking) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            fn.call(this, event);
            ticking = false;
          });
        }

        ticking = true;
      };
    }

    const isIE11 = isIE11Test(navigator);
    const isChrome = isChromeTest(navigator);
    const isSafari = isSafariTest(window.safari); // The following functions are for tests only

    function isIE11Test(navigator) {
      // https://stackoverflow.com/questions/17447373/how-can-i-target-only-internet-explorer-11-with-javascript
      return /Trident.*rv[ :]*11\./.test(navigator.userAgent);
    }
    function isChromeTest(navigator) {
      // https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome
      return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }
    function isSafariTest(safari) {
      // via https://stackoverflow.com/a/9851769
      return safari && safari.pushNotification && safari.pushNotification.toString() === '[object SafariRemoteNotification]';
    }

    /**
     * Set an attribute on an element, if it's a normal element
     * it will use setAttribute, if it's an LWC component
     * it will use the public property
     *
     * @param {HTMLElement} element The element to act on
     * @param {String} attribute the attribute to set
     * @param {Any} value the value to set
     */
    function smartSetAttribute(element, attribute, value) {
      if (element.tagName.match(/^LIGHTNING/i)) {
        attribute = attribute.replace(/-\w/g, m => m[1].toUpperCase());
        element[attribute] = value ? value : null;
      } else if (value) {
        element.setAttribute(attribute, value);
      } else {
        element.removeAttribute(attribute);
      }
    }

    const CONTENT_SEPARATOR = '\n';
    /**
    <template>
        <span lwc:dom="manual" class="visually-hidden"></span>
        <input>
    </template>

    class Foo extends LightningElement {
        constructor() {
            super();
            this.ariaObserver = new ContentMutation(this);
        }

        @track ariaLabeledbyValue = '';

        @api
        get ariaLabeledby() {
            return this.ariaLabeledbyValue; // whatever they set, is what they get back.
        }
        set ariaLabeledby(refs) {
            this.ariaLabeledbyValue = refs;
            this.ariaObserver.link('input', 'aria-labeledby', refs, 'span.visually-hidden');
        }

        renderedCallback() {
            this.ariaObserver.sync();
        }
    }
    **/

    function getAttr(elm, attr) {
      if (elm.tagName.match(/lightning/i)) {
        return elm[attr];
      }

      return elm.getAttribute(attr);
    }

    function extractElements(root, selector) {
      if (typeof selector !== 'string' || selector === '') {
        return [];
      }

      return [].slice.call(root.querySelectorAll(selector));
    }

    function extractContent(elements) {
      return elements.map(element => element.textContent).filter(text => text.length).join(CONTENT_SEPARATOR);
    }

    function splitIds(ids) {
      return (ids + '').trim().split(/\s+/);
    }

    function hashIds(ids) {
      return (ids + '').trim().split(/\s+/).reduce((r, v) => {
        r[v] = 1;
        return r;
      }, {});
    } // this method should check each individual id from computedIds
    // against the existing value of the attrName on elm, and dupe
    // them, and add the new ones.


    function addAriaRefWhenNeeded(elm, attrName, computedIds) {
      const newIds = splitIds(computedIds);
      const oldIds = getAttr(elm, attrName) || '';
      const oldIdsHash = hashIds(oldIds);
      const suffix = [];

      for (let i = 0; i < newIds.length; i += 1) {
        if (!oldIdsHash[newIds[i]]) {
          suffix.push(newIds[i]);
        }
      }

      if (suffix.length !== 0) {
        smartSetAttribute(elm, attrName, oldIds + (oldIds.length === 0 ? '' : ' ') + suffix.join(' '));
      }
    } // this method should check each individual id from computedIds
    // against the existing value of the attrName on elm, and remove
    // them when possible in preparation for some new values.


    function removeAriaRefWhenPossible(elm, attrName, computedIds) {
      const newIds = splitIds(computedIds);
      const oldIds = getAttr(elm, attrName) || '';
      const oldIdsHash = hashIds(oldIds);
      const newValues = [];

      for (let i = 0; i < newIds.length; i += 1) {
        if (!oldIdsHash[newIds[i]]) {
          newValues.push(newIds[i]);
        }
      }

      smartSetAttribute(elm, attrName, newValues.join(' '));
    }

    class ContentMutation {
      constructor(component) {
        this.template = component.template;
        this.isNative = this.template.constructor.toString().match(/\[native code\]/);
        this.state = {};
        this.liveIds = {};
        this.guid = guid();
      }

      connectLiveIdRef(refs, callback) {
        const selector = (refs + '').trim().split(/\s+/).map(ref => `[id*="${ref}"]`).join(',');
        const liveId = {
          selector,
          callback
        };
        this.liveIds[refs] = liveId;
      }

      link(innerSelector, attrName, ids, placeholderContainerSelector) {
        let attrState = this.state[attrName];

        if (attrState) {
          // note: we don't support linking to a different innerSelector,
          // attrName, or placeholderContainerSelector
          if (!this.isNative) {
            const elm = this.template.querySelector(innerSelector);

            if (elm) {
              // removing the old ids if possible before setting the new ones
              removeAriaRefWhenPossible(elm, attrName, attrState.ids);
            }

            attrState.ids = ids;
          }
        } else {
          attrState = this.state[attrName] = {
            ids,
            innerSelector,
            placeholderContainerSelector
          };
        }

        if (this.isNative) {
          attrState.outerSelector = (ids + '').trim().split(/\s+/).map(ref => `#${ref}`).join(',');
          attrState.placeholder = document.createElement('span');
          attrState.placeholder.id = `auto-link-${attrName}-${this.guid}`;
        }

        if (this.template.host.parentNode) {
          this.privateUpdate(attrName);
        }
      }

      sync() {
        if (!this.template.host.parentNode) {
          throw new Error(`Invalid sync invocation. It can only be invoked during renderedCallback().`);
        }

        if (this.isNative && !this.mo) {
          this.privateConnect();
        }

        for (const attrName in this.state) {
          if (Object.prototype.hasOwnProperty.call(this.state, attrName)) {
            this.privateUpdate(attrName);
          }
        } // live idRef feature is a no-op in native


        if (!this.isNative) {
          this.privateUpdateLiveIds();
        }
      }

      privateExtractIds(elements) {
        return elements.map(el => {
          return el.getAttribute('id');
        }).join(' ');
      }

      privateUpdateLiveIds() {
        const root = this.template.host.getRootNode(); // if not connected do nothing

        if (!root) {
          return;
        }

        for (const liveId in this.liveIds) {
          if (Object.prototype.hasOwnProperty.call(this.liveIds, liveId)) {
            const thisId = this.liveIds[liveId];

            if (!thisId.elements) {
              // element refs are cached
              thisId.elements = Array.prototype.slice.call(root.querySelectorAll(thisId.selector));
            }

            const newIds = this.privateExtractIds(thisId.elements); // only fire calback if the value changed

            if (newIds !== thisId.ids) {
              thisId.callback(newIds);
              thisId.ids = newIds;
            }
          }
        }
      }

      privateUpdate(attrName) {
        const {
          innerSelector
        } = this.state[attrName];
        const elm = this.template.querySelector(innerSelector);

        if (!elm) {
          return; // nothing to update
        }

        let computedIds;

        if (this.isNative) {
          const {
            outerSelector,
            content,
            placeholder,
            placeholderContainerSelector
          } = this.state[attrName];
          const newContent = extractContent(extractElements(this.root, outerSelector));

          if (content !== newContent) {
            this.state[attrName].content = placeholder.textContent = newContent;
          }

          if (!placeholder.parentNode) {
            // inserting the placeholder once
            const container = this.template.querySelector(placeholderContainerSelector);

            if (container) {
              container.appendChild(placeholder);
            }
          }

          computedIds = placeholder.id;
        } else {
          computedIds = this.state[attrName].ids;
        }

        addAriaRefWhenNeeded(elm, attrName, computedIds);
      }

      privateConnect() {
        // caching root ref
        this.root = this.template.host.getRootNode(); // creating the observer once

        const mo = new MutationObserver(() => {
          if (!this.template.host.parentNode) {
            return; // do nothing when the template is not connected
          }

          this.sync();
        });
        mo.observe(this.root, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }

    }

    // hide panel on scroll
    const POSITION_CHANGE_THRESHOLD = 5;
    function observePosition(target, threshold = POSITION_CHANGE_THRESHOLD, originalRect, callback) {
      // retrieve current bounding client rect of target element
      const newBoundingRect = target.getBoundingClientRect();
      const newLeft = newBoundingRect.left;
      const newTop = newBoundingRect.top; // old bounding rect values

      const oldLeft = originalRect.left;
      const oldTop = originalRect.top; // if we have a position change (horizontal or vertical) equal or greater to the threshold then execute the callback

      const horizontalShiftDelta = Math.abs(newLeft - oldLeft);
      const verticalShiftDelta = Math.abs(newTop - oldTop);

      if (horizontalShiftDelta >= threshold || verticalShiftDelta >= threshold) {
        callback();
      }
    }

    /**
     * @param {HTMLElement} element Element to act on
     * @param {Object} values values and attributes to set, if the value is
     *                        falsy it the attribute will be removed
     */

    function synchronizeAttrs(element, values) {
      if (!element) {
        return;
      }

      const attributes = Object.keys(values);
      attributes.forEach(attribute => {
        smartSetAttribute(element, attribute, values[attribute]);
      });
    }
    /**
     * Get the actual DOM id for an element
     * @param {HTMLElement|String} el The element to get the id for (string will just be returned)
     *
     * @returns {String} The DOM id or null
     */

    function getRealDOMId(el) {
      if (el && typeof el === 'string') {
        return el;
      } else if (el) {
        return el.getAttribute('id');
      }

      return null;
    }
    const URL_CHECK_REGEX = /^(\/+|\.+|ftp|http(s?):\/\/)/i;
    function isAbsoluteUrl(url) {
      return URL_CHECK_REGEX.test(url);
    }
    /**
     * Returns the active elements at each shadow root level
     * @returns {Array} Active Elements  at each shadow root level
     */

    function getShadowActiveElements() {
      let activeElement = document.activeElement;
      const shadowActiveElements = [];

      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        shadowActiveElements.push(activeElement);
        activeElement = activeElement.shadowRoot.activeElement;
      }

      if (activeElement) {
        shadowActiveElements.push(activeElement);
      }

      return shadowActiveElements;
    }
    function isRTL() {
      return document.dir === 'rtl';
    }
    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }
    function isNotUndefinedOrNull(value) {
      return !isUndefinedOrNull(value);
    }
    const DEFAULT_ZINDEX_BASELINE = 9000;
    /**
     * Returns the zIndex baseline from slds zIndex variable --lwc-zIndexModal.
     * @returns {Number} zIndex baseline
     */

    function getZIndexBaseline() {
      const value = (window.getComputedStyle(document.documentElement) || document.documentElement.style).getPropertyValue('--lwc-zIndexModal');
      const base = parseInt(value, 10);
      return isNaN(base) ? DEFAULT_ZINDEX_BASELINE : base;
    }

    var _tmpl$1 = void 0;

    // Taken from https://github.com/jonathantneal/svg4everybody/pull/139
    // Remove this iframe-in-edge check once the following is resolved https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8323875/
    const isEdgeUA = /\bEdge\/.(\d+)\b/.test(navigator.userAgent);
    const inIframe = window.top !== window.self;
    const isIframeInEdge = isEdgeUA && inIframe;
    var isIframeInEdge$1 = lwc.registerComponent(isIframeInEdge, {
      tmpl: _tmpl$1
    });

    // Taken from https://git.soma.salesforce.com/aura/lightning-global/blob/999dc35f948246181510df6e56f45ad4955032c2/src/main/components/lightning/SVGLibrary/stamper.js#L38-L60
    function fetchSvg(url) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();

        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              resolve(xhr.responseText);
            } else {
              reject(xhr);
            }
          }
        };
      });
    }

    // Which looks like it was inspired by https://github.com/jonathantneal/svg4everybody/blob/377d27208fcad3671ed466e9511556cb9c8b5bd8/lib/svg4everybody.js#L92-L107
    // Modify at your own risk!

    const newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/;
    const webkitUA = /\bAppleWebKit\/(\d+)\b/;
    const olderEdgeUA = /\bEdge\/12\.(\d+)\b/;
    const isIE = newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537;
    const supportsSvg = !isIE && !isIframeInEdge$1;
    var supportsSvg$1 = lwc.registerComponent(supportsSvg, {
      tmpl: _tmpl$1
    });

    /**
    This polyfill injects SVG sprites into the document for clients that don't
    fully support SVG. We do this globally at the document level for performance
    reasons. This causes us to lose namespacing of IDs across sprites. For example,
    if both #image from utility sprite and #image from doctype sprite need to be
    rendered on the page, both end up as #image from the doctype sprite (last one
    wins). SLDS cannot change their image IDs due to backwards-compatibility
    reasons so we take care of this issue at runtime by adding namespacing as we
    polyfill SVG elements.

    For example, given "/assets/icons/action-sprite/svg/symbols.svg#approval", we
    replace the "#approval" id with "#${namespace}-approval" and a similar
    operation is done on the corresponding symbol element.
    **/
    const svgTagName = /svg/i;

    const isSvgElement = el => el && svgTagName.test(el.nodeName);

    const requestCache = {};
    const symbolEls = {};
    const svgFragments = {};
    const spritesContainerId = 'slds-svg-sprites';
    let spritesEl;
    function polyfill(el) {
      if (!supportsSvg$1 && isSvgElement(el)) {
        if (!spritesEl) {
          spritesEl = document.createElement('svg');
          spritesEl.xmlns = 'http://www.w3.org/2000/svg';
          spritesEl['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';
          spritesEl.style.display = 'none';
          spritesEl.id = spritesContainerId;
          document.body.insertBefore(spritesEl, document.body.childNodes[0]);
        }

        Array.from(el.getElementsByTagName('use')).forEach(use => {
          // We access the href differently in raptor and in aura, probably
          // due to difference in the way the svg is constructed.
          const src = use.getAttribute('xlink:href') || use.getAttribute('href');

          if (src) {
            // "/assets/icons/action-sprite/svg/symbols.svg#approval" =>
            // ["/assets/icons/action-sprite/svg/symbols.svg", "approval"]
            const parts = src.split('#');
            const url = parts[0];
            const id = parts[1];
            const namespace = url.replace(/[^\w]/g, '-');
            const href = `#${namespace}-${id}`;

            if (url.length) {
              // set the HREF value to no longer be an external reference
              if (use.getAttribute('xlink:href')) {
                use.setAttribute('xlink:href', href);
              } else {
                use.setAttribute('href', href);
              } // only insert SVG content if it hasn't already been retrieved


              if (!requestCache[url]) {
                requestCache[url] = fetchSvg(url);
              }

              requestCache[url].then(svgContent => {
                // create a document fragment from the svgContent returned (is parsed by HTML parser)
                if (!svgFragments[url]) {
                  const svgFragment = document.createRange().createContextualFragment(svgContent);
                  svgFragments[url] = svgFragment;
                }

                if (!symbolEls[href]) {
                  const svgFragment = svgFragments[url];
                  const symbolEl = svgFragment.querySelector(`#${id}`);
                  symbolEls[href] = true;
                  symbolEl.id = `${namespace}-${id}`;
                  spritesEl.appendChild(symbolEl);
                }
              });
            }
          }
        });
      }
    }

    const validNameRe = /^([a-zA-Z]+):([a-zA-Z]\w*)$/;
    const underscoreRe = /_/g;
    let pathPrefix;
    const tokenNameMap = Object.assign(Object.create(null), {
      action: 'lightning.actionSprite',
      custom: 'lightning.customSprite',
      doctype: 'lightning.doctypeSprite',
      standard: 'lightning.standardSprite',
      utility: 'lightning.utilitySprite'
    });
    const tokenNameMapRtl = Object.assign(Object.create(null), {
      action: 'lightning.actionSpriteRtl',
      custom: 'lightning.customSpriteRtl',
      doctype: 'lightning.doctypeSpriteRtl',
      standard: 'lightning.standardSpriteRtl',
      utility: 'lightning.utilitySpriteRtl'
    });
    const defaultTokenValueMap = Object.assign(Object.create(null), {
      'lightning.actionSprite': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.actionSpriteRtl': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.customSprite': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.customSpriteRtl': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.doctypeSprite': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.doctypeSpriteRtl': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.standardSprite': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.standardSpriteRtl': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.utilitySprite': '/assets/icons/utility-sprite/svg/symbols.svg',
      'lightning.utilitySpriteRtl': '/assets/icons/utility-sprite/svg/symbols.svg'
    });

    const getDefaultBaseIconPath = (category, nameMap) => defaultTokenValueMap[nameMap[category]];

    const getBaseIconPath = (category, direction) => {
      const nameMap = direction === 'rtl' ? tokenNameMapRtl : tokenNameMap;
      return configProvider.getToken(nameMap[category]) || getDefaultBaseIconPath(category, nameMap);
    };

    const getMatchAtIndex = index => iconName => {
      const result = validNameRe.exec(iconName);
      return result ? result[index] : '';
    };

    const getCategory = getMatchAtIndex(1);
    const getName = getMatchAtIndex(2);
    const isValidName = iconName => validNameRe.test(iconName);
    const getIconPath = (iconName, direction = 'ltr') => {
      pathPrefix = pathPrefix !== undefined ? pathPrefix : configProvider.getPathPrefix();

      if (isValidName(iconName)) {
        const baseIconPath = getBaseIconPath(getCategory(iconName), direction);

        if (baseIconPath) {
          // This check was introduced the following MS-Edge issue:
          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9655192/
          // If and when this get fixed, we can safely remove this block of code.
          if (isIframeInEdge$1) {
            // protocol => 'https:' or 'http:'
            // host => hostname + port
            const origin = `${window.location.protocol}//${window.location.host}`;
            return `${origin}${pathPrefix}${baseIconPath}#${getName(iconName)}`;
          }

          return `${pathPrefix}${baseIconPath}#${getName(iconName)}`;
        }
      }

      return '';
    };
    const computeSldsClass = iconName => {
      if (isValidName(iconName)) {
        const category = getCategory(iconName);
        const name = getName(iconName).replace(underscoreRe, '-');
        return `slds-icon-${category}-${name}`;
      }

      return '';
    };

    class LightningPrimitiveIcon extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.iconName = void 0;
        this.src = void 0;
        this.svgClass = void 0;
        this.size = 'medium';
        this.variant = void 0;
        this.privateIconSvgTemplates = configProvider.getIconSvgTemplates();
      }

      get inlineSvgProvided() {
        return !!this.privateIconSvgTemplates;
      }

      renderedCallback() {
        if (this.iconName !== this.prevIconName && !this.inlineSvgProvided) {
          this.prevIconName = this.iconName;
          const svgElement = this.template.querySelector('svg');
          polyfill(svgElement);
        }
      }

      get href() {
        return this.src || getIconPath(this.iconName, dir);
      }

      get name() {
        return getName(this.iconName);
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: 'medium',
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      get normalizedVariant() {
        // NOTE: Leaving a note here because I just wasted a bunch of time
        // investigating why both 'bare' and 'inverse' are supported in
        // lightning-primitive-icon. lightning-icon also has a deprecated
        // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
        // that no classes should be applied. So this component needs to
        // support both 'bare' and 'inverse' while lightning-icon only needs to
        // support 'inverse'.
        return normalizeString(this.variant, {
          fallbackValue: '',
          validValues: ['bare', 'error', 'inverse', 'warning', 'success']
        });
      }

      get computedClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const classes = classSet(this.svgClass);

        if (normalizedVariant !== 'bare') {
          classes.add('slds-icon');
        }

        switch (normalizedVariant) {
          case 'error':
            classes.add('slds-icon-text-error');
            break;

          case 'warning':
            classes.add('slds-icon-text-warning');
            break;

          case 'success':
            classes.add('slds-icon-text-success');
            break;

          case 'inverse':
          case 'bare':
            break;

          default:
            // if custom icon is set, we don't want to set
            // the text-default class
            if (!this.src) {
              classes.add('slds-icon-text-default');
            }

        }

        if (normalizedSize !== 'medium') {
          classes.add(`slds-icon_${normalizedSize}`);
        }

        return classes.toString();
      }

      resolveTemplate() {
        const name = this.iconName;

        if (isValidName(name)) {
          const [spriteName, iconName] = name.split(':');
          const template = this.privateIconSvgTemplates[`${spriteName}_${iconName}`];

          if (template) {
            return template;
          }
        }

        return _tmpl;
      }

      render() {
        if (this.inlineSvgProvided) {
          return this.resolveTemplate();
        }

        return _tmpl;
      }

    }

    lwc.registerDecorators(LightningPrimitiveIcon, {
      publicProps: {
        iconName: {
          config: 0
        },
        src: {
          config: 0
        },
        svgClass: {
          config: 0
        },
        size: {
          config: 0
        },
        variant: {
          config: 0
        }
      },
      fields: ["privateIconSvgTemplates"]
    });

    var _lightningPrimitiveIcon = lwc.registerComponent(LightningPrimitiveIcon, {
      tmpl: _tmpl
    });

    function tmpl$1($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_element("div", {
        classMap: {
          "slds-form-element__icon": true
        },
        key: 3
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true
        },
        attrs: {
          "type": "button"
        },
        key: 2
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "svgClass": $cmp.computedSvgClass,
          "iconName": $cmp.iconName,
          "variant": "bare"
        },
        key: 0
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.i18n.buttonAlternativeText)])])])];
    }

    var _tmpl$2 = lwc.registerTemplate(tmpl$1);
    tmpl$1.stylesheets = [];
    tmpl$1.stylesheetTokens = {
      hostAttribute: "lightning-helptext_helptext-host",
      shadowAttribute: "lightning-helptext_helptext"
    };

    var labelButtonAlternativeText = 'Help';

    const POSITION_ATTR_NAME = 'data-position-id';

    class BrowserWindow {
      get window() {
        if (!this._window) {
          this._window = window; // JTEST/Ingtegration: getComputedStyle may be null

          if (!this.window.getComputedStyle) {
            this.window.getComputedStyle = node => {
              return node.style;
            };
          }
        }

        return this._window;
      }

      mockWindow(value) {
        // For test, allow mock window.
        this._window = value;
      }

      get documentElement() {
        assert(this.window.document, 'Missing window.document');
        return this.window.document.documentElement;
      }

      get MutationObserver() {
        return this.window.MutationObserver;
      }

      isWindow(element) {
        return element && element.toString() === '[object Window]';
      }

    }

    const WindowManager = new BrowserWindow();

    function isShadowRoot(node) {
      return node && node.nodeType === 11;
    }

    function enumerateParent(elem, stopEl, checker) {
      // document.body is not necessarily a body tag, because of the (very rare)
      // case of a frameset.
      if (!elem || elem === stopEl || elem === document.body) {
        return null;
      } // if overflow is auto and overflow-y is also auto,
      // however in firefox the opposite is not true


      try {
        // getComputedStyle throws an exception
        // if elem is not an element
        // (can happen during unrender)
        const computedStyle = WindowManager.window.getComputedStyle(elem);

        if (!computedStyle) {
          return null;
        }

        if (checker(computedStyle)) {
          return elem;
        }

        return enumerateParent(isShadowRoot(elem.parentNode) ? elem.parentNode.host : elem.parentNode, stopEl, checker);
      } catch (e) {
        return null;
      }
    }

    function getScrollableParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        const overflow = computedStyle['overflow-y'];
        return overflow === 'auto' || overflow === 'scroll';
      });
    }

    function queryOverflowHiddenParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        return computedStyle['overflow-x'] === 'hidden' || computedStyle['overflow-y'] === 'hidden';
      });
    }

    function isInDom(el) {
      if (el === WindowManager.window) {
        return true;
      }

      if (!isShadowRoot(el.parentNode) && el.parentNode && el.parentNode.tagName && el.parentNode.tagName.toUpperCase() === 'BODY') {
        return true;
      }

      if (isShadowRoot(el.parentNode) && el.parentNode.host) {
        return isInDom(el.parentNode.host);
      }

      if (el.parentNode) {
        return isInDom(el.parentNode);
      }

      return false;
    }
    function isScrolling(elem) {
      return elem.scrollHeight > elem.clientHeight;
    }
    function isDomNode(obj) {
      return obj.nodeType && (obj.nodeType === 1 || obj.nodeType === 11);
    }
    function timeout(time) {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        setTimeout(() => {
          resolve();
        }, time);
      });
    }
    function containsScrollingElement(list) {
      const len = list.length;

      if (!len) {
        return false;
      }

      for (let i = 0; i < len; i++) {
        if (isScrolling(list[i])) {
          return true;
        }
      }

      return false;
    }
    function queryScrollableChildren(element) {
      return element.querySelectorAll('[data-scoped-scroll="true"]');
    }
    function getPositionTarget(element) {
      return element.tagName === 'TEXTAREA' ? isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode : element;
    }
    let lastId = 1000000;
    function generateUniqueSelector() {
      return `lgcp-${lastId++}`;
    }
    function normalizeElement(element) {
      const selector = generateUniqueSelector();
      element.setAttribute(POSITION_ATTR_NAME, selector);
      element = // eslint-disable-next-line @lwc/lwc/no-document-query
      document.querySelector(`[${POSITION_ATTR_NAME}="${selector}"]`) || element;
      return element;
    }

    function isInsideOverlay(element, modalOnly) {
      if (!element) {
        return false;
      }

      if (element.classList && (element.classList.contains('uiModal') || element.localName === 'lightning-dialog' || !modalOnly && element.classList.contains('uiPanel'))) {
        return true;
      }

      if (!element.parentNode) {
        return false;
      }

      return isInsideOverlay(isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode, modalOnly);
    }

    function isInsideModal(element) {
      return isInsideOverlay(element, true);
    }
    function normalizePosition(element, nextIndex, target, alignWidth) {
      // Set element position to fixed
      // 1. element is inside overlay
      // or 2. When element isn't align with target's width, and target's parent has overflow-x:hidden setting.
      const isFixed = isInsideOverlay(element) || !alignWidth && queryOverflowHiddenParent(target, WindowManager.window);
      element.style.position = isFixed ? 'fixed' : 'absolute';
      element.style.zIndex = nextIndex || 0;
      element.style.left = '-9999px'; // Avoid flicker
      // we always position from the left, but in RTL mode Omakase swaps left and right properties.
      // To always allow positioning from the left we set right to auto so position library can do its work.

      element.style.right = 'auto';
      element.style.top = '0px'; // Avoid flicker

      return element;
    }
    function requestAnimationFrameAsPromise() {
      return new Promise(resolve => {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => resolve());
      });
    }

    const Direction = {
      Center: 'center',
      Middle: 'middle',
      Right: 'right',
      Left: 'left',
      Bottom: 'bottom',
      Top: 'top',
      Default: 'default'
    };
    const VerticalMap = {
      top: Direction.Top,
      bottom: Direction.Bottom,
      center: Direction.Middle
    };
    const HorizontalMap = {
      left: Direction.Left,
      right: Direction.Right,
      center: Direction.Center
    };
    const FlipMap = {
      left: Direction.Right,
      right: Direction.Left,
      top: Direction.Bottom,
      bottom: Direction.Top,
      center: Direction.Center,
      default: Direction.Right
    };

    function getWindowSize() {
      return {
        width: WindowManager.window.innerWidth || document.body.clientWidth || 0,
        height: WindowManager.window.innerHeight || document.body.clientHeight || 0
      };
    }

    function normalizeDirection(direction, defaultValue) {
      return normalizeString(direction, {
        fallbackValue: defaultValue || Direction.Default,
        validValues: [Direction.Center, Direction.Right, Direction.Left, Direction.Bottom, Direction.Top, Direction.Middle, Direction.Default]
      });
    }
    function mapToHorizontal(value) {
      value = normalizeDirection(value, Direction.Left);
      return HorizontalMap[value];
    }
    function mapToVertical(value) {
      value = normalizeDirection(value, Direction.Left);
      return VerticalMap[value];
    }
    function flipDirection(value) {
      value = normalizeDirection(value, Direction.Left);
      return FlipMap[value];
    } // TODO: Remove, not currently in use.
    function checkFlipPossibility(element, target, leftAsBoundary) {
      const viewPort = getWindowSize();
      const elemRect = element.getBoundingClientRect();
      const referenceElemRect = target.getBoundingClientRect();
      const height = typeof elemRect.height !== 'undefined' ? elemRect.height : elemRect.bottom - elemRect.top;
      const width = typeof elemRect.width !== 'undefined' ? elemRect.width : elemRect.right - elemRect.left; // TODO: We'll need to revisit the leftAsBoundary config property. Either we'll need a better
      // name to cover the RTL language cases and maybe open up the possibility of bounding the
      // element to the target in both the horizontal and vertical directions.
      // The boundary shrinks the available area to the edge of the target rather than the viewport.

      let rightAsBoundary = false;

      if (document.dir === 'rtl') {
        rightAsBoundary = leftAsBoundary;
        leftAsBoundary = false;
      }

      const hasSpaceAbove = referenceElemRect.top >= height;
      const hasSpaceBelow = viewPort.height - referenceElemRect.bottom >= height; // Assuming left alignment is specified this tests if:
      // - there's room to accommodate the element with right alignment
      // - there's not enough room to accommodate the element with left alignment

      const shouldAlignToRight = referenceElemRect.right >= width && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width); // Assuming right alignment is specified this tests if:
      // - there's room to accommodate the element with left alignment
      // - there's not enough room to accommodate the element with right alignment

      const shouldAlignToLeft = referenceElemRect.left + width <= viewPort.width && referenceElemRect.right - width < (leftAsBoundary ? referenceElemRect.left : 0); // Assuming center alignment, does the viewport have space to fit half of the element around
      // the target?

      const centerOverflow = {
        left: referenceElemRect.left - width * 0.5 < 0,
        right: referenceElemRect.right + width * 0.5 > viewPort.width,
        top: referenceElemRect.top - height * 0.5 < 0,
        bottom: referenceElemRect.bottom + height * 0.5 > viewPort.height
      };
      return {
        shouldAlignToLeft,
        shouldAlignToRight,
        hasSpaceAbove,
        hasSpaceBelow,
        centerOverflow
      };
    }

    class Transformer {
      constructor(pad, boxDirections, transformX, transformY) {
        this.pad = pad || 0;
        this.boxDirections = boxDirections || {
          left: true,
          right: true
        };

        this.transformX = transformX || function () {};

        this.transformY = transformY || function () {};
      }

      transform() {// no-op
      }

    }

    class TopTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: this.transformY(targetBox.top, targetBox, elementBox) + this.pad
        };
      }

    }

    class BottomTransFormer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: this.transformY(targetBox.top, targetBox, elementBox) - elementBox.height - this.pad
        };
      }

    }

    class CenterTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) - 0.5 * elementBox.width)
        };
      }

    }

    class MiddleTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: Math.floor(0.5 * (2 * targetBox.top + targetBox.height - elementBox.height))
        };
      }

    }

    class LeftTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: this.transformX(targetBox.left, targetBox, elementBox) + this.pad
        };
      }

    }

    class RightTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: this.transformX(targetBox.left, targetBox, elementBox) - elementBox.width - this.pad
        };
      }

    }

    class BelowTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const top = targetBox.top + targetBox.height + this.pad;
        return elementBox.top < top ? {
          top
        } : {};
      }

    }

    const MIN_HEIGHT = 36; // Minimum Line Height

    const MIN_WIDTH = 36;

    class ShrinkingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
          retBox.height = Math.max(elementBox.height - (retBox.top - elementBox.top), MIN_HEIGHT);
        }

        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
          retBox.width = Math.max(elementBox.width - (retBox.left - elementBox.left), MIN_WIDTH);
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.right = targetBox.left + targetBox.width - this.pad;
          retBox.width = Math.max(retBox.right - (retBox.left || elementBox.left), MIN_WIDTH);
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.bottom = targetBox.top + targetBox.height - this.pad;
          retBox.height = Math.max(retBox.bottom - (retBox.top || elementBox.top), MIN_HEIGHT);
        }

        return retBox;
      }

    }

    class BoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
        }

        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.left = targetBox.left + targetBox.width - elementBox.width - this.pad;
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.top = targetBox.top + targetBox.height - elementBox.height - this.pad;
        }

        return retBox;
      }

    }

    class InverseBoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.left && targetBox.left - this.pad < elementBox.left) {
          retBox.left = targetBox.left - this.pad;
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width < targetBox.left + targetBox.width + this.pad) {
          retBox.left = targetBox.width + this.pad - elementBox.width + targetBox.left;
        }

        if (this.boxDirections.top && targetBox.top < elementBox.top + this.pad) {
          retBox.top = targetBox.top - this.pad;
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height < targetBox.top + targetBox.height + this.pad) {
          retBox.top = targetBox.height + this.pad - elementBox.height + targetBox.top;
        }

        return retBox;
      }

    }

    const TransformFunctions = {
      center(input, targetBox) {
        return Math.floor(input + 0.5 * targetBox.width);
      },

      right(input, targetBox) {
        return input + targetBox.width;
      },

      left(input) {
        return input;
      },

      bottom(input, targetBox) {
        return input + targetBox.height;
      }

    };
    const Transformers = {
      top: TopTransformer,
      bottom: BottomTransFormer,
      center: CenterTransformer,
      middle: MiddleTransformer,
      left: LeftTransformer,
      right: RightTransformer,
      below: BelowTransformer,
      'bounding box': BoundingBoxTransformer,
      'shrinking box': ShrinkingBoxTransformer,
      'inverse bounding box': InverseBoundingBoxTransformer,
      default: Transformer
    };
    function toTransformFunctions(value) {
      return TransformFunctions[value] || TransformFunctions.left;
    }

    class TransformBuilder {
      type(value) {
        this._type = value;
        return this;
      }

      align(horizontal, vertical) {
        this._transformX = toTransformFunctions(horizontal);
        this._transformY = toTransformFunctions(vertical);
        return this;
      }

      pad(value) {
        this._pad = parseInt(value, 10);
        return this;
      }

      boxDirections(value) {
        this._boxDirections = value;
        return this;
      }

      build() {
        const AConstructor = Transformers[this._type] ? Transformers[this._type] : Transformers[Direction.Default];
        return new AConstructor(this._pad || 0, this._boxDirections || {}, this._transformX || toTransformFunctions(Direction.left), this._transformY || toTransformFunctions(Direction.left));
      }

    }

    class Constraint {
      constructor(type, config) {
        const {
          target,
          element,
          pad,
          boxDirections
        } = config;
        const {
          horizontal,
          vertical
        } = config.targetAlign;
        this._element = element;
        this._targetElement = target;
        this.destroyed = false;
        this._transformer = new TransformBuilder().type(type).align(horizontal, vertical).pad(pad).boxDirections(boxDirections).build();
      }

      detach() {
        this._disabled = true;
      }

      attach() {
        this._disabled = false;
      }

      computeDisplacement() {
        if (!this._disabled) {
          this._targetElement.refresh();

          this._element.refresh();

          this._pendingBox = this._transformer.transform(this._targetElement, this._element);
        }

        return this;
      }

      computePosition() {
        const el = this._element;

        if (!this._disabled) {
          Object.keys(this._pendingBox).forEach(key => {
            el.setDirection(key, this._pendingBox[key]);
          });
        }

        return this;
      }

      destroy() {
        this._element.release();

        this._targetElement.release();

        this._disabled = true;
        this.destroyed = true;
      }

    }

    class ElementProxy {
      constructor(el, id) {
        this.id = id;
        this.width = 0;
        this.height = 0;
        this.left = 0;
        this.top = 0;
        this.right = 0;
        this.bottom = 0;
        this._dirty = false;
        this._node = null;
        this._releaseCb = null;

        if (!el) {
          throw new Error('Element missing');
        } // W-3262919
        // for some reason I cannot figure out sometimes the
        // window, which clearly a window object, is not the window object
        // this will correct that. It might be related to locker


        if (WindowManager.isWindow(el)) {
          el = WindowManager.window;
        }

        this._node = el;
        this.setupObserver();
        this.refresh();
      }

      setupObserver() {
        // this check is because phantomjs does not support
        // mutation observers. The consqeuence here
        // is that any browser without mutation observers will
        // fail to update dimensions if they changwe after the proxy
        // is created and the proxy is not not refreshed
        if (WindowManager.MutationObserver && !this._node.isObserved) {
          // Use mutation observers to invalidate cache. It's magic!
          this._observer = new WindowManager.MutationObserver(this.refresh.bind(this)); // do not observe the window

          if (!WindowManager.isWindow(this._node)) {
            this._observer.observe(this._node, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });

            this._node.isObserved = true;
          }
        }
      }

      setReleaseCallback(cb, scope) {
        const scopeObj = scope || this;
        this._releaseCb = cb.bind(scopeObj);
      }

      checkNodeIsInDom() {
        // if underlying DOM node is gone,
        // this proxy should be released
        if (!isInDom(this._node)) {
          return false;
        }

        return true;
      }

      refresh() {
        const w = WindowManager.window;

        if (!this.isDirty()) {
          if (!this.checkNodeIsInDom()) {
            return this.release();
          }

          let box, x, scrollTop, scrollLeft;

          if (typeof w.pageYOffset !== 'undefined') {
            scrollTop = w.pageYOffset;
            scrollLeft = w.pageXOffset;
          } else {
            scrollTop = w.scrollY;
            scrollLeft = w.scrollX;
          }

          if (!WindowManager.isWindow(this._node)) {
            // force paint
            // eslint-disable-next-line no-unused-vars
            const offsetHeight = this._node.offsetHeight;
            box = this._node.getBoundingClientRect(); // not using integers causes weird rounding errors
            // eslint-disable-next-line guard-for-in

            for (x in box) {
              this[x] = Math.floor(box[x]);
            }

            this.top = Math.floor(this.top + scrollTop);
            this.bottom = Math.floor(this.top + box.height);
            this.left = Math.floor(this.left + scrollLeft);
            this.right = Math.floor(this.left + box.width);
          } else {
            box = {};
            this.width = WindowManager.documentElement.clientWidth;
            this.height = WindowManager.documentElement.clientHeight;
            this.left = scrollLeft;
            this.top = scrollTop;
            this.right = WindowManager.documentElement.clientWidth + scrollLeft;
            this.bottom = WindowManager.documentElement.clientHeight;
          }

          this._dirty = false;
        }

        return this._dirty;
      }

      getNode() {
        return this._node;
      }

      isDirty() {
        return this._dirty;
      }

      bake() {
        const w = WindowManager.window;

        const absPos = this._node.getBoundingClientRect();

        const style = w.getComputedStyle(this._node) || this._node.style;

        const hasPageOffset = typeof w.pageYOffset !== 'undefined';
        const scrollTop = hasPageOffset ? w.pageYOffset : w.scrollY;
        const scrollLeft = hasPageOffset ? w.pageXOffset : w.scrollX;
        const originalLeft = style.left.match(/auto|fixed/) ? '0' : parseInt(style.left.replace('px', ''), 10);
        const originalTop = style.top.match(/auto|fixed/) ? '0' : parseInt(style.top.replace('px', ''), 10);
        const leftDif = Math.round(this.left - (absPos.left + scrollLeft));
        const topDif = this.top - (absPos.top + scrollTop);
        this._node.style.left = `${originalLeft + leftDif}px`;
        this._node.style.top = `${originalTop + topDif}px`;

        if (this._restoreSize) {
          // Only store the first height/width which is the original height/width.
          this.originalHeight = this.originalHeight || this._node.style.height;
          this.originalWidth = this.originalWidth || this._node.style.width;
          this._node.style.width = `${this.width}px`;
          this._node.style.height = `${this.height}px`;
        }

        this._dirty = false;
      }

      setDirection(direction, val) {
        this[direction] = val;
        this._dirty = true; // if size is changed, should restore the original size.

        if (direction === 'height' || direction === 'width') {
          this._restoreSize = true;
        }
      }

      release() {
        if (this._restoreSize) {
          this._node.style.width = this.originalWidth;
          this._node.style.height = this.originalHeight;

          if (this._removeMinHeight) {
            this._node.style.minHeight = '';
          }
        }

        if (this._releaseCb) {
          this._releaseCb(this);
        }
      }

      querySelectorAll(selector) {
        return this._node.querySelectorAll(selector);
      }

    }

    class ProxyCache {
      constructor() {
        this.proxyCache = {};
      }

      get count() {
        return Object.keys(this.proxyCache).length;
      }

      releaseOrphanProxies() {
        for (const proxy in this.proxyCache) {
          if (!this.proxyCache[proxy].el.checkNodeIsInDom()) {
            this.proxyCache[proxy].el.release();
          }
        }
      }

      bakeOff() {
        for (const proxy in this.proxyCache) {
          if (this.proxyCache[proxy].el.isDirty()) {
            this.proxyCache[proxy].el.bake();
          }
        }
      }

      getReferenceCount(proxy) {
        const id = proxy.id;

        if (!id || !this.proxyCache[id]) {
          return 0;
        }

        return this.proxyCache[id].refCount;
      }

      release(proxy) {
        const proxyInstance = this.proxyCache[proxy.id];

        if (proxyInstance) {
          --proxyInstance.refCount;
        }

        if (proxyInstance && proxyInstance.refCount <= 0) {
          delete this.proxyCache[proxy.id];
        }
      }

      reset() {
        this.proxyCache = {};
      }

      create(element) {
        let key = 'window';

        if (!WindowManager.isWindow(element)) {
          key = element ? element.getAttribute(POSITION_ATTR_NAME) : null; // 1 - Node.ELEMENT_NODE, 11 - Node.DOCUMENT_FRAGMENT_NODE

          assert(key && element.nodeType && (element.nodeType !== 1 || element.nodeType !== 11), `Element Proxy requires an element and has property ${POSITION_ATTR_NAME}`);
        }

        if (this.proxyCache[key]) {
          this.proxyCache[key].refCount++;
          return this.proxyCache[key].el;
        }

        const newProxy = new ElementProxy(element, key);
        newProxy.setReleaseCallback(release, newProxy);
        this.proxyCache[key] = {
          el: newProxy,
          refCount: 1
        }; // run GC

        timeout(0).then(() => {
          this.releaseOrphanProxies();
        });
        return this.proxyCache[key].el;
      }

    }

    lwc.registerDecorators(ProxyCache, {
      fields: ["proxyCache"]
    });

    const elementProxyCache = new ProxyCache();
    function bakeOff() {
      elementProxyCache.bakeOff();
    }
    function release(proxy) {
      return elementProxyCache.release(proxy);
    }
    function createProxy(element) {
      return elementProxyCache.create(element);
    }

    class RepositionQueue {
      constructor() {
        this.callbacks = [];
        this.repositionScheduled = false;
        this._constraints = [];
        this.timeoutId = 0;
        this.lastIndex = getZIndexBaseline();
        this.eventsBound = false;
      }

      get nextIndex() {
        return this.lastIndex++;
      }

      get constraints() {
        return this._constraints;
      }

      set constraints(value) {
        this._constraints = this._constraints.concat(value);
      }

      dispatchRepositionCallbacks() {
        while (this.callbacks.length > 0) {
          this.callbacks.shift()();
        }
      }

      add(callback) {
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
          return true;
        }

        return false;
      }

      scheduleReposition(callback) {
        if (this.timeoutId === 0) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          this.timeoutId = setTimeout(() => {
            this.reposition(callback);
          }, 10);
        }
      }

      reposition(callback) {
        // all the callbacks will be called
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
        } // this is for throttling


        clearTimeout(this.timeoutId);
        this.timeoutId = 0; // this semaphore is to make sure
        // if reposition is called twice within one frame
        // we only run this once

        if (!this.repositionScheduled) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            this.repositionScheduled = false; // this must be executed in order or constraints
            // will behave oddly

            this._constraints = this._constraints.filter(constraint => {
              if (!constraint.destroyed) {
                constraint.computeDisplacement().computePosition();
                return true;
              }

              return false;
            });
            bakeOff();
            this.dispatchRepositionCallbacks();
          });
          this.repositionScheduled = true;
        }
      }

      get repositioning() {
        if (!this._reposition) {
          this._reposition = this.scheduleReposition.bind(this);
        }

        return this._reposition;
      }

      bindEvents() {
        if (!this.eventsBound) {
          window.addEventListener('resize', this.repositioning);
          window.addEventListener('scroll', this.repositioning);
          this.eventsBound = true;
        }
      }

      detachEvents() {
        window.removeEventListener('resize', this.repositioning);
        window.removeEventListener('scroll', this.repositioning);
        this.eventsBound = false;
      }

    }

    lwc.registerDecorators(RepositionQueue, {
      fields: ["callbacks", "repositionScheduled", "_constraints", "timeoutId", "lastIndex", "eventsBound"]
    });

    const positionQueue = new RepositionQueue();
    function scheduleReposition(callback) {
      positionQueue.scheduleReposition(callback);
    }
    function bindEvents() {
      positionQueue.bindEvents();
    }
    function addConstraints(list) {
      positionQueue.constraints = list;
    }
    function reposition(callback) {
      positionQueue.reposition(callback);
    }
    function nextIndex() {
      return positionQueue.nextIndex;
    }

    class Relationship {
      constructor(config, constraintList, scrollableParent) {
        this.config = config;
        this.constraintList = constraintList;
        this.scrollableParent = scrollableParent;
      }

      disable() {
        this.constraintList.forEach(constraintToDisable => {
          constraintToDisable.detach();
        });
      }

      enable() {
        this.constraintList.forEach(constraintToEnable => {
          constraintToEnable.attach();
        });
      }

      destroy() {
        if (this.config.removeListeners) {
          this.config.removeListeners();
          this.config.removeListeners = undefined;
        }

        while (this.constraintList.length > 0) {
          this.constraintList.pop().destroy();
        } // Clean up node appended to body of dom


        if (this.config.appendToBody && this.config.element) {
          // eslint-disable-next-line @lwc/lwc/no-document-query
          const nodeToRemove = document.querySelector(`[${POSITION_ATTR_NAME}="${this.config.element.getAttribute(POSITION_ATTR_NAME)}"]`);

          if (nodeToRemove) {
            nodeToRemove.parentNode.removeChild(nodeToRemove);
          }
        }
      }

      reposition() {
        return new Promise(resolve => {
          reposition(() => {
            resolve();
          });
        });
      }

    }

    const DEFAULT_MIN_HEIGHT = '1.875rem';

    function setupObserver(config, scrollableParent) {
      let proxyWheelEvents = true;
      const observedElement = config.element;

      if (WindowManager.MutationObserver && !observedElement.isObserved) {
        // phantomjs :(
        let scrollableChildren = queryScrollableChildren(observedElement);
        const observer = new WindowManager.MutationObserver(() => {
          scrollableChildren = queryScrollableChildren(observedElement);
          proxyWheelEvents = !containsScrollingElement(scrollableChildren);
        });

        if (containsScrollingElement(scrollableChildren)) {
          proxyWheelEvents = false;
        }

        observer.observe(observedElement, {
          attributes: true,
          subtree: true,
          childList: true
        });
        observedElement.isObserved = true;
      }

      if (scrollableParent) {
        scrollableParent.addEventListener('scroll', scheduleReposition); // if the target element is inside a
        // scrollable element, we need to make sure
        // scroll events move that element,
        // not the parent, also we need to reposition on scroll

        const wheelCallback = e => {
          if (proxyWheelEvents && scrollableParent && typeof scrollableParent.scrollTop !== 'undefined') {
            scrollableParent.scrollTop += e.deltaY;
          }
        };

        observedElement.addEventListener('wheel', wheelCallback);

        config.removeListeners = () => {
          scrollableParent.removeEventListener('scroll', scheduleReposition);
          observedElement.removeEventListener('wheel', wheelCallback);
        };
      }
    }

    function validateConfig(config) {
      assert(config.element && isDomNode(config.element), 'Element is undefined or missing, or not a Dom Node');
      assert(config.target && (WindowManager.isWindow(config.target) || isDomNode(config.target)), 'Target is undefined or missing');
    }

    function createRelationship(config) {
      bindEvents();

      if (config.alignWidth && config.element.style.position === 'fixed') {
        config.element.style.width = config.target.getBoundingClientRect().width + 'px';
      }

      const constraintList = [];
      const scrollableParent = getScrollableParent(getPositionTarget(config.target), WindowManager.window); // This observer and the test for scrolling children
      // is so that if a panel contains a scroll we do not
      // proxy the events to the "parent"  (actually the target's parent)

      setupObserver(config, scrollableParent);

      if (config.appendToBody) {
        document.body.appendChild(config.element);
      }

      config.element = createProxy(config.element);
      config.target = createProxy(config.target); // Add horizontal constraint.

      const horizontalConfig = Object.assign({}, config);

      if (horizontalConfig.padLeft !== undefined) {
        horizontalConfig.pad = horizontalConfig.padLeft;
      } // Add vertical constraint.


      const verticalConfig = Object.assign({}, config);

      if (verticalConfig.padTop !== undefined) {
        verticalConfig.pad = verticalConfig.padTop;
      }

      constraintList.push(new Constraint(mapToHorizontal(config.align.horizontal), horizontalConfig));
      constraintList.push(new Constraint(mapToVertical(config.align.vertical), verticalConfig));
      const autoShrink = config.autoShrink.height || config.autoShrink.width;

      if (config.scrollableParentBound && scrollableParent) {
        const parent = normalizeElement(scrollableParent);
        const boxConfig = {
          element: config.element,
          enabled: config.enabled,
          target: createProxy(parent),
          align: {},
          targetAlign: {},
          pad: 3,
          boxDirections: {
            top: true,
            bottom: true,
            left: true,
            right: true
          }
        };

        if (autoShrink) {
          const style = boxConfig.element.getNode().style;

          if (!style.minHeight) {
            style.minHeight = config.minHeight;
            boxConfig.element._removeMinHeight = true;
          }

          boxConfig.boxDirections = {
            top: !!config.autoShrink.height,
            bottom: !!config.autoShrink.height,
            left: !!config.autoShrink.width,
            right: !!config.autoShrink.width
          };
          constraintList.push(new Constraint('shrinking box', boxConfig));
        } else {
          constraintList.push(new Constraint('bounding box', boxConfig));
        }
      }

      addConstraints(constraintList);
      reposition();
      return new Relationship(config, constraintList, scrollableParent);
    }

    function isAutoFlipHorizontal(config) {
      return config.autoFlip || config.autoFlipHorizontal;
    }

    function isAutoFlipVertical(config) {
      return config.autoFlip || config.autoFlipVertical;
    }

    function normalizeAlignments(config, flipConfig) {
      const align = {
        horizontal: config.align.horizontal,
        vertical: config.align.vertical
      };
      const targetAlign = {
        horizontal: config.targetAlign.horizontal,
        vertical: config.targetAlign.vertical
      }; // Horizontal alignments flip for RTL languages.

      if (document.dir === 'rtl') {
        align.horizontal = flipDirection(align.horizontal);
        targetAlign.horizontal = flipDirection(targetAlign.horizontal);
      } // When using the autoFlip flags with center alignment, we change the element alignment to fit
      // within the viewport when it's detected that it overflows the edge of the viewport.


      let vFlip = false;

      if (isAutoFlipVertical(config)) {
        if (align.vertical === Direction.Bottom) {
          vFlip = !flipConfig.hasSpaceAbove && flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Top) {
          vFlip = flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Center) {
          if (flipConfig.centerOverflow.top && !flipConfig.centerOverflow.bottom) {
            align.vertical = targetAlign.vertical = Direction.Top;
          } else if (flipConfig.centerOverflow.bottom && !flipConfig.centerOverflow.top) {
            align.vertical = targetAlign.vertical = Direction.Bottom;
          }
        }
      }

      let hFlip = false;

      if (isAutoFlipHorizontal(config)) {
        if (align.horizontal === Direction.Left) {
          hFlip = flipConfig.shouldAlignToRight;
        } else if (align.horizontal === Direction.Right) {
          hFlip = flipConfig.shouldAlignToLeft;
        } else if (align.horizontal === Direction.Center) {
          if (flipConfig.centerOverflow.left && !flipConfig.centerOverflow.right) {
            align.horizontal = targetAlign.horizontal = Direction.Left;
          } else if (flipConfig.centerOverflow.right && !flipConfig.centerOverflow.left) {
            align.horizontal = targetAlign.horizontal = Direction.Right;
          }
        }
      }

      return {
        align: {
          horizontal: hFlip ? flipDirection(align.horizontal) : normalizeDirection(align.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(align.vertical) : normalizeDirection(align.vertical, Direction.Top)
        },
        targetAlign: {
          horizontal: hFlip ? flipDirection(targetAlign.horizontal) : normalizeDirection(targetAlign.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(targetAlign.vertical) : normalizeDirection(targetAlign.vertical, Direction.Bottom)
        }
      };
    }

    function normalizeConfig(config) {
      config.align = config.align || {};
      config.targetAlign = config.targetAlign || {};
      config.isInsideModal = isInsideModal(config.element);
      const flipConfig = checkFlipPossibility(config.element, config.target, config.leftAsBoundary);
      const {
        align,
        targetAlign
      } = normalizeAlignments(config, flipConfig); // When inside modal, element may expand out of the viewport and be cut off.
      // So if inside modal, and don't have enough space above or below, will add bounding box rule.

      if (config.isInsideModal && !flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow) {
        config.scrollableParentBound = true;
      }

      return {
        target: config.target,
        element: config.element,
        align,
        targetAlign,
        alignWidth: config.alignWidth,
        scrollableParentBound: config.scrollableParentBound,
        pad: config.pad,
        padTop: config.padTop,
        padLeft: config.padLeft,
        autoShrink: {
          height: config.autoShrink || config.autoShrinkHeight,
          width: config.autoShrink || config.autoShrinkWidth
        },
        minHeight: config.minHeight || DEFAULT_MIN_HEIGHT
      };
    }

    function toElement(root, target) {
      if (target && typeof target === 'string') {
        return root.querySelector(target);
      } else if (target && typeof target === 'function') {
        return target();
      }

      return target;
    }

    function startPositioning(root, config) {
      assert(root, 'Root is undefined or missing');
      assert(config, 'Config is undefined or missing');
      const node = normalizeElement(root);
      const target = toElement(node, config.target);
      const element = toElement(node, config.element); // when target/element is selector, there is chance, dom isn't present anymore.

      if (!target || !element) {
        return null;
      }

      config.target = normalizeElement(target);
      config.element = normalizeElement(element); // Element absolute / fixed must be set prior to getBoundingClientRect call or
      // the scrollable parent (usually due to uiModal/uiPanel) will push the page down.

      config.element = normalizePosition(config.element, nextIndex(), config.target, config.alignWidth);
      validateConfig(config);
      return createRelationship(normalizeConfig(config));
    }
    function stopPositioning(relationship) {
      if (relationship) {
        relationship.destroy();
      }
    }
    class AutoPosition {
      constructor(root) {
        this._autoPositionUpdater = null;
        this._root = root;
      }

      start(config) {
        return requestAnimationFrameAsPromise().then(() => {
          let promise = Promise.resolve();

          if (!this._autoPositionUpdater) {
            this._autoPositionUpdater = startPositioning(this._root, config);
          } else {
            promise = promise.then(() => {
              return this._autoPositionUpdater.reposition();
            });
          }

          return promise.then(() => {
            return this._autoPositionUpdater;
          });
        });
      }

      stop() {
        if (this._autoPositionUpdater) {
          stopPositioning(this._autoPositionUpdater);
          this._autoPositionUpdater = null;
        }

        return Promise.resolve();
      }

    }

    lwc.registerDecorators(AutoPosition, {
      fields: ["_autoPositionUpdater"]
    });

    function tmpl$2($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 0,
        on: {
          "mouseleave": _m0 || ($ctx._m0 = api_bind($cmp.handleMouseLeave))
        }
      }, [])];
    }

    var _tmpl$3 = lwc.registerTemplate(tmpl$2);
    tmpl$2.stylesheets = [];
    tmpl$2.stylesheetTokens = {
      hostAttribute: "lightning-primitiveBubble_primitiveBubble-host",
      shadowAttribute: "lightning-primitiveBubble_primitiveBubble"
    };

    const DEFAULT_ALIGN = {
      horizontal: 'left',
      vertical: 'bottom'
    };

    class LightningPrimitiveBubble extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          visible: false,
          contentId: ''
        };
        this.divElement = void 0;
      }

      get contentId() {
        return this.state.contentId;
      }

      set contentId(value) {
        this.state.contentId = value;

        if (this.state.inDOM) {
          this.divEl.setAttribute('id', this.state.contentId);
        }
      }

      connectedCallback() {
        this.updateClassList();
        this.state.inDOM = true;
      }

      disconnectedCallback() {
        this.state.inDOM = false;
      }

      renderedCallback() {
        // set content manually once rendered
        // - this is required to avoid the content update being in the wrong 'tick'
        this.setContentManually();
        this.setIdManually();
      }

      set content(value) {
        this.state.content = value;

        if (this.state.inDOM) {
          this.setContentManually();
        }
      }

      get content() {
        return this.state.content || '';
      }

      get align() {
        return this.state.align || DEFAULT_ALIGN;
      }

      set align(value) {
        this.state.align = value;
        this.updateClassList();
      }

      get visible() {
        return this.state.visible;
      }

      set visible(value) {
        this.state.visible = value;
        this.updateClassList();
      }

      setIdManually() {
        this.divElement = this.divElement ? this.divElement : this.template.querySelector('div');
        this.divElement.setAttribute('id', this.state.contentId);
      } // manually set the content value


      setContentManually() {
        /* manipulate DOM directly */
        this.template.querySelector('.slds-popover__body').textContent = this.state.content;
      } // compute class value for this bubble


      updateClassList() {
        const classes = classSet('slds-popover').add('slds-popover_tooltip'); // show or hide bubble

        classes.add({
          'slds-rise-from-ground': this.visible,
          'slds-fall-into-ground': !this.visible
        }); // apply the proper nubbin CSS class

        const {
          horizontal,
          vertical
        } = this.align;
        classes.add({
          'slds-nubbin_top-left': horizontal === 'left' && vertical === 'top',
          'slds-nubbin_top-right': horizontal === 'right' && vertical === 'top',
          'slds-nubbin_bottom-left': horizontal === 'left' && vertical === 'bottom',
          'slds-nubbin_bottom-right': horizontal === 'right' && vertical === 'bottom',
          'slds-nubbin_bottom': horizontal === 'center' && vertical === 'bottom',
          'slds-nubbin_top': horizontal === 'center' && vertical === 'top',
          'slds-nubbin_left': horizontal === 'left' && vertical === 'center',
          'slds-nubbin_right': horizontal === 'right' && vertical === 'center'
        });
        classListMutation(this.classList, classes);
      }

      handleMouseLeave() {
        this.visible = false;
      }

    }

    lwc.registerDecorators(LightningPrimitiveBubble, {
      publicProps: {
        contentId: {
          config: 3
        },
        content: {
          config: 3
        },
        align: {
          config: 3
        },
        visible: {
          config: 3
        }
      },
      track: {
        state: 1
      },
      fields: ["divElement"]
    });

    var LightningPrimitiveBubble$1 = lwc.registerComponent(LightningPrimitiveBubble, {
      tmpl: _tmpl$3
    });

    var formFactor = 'Large';

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const BUBBLE_ID = `salesforce-lightning-tooltip-bubble_${guid()}`;

    function isResizeObserverSupported() {
      return window.ResizeObserver != null;
    }

    function buildResizeObserver(callback) {
      if (isResizeObserverSupported()) {
        return new ResizeObserver(callback);
      }

      return {
        observe() {},

        unobserve() {}

      };
    }
    /**
     * Shared instance of a primitive bubble used as a tooltip by most components. This was originally
     * defined in the helptext component which is where the minWidth style came from.
     * TODO: We may want to revisit the minWidth style with the PO and/or UX.
     */


    let CACHED_BUBBLE_ELEMENT;

    function getCachedBubbleElement() {
      if (!CACHED_BUBBLE_ELEMENT) {
        CACHED_BUBBLE_ELEMENT = lwc.createElement('lightning-primitive-bubble', {
          is: LightningPrimitiveBubble$1
        });
        CACHED_BUBBLE_ELEMENT.contentId = BUBBLE_ID;
        CACHED_BUBBLE_ELEMENT.style.position = 'absolute';
        CACHED_BUBBLE_ELEMENT.style.minWidth = '75px';
        CACHED_BUBBLE_ELEMENT.style.display = 'none';
      }

      return CACHED_BUBBLE_ELEMENT;
    }

    const ARIA_DESCRIBEDBY = 'aria-describedby';
    /**
     * Used as a position offset to compensate for the nubbin. The dimensions of the nubbin are not
     * included in the position library bounding box calculations. This is the size in pixels of the
     * nubbin.
     * TODO: We may want to measure this instead in cases it changes.
     */

    const NUBBIN_SIZE = 16;
    /**
     * Used in the calculation that moves the tooltip to a location that places the nubbin at the
     * center of the target element. This is the nubbin offset from the edge of the bubble in pixels
     * when using slds-nubbin_bottom-left or slds-nubbin_bottom-right.
     * TODO: We may want to measure this instead in case it changes.
     */

    const NUBBIN_OFFSET = 24;
    /**
     * Known tooltip types:
     * - info: used in cases where target already has click handlers such as button-icon
     * - toggle: used in cases where target only shows a tooltip such as helptext
     */

    const TooltipType = {
      Info: 'info',
      Toggle: 'toggle'
    };
    /**
     * Allows us to attach a tooltip to components. Typical usage is as follows:
     * - Create an instance of Tooltip
     * - Call Tooltip.initialize() to add the appropriate listeners to the element that needs a tooltip
     * See buttonIcon and buttonMenu for example usage.
     */

    class Tooltip {
      /**
       * A shared instance of primitiveBubble is used when an element is not specified in the config
       * object.
       * @param {string} value the content of the tooltip
       * @param {object} config specifies the root component, target element of the tooltip
       */
      constructor(value, config) {
        this._autoPosition = null;
        this._disabled = true;
        this._initialized = false;
        this._visible = false;
        this._config = {};
        assert(config.target, 'target for tooltip is undefined or missing');
        this.value = value;
        this._root = config.root;
        this._target = config.target;
        this._config = _objectSpread({}, config);
        this._config.align = config.align || {};
        this._config.targetAlign = config.targetAlign || {};
        this._type = normalizeString(config.type, {
          fallbackValue: TooltipType.Info,
          validValues: Object.values(TooltipType)
        }); // If a tooltip element is not given, fall back on the globally shared instance.

        this._element = config.element;

        if (!this._element) {
          this._element = getCachedBubbleElement;
          const bubbleElement = getCachedBubbleElement();

          if (bubbleElement.parentNode === null) {
            document.body.appendChild(bubbleElement);
          }
        }

        this.handleDocumentTouch = this.handleDocumentTouch.bind(this);
      }
      /**
       * Disables the tooltip.
       */


      detach() {
        this._disabled = true;
      }
      /**
       * Enables the tooltip.
       */


      attach() {
        this._disabled = false;
      }
      /**
       * Adds the appropriate event listeners to the target element to make the tooltip appear. Also
       * links the tooltip and target element via the aria-describedby attribute for screen readers.
       */


      initialize() {
        const target = this._target();

        if (!this._initialized && target) {
          switch (this._type) {
            case TooltipType.Toggle:
              this.addToggleListeners();
              break;

            case TooltipType.Info:
            default:
              this.addInfoListeners();
              break;
          }

          const ariaDescribedBy = normalizeAriaAttribute([target.getAttribute(ARIA_DESCRIBEDBY), this._element().contentId]);
          target.setAttribute(ARIA_DESCRIBEDBY, ariaDescribedBy);
          this._initialized = true;
        }
      }

      addInfoListeners() {
        const target = this._target();

        if (!this._initialized && target) {
          ['mouseenter', 'focus'].forEach(name => target.addEventListener(name, () => this.show())); // Unlike the tooltip in Aura, we want clicks and keys to dismiss the tooltip.

          ['mouseleave', 'blur', 'click', 'keydown'].forEach(name => target.addEventListener(name, event => this.hideIfNotSelfCover(event)));
        }
      }

      hideIfNotSelfCover(event) {
        if (event.type === 'mouseleave' && event.clientX && event.clientY) {
          // In any chance, if mouseleave is caused by tooltip itself, it would means
          // tooltip cover the target which mostly caused by dynamic resize of tooltip by CSS or JS.
          try {
            const elementMouseIsOver = document.elementFromPoint ? document.elementFromPoint(event.clientX, event.clientY) : null;

            if (elementMouseIsOver === this._element()) {
              if (!isResizeObserverSupported()) {
                this.startPositioning();
              }

              return;
            }
          } catch (ex) {// Jest Throw Exception
          }
        }

        this.hide();
      }

      handleDocumentTouch() {
        if (this._visible) {
          this.hide();
        }
      }

      addToggleListeners() {
        const target = this._target();

        if (!this._initialized && target) {
          if (Tooltip.isMobile()) {
            target.addEventListener('touchstart', e => {
              e.stopPropagation();
              this.toggle();
            });
          } else {
            ['mouseenter', 'focus'].forEach(name => target.addEventListener(name, () => this.show()));
            ['mouseleave', 'blur'].forEach(name => target.addEventListener(name, event => this.hideIfNotSelfCover(event)));
          }
        }
      }

      get resizeObserver() {
        if (!this._resizeObserver) {
          this._resizeObserver = buildResizeObserver(() => {
            if (this._visible && this._autoPosition) {
              this.startPositioning();
            }
          });
        }

        return this._resizeObserver;
      }

      show() {
        if (this._disabled) {
          return;
        }

        this._visible = true;

        const tooltip = this._element(); // Check if default global instance is hidden.


        if (CACHED_BUBBLE_ELEMENT && CACHED_BUBBLE_ELEMENT.style.display === 'none') {
          CACHED_BUBBLE_ELEMENT.style.display = '';
        }

        tooltip.content = this._value;
        this.startPositioning();

        if (Tooltip.isMobile()) {
          document.addEventListener('touchstart', this.handleDocumentTouch);
        }

        this.resizeObserver.observe(tooltip);
      }

      hide() {
        this._visible = false;

        const tooltip = this._element();

        tooltip.visible = this._visible;
        this.stopPositioning();

        if (Tooltip.isMobile()) {
          document.removeEventListener('touchstart', this.handleDocumentTouch);
        }

        this.resizeObserver.unobserve(tooltip);
      }

      toggle() {
        if (this._visible) {
          this.hide();
        } else {
          this.show();
        }
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
        this._disabled = !value;
      }

      get initialized() {
        return this._initialized;
      }

      get visible() {
        return this._visible;
      }

      startPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this._root);
        } // The lightning-helptext component was originally left aligned.


        const align = {
          horizontal: this._config.align.horizontal || Direction.Left,
          vertical: this._config.align.vertical || Direction.Bottom
        };
        const targetAlign = {
          horizontal: this._config.targetAlign.horizontal || Direction.Left,
          vertical: this._config.targetAlign.vertical || Direction.Top
        }; // Pads the tooltip so its nubbin is at the center of the target element.

        const targetBox = this._target().getBoundingClientRect();

        const padLeft = targetBox.width * 0.5 - NUBBIN_OFFSET;

        this._autoPosition.start({
          target: this._target,
          element: this._element,
          align,
          targetAlign,
          autoFlip: true,
          padTop: NUBBIN_SIZE,
          padLeft
        }).then(autoPositionUpdater => {
          // The calculation above may have flipped the alignment of the tooltip. When the
          // tooltip changes alignment we need to update the nubbin class to have it draw in
          // the appropriate place.
          if (autoPositionUpdater) {
            const tooltip = this._element();

            tooltip.align = autoPositionUpdater.config.align;
            tooltip.visible = this._visible;
          }
        });
      }

      stopPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      static isMobile() {
        return formFactor === 'Small';
      }

    }

    lwc.registerDecorators(Tooltip, {
      fields: ["_autoPosition", "_disabled", "_initialized", "_visible", "_config"]
    });

    const i18n = {
      buttonAlternativeText: labelButtonAlternativeText
    };
    const DEFAULT_ICON_NAME = 'utility:info';
    const DEFAULT_ICON_VARIANT = 'bare';
    /**
     * An icon with a text popover used for tooltips.
     */

    class LightningHelptext extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          iconName: DEFAULT_ICON_NAME,
          iconVariant: DEFAULT_ICON_VARIANT
        };
        this._tooltip = null;
      }

      /**
       * Text to be shown in the popover.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      set content(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button'),
            type: TooltipType.Toggle
          });

          this._tooltip.initialize();
        }
      }

      get content() {
        return this._tooltip ? this._tooltip.value : undefined;
      }
      /**
       * The Lightning Design System name of the icon used as the visible element.
       * Names are written in the format 'utility:info' where 'utility' is the category,
       * and 'info' is the specific icon to be displayed.
       * The default is 'utility:info'.
       * @type {string}
       * @param {string} value the icon name to use
       * @default utility:info
       */


      set iconName(value) {
        this.state.iconName = value;
      }

      get iconName() {
        if (isValidName(this.state.iconName)) {
          return this.state.iconName;
        }

        return DEFAULT_ICON_NAME;
      }
      /**
       * Changes the appearance of the icon.
       * Accepted variants include inverse, warning, error.
       * @type {string}
       * @param {string} value the icon variant to use
       * @default bare
       */


      set iconVariant(value) {
        this.state.iconVariant = value;
      }

      get iconVariant() {
        // NOTE: Leaving a note here because I just wasted a bunch of time
        // investigating why both 'bare' and 'inverse' are supported in
        // lightning-primitive-icon. lightning-icon also has a deprecated
        // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
        // that no classes should be applied. So this component needs to
        // support both 'bare' and 'inverse' while lightning-icon only needs to
        // support 'inverse'.
        return normalizeString(this.state.iconVariant, {
          fallbackValue: DEFAULT_ICON_VARIANT,
          validValues: ['bare', 'error', 'inverse', 'warning']
        });
      }

      renderedCallback() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      get i18n() {
        return i18n;
      } // compute SVG CSS classes to apply to the icon


      get computedSvgClass() {
        const classes = classSet('slds-button__icon');

        switch (this.iconVariant) {
          case 'error':
            classes.add('slds-icon-text-error');
            break;

          case 'warning':
            classes.add('slds-icon-text-warning');
            break;

          case 'inverse':
          case 'bare':
            break;

          default:
            // if custom icon is set, we don't want to set
            // the text-default class
            classes.add('slds-icon-text-default');
        }

        return classes.toString();
      }

    }

    lwc.registerDecorators(LightningHelptext, {
      publicProps: {
        content: {
          config: 3
        },
        iconName: {
          config: 3
        },
        iconVariant: {
          config: 3
        }
      },
      track: {
        state: 1
      },
      fields: ["_tooltip"]
    });

    var _lightningHelptext = lwc.registerComponent(LightningHelptext, {
      tmpl: _tmpl$2
    });

    function stylesheet$3(hostSelector, shadowSelector, nativeShadow) {
      return "slot" + shadowSelector + " {display: inline-block;}\n";
    }
    var _implicitStylesheets$3 = [stylesheet$3];

    function tmpl$3($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot
      } = $api;
      return [api_slot("", {
        key: 0
      }, [], $slotset)];
    }

    var _tmpl$4 = lwc.registerTemplate(tmpl$3);
    tmpl$3.slots = [""];
    tmpl$3.stylesheets = [];

    if (_implicitStylesheets$3) {
      tmpl$3.stylesheets.push.apply(tmpl$3.stylesheets, _implicitStylesheets$3);
    }
    tmpl$3.stylesheetTokens = {
      hostAttribute: "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone-host",
      shadowAttribute: "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone"
    };

    class LightningPrimitiveFileDroppableZone extends lwc.LightningElement {
      get disabled() {
        return this._disabled || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple || false;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      constructor() {
        super();
        this._disabled = void 0;
        this._multiple = void 0;
        this.template.addEventListener('dragover', this.allowDrop.bind(this));
        this.template.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.template.addEventListener('drop', this.handleOnDrop.bind(this));
      }

      connectedCallback() {
        this.classList.add('slds-file-selector__dropzone');
      }

      setDragOver(dragOver) {
        this.classList.toggle('slds-has-drag-over', dragOver);
      }

      handleDragLeave() {
        this.setDragOver(false);
      }

      handleOnDrop(event) {
        event.preventDefault();
        this.setDragOver(false);

        if (this.disabled) {
          event.stopPropagation();
          return;
        }

        if (!this.meetsMultipleCriteria(event)) {
          event.stopPropagation();
        }
      }

      allowDrop(event) {
        event.preventDefault();

        if (!this.disabled) {
          this.setDragOver(true);
        }
      }

      meetsMultipleCriteria(dragEvent) {
        const files = dragEvent.dataTransfer.files;
        return !(files.length > 1 && !this.multiple);
      }

    }

    lwc.registerDecorators(LightningPrimitiveFileDroppableZone, {
      publicProps: {
        disabled: {
          config: 3
        },
        multiple: {
          config: 3
        }
      },
      track: {
        _disabled: 1,
        _multiple: 1
      }
    });

    var _lightningPrimitiveFileDroppableZone = lwc.registerComponent(LightningPrimitiveFileDroppableZone, {
      tmpl: _tmpl$4
    });

    function tmpl$4($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        gid: api_scoped_id,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-color-picker__custom": true
        },
        key: 31
      }, [api_element("p", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("color-picker-instructions")
        },
        key: 0
      }, [api_dynamic($cmp.i18n.colorPickerInstructions)]), api_element("div", {
        classMap: {
          "slds-m-bottom_small": true
        },
        style: $cmp.gradientStyle,
        attrs: {
          "data-id": "color-gradient"
        },
        key: 4,
        on: {
          "mousedown": _m3 || ($ctx._m3 = api_bind($cmp.handleMouseDown))
        }
      }, [api_element("canvas", {
        attrs: {
          "width": $cmp.canvasRect.x,
          "height": $cmp.canvasRect.y
        },
        key: 1
      }, []), api_element("a", {
        classMap: {
          "slds-color-picker__range-indicator": true
        },
        styleMap: {
          "position": "absolute",
          "display": "inline"
        },
        attrs: {
          "data-id": "color-anchor",
          "href": "javascript:void(0)",
          "aria-live": "assertive",
          "aria-atomic": "true",
          "aria-describedby": `${api_scoped_id("color-picker-instructions")}`
        },
        key: 3,
        on: {
          "mousedrag": _m0 || ($ctx._m0 = api_bind($cmp.handlePreventDefault)),
          "mousedown": _m1 || ($ctx._m1 = api_bind($cmp.handlePreventDefault)),
          "keydown": _m2 || ($ctx._m2 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 2
      }, [api_dynamic($cmp.computedSaturationAndBrightness)])])]), api_element("div", {
        classMap: {
          "slds-color-picker__hue-and-preview": true
        },
        key: 9
      }, [api_element("label", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "for": `${api_scoped_id("rainbow")}`
        },
        key: 5
      }, [api_dynamic($cmp.i18n.hueInput)]), api_element("input", {
        classMap: {
          "slds-color-picker__hue-slider": true
        },
        attrs: {
          "data-id": "hue-slider",
          "type": "range",
          "min": "0",
          "max": "360",
          "id": api_scoped_id("rainbow")
        },
        props: {
          "value": $cmp._hueValue
        },
        key: 6,
        on: {
          "mousedown": _m4 || ($ctx._m4 = api_bind($cmp.handleDrag)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.onChange))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-swatch": true
        },
        style: $cmp.thumbnailStyle,
        attrs: {
          "data-id": "color-preview"
        },
        key: 8
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 7
      }, [api_dynamic($cmp._hex)])])]), api_element("div", {
        classMap: {
          "slds-color-picker__custom-inputs": true
        },
        key: 29
      }, [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-color-picker__input-custom-hex": true
        },
        key: 13
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 10
      }, [api_dynamic($cmp.i18n.hexLabel)]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 12
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "data-primary-input": true,
          "type": "text",
          "id": api_scoped_id("input"),
          "minlength": "4",
          "maxlength": "7",
          "pattern": "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$",
          "placeholder": "#FFFFFF"
        },
        props: {
          "value": $cmp._hex
        },
        key: 11,
        on: {
          "change": _m6 || ($ctx._m6 = api_bind($cmp.handleHexChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 18
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("red")}`
        },
        key: 15
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.redAbbr
        },
        key: 14
      }, [api_dynamic($cmp.i18n.rInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 17
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("red"),
          "data-color-name": "red",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.red
        },
        key: 16,
        on: {
          "change": _m7 || ($ctx._m7 = api_bind($cmp.handleRgbChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 23
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("green")}`
        },
        key: 20
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.greenAbbr
        },
        key: 19
      }, [api_dynamic($cmp.i18n.gInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 22
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("green"),
          "data-color-name": "green",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.green
        },
        key: 21,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleRgbChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 28
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("blue")}`
        },
        key: 25
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.blueAbbr
        },
        key: 24
      }, [api_dynamic($cmp.i18n.bInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 27
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("blue"),
          "data-color-name": "blue",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.blue
        },
        key: 26,
        on: {
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleRgbChange))
        }
      }, [])])])]), $cmp._errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "aria-live": "assertive"
        },
        key: 30
      }, [api_dynamic($cmp._errorMessage)]) : null])];
    }

    var _tmpl$5 = lwc.registerTemplate(tmpl$4);
    tmpl$4.stylesheets = [];
    tmpl$4.stylesheetTokens = {
      hostAttribute: "lightning-colorPickerCustom_colorPickerCustom-host",
      shadowAttribute: "lightning-colorPickerCustom_colorPickerCustom"
    };

    var labelBInput = 'B';

    var labelBlueAbbr = 'Blue';

    var labelColorPickerInstructions = 'Use arrow keys to select a saturation and brightness, on an x and y axis.';

    var labelErrorMessage = 'Enter a valid hexadecimal value.';

    var labelGInput = 'G';

    var labelGreenAbbr = 'Green';

    var labelHexLabel = 'Hex';

    var labelHueInput = 'Select Hue';

    var labelRInput = 'R';

    var labelRedAbbr = 'Red';

    let idCounter = 0;
    function generateUniqueId(prefix = 'input') {
      idCounter++;
      return `${prefix}-${idCounter}`;
    }

    /**
     Represents an object which keeps track of a user's interacting state.
     @constructor InteractingState
     @param {Object} options - The options object.
     @param {Object} [options.duration=2000] - The number of milliseconds of idle time to wait before exiting the interacting state.
     @param {Object} [options.debounceInteraction=false] - Whether to debounce interaction to ignore consecutive leave-enter interactions.
     **/

    class InteractingState {
      constructor(options) {
        const duration = options && options.duration >= 0 ? options.duration : 2000;
        this.eventemitter = new EventEmitter();
        this._interacting = false;
        this._debouncedLeave = debounce(this.leave.bind(this), duration);
        this._debounceInteraction = options && options.debounceInteraction;
        this._interactedRecently = false;

        if (this._debounceInteraction) {
          // debounce leave until a short time later
          this._debouncedEmitLeave = debounce(() => {
            if (!this._interacting) {
              this._interactedRecently = false;
              this.eventemitter.emit('leave');
            }
          }, 200); // debounce enter until left

          this._debouncedEmitEnter = () => {
            if (!this._interactedRecently) {
              this._interactedRecently = true;
              this.eventemitter.emit('enter');
            }
          };
        }
      }
      /**
       Checks whether or not we are in the interacting state.
       @method InteractingState#isInteracting
       @return {Boolean} - Whether or not we are interacting.
       **/


      isInteracting() {
        return this._interacting;
      }
      /**
       Enters the interacting state.
       @method InteractingState#enter
       @returns {void}
       **/


      enter() {
        if (!this._interacting) {
          this._interacting = true;

          if (this._debounceInteraction) {
            this._debouncedEmitEnter();
          } else {
            this.eventemitter.emit('enter');
          }
        }
      }
      /**
       Registers a handler to execute when we enter the interacting state.
       @method InteractingState#onenter
       @param {Function} handler - The callback function.
       **/


      onenter(handler) {
        this.eventemitter.on('enter', handler);
      }
      /**
       Leaves the interacting state.
       @method InteractingState#leave
       @returns {void}
       **/


      leave() {
        if (this._interacting) {
          this._interacting = false;

          if (this._debounceInteraction) {
            this._debouncedEmitLeave();
          } else {
            this.eventemitter.emit('leave');
          }
        }
      }
      /**
       Registers a handler to execute when we leave the interacting state.
       @method InteractingState#onleave
       @param {Function} handler - The callback function.
       **/


      onleave(handler) {
        this.eventemitter.on('leave', handler);
      }
      /**
       Signals the start of the transition into the interacting state and
       schedules a transition out of the interacting state after an idle
       duration. Calling this method multiple times will reset the timer.
       @method InteractingState#interacting
       @returns {void}
       **/


      interacting() {
        this.enter();

        this._debouncedLeave();
      }

    }
    /**
     Creates a debounced function that delays invoking `func` until after
     `delay` milliseconds have elapsed since the last time the debounced
     function was invoked.
     @function debounce
     @param {Function} func - The function to debounce
     @param {Number} delay - The number of milliseconds to delay
     @param {Object} options - The options object
     @param {Boolean} options.leading - Specify invoking on the leading edge of the timeout
     @return {Function} - debounced function
     **/

    function debounce(func, delay, options) {
      const _options = options || {};

      let invokeLeading = _options.leading;
      let timer;
      return function debounced() {
        const args = Array.prototype.slice.apply(arguments);

        if (invokeLeading) {
          func.apply(this, args);
          invokeLeading = false;
        }

        clearTimeout(timer); // eslint-disable-next-line @lwc/lwc/no-async-operation

        timer = setTimeout(function () {
          func.apply(this, args);
          invokeLeading = _options.leading; // reset for next debounce sequence
        }, delay);
      };
    }

    var labelBadInput = 'Enter a valid value.';

    var labelPatternMismatch = 'Your entry does not match the allowed pattern.';

    var labelRangeOverflow = 'The number is too high.';

    var labelRangeUnderflow = 'The number is too low.';

    var labelStepMismatch = 'Your entry isn\'t a valid increment.';

    var labelTooLong = 'Your entry is too long.';

    var labelTooShort = 'Your entry is too short.';

    var labelTypeMismatch = 'You have entered an invalid format.';

    var labelValueMissing = 'Complete this field.';

    const constraintsSortedByPriority = ['customError', 'badInput', 'patternMismatch', 'rangeOverflow', 'rangeUnderflow', 'stepMismatch', 'tooLong', 'tooShort', 'typeMismatch', 'valueMissing'];
    const defaultLabels = {
      badInput: labelBadInput,
      customError: labelBadInput,
      patternMismatch: labelPatternMismatch,
      rangeOverflow: labelRangeOverflow,
      rangeUnderflow: labelRangeUnderflow,
      stepMismatch: labelStepMismatch,
      tooLong: labelTooLong,
      tooShort: labelTooShort,
      typeMismatch: labelTypeMismatch,
      valueMissing: labelValueMissing
    };

    function resolveBestMatch(validity) {
      let validityState;

      if (validity && validity.valid === false) {
        validityState = 'badInput';
        constraintsSortedByPriority.some(stateName => {
          if (validity[stateName] === true) {
            validityState = stateName;
            return true;
          }

          return false;
        });
      }

      return validityState;
    }

    function computeConstraint(valueProvider, constraint) {
      const provider = valueProvider[constraint];

      if (typeof provider === 'function') {
        return provider();
      }

      if (typeof provider === 'boolean') {
        return provider;
      }

      return false;
    } // We're doing the below to avoid exposing the constraintsProvider in the ValidityState


    function newValidityState(constraintsProvider) {
      class ValidityState {
        get valueMissing() {
          return computeConstraint(constraintsProvider, 'valueMissing');
        }

        get typeMismatch() {
          return computeConstraint(constraintsProvider, 'typeMismatch');
        }

        get patternMismatch() {
          return computeConstraint(constraintsProvider, 'patternMismatch');
        }

        get tooLong() {
          return computeConstraint(constraintsProvider, 'tooLong');
        }

        get tooShort() {
          return computeConstraint(constraintsProvider, 'tooShort');
        }

        get rangeUnderflow() {
          return computeConstraint(constraintsProvider, 'rangeUnderflow');
        }

        get rangeOverflow() {
          return computeConstraint(constraintsProvider, 'rangeOverflow');
        }

        get stepMismatch() {
          return computeConstraint(constraintsProvider, 'stepMismatch');
        }

        get customError() {
          return computeConstraint(constraintsProvider, 'customError');
        }

        get badInput() {
          return computeConstraint(constraintsProvider, 'badInput');
        }

        get valid() {
          return !(this.valueMissing || this.typeMismatch || this.patternMismatch || this.tooLong || this.tooShort || this.rangeUnderflow || this.rangeOverflow || this.stepMismatch || this.customError || this.badInput);
        }

      }

      return new ValidityState();
    }

    function buildSyntheticValidity(constraintProvider) {
      return Object.freeze(newValidityState(constraintProvider));
    }
    function getErrorMessage(validity, labelMap) {
      const key = resolveBestMatch(validity);

      if (key) {
        return labelMap[key] ? labelMap[key] : defaultLabels[key];
      }

      return '';
    }
    class FieldConstraintApi {
      constructor(inputComponentProvider, constraintProviders) {
        assert(typeof inputComponentProvider === 'function');
        this._inputComponentProvider = inputComponentProvider;
        this._constraintsProvider = Object.assign({}, constraintProviders);

        if (!this._constraintsProvider.customError) {
          this._constraintsProvider.customError = () => typeof this._customValidityMessage === 'string' && this._customValidityMessage !== '';
        }
      }

      get validity() {
        if (!this._constraint) {
          this._constraint = buildSyntheticValidity(this._constraintsProvider);
        }

        return this._constraint;
      }

      checkValidity() {
        const isValid = this.validity.valid;

        if (!isValid) {
          if (this.inputComponent) {
            this.inputComponent.dispatchEvent(new CustomEvent('invalid', {
              cancellable: true
            }));
          }
        }

        return isValid;
      }

      reportValidity(callback) {
        const valid = this.checkValidity(); // the input might have been removed from the DOM by the time we query it

        if (this.inputComponent) {
          this.inputComponent.classList.toggle('slds-has-error', !valid);

          if (callback) {
            callback(this.validationMessage);
          }
        }

        return valid;
      }

      setCustomValidity(message) {
        this._customValidityMessage = message;
      }

      get validationMessage() {
        return getErrorMessage(this.validity, {
          customError: this._customValidityMessage,
          badInput: this.inputComponent.messageWhenBadInput,
          patternMismatch: this.inputComponent.messageWhenPatternMismatch,
          rangeOverflow: this.inputComponent.messageWhenRangeOverflow,
          rangeUnderflow: this.inputComponent.messageWhenRangeUnderflow,
          stepMismatch: this.inputComponent.messageWhenStepMismatch,
          tooShort: this.inputComponent.messageWhenTooShort,
          tooLong: this.inputComponent.messageWhenTooLong,
          typeMismatch: this.inputComponent.messageWhenTypeMismatch,
          valueMissing: this.inputComponent.messageWhenValueMissing
        });
      }

      get inputComponent() {
        if (!this._inputComponentElement) {
          this._inputComponentElement = this._inputComponentProvider();
        }

        return this._inputComponentElement;
      }

    }
    class FieldConstraintApiWithProxyInput {
      constructor(inputComponent, overrides = {}, inputElementName = 'input') {
        this._inputComponent = inputComponent;
        this._overrides = overrides;
        this._proxyInput = document.createElement(inputElementName);
      }

      setInputAttributes(attributes) {
        this._attributes = attributes;

        this._attributeUpdater = attributeNames => {
          if (!attributes) {
            return;
          }

          if (typeof attributeNames === 'string') {
            this._setAttribute(attributeNames, attributes[attributeNames]());
          } else {
            attributeNames.forEach(attributeName => {
              this._setAttribute(attributeName, attributes[attributeName]());
            });
          }
        };

        return this._attributeUpdater;
      }

      get validity() {
        return this._constraintApi.validity;
      }

      checkValidity() {
        return this._constraintApi.checkValidity();
      }

      reportValidity(callback) {
        return this._constraintApi.reportValidity(callback);
      }

      setCustomValidity(message) {
        this._constraintApi.setCustomValidity(message);

        this._proxyInput.setCustomValidity(message);
      }

      get validationMessage() {
        return this._constraintApi.validationMessage;
      }

      _setAttribute(attributeName, value) {
        if (value !== null && value !== undefined && value !== false) {
          if (attributeName === 'value') {
            if (this._proxyInput.type === 'file') {
              // Can't set value on file
              return;
            }

            this._proxyInput.value = value;
          } else {
            this._proxyInput.setAttribute(attributeName, value);
          }
        } else {
          this._removeAttribute(attributeName);
        }
      }

      _removeAttribute(attributeName) {
        this._proxyInput.removeAttribute(attributeName);
      }

      get _constraintApi() {
        if (!this._privateConstraintApi) {
          this._updateAllAttributes();

          const computeConstraintWithProxyInput = constraintName => {
            const constraintOverride = this._overrides[constraintName];

            const isDisabledOrReadOnly = this._proxyInput.hasAttribute('disabled') || this._proxyInput.hasAttribute('readonly');

            if (typeof constraintOverride === 'function') {
              return !isDisabledOrReadOnly && constraintOverride();
            } // Firefox incorrectly computes rangeUnderflow for disabled and readonly inputs, so we're adding
            // a check here instead to always return false when the input has readonly or disabled attributes set


            return !isDisabledOrReadOnly && this._proxyInput.validity[constraintName];
          };

          const constraintsProvider = constraintsSortedByPriority.reduce((provider, constraint) => {
            provider[constraint] = computeConstraintWithProxyInput.bind(this, constraint);
            return provider;
          }, {});
          this._privateConstraintApi = new FieldConstraintApi(this._inputComponent, constraintsProvider);
        }

        return this._privateConstraintApi;
      }

      _updateAllAttributes() {
        if (this._attributes) {
          Object.entries(this._attributes).forEach(([key, valueFunction]) => {
            this._setAttribute(key, valueFunction());
          });
        }
      }

    }

    const VARIANT = {
      STANDARD: 'standard',
      LABEL_HIDDEN: 'label-hidden',
      LABEL_STACKED: 'label-stacked',
      LABEL_INLINE: 'label-inline'
    };
    /**
    A variant normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/

    function normalizeVariant(value) {
      return normalizeString(value, {
        fallbackValue: VARIANT.STANDARD,
        validValues: [VARIANT.STANDARD, VARIANT.LABEL_HIDDEN, VARIANT.LABEL_STACKED, VARIANT.LABEL_INLINE]
      });
    }

    function isEmptyString(s) {
      return s === undefined || s === null || typeof s === 'string' && s.trim() === '';
    }

    function fullHexValue(hex) {
      if (Array.isArray(hex) && hex.length > 0) {
        hex = hex[0];
      }

      if (hex && hex.length <= 6 && hex.charAt(0) !== '#') {
        hex = '#' + hex;
      }

      const isInputValid = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);

      if (!isInputValid) {
        hex = '#000000';
      } // Converting 3 digit hex color to 6 digit hex color


      if (hex.length === 4) {
        hex = '#' + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2) + hex.charAt(3) + hex.charAt(3);
      }

      return hex;
    }
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHexValue(hex));

      if (!result) {
        return null;
      }

      return {
        red: parseInt(result[1], 16),
        green: parseInt(result[2], 16),
        blue: parseInt(result[3], 16)
      };
    }
    function rgbToHex(rgb) {
      const r = rgb.red;
      const g = rgb.green;
      const b = rgb.blue;
      const bin = r << 16 | g << 8 | b;
      return function (hex) {
        return new Array(7 - hex.length).join('0') + hex;
      }(bin.toString(16).toUpperCase());
    }
    function rgbToHsl(rgb) {
      const r1 = rgb.red / 255;
      const g1 = rgb.green / 255;
      const b1 = rgb.blue / 255;
      const maxColor = Math.max(r1, g1, b1);
      const minColor = Math.min(r1, g1, b1); // Calculate L:

      let L = (maxColor + minColor) / 2;
      let S = 0;
      let H = 0;

      if (maxColor !== minColor) {
        // Calculate S:
        if (L < 0.5) {
          S = (maxColor - minColor) / (maxColor + minColor);
        } else {
          S = (maxColor - minColor) / (2.0 - maxColor - minColor);
        } // Calculate H:


        if (r1 === maxColor) {
          const x = g1 - b1,
                y = maxColor - minColor;
          H = x / y;
        } else if (g1 === maxColor) {
          const x = b1 - r1,
                y = maxColor - minColor,
                z = x / y;
          H = 2.0 + z;
        } else {
          const x = r1 - g1,
                y = maxColor - minColor,
                z = x / y;
          H = 4.0 + z;
        }
      }

      L *= 100;
      S *= 100;
      H *= 60;

      if (H < 0) {
        H += 360;
      }

      const result = {
        hue: H,
        saturation: S,
        lightness: L
      };
      return result;
    }
    function rgbToPosition(rgb, canvas) {
      const hsv = rgbToHsv(rgb);
      const saturation = hsv.saturation / 100,
            brightness = hsv.brightness / 100;
      const x = canvas.x * saturation;
      const y = canvas.y * (1 - brightness);
      return {
        x,
        y
      };
    }
    function rgbToHsv(rgb) {
      const r = rgb.red / 255;
      const g = rgb.green / 255;
      const b = rgb.blue / 255;
      const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
      const d = max - min,
            s = max === 0 ? 0 : d / max,
            v = max;
      let h, x, y;

      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            x = g - b;
            y = x / d;
            h = y + (g < b ? 6 : 0);
            break;

          case g:
            x = b - r;
            y = x / d;
            h = y + 2;
            break;

          case b:
            x = r - g;
            y = x / d;
            h = y + 4;
            break;
        }

        h /= 6;
      }

      const result = {
        hue: h * 360,
        saturation: s * 100,
        brightness: v * 100
      };
      return result;
    }

    const i18n$1 = {
      bInput: labelBInput,
      blueAbbr: labelBlueAbbr,
      colorPickerInstructions: labelColorPickerInstructions,
      errorMessage: labelErrorMessage,
      gInput: labelGInput,
      greenAbbr: labelGreenAbbr,
      hexLabel: labelHexLabel,
      hueInput: labelHueInput,
      rInput: labelRInput,
      redAbbr: labelRedAbbr
    };
    const CANVAS = {
      x: 198,
      y: 80
    };

    class LightningColorPickerCustom extends lwc.LightningElement {
      constructor() {
        super();
        this._hueValue = null;
        this._rgb = {
          red: '86',
          green: '121',
          blue: '192'
        };
        this._hex = '#5679C0';
        this._errorMessage = null;
        this._currentColor = null;
        this._initialized = false;
        this.uniqueId = generateUniqueId();
      }

      renderedCallback() {
        if (!this._initialized) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            this.focus();
          });
          this.gradient();
          this.handleUpdateAnchor();
          this._initialized = true;
        }
      }

      get currentColor() {
        return this._currentColor;
      }

      set currentColor(value) {
        const fullHex = fullHexValue(value);
        this._currentColor = value;
        this._hex = fullHex;
        this._rgb = hexToRgb(fullHex);
      }

      focus() {
        this.anchorElement.focus();
      }

      get i18n() {
        return i18n$1;
      }

      get thumbnailStyle() {
        return `background: ${this._hex || 'hsl(220, 46%, 55%)'};`;
      }

      get gradientStyle() {
        return `background: ${this._hex || 'rgb(0, 85, 255)'}; position: relative;`;
      }

      get canvasRect() {
        return CANVAS;
      }

      get anchorElement() {
        return this.template.querySelector('*[data-id="color-anchor"]');
      }

      get thumbnailElement() {
        return this.template.querySelector('*[data-id="color-preview"]');
      }

      get gradientElement() {
        return this.template.querySelector('*[data-id="color-gradient"]');
      }

      get computedSaturationAndBrightness() {
        const rgb = this._rgb;
        const saturation = rgbToHsv(rgb).saturation || 0;
        const brightness = rgbToHsv(rgb).brightness || 0;
        return `Saturation: ${saturation.toFixed()}%. Brightness: ${brightness.toFixed()}%.`;
      }

      handlePreventDefault(event) {
        event.preventDefault();
      }

      selectColor(event) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            color: event.target.innerText
          }
        }));
      }

      handleMouseDown(event) {
        event.preventDefault();
        this.onMouseDrag(event, true);
      }

      handleDrag(event) {
        this.onMouseDrag(event, false);
      }

      onChange() {
        this.rainbowCursor();
      }

      parseAndLimit(value) {
        let out = value;

        if (!value || parseInt(value, 10) < 0 || isNaN(value)) {
          out = 0;
        } else if (parseInt(value, 10) > 255) {
          out = 255;
        }

        return out;
      }

      handleRgbChange(event) {
        const target = event.currentTarget;
        const value = this.parseAndLimit(target.value); // Fix for no rerender on second bad value attempt

        target.value = value;
        const color = target.getAttribute('data-color-name');

        if (color === 'red') {
          this._rgb.red = value;
        } else if (color === 'green') {
          this._rgb.green = value;
        } else if (color === 'blue') {
          this._rgb.blue = value;
        }

        const rgb = this._rgb;
        const hue = rgbToHsl(rgb).hue;
        const position = this.rgbToPosition(rgb);
        const selectedColor = `#${rgbToHex(rgb)}`;
        this.updateRainbow(hue);
        this.setCanvasColor(hue);
        this.setCanvasCursor(position.x, position.y);
        this.updateSelectedColor(selectedColor);
      }

      handleHexChange(event) {
        const isInputValid = event.srcElement.validity.valid;

        if (isInputValid) {
          const selectedColor = fullHexValue(event.target.value);
          this.classList.remove('slds-has-error');
          this._errorMessage = null;
          const rgb = hexToRgb(selectedColor);
          this._rgb = rgb;
          const hue = rgbToHsl(rgb).hue;
          const position = this.rgbToPosition(rgb);
          this.updateRainbow(hue);
          this.setCanvasColor(hue);
          this.setCanvasCursor(position.x, position.y);
          this.updateSelectedColor(selectedColor);
        } else {
          event.srcElement.classList.add('slds-has-error');
          this._errorMessage = getErrorMessage(event.srcElement.validity, {
            patternMismatch: this.i18n.errorMessage
          });
        }
      }

      updateSelectedColor(selectedColor) {
        this.template.querySelector(`[data-primary-input]`).classList.remove('slds-has-error');
        this._errorMessage = null;
        this._hex = selectedColor;
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updateselectedcolor', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            color: selectedColor
          }
        }));
      }

      onMouseDrag(event, isGradientCursor) {
        const that = this;
        let drag = false;

        if (isGradientCursor) {
          this.getColorFromGradient(event);
        } else {
          this.rainbowCursor();
        }

        if (this._mousedown && this._mousemove && this._mouseup) {
          return;
        }

        that._mousedown = function () {
          drag = true;
          this._cursorActive = true;
        };

        that._mouseup = function () {
          drag = false;
          this._cursorActive = false;
          window.removeEventListener('mousedown', that._mousedown);
          window.removeEventListener('mouseup', that._mouseup);
          window.removeEventListener('mousemove', that._mousemove);
          that._mousedown = null;
          that._mouseup = null;
          that._mousemove = null;
        };

        that._mousemove = function (evt) {
          if (drag && isGradientCursor) {
            that.getColorFromGradient(evt);
          } else if (drag) {
            that.rainbowCursor();
          }
        };

        window.addEventListener('mousedown', that._mousedown);
        window.addEventListener('mouseup', that._mouseup);
        window.addEventListener('mousemove', that._mousemove);
      }

      gradient() {
        const hue = rgbToHsl(this._rgb).hue;
        this.canvasContext();
        this.setCanvasColor(hue);
        this.updateRainbow(hue);
      }

      getColorFromGradient(event) {
        let cursorPosition;

        if (event.type === 'keydown' && event.key !== 'Tab') {
          cursorPosition = this.gradientCursorPositionFromKeydown(event);
        } else if (event.type === 'mousedown' || event.type === 'mousemove') {
          cursorPosition = this.gradientCursorPosition(event);
        } else {
          return;
        }

        const x = cursorPosition.x;
        const y = cursorPosition.y; // Get the current HUE value and update the canvas & cursor

        this.setCanvasColor(this._hueValue); // set color from gradient

        this.setRGBValues(x, y);
      }

      rainbowCursor() {
        const rainbow = this.template.querySelector('*[data-id="hue-slider"]');
        const position = this._cachePosition || this.rgbToPosition(this._rgb);
        this.setCanvasColor(rainbow.value);
        this.setRGBValues(position.x, position.y);
        this.updateRainbow(rainbow.value);
      }

      updateRainbow(hue) {
        this._hueValue = hue;
      }

      handleUpdateAnchor() {
        const position = this._cachePosition || this.rgbToPosition(this._rgb);
        const anchor = this.anchorElement;
        const offset = anchor.offsetWidth / 2;
        const x = position.x - offset + 5;
        const y = position.y - offset - 5;
        const xPercent = x / this._canvas.width * 100;
        const yPercent = y / this._canvas.height * 100;
        anchor.style.left = `${xPercent}%`;
        anchor.style.top = `${yPercent}%`;
      }

      gradientCursorPosition(event) {
        const canvas = this._canvas;
        const gradientCanvas = canvas.getBoundingClientRect();
        let x = event.clientX - gradientCanvas.left;
        let y = event.clientY - gradientCanvas.top;

        if (x > gradientCanvas.width) {
          x = gradientCanvas.width - 1;
        }

        if (x < 0) {
          x = 0;
        }

        if (y > gradientCanvas.height) {
          y = gradientCanvas.height;
        }

        if (y < 0) {
          y = 0;
        }
        /*
         * Caching the position x & y in the component so that we can use it when moving the rainbow slider
         * instead of calculating the position of x & y each time.
         */


        this._cachePosition = {
          x,
          y
        };
        return {
          x,
          y
        };
      }

      gradientCursorPositionFromKeydown(event) {
        event.preventDefault();
        const canvas = this._canvas;
        const gradientCanvas = canvas.getBoundingClientRect();
        const keyCode = event.keyCode;
        let x, y;

        if (!this._cachePosition) {
          this._cachePosition = this.rgbToPosition(this._rgb);
        }

        const positionMap = {};
        positionMap[keyCodes.left] = {
          x: -1,
          y: 0
        };
        positionMap[keyCodes.up] = {
          x: 0,
          y: -1
        };
        positionMap[keyCodes.right] = {
          x: +1,
          y: 0
        };
        positionMap[keyCodes.down] = {
          x: 0,
          y: +1
        };
        const transform = positionMap[keyCode] ? positionMap[keyCode] : {
          x: 0,
          y: 0
        };
        x = this._cachePosition.x + transform.x;
        y = this._cachePosition.y + transform.y;

        if (x > gradientCanvas.width) {
          x = gradientCanvas.width - 1;
        }

        if (x < 0) {
          x = 0;
        }

        if (y > gradientCanvas.height) {
          y = gradientCanvas.height;
        }

        if (y < 0) {
          y = 0;
        }
        /*
         * Caching the position x & y in the component so that we can use it when moving the rainbow slider
         * instead of calculating the position of x & y each time.
         */


        this._cachePosition = {
          x,
          y
        };
        return {
          x,
          y
        };
      }

      setRGBValues(x, y) {
        const ctx = this._canvasCtx;
        const imageData = ctx.getImageData(x, y, 1, 1).data;
        const rgb = {
          red: imageData[0],
          green: imageData[1],
          blue: imageData[2]
        };
        const color = `#${rgbToHex(rgb)}`;
        this._rgb = rgb;
        this.updateSelectedColor(color);
        this.handleUpdateAnchor();
      }

      setCanvasColor(hue) {
        const ctx = this._canvasCtx; // don't map the gradient onto extreme left and right to make extremes have their max values

        const white = ctx.createLinearGradient(1, 0, this.canvasRect.x - 1, 0);
        white.addColorStop(0, 'rgb(255,255,255)');
        white.addColorStop(1, 'hsl(' + hue + ', 100%, 50%)');
        ctx.fillStyle = white;
        ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y); // starting y is the first line to avoid blending the black into the hue, thus
        // making extreme values unselectable

        const black = ctx.createLinearGradient(0, 1, 0, this.canvasRect.y);
        black.addColorStop(0, 'rgba(0,0,0,0)');
        black.addColorStop(1, 'rgb(0,0,0)');
        ctx.fillStyle = black;
        ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y);
      }

      setCanvasCursor(x, y) {
        const position = {
          x,
          y
        };
        const anchor = this.anchorElement;
        const offset = anchor.offsetWidth / 2;
        x = position.x - offset + 5;
        y = position.y - offset - 5;
        const xPercent = x / this._canvas.width * 100;
        const yPercent = y / this._canvas.height * 100;
        anchor.style.left = `${xPercent}%`;
        anchor.style.top = `${yPercent}%`;
      }

      canvasContext() {
        this._canvas = this.template.querySelector('canvas');
        this._canvasCtx = this._canvas.getContext('2d');
        this._cursorActive = false;
      }

      handleKeydown(event) {
        this.getColorFromGradient(event);
      }

      rgbToPosition(rgb) {
        return rgbToPosition(rgb, this.canvasRect);
      }

    }

    lwc.registerDecorators(LightningColorPickerCustom, {
      publicProps: {
        currentColor: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _hueValue: 1,
        _rgb: 1,
        _hex: 1,
        _errorMessage: 1,
        _currentColor: 1
      },
      fields: ["_initialized"]
    });

    var _lightningColorPickerCustom = lwc.registerComponent(LightningColorPickerCustom, {
      tmpl: _tmpl$5
    });

    function tmpl$5($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        gid: api_scoped_id,
        h: api_element,
        d: api_dynamic,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("section", {
        classMap: {
          "slds-popover": true,
          "slds-color-picker__selector": true,
          "slds-show": true,
          "slds-is-absolute": true
        },
        attrs: {
          "role": "dialog",
          "aria-label": "Choose a color",
          "aria-describedby": `${api_scoped_id("dialog-body-id")}`
        },
        key: 6,
        on: {
          "updateselectedcolor": _m2 || ($ctx._m2 = api_bind($cmp.handleUpdateSelectedColor)),
          "keydown": _m3 || ($ctx._m3 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        attrs: {
          "id": api_scoped_id("dialog-body-id")
        },
        key: 1
      }, [api_custom_element("lightning-color-picker-custom", _lightningColorPickerCustom, {
        props: {
          "currentColor": $cmp.currentColor
        },
        key: 0
      }, [])]), api_element("footer", {
        classMap: {
          "slds-popover__footer": true
        },
        key: 5
      }, [api_element("div", {
        classMap: {
          "slds-color-picker__selector-footer": true
        },
        key: 4
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_neutral": true
        },
        attrs: {
          "name": "cancel"
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCancelClick))
        }
      }, [api_dynamic($cmp.i18n.cancelButton)]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true
        },
        attrs: {
          "name": "done"
        },
        key: 3,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleDoneClick))
        }
      }, [api_dynamic($cmp.i18n.doneButton)])])])])];
    }

    var _tmpl$6 = lwc.registerTemplate(tmpl$5);
    tmpl$5.stylesheets = [];
    tmpl$5.stylesheetTokens = {
      hostAttribute: "lightning-colorPickerPanel_colorPickerPanel-host",
      shadowAttribute: "lightning-colorPickerPanel_colorPickerPanel"
    };

    var labelCancelButton = 'Cancel';

    var labelCustomTab = 'Custom';

    var labelDefaultTab = 'Default';

    var labelDoneButton = 'Done';

    const i18n$2 = {
      cancelButton: labelCancelButton,
      customTab: labelCustomTab,
      defaultTab: labelDefaultTab,
      doneButton: labelDoneButton
    };
    const DEFAULT_COLOR = '#000000';

    class LightningColorPickerPanel extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.currentColor = void 0;
        this._isCustomTabActive = false;
        this._selectedColor = null;
      }

      connectedCallback() {
        this._selectedColor = this.currentColor || DEFAULT_COLOR;
      }

      get i18n() {
        return i18n$2;
      }

      get computedClassDefault() {
        return classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': !this._isCustomTabActive
        }).toString();
      }

      get computedClassCustom() {
        return classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': this._isCustomTabActive
        }).toString();
      }

      get ariaSelectedDefault() {
        return !this._isCustomTabActive.toString();
      }

      get ariaSelectedCustom() {
        return this._isCustomTabActive.toString();
      }

      handleTabChange(event) {
        event.preventDefault();
        const tabElement = event.currentTarget;

        if (tabElement.classList.contains('slds-is-active')) {
          return;
        }

        this._isCustomTabActive = tabElement.title !== i18n$2.defaultTab;
      }

      handleUpdateSelectedColor(event) {
        this._selectedColor = event.detail.color;
      }

      dispatchUpdateColorEventWithColor(color) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          composed: true,
          bubbles: true,
          detail: {
            color
          }
        }));
      }

      handleDoneClick() {
        this.dispatchUpdateColorEventWithColor(this._selectedColor);
      }

      handleCancelClick() {
        this.dispatchUpdateColorEventWithColor(this.currentColor);
      }

      handleKeydown(event) {
        if (event.keyCode === keyCodes.escape) {
          event.preventDefault();
          this.dispatchUpdateColorEventWithColor(this.currentColor);
        } else if (event.shiftKey && event.keyCode === keyCodes.tab && event.srcElement.dataset.id === 'color-anchor') {
          event.preventDefault();
          this.template.querySelector('button[name="done"]').focus();
        } else if (!event.shiftKey && event.keyCode === keyCodes.tab && event.srcElement.name === 'done') {
          event.preventDefault();
          this.template.querySelector('lightning-color-picker-custom').focus();
        }
      }

    }

    lwc.registerDecorators(LightningColorPickerPanel, {
      publicProps: {
        currentColor: {
          config: 0
        }
      },
      track: {
        _isCustomTabActive: 1,
        _selectedColor: 1
      }
    });

    var _lightningColorPickerPanel = lwc.registerComponent(LightningColorPickerPanel, {
      tmpl: _tmpl$6
    });

    function tmpl$6($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-color-picker__summary-button": true,
          "slds-button_icon": true,
          "slds-button_icon-more": true
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 4,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleColorPickerToggleClick))
        }
      }, [api_element("span", {
        classMap: {
          "slds-swatch": true
        },
        style: $cmp.colorInputStyle,
        attrs: {
          "data-id": "thumbnail"
        },
        key: 1
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 0
      }, [api_dynamic($cmp.i18n.a11yTriggerText)])]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:down",
          "svgClass": "slds-button__icon slds-button__icon_small",
          "variant": "bare"
        },
        key: 2
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true,
          "a11y-color-value": true
        },
        key: 3
      }, [api_dynamic($cmp.value)])]), $cmp._isColorPickerPanelOpen ? api_custom_element("lightning-color-picker-panel", _lightningColorPickerPanel, {
        classMap: {
          "color-picker-panel": true
        },
        props: {
          "currentColor": $cmp.value
        },
        key: 5,
        on: {
          "updatecolor": _m1 || ($ctx._m1 = api_bind($cmp.handleUpdateColorEvent))
        }
      }, []) : null];
    }

    var _tmpl$7 = lwc.registerTemplate(tmpl$6);
    tmpl$6.stylesheets = [];
    tmpl$6.stylesheetTokens = {
      hostAttribute: "lightning-primitiveColorpickerButton_primitiveColorpickerButton-host",
      shadowAttribute: "lightning-primitiveColorpickerButton_primitiveColorpickerButton"
    };

    var labelA11yTriggerText = 'Choose a color. Current color: ';

    const i18n$3 = {
      a11yTriggerText: labelA11yTriggerText
    };

    class PrimitiveColorpickerButton extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._isColorPickerPanelOpen = false;
        this._value = '';
        this._disabled = false;
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
      }
      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      focus() {
        const button = this.template.querySelector('button');
        return button && button.focus();
      }

      blur() {
        const button = this.template.querySelector('button');
        return button && button.blur();
      }

      get colorInputStyle() {
        return `background: ${this.value || '#5679C0'};`;
      }

      handleColorPickerToggleClick(event) {
        event.preventDefault();
        this._isColorPickerPanelOpen = !this._isColorPickerPanelOpen;

        if (this._isColorPickerPanelOpen) {
          this.startColorPickerPositioning();
        } else {
          this.stopColorPickerPositioning();
        }
      }

      startColorPickerPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this);
        }

        this._autoPosition.start({
          target: () => this.template.querySelector('button.slds-color-picker__summary-button'),
          element: () => this.template.querySelector('lightning-color-picker-panel').shadowRoot.querySelector('section'),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Bottom
          },
          autoFlip: true
        });
      }

      stopColorPickerPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      handleUpdateColorEvent(event) {
        event.stopPropagation();
        const detail = event.detail;
        this._isColorPickerPanelOpen = false;
        this.stopColorPickerPositioning();
        this.dispatchEvent(new CustomEvent('change', {
          detail
        }));
      }

      get i18n() {
        return i18n$3;
      }

    }

    PrimitiveColorpickerButton.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveColorpickerButton, {
      publicProps: {
        value: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur"],
      track: {
        _isColorPickerPanelOpen: 1,
        _value: 1,
        _disabled: 1
      }
    });

    var _lightningPrimitiveColorpickerButton = lwc.registerComponent(PrimitiveColorpickerButton, {
      tmpl: _tmpl$7
    });

    function tmpl$7($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        gid: api_scoped_id,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "name": $cmp.name,
          "title": $cmp.computedTitle,
          "accesskey": $cmp.computedAccessKey,
          "type": $cmp.normalizedType,
          "value": $cmp.value,
          "aria-describedby": api_scoped_id($cmp.computedAriaDescribedBy),
          "aria-label": $cmp.computedAriaLabel,
          "aria-controls": api_scoped_id($cmp.computedAriaControls),
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-live": $cmp.computedAriaLive,
          "aria-atomic": $cmp.computedAriaAtomic
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 0
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.alternativeText)]) : null])];
    }

    var _tmpl$8 = lwc.registerTemplate(tmpl$7);
    tmpl$7.stylesheets = [];
    tmpl$7.stylesheetTokens = {
      hostAttribute: "lightning-buttonIcon_buttonIcon-host",
      shadowAttribute: "lightning-buttonIcon_buttonIcon"
    };

    function tmpl$8($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var _tmpl$9 = lwc.registerTemplate(tmpl$8);
    tmpl$8.stylesheets = [];
    tmpl$8.stylesheetTokens = {
      hostAttribute: "lightning-primitiveButton_primitiveButton-host",
      shadowAttribute: "lightning-primitiveButton_primitiveButton"
    };

    class LightningPrimitiveButton extends lwc.LightningElement {
      get disabled() {
        return this.state.disabled;
      }

      set disabled(value) {
        this.state.disabled = normalizeBoolean(value);
      }

      set accessKey(value) {
        this.state.accesskey = value;
      }

      get accessKey() {
        return this.state.accesskey;
      }

      get computedAccessKey() {
        return this.state.accesskey;
      }

      get title() {
        return this.state.title;
      }

      set title(value) {
        this.state.title = value;
      }

      get ariaLabel() {
        return this.state.ariaLabel;
      }

      set ariaLabel(value) {
        this.state.ariaLabel = value;
      }

      get computedAriaLabel() {
        return this.state.ariaLabel;
      }

      get ariaDescribedBy() {
        return this.state.ariaDescribedBy;
      }

      set ariaDescribedBy(value) {
        this.state.ariaDescribedBy = value;
      }

      get computedAriaDescribedBy() {
        return this.state.ariaDescribedBy;
      }

      get ariaControls() {
        return this.state.ariaControls;
      }

      set ariaControls(value) {
        this.state.ariaControls = value;
      }

      get computedAriaControls() {
        return this.state.ariaControls;
      }

      get ariaExpanded() {
        return this.state.ariaExpanded;
      }

      set ariaExpanded(value) {
        this.state.ariaExpanded = normalizeString(value, {
          fallbackValue: undefined,
          validValues: ['true', 'false']
        });
      }

      get computedAriaExpanded() {
        return this.state.ariaExpanded || null;
      }

      set ariaLive(value) {
        this.state.ariaLive = value;
      }

      get ariaLive() {
        return this.state.ariaLive;
      }

      get computedAriaLive() {
        return this.state.ariaLive;
      }

      get ariaAtomic() {
        return this.state.ariaAtomic || null;
      }

      set ariaAtomic(value) {
        this.state.ariaAtomic = normalizeString(value, {
          fallbackValue: undefined,
          validValues: ['true', 'false']
        });
      }

      get computedAriaAtomic() {
        return this.state.ariaAtomic || null;
      }

      focus() {}

      constructor() {
        super(); // Workaround for an IE11 bug where click handlers on button ancestors
        // receive the click event even if the button element has the `disabled`
        // attribute set.

        this.state = {
          accesskey: null,
          ariaAtomic: null,
          ariaControls: null,
          ariaDescribedBy: null,
          ariaExpanded: null,
          ariaLabel: null,
          ariaLive: null,
          disabled: false
        };

        if (isIE11) {
          this.template.addEventListener('click', event => {
            if (this.disabled) {
              event.stopImmediatePropagation();
            }
          });
        }
      }

    }

    lwc.registerDecorators(LightningPrimitiveButton, {
      publicProps: {
        disabled: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        title: {
          config: 3
        },
        ariaLabel: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaExpanded: {
          config: 3
        },
        ariaLive: {
          config: 3
        },
        ariaAtomic: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      }
    });

    var LightningPrimitiveButton$1 = lwc.registerComponent(LightningPrimitiveButton, {
      tmpl: _tmpl$9
    });

    const DEFAULT_SIZE = 'medium';
    const DEFAULT_VARIANT = 'border';
    const DEFAULT_TYPE = 'button';
    /**
     * An icon-only HTML button.
     */

    class LightningButtonIcon extends LightningPrimitiveButton$1 {
      constructor(...args) {
        super(...args);
        this.name = void 0;
        this.value = void 0;
        this.variant = DEFAULT_VARIANT;
        this.iconName = void 0;
        this.iconClass = void 0;
        this.size = DEFAULT_SIZE;
        this.type = DEFAULT_TYPE;
        this.alternativeText = void 0;
        this._order = null;
        this._tooltip = null;
      }

      /**
       * Text to display when the user mouses over or focuses on the button.
       * The tooltip is auto-positioned relative to the button and screen space.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      // remove-next-line-for-c-namespace
      set tooltip(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button')
          });

          this._tooltip.initialize();
        }
      } // remove-next-line-for-c-namespace


      get tooltip() {
        return this._tooltip ? this._tooltip.value : undefined;
      }

      // this is there because raptor currently doesnt support inheritance
      render() {
        return _tmpl$8;
      }

      get computedTitle() {
        return this.state.title || this.alternativeText || '';
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: DEFAULT_VARIANT,
          validValues: ['bare', 'brand', 'container', 'border', 'border-filled', 'bare-inverse', 'border-inverse']
        });
      }

      get normalizedType() {
        return normalizeString(this.type, {
          fallbackValue: DEFAULT_TYPE,
          validValues: ['button', 'reset', 'submit']
        });
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: DEFAULT_SIZE,
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      getVariantBase() {
        return this.normalizedVariant.split('-')[0];
      }

      getVariantModifier() {
        return this.normalizedVariant.split('-')[1] || '';
      }

      get computedButtonClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const isBare = this.getVariantBase(normalizedSize) === 'bare';
        const classes = classSet('slds-button');
        classes.add('slds-button_icon');

        if (!isBare) {
          // If the variant is not bare, then size the button instead of the icon
          switch (normalizedSize) {
            case 'small':
              classes.add('slds-button_icon-small');
              break;

            case 'x-small':
              classes.add('slds-button_icon-x-small');
              break;

            case 'xx-small':
              classes.add('slds-button_icon-xx-small');
              break;

            case 'large':
              // There is no `large` modifier for buttons so we should drop down one size to `medium`
              console.warn(`<lightning-button-icon> The non-bare variants of buttonIcon do not support a size value of "large". Supported values include "xx-small", "x-small", "small", and "medium". Falling back to size value "medium".`);
          }
        }

        return classes.add({
          'slds-button_icon-bare': isBare,
          'slds-button_icon-container': normalizedVariant === 'container',
          'slds-button_icon-border': normalizedVariant === 'border',
          'slds-button_icon-border-filled': normalizedVariant === 'border-filled',
          'slds-button_icon-border-inverse': normalizedVariant === 'border-inverse',
          'slds-button_icon-inverse': normalizedVariant === 'bare-inverse',
          'slds-button_icon-brand': normalizedVariant === 'brand',
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedIconClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const isBare = this.getVariantBase(normalizedVariant) === 'bare';
        const iconClass = this.iconClass || '';
        const classes = classSet('slds-button__icon');
        classes.add(iconClass);

        if (isBare) {
          // If the variant is bare, then size the icon instead of the button
          switch (normalizedSize) {
            case 'large':
              classes.add('slds-button__icon_large');
              break;

            case 'small':
              classes.add('slds-button__icon_small');
              break;

            case 'xx-small':
              // There is no `xx-small` modifier for bare so we should drop down one size to `x-small`
              console.warn(`<lightning-button-icon> The bare variant of buttonIcon does not support a size value of "xx-small". Supported values include "x-small", "small", "medium", and "large". The default is "medium".`);

            /* falls through */

            case 'x-small':
              classes.add('slds-button__icon_x-small');
              break;
          }
        }

        if (this.getVariantModifier(normalizedVariant) === 'inverse') {
          classes.add('slds-button_icon-inverse');
        }

        return classes.toString();
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        if (this._connected) {
          this.template.querySelector('button').focus();
        }
      }
      /**
       * Clicks the button.
       */


      click() {
        if (this._connected) {
          this.template.querySelector('button').click();
        }
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * Once we are connected, we fire a register event so the button-group (or other) component can register
       * the buttons.
       */


      connectedCallback() {
        this._connected = true;
        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      } // remove-next-line-for-c-namespace


      renderedCallback() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

    }

    LightningButtonIcon.delegatesFocus = true;

    lwc.registerDecorators(LightningButtonIcon, {
      publicProps: {
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        variant: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconClass: {
          config: 0
        },
        size: {
          config: 0
        },
        type: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        tooltip: {
          config: 3
        }
      },
      publicMethods: ["focus", "click"],
      track: {
        _order: 1
      },
      fields: ["_tooltip"]
    });

    var _lightningButtonIcon = lwc.registerComponent(LightningButtonIcon, {
      tmpl: _tmpl$8
    });

    function stylesheet$4(hostSelector, shadowSelector, nativeShadow) {
      return "[dir=\"rtl\"] .slds-dropdown_left" + shadowSelector + " {left: 0;right: auto;}\n";
    }
    var _implicitStylesheets$4 = [stylesheet$4];

    function tmpl$9($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        k: api_key,
        i: api_iterator,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("select")}`
        },
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-select_container": true
        },
        key: 5
      }, [api_element("select", {
        classMap: {
          "slds-select": true
        },
        attrs: {
          "id": api_scoped_id("select"),
          "name": $cmp.name,
          "size": $cmp.size,
          "accesskey": $cmp.accessKey,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        props: {
          "disabled": $cmp.disabled,
          "multiple": $cmp.multiple
        },
        key: 4,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, api_iterator($cmp.options, function (option) {
        return api_element("option", {
          attrs: {
            "value": option.value
          },
          key: api_key(3, option.value)
        }, [api_dynamic(option.label)]);
      }))])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "aria-live": "assertive"
        },
        key: 7
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var _tmpl$a = lwc.registerTemplate(tmpl$9);
    tmpl$9.stylesheets = [];
    tmpl$9.stylesheetTokens = {
      hostAttribute: "lightning-primitiveSelect_primitiveSelect-host",
      shadowAttribute: "lightning-primitiveSelect_primitiveSelect"
    };

    var labelRequired = 'required';

    const i18n$4 = {
      required: labelRequired
    };
    const {
      reduce: ArrayReduce
    } = Array.prototype;

    class LightningPrimitiveSelect extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._errorMessage = '';
        this._options = [];
        this._selectedValue = void 0;
        this._variant = void 0;
        this._required = false;
        this._disabled = false;
        this._multiple = false;
        this._fieldLevelHelp = void 0;
        this._size = void 0;
        this._ariaDescribedBy = void 0;
        this._tabIndex = void 0;
        this.label = void 0;
        this.name = void 0;
        this.messageWhenValueMissing = void 0;
        this.accessKey = void 0;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
        this.updateClassList();
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple;
      }

      set size(newValue) {
        this._size = newValue;
      }

      get size() {
        if (!this.multiple) {
          return null;
        }

        if (this._size === undefined) {
          return '4';
        }

        return this._size;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get disabled() {
        return this._disabled;
      }

      set value(newValue) {
        this._selectedValue = newValue;

        if (this.connected && newValue) {
          this.selectOptionsByValue(newValue);
        }
      }

      get value() {
        return this._selectedValue;
      }

      set options(newValue) {
        this._options = newValue;

        if (this.connected && newValue) {
          this.selectOptionsByValue(this._selectedValue);
        }
      }

      get options() {
        return this._options;
      }

      get tabIndex() {
        return this._tabIndex;
      }

      set tabIndex(newValue) {
        this._tabIndex = newValue;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid());
        this.connected = true;
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      renderedCallback() {
        if (this.options && this._selectedValue !== undefined) {
          this.selectOptionsByValue(this._selectedValue);
        }
      }

      disconnectedCallback() {
        this.connected = false;
      }

      focus() {
        if (this.connected) {
          this.getElement.focus();
        }
      }

      blur() {
        if (this.connected) {
          this.getElement.blur();
        }
      }

      get validity() {
        const missing = !this.disabled && this.required && (this._selectedValue == null || this._selectedValue === '' || this._selectedValue.length === 0);
        return buildSyntheticValidity({
          valueMissing: missing,
          customError: this.customErrorMessage != null && this.customErrorMessage !== ''
        });
      }

      checkValidity() {
        const isValid = this.validity.valid;

        if (!isValid) {
          this.dispatchEvent(new CustomEvent('invalid', {
            cancellable: true
          }));
        }

        return isValid;
      }

      reportValidity() {
        this.showHelpMessageIfInvalid();
        return this.checkValidity();
      }

      setCustomValidity(message) {
        this.customErrorMessage = message;
      }

      showHelpMessageIfInvalid() {
        const validity = this.validity;

        if (validity.valid) {
          this._errorMessage = '';
          this.classList.remove('slds-has-error');
          this.removeAriaDescribedBy();
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = getErrorMessage(validity, {
            valueMissing: this.messageWhenValueMissing,
            customError: this.customErrorMessage
          });
          this.setAriaDescribedBy(this.computedUniqueErrorMessageElementId);
        }
      }

      get i18n() {
        return i18n$4;
      }

      get errorMessage() {
        return this._errorMessage;
      }

      get getElement() {
        return this.template.querySelector('select');
      }

      get computedUniqueErrorMessageElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        return this._ariaDescribedBy;
      }

      handleChange(event) {
        event.preventDefault();
        event.stopPropagation();
        this._selectedValue = this.getSelectedOptionValues();
        this.dispatchChangeEvent();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._selectedValue
          }
        }));
      }

      selectOptionsByValue(optionValue) {
        if (this.multiple) {
          if (Array.isArray(optionValue)) {
            const options = this.template.querySelectorAll('option');
            options.forEach(option => {
              option.selected = optionValue.includes(option.value);
            });
          }
        } else {
          this.getElement.value = optionValue;
        }
      }

      getSelectedOptionValues() {
        if (this.multiple) {
          const options = this.template.querySelectorAll('option');
          return ArrayReduce.call(options, (selectedValues, option) => {
            if (option.selected) {
              selectedValues.push(option.value);
            }

            return selectedValues;
          }, []);
        }

        return this.getElement.value;
      }

      setAriaDescribedBy(val) {
        this.getElement.setAttribute('aria-describedby', val);
      }

      removeAriaDescribedBy() {
        this.getElement.removeAttribute('aria-describedby');
      }

    }

    lwc.registerDecorators(LightningPrimitiveSelect, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        multiple: {
          config: 3
        },
        size: {
          config: 3
        },
        required: {
          config: 3
        },
        disabled: {
          config: 3
        },
        value: {
          config: 3
        },
        options: {
          config: 3
        },
        tabIndex: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _errorMessage: 1,
        _options: 1,
        _selectedValue: 1,
        _variant: 1,
        _required: 1,
        _disabled: 1,
        _multiple: 1,
        _fieldLevelHelp: 1,
        _size: 1,
        _ariaDescribedBy: 1,
        _tabIndex: 1
      }
    });

    var _lightningPrimitiveSelect = lwc.registerComponent(LightningPrimitiveSelect, {
      tmpl: _tmpl$a
    });

    function tmpl$a($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        k: api_key,
        i: api_iterator,
        ti: api_tab_index
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16,
        _m17,
        _m18,
        _m19,
        _m20,
        _m21,
        _m22,
        _m23,
        _m24,
        _m25,
        _m26,
        _m27,
        _m28,
        _m29,
        _m30,
        _m31,
        _m32,
        _m33,
        _m34,
        _m35,
        _m36,
        _m37,
        _m38,
        _m39,
        _m40,
        _m41,
        _m42
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-datepicker": true,
          "slds-dropdown": true,
          "slds-dropdown_left": true
        },
        attrs: {
          "aria-hidden": "false",
          "aria-label": $cmp.computedAriaLabel,
          "role": "dialog",
          "tabindex": "-1"
        },
        key: 19,
        on: {
          "mousedown": _m37 || ($ctx._m37 = api_bind($cmp.cancelBlur)),
          "mouseup": _m38 || ($ctx._m38 = api_bind($cmp.allowBlur)),
          "keydown": _m39 || ($ctx._m39 = api_bind($cmp.cancelBlur)),
          "keyup": _m40 || ($ctx._m40 = api_bind($cmp.allowBlur)),
          "focus": _m41 || ($ctx._m41 = api_bind($cmp.handleFocus)),
          "blur": _m42 || ($ctx._m42 = api_bind($cmp.handleBlur))
        }
      }, [api_element("div", {
        classMap: {
          "slds-datepicker__filter": true,
          "slds-grid": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-datepicker__filter_month": true,
          "slds-grid": true,
          "slds-grid_align-spread": true,
          "slds-grow": true
        },
        key: 5
      }, [api_element("div", {
        classMap: {
          "slds-align-middle": true
        },
        key: 1
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:left",
          "variant": "container",
          "alternativeText": $cmp.i18n.previousMonth
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.goToPreviousMonth)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handlePrevNavKeyDown)),
          "keyup": _m2 || ($ctx._m2 = api_bind($cmp.allowBlur)),
          "mousedown": _m3 || ($ctx._m3 = api_bind($cmp.cancelBlur)),
          "mouseup": _m4 || ($ctx._m4 = api_bind($cmp.allowBlur)),
          "focus": _m5 || ($ctx._m5 = api_bind($cmp.handleFocus)),
          "blur": _m6 || ($ctx._m6 = api_bind($cmp.handleBlur))
        }
      }, [])]), api_element("h2", {
        classMap: {
          "slds-align-middle": true
        },
        attrs: {
          "aria-atomic": "true",
          "aria-live": "assertive",
          "id": api_scoped_id("month-title"),
          "data-index": $cmp.monthIndex
        },
        key: 2
      }, [api_dynamic($cmp.computedMonthTitle)]), api_element("div", {
        classMap: {
          "slds-align-middle": true
        },
        key: 4
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:right",
          "variant": "container",
          "alternativeText": $cmp.i18n.nextMonth
        },
        key: 3,
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.goToNextMonth)),
          "mousedown": _m8 || ($ctx._m8 = api_bind($cmp.cancelBlur)),
          "mouseup": _m9 || ($ctx._m9 = api_bind($cmp.allowBlur)),
          "keydown": _m10 || ($ctx._m10 = api_bind($cmp.cancelBlur)),
          "keyup": _m11 || ($ctx._m11 = api_bind($cmp.allowBlur)),
          "focus": _m12 || ($ctx._m12 = api_bind($cmp.handleFocus)),
          "blur": _m13 || ($ctx._m13 = api_bind($cmp.handleBlur))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-shrink-none": true
        },
        key: 7
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.calendarYear,
          "label": $cmp.i18n.yearSelector,
          "variant": "label-hidden",
          "options": $cmp.computedYearList
        },
        key: 6,
        on: {
          "change": _m14 || ($ctx._m14 = api_bind($cmp.handleYearChange)),
          "click": _m15 || ($ctx._m15 = api_bind($cmp.handleYearSelectClick)),
          "mousedown": _m16 || ($ctx._m16 = api_bind($cmp.cancelBlur)),
          "mouseup": _m17 || ($ctx._m17 = api_bind($cmp.allowBlur)),
          "keydown": _m18 || ($ctx._m18 = api_bind($cmp.cancelBlur)),
          "keyup": _m19 || ($ctx._m19 = api_bind($cmp.allowBlur)),
          "focus": _m20 || ($ctx._m20 = api_bind($cmp.handleFocus)),
          "blur": _m21 || ($ctx._m21 = api_bind($cmp.handleBlur))
        }
      }, [])])]), api_element("table", {
        classMap: {
          "slds-datepicker__month": true
        },
        attrs: {
          "aria-labelledby": `${api_scoped_id("month-title")}`,
          "role": "grid"
        },
        key: 17
      }, [api_element("thead", {
        key: 12
      }, [api_element("tr", {
        attrs: {
          "id": api_scoped_id("weekdays-element")
        },
        key: 11
      }, api_iterator($cmp.computedWeekdayLabels, function (weekday) {
        return api_element("th", {
          attrs: {
            "id": api_scoped_id(weekday.fullName),
            "scope": "col"
          },
          key: api_key(10, weekday.fullName)
        }, [api_element("abbr", {
          attrs: {
            "title": weekday.fullName
          },
          key: 9
        }, [api_dynamic(weekday.shortName)])]);
      }))]), api_element("tbody", {
        key: 16,
        on: {
          "keydown": _m29 || ($ctx._m29 = api_bind($cmp.handleCalendarKeyDown))
        }
      }, api_iterator($cmp.computedMonth, function (week, index) {
        return api_element("tr", {
          key: api_key(15, week.id)
        }, api_iterator(week.days, function (day) {
          return api_element("td", {
            className: day.className,
            attrs: {
              "role": "gridcell",
              "aria-selected": day.isSelected,
              "aria-disabled": day.isDisabled,
              "aria-current": day.ariaCurrent,
              "tabindex": api_tab_index(day.tabIndex),
              "data-value": day.dateValue
            },
            key: api_key(14, day.dateValue),
            on: {
              "mousedown": _m23 || ($ctx._m23 = api_bind($cmp.cancelBlur)),
              "mouseup": _m24 || ($ctx._m24 = api_bind($cmp.allowBlur)),
              "keydown": _m25 || ($ctx._m25 = api_bind($cmp.cancelBlur)),
              "keyup": _m26 || ($ctx._m26 = api_bind($cmp.allowBlur)),
              "focus": _m27 || ($ctx._m27 = api_bind($cmp.handleFocus)),
              "blur": _m28 || ($ctx._m28 = api_bind($cmp.handleBlur))
            }
          }, [api_element("span", {
            classMap: {
              "slds-day": true
            },
            key: 13,
            on: {
              "click": _m22 || ($ctx._m22 = api_bind($cmp.handleDateClick))
            }
          }, [api_dynamic(day.dayInMonth)])]);
        }));
      }))]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-align_absolute-center": true,
          "slds-text-link": true
        },
        attrs: {
          "name": "today",
          "type": "button"
        },
        key: 18,
        on: {
          "click": _m30 || ($ctx._m30 = api_bind($cmp.handleTodayClick)),
          "keydown": _m31 || ($ctx._m31 = api_bind($cmp.handleTodayKeyDown)),
          "keyup": _m32 || ($ctx._m32 = api_bind($cmp.allowBlur)),
          "mousedown": _m33 || ($ctx._m33 = api_bind($cmp.cancelBlur)),
          "mouseup": _m34 || ($ctx._m34 = api_bind($cmp.allowBlur)),
          "focus": _m35 || ($ctx._m35 = api_bind($cmp.handleFocus)),
          "blur": _m36 || ($ctx._m36 = api_bind($cmp.handleBlur))
        }
      }, [api_dynamic($cmp.i18n.today)])])];
    }

    var _tmpl$b = lwc.registerTemplate(tmpl$a);
    tmpl$a.stylesheets = [];

    if (_implicitStylesheets$4) {
      tmpl$a.stylesheets.push.apply(tmpl$a.stylesheets, _implicitStylesheets$4);
    }
    tmpl$a.stylesheetTokens = {
      hostAttribute: "lightning-calendar_calendar-host",
      shadowAttribute: "lightning-calendar_calendar"
    };

    var labelAriaLabelMonth = 'Date picker: ';

    var labelNextMonth = 'Next Month';

    var labelPreviousMonth = 'Previous Month';

    var labelToday = 'Today';

    var labelYearSelector = 'Pick a Year';

    var firstDayOfWeek = '1';

    function handleKeyDownOnCalendar(event, date, calendarInterface) {
      const tdElement = event.target;
      const keyValue = normalizeKeyValue(event.key);

      switch (keyValue) {
        case 'ArrowUp':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 7);
          calendarInterface.focusDate(date);
          break;

        case 'ArrowDown':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 7);
          calendarInterface.focusDate(date);
          break;

        case 'ArrowRight':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 1);
          calendarInterface.focusDate(date);
          break;

        case 'ArrowLeft':
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 1);
          calendarInterface.focusDate(date);
          break;

        case 'Enter':
        case ' ':
          preventDefaultAndStopPropagation(event);
          calendarInterface.selectDate(tdElement);
          break;

        case 'PageUp':
          preventDefaultAndStopPropagation(event);

          if (event.altKey) {
            date.setFullYear(date.getFullYear() - 1);
          } else {
            date.setMonth(date.getMonth() - 1);
          }

          calendarInterface.focusDate(date);
          break;

        case 'PageDown':
          preventDefaultAndStopPropagation(event);

          if (event.altKey) {
            date.setFullYear(date.getFullYear() + 1);
          } else {
            date.setMonth(date.getMonth() + 1);
          }

          calendarInterface.focusDate(date);
          break;

        case 'Home':
          {
            preventDefaultAndStopPropagation(event);
            const startOfWeek = calendarInterface.getStartOfWeek(date);
            calendarInterface.focusDate(startOfWeek);
            break;
          }

        case 'End':
          {
            preventDefaultAndStopPropagation(event);
            const endOfWeek = calendarInterface.getStartOfWeek(date);
            endOfWeek.setDate(endOfWeek.getDate() + 6);
            calendarInterface.focusDate(endOfWeek);
            break;
          }
      }
    }
    function handleKeyDownOnToday(event, calendarInterface) {
      switch (normalizeKeyValue(event.key)) {
        case 'Tab':
          if (!event.shiftKey) {
            preventDefaultAndStopPropagation(event);
            calendarInterface.focusFirstFocusableElement();
          }

          break;
      }
    }
    function handleKeyDownOnPreviousMonthNav(event, calendarInterface) {
      switch (normalizeKeyValue(event.key)) {
        case 'Tab':
          if (event.shiftKey) {
            preventDefaultAndStopPropagation(event);
            calendarInterface.focusLastFocusableElement();
          }

          break;
      }
    }

    function preventDefaultAndStopPropagation(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    // This is a library built from Globalization's repo
    /**
     * Define address format patterns.
     */

    var AddressFormatPattern = Object.freeze({
      /**
       *
       * N: Name (The formatting of names for this field is outside of the scope of the address elements.)
       * O: Organization
       * A: Address Lines (2 or 3 lines address)
       * D: District (Sub-locality): smaller than a city, and could be a neighborhood, suburb or dependent locality.
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * X: Sorting code, for example, CEDEX as used in France
       * n: newline
       */
      A: Symbol('Address Lines'),
      C: Symbol('City'),
      S: Symbol('State'),
      K: Symbol('Country'),
      Z: Symbol('Zip Code'),
      n: Symbol('New Line'),
      fromPlaceHolder: function fromPlaceHolder(placeHolder) {
        switch (placeHolder) {
          case 'A':
            return AddressFormatPattern.A;

          case 'C':
            return AddressFormatPattern.C;

          case 'S':
            return AddressFormatPattern.S;

          case 'K':
            return AddressFormatPattern.K;

          case 'Z':
            return AddressFormatPattern.Z;

          case 'n':
            return AddressFormatPattern.n;
        }

        return null;
      },
      getPlaceHolder: function getPlaceHolder(pattern) {
        switch (pattern) {
          case AddressFormatPattern.A:
            return 'A';

          case AddressFormatPattern.C:
            return 'C';

          case AddressFormatPattern.S:
            return 'S';

          case AddressFormatPattern.K:
            return 'K';

          case AddressFormatPattern.Z:
            return 'Z';

          case AddressFormatPattern.n:
            return 'n';
        }

        return null;
      },
      getData: function getData(pattern, data) {
        if (data) {
          switch (pattern) {
            case AddressFormatPattern.A:
              return data.address;

            case AddressFormatPattern.C:
              return data.city;

            case AddressFormatPattern.S:
              return data.state;

            case AddressFormatPattern.K:
              return data.country;

            case AddressFormatPattern.Z:
              return data.zipCode;

            case AddressFormatPattern.n:
              return data.newLine;
          }
        }

        return null;
      }
    });

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    /**
     * Address token types enum
     *
     * @private
     */


    var AddressTokenTypes = Object.freeze({
      DATA: Symbol('data'),
      STRING: Symbol('string'),
      NEWLINE: Symbol('newline'),
      GROUP: Symbol('group')
    });
    /**
     * AddressToken class
     *
     * @private
     */

    var AddressToken = function () {
      /**
       *
       * @param {AddressTokenTypes} type
       * @param {string} string
       * @param {*} pattern
       */
      function AddressToken(type, string, pattern) {
        classCallCheck(this, AddressToken);
        this.type = type;
        this.string = string;
        this.pattern = pattern;
      }
      /**
       * Construct a string type token
       *
       * @param {string} string String
       * @return {AddressToken} Address Token
       */


      createClass(AddressToken, null, [{
        key: 'string',
        value: function string(_string) {
          return new AddressToken(AddressTokenTypes.STRING, _string);
        }
        /**
         * Construct a data type token
         *
         * @param {pattern} pattern Address Format Pattern
         * @return {AddressToken} Address Token
         */

      }, {
        key: 'data',
        value: function data(pattern) {
          return new AddressToken(AddressTokenTypes.DATA, undefined, pattern);
        }
        /**
         * Construct a new line type token
         *
         * @return {AddressToken} Address Token
         */

      }, {
        key: 'newLine',
        value: function newLine() {
          return new AddressToken(AddressTokenTypes.NEWLINE);
        }
      }]);
      return AddressToken;
    }();

    // This is a library built from Globalization's repo

    /**
     S: Salutation
     F: First Name(givenName)
     M: Middle Name
     L: Last Name(familyName)
     X: Suffix
     I: Informal Name
     */

    var fieldConstants = {
      SALUTATION: Symbol('Salutation'),
      FIRST: Symbol('First Name'),
      MIDDLE: Symbol('Middle Name'),
      LAST: Symbol('Last Name'),
      SUFFIX: Symbol('Suffix'),
      INFORMAL: Symbol('Informal Name')
    };

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var Format = function Format(parts) {
      _classCallCheck(this, Format);

      this.parts = Object.freeze(parts);
      Object.freeze(this);
    };
    /**
     * Represents a field within the format
     */


    var FieldFormatPart = function FieldFormatPart(field) {
      _classCallCheck(this, FieldFormatPart);

      this.field = field;
      this.type = 'field';
      Object.freeze(this);
    };
    /**
     * Represents text to be output directly
     */


    var TextFormatPart = function TextFormatPart(text) {
      _classCallCheck(this, TextFormatPart);

      this.type = 'text';
      this.text = text;
      Object.freeze(this);
    };

    var fieldFormatParts = Object.freeze({
      SALUTATION: new FieldFormatPart(fieldConstants.SALUTATION),
      FIRST: new FieldFormatPart(fieldConstants.FIRST),
      MIDDLE: new FieldFormatPart(fieldConstants.MIDDLE),
      LAST: new FieldFormatPart(fieldConstants.LAST),
      SUFFIX: new FieldFormatPart(fieldConstants.SUFFIX),
      INFORMAL: new FieldFormatPart(fieldConstants.INFORMAL)
    });

    var FormatParser = function () {
      function FormatParser() {
        _classCallCheck(this, FormatParser);
      }

      _createClass(FormatParser, [{
        key: 'parse',

        /**
         * Parses the format
         * @param {string} fmt the format to be parsed
         * @returns {Format}
         */
        value: function parse(fmt) {
          var nodes = [];
          var textBuffer = ''; // parse the format string

          for (var i = 0; i < fmt.length; i = i + 1) {
            if (fmt[i] === '%') {
              i = i + 1; // move to the next character after %
              // end the last text buffer

              if (textBuffer.length > 0) {
                nodes.push(Object.freeze(new TextFormatPart(textBuffer)));
                textBuffer = '';
              }

              if (i >= fmt.length) {
                throw new Error('Unexpected end of format. Symbol at ' + (i - 1) + ' should be followed by a valid field code');
              }

              var code = fmt[i];

              switch (code) {
                case 'S':
                  nodes.push(fieldFormatParts.SALUTATION);
                  break;

                case 'F':
                  nodes.push(fieldFormatParts.FIRST);
                  break;

                case 'M':
                  nodes.push(fieldFormatParts.MIDDLE);
                  break;

                case 'L':
                  nodes.push(fieldFormatParts.LAST);
                  break;

                case 'X':
                  nodes.push(fieldFormatParts.SUFFIX);
                  break;

                case 'I':
                  nodes.push(fieldFormatParts.INFORMAL);
                  break;
              }
            } else {
              // if it wasn't a symbol, then just output the value directly
              textBuffer += fmt[i];
            }
          }

          if (textBuffer.length > 0) {
            nodes.push(new TextFormatPart(textBuffer));
          }

          return new Format(nodes);
        }
      }]);

      return FormatParser;
    }();

    var formatParser = new FormatParser();

    var numberFormat = '#,##0.###';

    var percentFormat = '#,##0%';

    var currencyFormat = '¤#,##0.00;(¤#,##0.00)';

    var currency = 'USD';

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat#Parameters

    const POSSIBLE_OPTS = {
      style: true,
      currency: true,
      currencyDisplay: true,
      useGrouping: true,
      minimumIntegerDigits: true,
      minimumFractionDigits: true,
      maximumFractionDigits: true,
      minimumSignificantDigits: true,
      maximumSignificantDigits: true
    };
    const STYLE = {
      DECIMAL: 'decimal',
      CURRENCY: 'currency',
      PERCENT: 'percent'
    };
    const CURRENCY_DISPLAY = {
      CODE: 'code',
      // USD
      SYMBOL: 'symbol',
      // $
      NAME: 'name' // US Dollars

    };
    const SAFE_NUM_LENGTH = 15;
    const numberFormatInstancesCache = {};

    function getStringOfChar(char, amount) {
      return new Array(amount + 1).join(char);
    }

    function getGroupingCount(skeleton) {
      const match = skeleton.match(/,[#0]*\./);
      return match ? match[0].length - 2 : 0;
    }

    function getOptionsUniqueKey(options) {
      return Object.keys(options).sort().reduce((prev, optionName) => {
        if (POSSIBLE_OPTS[optionName]) {
          return prev + optionName + options[optionName] + '';
        }

        return prev;
      }, '');
    }

    function toNumber(value, defaultValue) {
      const number = parseInt(value, 10);

      if (isNaN(number)) {
        return defaultValue;
      }

      return number;
    }

    function getFractionPart(options) {
      const minimumDigits = toNumber(options.minimumFractionDigits, 0);
      const maximumDigits = Math.max(toNumber(options.maximumFractionDigits, 0), minimumDigits);
      return '.' + new Array(minimumDigits + 1).join('0') + new Array(maximumDigits - minimumDigits + 1).join('#');
    }

    function updateFractionPart(skeleton, options) {
      const fractionPart = getFractionPart(options);
      return fractionPart ? skeleton.replace(/\.(0|#)*/, fractionPart) : skeleton;
    }

    function updateCurrencySymbol(skeleton, currencyCode, options) {
      const symbol = String.fromCharCode(164);

      if (options.currencyDisplay === CURRENCY_DISPLAY.NAME) {
        // append the currency code at the end.
        return skeleton.replace(symbol, '') + currencyCode;
      }

      return skeleton.replace(symbol, currencyCode);
    }

    function updateIntegerPart(skeleton, options) {
      const minimumIntegerDigits = options.minimumIntegerDigits;
      const groupingCount = getGroupingCount(skeleton);

      if (!minimumIntegerDigits) {
        return skeleton;
      }

      if (minimumIntegerDigits <= groupingCount) {
        return skeleton.replace(/,[#0]*\./, ',' + getStringOfChar('#', groupingCount - minimumIntegerDigits) + getStringOfChar('0', minimumIntegerDigits) + '.');
      }

      return skeleton.replace(/[#0]*\./, getStringOfChar('0', minimumIntegerDigits - groupingCount) + ',' + getStringOfChar('0', groupingCount) + '.');
    }

    function getBestMatchCurrencySymbol(code, currencyDisplay) {
      if (!('Intl' in window)) {
        return code; // fail gracefully.
      }

      const opts = {
        style: 'currency',
        currency: code,
        minimumFractionDigits: 0
      };

      if (currencyDisplay) {
        opts.currencyDisplay = currencyDisplay;
      }

      const nf = getFromCache(opts);
      return nf.format(2).replace(/2/g, '');
    }

    function getCurrency(options) {
      const currencyDisplay = options.currencyDisplay || CURRENCY_DISPLAY.SYMBOL;

      if (currencyDisplay === CURRENCY_DISPLAY.SYMBOL || currencyDisplay === CURRENCY_DISPLAY.NAME) {
        return getBestMatchCurrencySymbol(options.currency, currencyDisplay);
      }

      return options.currency;
    }

    function getFromCache(options) {
      const optionsUniqueKey = getOptionsUniqueKey(options);
      let numberFormatInstance = numberFormatInstancesCache[optionsUniqueKey];

      if (numberFormatInstance) {
        return numberFormatInstance;
      }

      numberFormatInstance = new Intl.NumberFormat(locale, options);
      numberFormatInstancesCache[optionsUniqueKey] = numberFormatInstance;
      return numberFormatInstance;
    }

    function exceedsSafeLength(value, maxFractionDigits) {
      const str = value.toString();
      const intPart = str.split('.')[0];
      return intPart.length + toNumber(maxFractionDigits, 0) >= SAFE_NUM_LENGTH;
    }

    function normalizedMinimumFractionDigits(options) {
      const fractionSkeleton = getFallbackFractionSkeleton(options.style);
      const fractionDigits = fractionSkeleton.replace(/[^0]/g, '');
      return fractionDigits.length;
    }

    function normalizedMaximumFractionDigits(options) {
      const fractionSkeleton = getFallbackFractionSkeleton(options.style);
      const fractionDigits = fractionSkeleton.replace(/[^0#]/g, '');
      return Math.max(options.minimumFractionDigits, fractionDigits.length);
    }

    function getFallbackFractionSkeleton(style) {
      let styleFormat = numberFormat;

      if (style === STYLE.CURRENCY) {
        styleFormat = currencyFormat;
      } else if (style === STYLE.PERCENT) {
        styleFormat = percentFormat;
      }

      const format = styleFormat.split(';')[0];
      return format.split('.')[1] || '';
    }

    function normalizeOptions(options) {
      const normalizedOpts = Object.assign({}, options);
      normalizedOpts.currency = normalizedOpts.currency || currency;

      if (normalizedOpts.minimumFractionDigits === undefined) {
        normalizedOpts.minimumFractionDigits = normalizedMinimumFractionDigits(normalizedOpts);
      }

      if (normalizedOpts.maximumFractionDigits === undefined || normalizedOpts.maximumFractionDigits < normalizedOpts.minimumFractionDigits) {
        normalizedOpts.maximumFractionDigits = normalizedMaximumFractionDigits(normalizedOpts);
      }

      return normalizedOpts;
    }

    function NumberOptions(options) {
      this.options = options || {};
    }

    NumberOptions.prototype.isCurrency = function () {
      return this.options.style === 'currency';
    };

    NumberOptions.prototype.isPercent = function () {
      return this.options.style === 'percent';
    };

    NumberOptions.prototype.isDefaultCurrency = function () {
      return !this.options.currency || currency === this.options.currency;
    };

    NumberOptions.prototype.getDefaultSkeleton = function () {
      return this.isCurrency() ? currencyFormat : this.isPercent() ? percentFormat : numberFormat;
    };

    NumberOptions.prototype.getSkeleton = function () {
      const options = this.options;
      const defaultSkeleton = this.getDefaultSkeleton();
      let skeleton = updateFractionPart(defaultSkeleton, options);
      skeleton = updateIntegerPart(skeleton, options);

      if (!this.isDefaultCurrency()) {
        skeleton = updateCurrencySymbol(skeleton, getCurrency(options), options);
      }

      return skeleton;
    };

    /*
     * Regex to test a string for an ISO8601 Date. The following formats are matched.
     * Note that if a time element is present (e.g. 'T'), the string should have a time zone designator (Z or +hh:mm or -hh:mm).
     *
     *  YYYY
     *  YYYY-MM
     *  YYYY-MM-DD
     *  YYYY-MM-DDThh:mmTZD
     *  YYYY-MM-DDThh:mm:ssTZD
     *  YYYY-MM-DDThh:mm:ss.STZD
     *
     *
     * @see: https://www.w3.org/TR/NOTE-datetime
     */
    const ISO8601_STRICT_PATTERN = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z){1})?)?)?$/i;
    /* Regex to test a string for an ISO8601 partial time or full time:
     * hh:mm
     * hh:mm:ss
     * hh:mm:ss.S
     * full time = partial time + TZD
     */

    const ISO8601_TIME_PATTERN = /^\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;
    const STANDARD_DATE_FORMAT = 'YYYY-MM-DD';
    const TIME_SEPARATOR = 'T';
    const TIMEZONE_INDICATOR = /(Z|([+-])(\d{2}):(\d{2}))$/;
    function isValidISODateTimeString(dateTimeString) {
      return isValidISO8601String(dateTimeString) && isValidDate(dateTimeString);
    }
    function isValidISOTimeString(timeString) {
      if (!isValidISO8601TimeString(timeString)) {
        return false;
      }

      const timeOnly = removeTimeZoneSuffix(timeString);
      return isValidDate(`2018-09-09T${timeOnly}Z`);
    }
    function removeTimeZoneSuffix(dateTimeString) {
      if (typeof dateTimeString === 'string') {
        return dateTimeString.split(TIMEZONE_INDICATOR)[0];
      }

      return dateTimeString;
    }

    function isValidISO8601String(dateTimeString) {
      if (typeof dateTimeString !== 'string') {
        return false;
      }

      return ISO8601_STRICT_PATTERN.test(dateTimeString);
    }

    function isValidISO8601TimeString(timeString) {
      if (typeof timeString !== 'string') {
        return false;
      }

      return ISO8601_TIME_PATTERN.test(timeString);
    }

    function isValidDate(value) {
      // Date.parse returns NaN if the argument doesn't represent a valid date
      const timeStamp = Date.parse(value);
      return isFinite(timeStamp);
    }

    // This is a library for all calls to the aura localizationService.
    function isBefore(date1, date2, unit) {
      return configProvider.getLocalizationService().isBefore(date1, date2, unit);
    }
    function isAfter(date1, date2, unit) {
      return configProvider.getLocalizationService().isAfter(date1, date2, unit);
    }
    function formatDateTimeUTC(date) {
      return configProvider.getLocalizationService().formatDateTimeUTC(date);
    }
    function formatDate(dateString, format, locale) {
      return configProvider.getLocalizationService().formatDate(dateString, format, locale);
    }
    function formatDateUTC(dateString, format, locale) {
      return configProvider.getLocalizationService().formatDateUTC(dateString, format, locale);
    }
    function formatTime(timeString, format) {
      return configProvider.getLocalizationService().formatTime(timeString, format);
    }
    function parseDateTimeUTC(dateTimeString) {
      return configProvider.getLocalizationService().parseDateTimeUTC(dateTimeString);
    }
    function parseDateTimeISO8601(dateTimeString) {
      return configProvider.getLocalizationService().parseDateTimeISO8601(dateTimeString);
    }
    function parseDateTime(dateTimeString, format, strictMode) {
      return configProvider.getLocalizationService().parseDateTime(dateTimeString, format, strictMode);
    }
    function syncUTCToWallTime(date, timeZone) {
      let converted = null; // eslint-disable-next-line new-cap

      configProvider.getLocalizationService().UTCToWallTime(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function syncWallTimeToUTC(date, timeZone) {
      let converted = null; // eslint-disable-next-line new-cap

      configProvider.getLocalizationService().WallTimeToUTC(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function toOtherCalendar(date) {
      return configProvider.getLocalizationService().translateToOtherCalendar(date);
    }
    function fromOtherCalendar(date) {
      return configProvider.getLocalizationService().translateFromOtherCalendar(date);
    }
    function toLocalizedDigits(input) {
      return configProvider.getLocalizationService().translateToLocalizedDigits(input);
    }
    function fromLocalizedDigits(input) {
      return configProvider.getLocalizationService().translateFromLocalizedDigits(input);
    } // This belongs to localization service; i.e. getLocalizationService().parseTime()
    // Should be removed after it's been added to the localization service

    function parseTime(timeString, format, strictParsing) {
      if (!timeString) {
        return null;
      }

      if (!format) {
        if (!isValidISOTimeString(timeString)) {
          return null;
        }

        return parseDateTimeISO8601(timeString);
      }

      const parseString = timeString.replace(/(\d)([AaPp][Mm])/g, '$1 $2'); // Modifying the time string so that strict parsing doesn't break on minor deviations

      const parseFormat = format.replace(/(\b|[^h])h{2}(?!h)/g, '$1h').replace(/(\b|[^H])H{2}(?!H)/g, '$1H').replace(/(\b|[^m])m{2}(?!m)/g, '$1m').replace(/\s*A/g, ' A').trim();
      const acceptableFormats = [parseFormat]; // We want to be lenient and accept input values with seconds or milliseconds precision.
      // So even though we may display the time as 10:23 AM, we would accept input values like 10:23:30.555 AM.

      acceptableFormats.push(parseFormat.replace('m', 'm:s'), parseFormat.replace('m', 'm:s.S'), parseFormat.replace('m', 'm:s.SS'), parseFormat.replace('m', 'm:s.SSS')); // Start parsing from the most strict format (i.e. time with milliseconds).
      // The strict mode parsing of time strings using parseDateTime seems to be lenient for certain formats

      acceptableFormats.reverse();

      for (let i = 0; i < acceptableFormats.length; i++) {
        const time = parseDateTime(parseString, acceptableFormats[i], strictParsing);

        if (time) {
          return time;
        }
      }

      return null;
    } // This is called from the numberFormat library when the value exceeds the safe length.

    function getNumberFormat(format) {
      return configProvider.getLocalizationService().getNumberFormat(format);
    }

    function numberFormatFallback(options) {
      const skeleton = new NumberOptions(options).getSkeleton();
      return {
        format: value => {
          return getNumberFormat(skeleton).format(value);
        }
      };
    }

    function numberFormat$1(options) {
      const normalizedOpts = Object.assign({}, normalizeOptions(options));

      if (!('Intl' in window)) {
        return numberFormatFallback(normalizedOpts);
      }

      return {
        format: value => {
          if (value && exceedsSafeLength(value, normalizedOpts.maximumFractionDigits)) {
            return numberFormatFallback(normalizedOpts).format(value);
          }

          const numberFormatInstance = getFromCache(normalizedOpts);
          return numberFormatInstance.format(value);
        }
      };
    }

    const FORMATTING_OPTS = ['weekday', 'year', 'month', 'day', 'hour', 'minute', 'second', 'era'];
    const FORMAT_MAP = {
      weekday: {
        short: 'EEE, ',
        narrow: 'EEE, ',
        long: 'EEEE, '
      },
      month: {
        short: 'MMM ',
        narrow: 'MMM ',
        numeric: 'MMM ',
        '2-digit': 'MMM ',
        long: 'MMMM '
      },
      day: {
        numeric: 'd, ',
        '2-digit': 'dd, '
      },
      year: {
        numeric: 'yyyy ',
        '2-digit': 'yy '
      },
      hour: {
        numeric12: 'h',
        numeric24: 'H',
        '2-digit12': 'hh',
        '2-digit24': 'HH'
      },
      minute: {
        numeric: 'mm',
        '2-digit': 'mm'
      },
      second: {
        numeric: 'ss',
        '2-digit': 'ss'
      },
      timeZoneName: {
        short: '[GMT]Z',
        long: '[GMT]Z'
      }
    };
    const SEPARATORS = [',', ' ', ':'];

    function getWeekDayPart(format, options) {
      const weekdayOptionValue = options.weekday;

      if (FORMAT_MAP.weekday[weekdayOptionValue] !== undefined) {
        format.push(FORMAT_MAP.weekday[weekdayOptionValue]);
      }
    }

    function getMonthPart(format, options) {
      const monthOptionValue = options.month;

      if (FORMAT_MAP.month[monthOptionValue] !== undefined) {
        format.push(FORMAT_MAP.month[monthOptionValue]);
      }
    }

    function getDayPart(format, options) {
      const dayOptionValue = options.day;

      if (FORMAT_MAP.day[dayOptionValue] !== undefined) {
        format.push(FORMAT_MAP.day[dayOptionValue]);
      }
    }

    function getYearPart(format, options) {
      const yearOptionValue = options.year;

      if (FORMAT_MAP.year[yearOptionValue] !== undefined) {
        format.push(FORMAT_MAP.year[yearOptionValue]);
      }
    }

    function getTZPart(format, options) {
      const timeZoneNameOptionValue = options.timeZoneName;

      if (FORMAT_MAP.timeZoneName[timeZoneNameOptionValue] !== undefined) {
        if (options.timeZone === 'UTC') {
          format.push('[GMT]');
        } else {
          format.push(FORMAT_MAP.timeZoneName[timeZoneNameOptionValue]);
        }
      }
    }

    function getTimePart(format, options) {
      const hourOptionValue = options.hour,
            minuteOptionValue = options.minute,
            secondOptionValue = options.second;
      let hasTime = false;
      let hasHourOnly = false; // hour 12 hr or 24 hr

      if (hourOptionValue === 'numeric' || hourOptionValue === '2-digit') {
        hasTime = true;

        if (options.hour12 === false) {
          if (hourOptionValue === 'numeric') {
            format.push(FORMAT_MAP.hour.numeric24);
          } else {
            format.push(FORMAT_MAP.hour['2-digit24']);
          }
        } else if (hourOptionValue === 'numeric') {
          format.push(FORMAT_MAP.hour.numeric12);
        } else {
          format.push(FORMAT_MAP.hour['2-digit12']);
        }

        if (FORMAT_MAP.minute[minuteOptionValue] !== undefined) {
          format.push(':');
        } else if (FORMAT_MAP.second[secondOptionValue] !== undefined) {
          hasHourOnly = true;
        }
      } // minute


      if (FORMAT_MAP.minute[minuteOptionValue] !== undefined) {
        hasTime = true;
        format.push(FORMAT_MAP.minute[minuteOptionValue]);

        if (FORMAT_MAP.second[secondOptionValue] !== undefined) {
          format.push(':');
        }
      } // second


      if (FORMAT_MAP.second[secondOptionValue] !== undefined && !hasHourOnly) {
        hasTime = true;
        format.push(FORMAT_MAP.second[secondOptionValue]);
      } // AM/PM marker


      if (hasTime) {
        format.push(' a ');
      }

      if (hasHourOnly) {
        format.push('[(sec]: ' + FORMAT_MAP.second[secondOptionValue] + '[)]');
      }
    }

    function DateTimeOptions(options) {
      this.options = options || {};
    }

    DateTimeOptions.prototype.hasFormattingOptions = function () {
      return FORMATTING_OPTS.some(opt => {
        return this.options[opt] !== undefined;
      });
    };

    DateTimeOptions.prototype.getSkeleton = function () {
      const format = [];
      getWeekDayPart(format, this.options);
      getMonthPart(format, this.options);
      getDayPart(format, this.options);
      getYearPart(format, this.options);
      getTimePart(format, this.options);
      getTZPart(format, this.options);
      let formatStr = format.join('');
      SEPARATORS.forEach(element => {
        if (formatStr.lastIndexOf(element) === formatStr.length - 1) {
          formatStr = formatStr.slice(0, -1);
        }
      });
      return formatStr;
    };

    const dateTimeFormatInstancesCache = {};
    const POSSIBLE_OPTS$1 = {
      weekday: true,
      era: true,
      year: true,
      month: true,
      day: true,
      hour: true,
      minute: true,
      second: true,
      timeZone: true,
      timeZoneName: true,
      hour12: true
    };

    function getOptionsUniqueKey$1(options) {
      return Object.keys(options).sort().reduce((prev, optionName) => {
        if (POSSIBLE_OPTS$1[optionName]) {
          return prev + optionName + options[optionName] + '';
        }

        return prev;
      }, '');
    }

    function getFromCache$1(options) {
      const optionsUniqueKey = getOptionsUniqueKey$1(options);
      let formatInstance = dateTimeFormatInstancesCache[optionsUniqueKey];

      if (!formatInstance) {
        formatInstance = new Intl.DateTimeFormat(locale, options);
        dateTimeFormatInstancesCache[optionsUniqueKey] = formatInstance;
      }

      return formatInstance;
    }

    function convertAndFormatDate(date, format, timeZone) {
      const translatedDate = toOtherCalendar(date);
      const converted = syncUTCToWallTime(translatedDate, timeZone);
      return formatDateUTC(converted, format);
    }

    function isDate(value) {
      return Object.prototype.toString.call(value) === '[object Date]' && !isNaN(value.getTime());
    }

    function toDate(value) {
      let dateObj = value;

      if (!isDate(value) && (typeof value === 'string' || typeof value === 'number')) {
        dateObj = new Date(isFinite(value) ? parseInt(value, 10) : Date.parse(value));
      }

      return dateObj;
    }

    const isTimeZonesSupported = function () {
      try {
        // IE11 only supports the UTC time zone and throws when given anything else
        // eslint-disable-next-line new-cap
        Intl.DateTimeFormat('en-US', {
          timeZone: 'America/Los_Angeles'
        });
      } catch (err) {
        return false;
      }

      return true;
    }();

    function dateTimeFormatFallback(dto) {
      // localization service will default to mediumDateFormat when no format is provided
      const format = dto.hasFormattingOptions() ? dto.getSkeleton() : null;
      const {
        timeZone
      } = dto.options;
      return {
        format: value => {
          // if value is an ISO date string (e.g. 2019-10-25), do not convert between timezones and just format the date
          if (isValidISODateTimeString(value) && value.indexOf(TIME_SEPARATOR) < 0) {
            return formatDate(value);
          } // FIXME use standard methods from localizationService for parsing and formatting instead


          const dateObj = toDate(value);

          if (isDate(dateObj)) {
            if (timeZone === 'UTC') {
              dateObj.setTime(dateObj.getTime() + dateObj.getTimezoneOffset() * 60 * 1000);
            }

            return convertAndFormatDate(dateObj, format, timeZone);
          }

          return '';
        }
      };
    }

    function dateTimeFormat(opts) {
      const options = opts || {};
      const dto = new DateTimeOptions(options);

      if (!('Intl' in window) || !dto.hasFormattingOptions() || !isTimeZonesSupported) {
        return dateTimeFormatFallback(dto);
      }

      return {
        format: value => {
          const dtf = getFromCache$1(options);
          return dtf.format(toDate(value));
        }
      };
    }

    const FALLBACK_LOCALE = 'en-us';
    const symbolsCache = {};
    function getNameOfWeekdays() {
      const localeCache = symbolsCache[locale];

      if (localeCache && localeCache.weekdays) {
        return localeCache.weekdays;
      }

      const locales = [locale, FALLBACK_LOCALE];
      const fullNameFormatter = new Intl.DateTimeFormat(locales, {
        weekday: 'long',
        timeZone: 'UTC'
      });
      const shortNameFormatter = new Intl.DateTimeFormat(locales, {
        weekday: 'short',
        timeZone: 'UTC'
      });
      const weekdays = [];

      for (let i = 0; i <= 6; i++) {
        // (1970, 0, 4) corresponds to a sunday.
        const date = new Date(Date.UTC(1970, 0, 4 + i));
        weekdays.push({
          fullName: format(fullNameFormatter, date),
          shortName: format(shortNameFormatter, date)
        });
      }

      if (!symbolsCache[locale]) {
        symbolsCache[locale] = {};
      }

      symbolsCache[locale].weekdays = weekdays;
      return weekdays;
    }
    function getMonthNames() {
      const localeCache = symbolsCache[locale];

      if (localeCache && localeCache.months) {
        return localeCache.months;
      }

      const locales = [locale, FALLBACK_LOCALE];
      const monthNameFormatter = new Intl.DateTimeFormat(locales, {
        month: 'long'
      });
      const months = [];

      for (let i = 0; i <= 11; i++) {
        const date = new Date(1970, i, 4);
        months.push({
          // we currently only need the fullName
          fullName: format(monthNameFormatter, date)
        });
      }

      if (!symbolsCache[locale]) {
        symbolsCache[locale] = {};
      }

      symbolsCache[locale].months = months;
      return months;
    }

    function format(dateTimeFormat, date) {
      const formattedDate = dateTimeFormat.format(date);
      return removeIE11Markers(formattedDate);
    }

    function removeIE11Markers(formattedString) {
      // IE11 adds LTR / RTL mark in the formatted date time string
      return formattedString.replace(/[\u200E\u200F]/g, '');
    }

    var mediumDateFormat = 'MMM d, yyyy';

    var mediumTimeFormat = 'h:mm:ss a';

    function normalizeISODate(value, format) {
      const dateValue = typeof value === 'string' ? value.trim() : value;

      if (!dateValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      } // if value is an ISO string, only fetch the date part


      const dateOnlyString = typeof dateValue === 'string' && dateValue.split(TIME_SEPARATOR)[0] || dateValue;
      assert(isValidISODateTimeString(dateOnlyString), `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedDate = parseDateTime(dateOnlyString, STANDARD_DATE_FORMAT);

      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      } // convert from Gregorian to Buddhist Calendar if necessary


      const civilDate = toOtherCalendar(parsedDate);
      return {
        isoValue: dateOnlyString,
        displayValue: formatDate(civilDate, format)
      };
    }
    function normalizeISOTime(value, format) {
      // We are not converting the time to the user's timezone. All values are displayed and saved as UTC time values
      const normalizedValue = removeTimeZoneSuffix(value);
      const timeValue = typeof normalizedValue === 'string' ? normalizedValue.trim() : normalizedValue;

      if (!timeValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      assert(isValidISOTimeString(timeValue), `datetime component: The value attribute accepts a valid ISO8601 formatted string. ` + `but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedTime = parseTime(timeValue);

      if (!parsedTime) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      return {
        isoValue: getISOTimeString(parsedTime),
        displayValue: formatTime(parsedTime, format)
      };
    }
    function normalizeISODateTime(value, timezone, format) {
      const dateTimeValue = typeof value === 'string' ? value.trim() : value;

      if (!dateTimeValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      assert(isValidISODateTimeString(dateTimeValue), `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedDate = parseDateTimeISO8601(dateTimeValue);

      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      const convertedDate = syncUTCToWallTime(parsedDate, timezone);
      return {
        // We are passing the ISO value without a timezone designator.
        // the native input type='datetime-local' who calls this does not accept timezone offset
        isoValue: removeTimeZoneSuffix(convertedDate.toISOString()),
        displayValue: formatDateTimeUTC(convertedDate)
      };
    }
    function normalizeFormattedDate(value, format) {
      const dateValue = typeof value === 'string' ? value.trim() : value;

      if (!dateValue) {
        return null;
      }

      const parsedDate = parseDateTime(dateValue, format || mediumDateFormat, true);

      if (!parsedDate) {
        return null;
      }

      const gregorianDate = fromOtherCalendar(parsedDate);
      return getISODateString(gregorianDate);
    }
    function normalizeFormattedTime(value, format) {
      const timeValue = typeof value === 'string' ? value.trim() : value;

      if (!timeValue) {
        return null;
      }

      const parsedDate = parseTime(timeValue, format || mediumTimeFormat, true);

      if (!parsedDate) {
        return null;
      }

      return getISOTimeString(parsedDate);
    } // The value here isn't really formatted, it's always an ISO string in the form isoDate + T + isoTime (without Z).

    function normalizeFormattedDateTime(value, timezone, format) {
      const datetimeValue = typeof value === 'string' ? value.trim() : value;

      if (!datetimeValue) {
        return null;
      } // given that value is an ISO string without Z, the method below is equivalent to parseDateTimeISO8601(value + 'Z')
      // However, parseDateTimeUTC is more concise and doesn't need any manipulation of the input (adding Z).


      const parsedDate = parseDateTimeUTC(datetimeValue);

      if (!parsedDate) {
        return null;
      }

      const convertedDate = syncWallTimeToUTC(parsedDate, timezone);
      return convertedDate.toISOString();
    }
    function getToday() {
      const today = getTodayBasedOnTimezone();
      return getISODateString(today);
    }
    function getISODateString(date) {
      return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
    }
    function getISOTimeString(date) {
      return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${doublePad(date.getMilliseconds())}`;
    }
    function getCurrentTime(timezone) {
      const today = getTodayBasedOnTimezone(timezone);
      return pad(today.getHours()) + ':' + pad(today.getMinutes());
    }

    function getTodayBasedOnTimezone(timezone) {
      const today = new Date();
      today.setTime(today.getTime() + today.getTimezoneOffset() * 60 * 1000); // time in UTC
      // localization service will use $Locale.timezone when no timezone provided

      return syncUTCToWallTime(today, timezone);
    }

    function pad(n) {
      return Number(n) < 10 ? '0' + n : n;
    }

    function doublePad(n) {
      const number = Number(n);

      if (number < 10) {
        return '00' + n;
      } else if (number < 100) {
        return '0' + n;
      }

      return n;
    }

    const i18n$5 = {
      ariaLabelMonth: labelAriaLabelMonth,
      nextMonth: labelNextMonth,
      previousMonth: labelPreviousMonth,
      today: labelToday,
      yearSelector: labelYearSelector
    };
    const WEEKS_PER_MONTH = 6;
    const DAYS_PER_WEEK = 7;
    const calendarCache = {}; // cache of calendar cells for a given year/month

    class LightningCalendar extends lwc.LightningElement {
      get value() {
        return this.selectedDate;
      }

      set value(newValue) {
        // if value is an ISO string, only fetch the time part
        const dateOnlyString = typeof newValue === 'string' ? newValue.split(TIME_SEPARATOR)[0] : newValue;

        if (dateOnlyString !== this.selectedDate) {
          this.selectedDate = dateOnlyString;

          if (!this._connected) {
            return;
          }

          const newDate = this.parseDate(dateOnlyString); // if the date is invalid, render today's date

          if (!newDate) {
            this.selectedDate = null;
            this.renderToday();
          } else {
            this.selectDate(newDate);
          }
        }
      }

      constructor() {
        super();
        this.calendarYear = null;
        this.calendarMonth = null;
        this.min = void 0;
        this.max = void 0;
        this.uniqueId = generateUniqueId();
      }

      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready'));
      }

      connectedCallback() {
        this._connected = true;
        this.todayDate = getToday();
        const renderDate = this.getSelectedDate() || this.getTodaysDate();
        this.renderCalendar(renderDate);
        this.keyboardInterface = this.calendarKeyboardInterface();
      }

      disconnectedCallback() {
        this._connected = false;
        this._hasFocus = false;
        this._cancelBlur = false;
      }
      /**
       * Sets focus on the focusable date cell in the calendar.
       */


      focus() {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const dateElement = this.getFocusableDateCell();

          if (dateElement) {
            dateElement.focus();
          }
        });
      }

      get i18n() {
        return i18n$5;
      }

      get computedAriaLabel() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return i18n$5.ariaLabelMonth + getMonthNames()[renderedMonth].fullName;
      }

      get computedMonthTitle() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return getMonthNames()[renderedMonth].fullName;
      }

      get computedWeekdayLabels() {
        const nameOfWeekdays = getNameOfWeekdays();
        const firstDay = this.getFirstDayOfWeek();
        const computedWeekdayLabels = []; // We need to adjust the weekday labels to start from the locale's first day of week

        for (let i = firstDay; i < nameOfWeekdays.length; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }

        for (let i = 0; i < firstDay; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }

        return computedWeekdayLabels;
      }

      get computedSelectElementId() {
        return this.uniqueId + '-select';
      }

      get computedWeekdaysElementId() {
        return this.uniqueId + '-weekdays';
      }

      get computedMonthTitleId() {
        return this.uniqueId + '-month';
      }

      get computedYearList() {
        const sampleDate = new Date();
        const currentYear = sampleDate.getFullYear();
        const minDate = this.parseDate(this.min);
        const maxDate = this.parseDate(this.max);
        const minYear = minDate ? minDate.getFullYear() : currentYear - 100;
        const maxYear = maxDate ? maxDate.getFullYear() : currentYear + 100;
        const yearList = [];

        for (let year = minYear; year <= maxYear; year++) {
          yearList.push({
            label: this.getYearDisplayValue(sampleDate, year),
            value: year
          });
        }

        return yearList;
      }

      get monthIndex() {
        return this.getCalendarDate().getMonth();
      }

      getYearDisplayValue(date, yearValue) {
        date.setFullYear(yearValue);
        return toLocalizedDigits(String(toOtherCalendar(date).getFullYear()));
      }

      get computedMonth() {
        if (!this._connected) {
          return [];
        }

        this.removeCurrentlySelectedDateAttributes();
        const selectedDate = this.getSelectedDate();
        const renderDate = this.getCalendarDate();
        const cacheKey = this.getCalendarCacheKey(renderDate, selectedDate);

        if (cacheKey in calendarCache) {
          return calendarCache[cacheKey];
        }

        const todayDate = this.getTodaysDate();
        const focusableDate = this.getInitialFocusDate(todayDate, selectedDate, renderDate);
        const calendarDates = {
          selectedDate,
          renderDate,
          focusableDate,
          todayDate,
          minDate: this.parseDate(this.min),
          maxDate: this.parseDate(this.max)
        };
        const monthCells = [];
        const date = this.getCalendarStartDate(renderDate);

        for (let week = 0; week < WEEKS_PER_MONTH; week++) {
          const weekCells = {
            id: week,
            days: []
          };

          for (let weekday = 0; weekday < DAYS_PER_WEEK; weekday++) {
            const dayCell = this.getDateCellAttributes(date, calendarDates);
            weekCells.days.push(dayCell);
            date.setDate(date.getDate() + 1);
          }

          monthCells.push(weekCells);
        }

        calendarCache[cacheKey] = monthCells;
        return monthCells;
      }

      getDateCellAttributes(date, calendarDates) {
        const isDisabled = !this.dateInCalendar(date, calendarDates.renderDate) || !this.isBetween(date, calendarDates.minDate, calendarDates.maxDate);
        const isSelected = this.isSame(date, calendarDates.selectedDate);
        const isToday = this.isSame(date, calendarDates.todayDate);
        const ariaCurrent = isToday ? 'date' : false;
        const tabIndex = this.isSame(date, calendarDates.focusableDate) ? '0' : false;
        const className = classSet().add({
          'slds-is-today': isToday,
          'slds-is-selected': isSelected,
          'slds-disabled-text': isDisabled
        }).toString();
        return {
          dayInMonth: toLocalizedDigits(String(date.getDate())),
          dateValue: this.formatDate(date),
          isDisabled,
          isSelected: isSelected ? 'true' : 'false',
          className,
          tabIndex,
          ariaCurrent
        };
      }

      dispatchSelectEvent() {
        this.dispatchEvent(new CustomEvent('select', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this.selectedDate
          }
        }));
      } // Determines if the date is in the rendered month/year calendar.


      dateInCalendar(date, calendarDate) {
        const renderedCalendar = calendarDate || this.getCalendarDate();
        return date.getMonth() === renderedCalendar.getMonth() && date.getFullYear() === renderedCalendar.getFullYear();
      }

      getInitialFocusDate(todayDate, selectedDate, renderedDate) {
        if (selectedDate && this.dateInCalendar(selectedDate, renderedDate)) {
          return selectedDate;
        }

        if (this.dateInCalendar(todayDate, renderedDate)) {
          return todayDate;
        }

        return new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
      }

      getTodaysDate() {
        if (this.todayDate) {
          return this.parseDate(this.todayDate);
        } // Today's date will be fetched in connectedCallback. In the meantime, use the date based on the device timezone.


        return new Date();
      }

      getSelectedDate() {
        return this.parseDate(this.selectedDate);
      } // returns the month and year in the calendar


      getCalendarDate() {
        if (this.calendarYear) {
          return new Date(this.calendarYear, this.calendarMonth, 1);
        }

        return this.getTodaysDate();
      }

      getCalendarStartDate(renderedDate) {
        const firstDayOfMonth = new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
        return this.getStartOfWeek(firstDayOfMonth);
      }

      getStartOfWeek(dayInWeek) {
        const firstDay = this.getFirstDayOfWeek(); // Negative dates in JS will subtract days from the 1st of the given month

        let startDay = dayInWeek.getDay();

        while (startDay !== firstDay) {
          dayInWeek.setDate(dayInWeek.getDate() - 1);
          startDay = dayInWeek.getDay();
        }

        return dayInWeek;
      }

      getFirstDayOfWeek() {
        return firstDayOfWeek - 1; // In Java, week days are 1 - 7
      } // This method is called when a new value is set, or when you click the today button.
      // In both cases, we need to check if newValue is in the currently rendered calendar


      selectDate(newDate) {
        if (this.dateInCalendar(newDate)) {
          const dateElement = this.getElementByDate(this.formatDate(newDate)); // do not select if date is disabled

          if (this.dateElementDisabled(dateElement)) {
            return;
          }

          this.selectDateInCalendar(dateElement);
        } else {
          this.renderCalendar(newDate);
        }
      } // Select a date in current calendar without the need to re-render the calendar


      selectDateInCalendar(dateElement) {
        this.selectedDate = dateElement.getAttribute('data-value');
        this.removeCurrentlySelectedDateAttributes();
        this.addSelectedDateAttributes(dateElement);
      }

      selectDateInCalendarAndDispatchSelect(dateElement) {
        // do not select if date is disabled
        if (this.dateElementDisabled(dateElement)) {
          return;
        }

        this.selectDateInCalendar(dateElement);
        this.dispatchSelectEvent();
      } // we should be able to control the select value with an attribute once we have a select component


      selectYear(year) {
        const optionElement = this.template.querySelector(`option[value='${year}']`);

        if (optionElement) {
          optionElement.selected = true;
        }
      }

      getElementByDate(dateString) {
        return this.template.querySelector(`td[data-value='${dateString}']`);
      }

      getFocusableDateCell() {
        return this.template.querySelector(`td[tabIndex='0']`);
      }

      unfocusDateCell(element) {
        if (element) {
          element.removeAttribute('tabIndex');
        }
      }

      focusDateCell(element) {
        if (element) {
          element.setAttribute('tabIndex', 0);
          element.focus();
        }
      }

      focusElementByDate(date) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const element = this.getElementByDate(this.formatDate(date));

          if (element) {
            this.unfocusDateCell(this.getFocusableDateCell());
            this.focusDateCell(element);
          }
        });
      }

      renderCalendar(newDate) {
        this.calendarMonth = newDate.getMonth();
        this.calendarYear = newDate.getFullYear();
        this.selectYear(newDate.getFullYear());
      }

      renderToday() {
        const todaysDate = this.getTodaysDate();

        if (this.dateInCalendar(todaysDate)) {
          this.removeCurrentlySelectedDateAttributes();
          this.unfocusDateCell(this.getFocusableDateCell());
          const todayElement = this.getElementByDate(this.todayDate);
          todayElement.setAttribute('tabIndex', 0);
        } else {
          this.renderCalendar(todaysDate);
        }
      }

      removeCurrentlySelectedDateAttributes() {
        const currentlySelectedElement = this.template.querySelector(`td[class*='slds-is-selected']`);

        if (currentlySelectedElement) {
          currentlySelectedElement.classList.remove('slds-is-selected');
          currentlySelectedElement.setAttribute('aria-selected', 'false');
        }

        this.unfocusDateCell(this.getFocusableDateCell());
      }

      addSelectedDateAttributes(dateElement) {
        this.focusDateCell(dateElement);
        dateElement.classList.add('slds-is-selected');
        dateElement.setAttribute('aria-selected', 'true');
      }

      dateElementDisabled(dateElement) {
        // do not select if date is disabled
        return !dateElement || dateElement.getAttribute('aria-disabled') === 'true';
      }

      handleBlur() {
        if (this._cancelBlur) {
          return;
        }

        this._hasFocus = false;
        this.dispatchEvent(new CustomEvent('leave'));
      }

      handleFocus() {
        if (this._hasFocus) {
          return;
        }

        this._hasFocus = true;
        this.dispatchEvent(new CustomEvent('enter'));
      }

      cancelBlur() {
        this._cancelBlur = true;
      }

      allowBlur() {
        this._cancelBlur = false;
      }

      handleCalendarKeyDown(event) {
        this.cancelBlur();
        const dateString = event.target.getAttribute('data-value');
        handleKeyDownOnCalendar(event, this.parseDate(dateString), this.keyboardInterface);
      }

      handleTodayKeyDown(event) {
        this.cancelBlur();
        handleKeyDownOnToday(event, this.keyboardInterface);
      }

      handlePrevNavKeyDown(event) {
        this.cancelBlur();
        handleKeyDownOnPreviousMonthNav(event, this.keyboardInterface);
      }

      handleDateClick(event) {
        event.stopPropagation();
        const tdElement = event.target.parentElement;
        this.selectDateInCalendarAndDispatchSelect(tdElement);
      }

      handleTodayClick(event) {
        event.stopPropagation();
        this.selectedDate = this.todayDate;
        this.selectDate(this.getTodaysDate());
        this.dispatchSelectEvent();
      }

      handleYearSelectClick(event) {
        event.stopPropagation();
      }

      handleYearChange(event) {
        event.stopPropagation();
        const newYearValue = event.target.value;

        if (this.calendarYear !== newYearValue) {
          this.calendarYear = newYearValue;
        }
      }

      goToNextMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() + 1);
        this.renderCalendar(calendarDate);
      }

      goToPreviousMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() - 1);
        this.renderCalendar(calendarDate);
      }

      calendarKeyboardInterface() {
        const that = this;
        return {
          focusDate(newDate) {
            if (!that.dateInCalendar(newDate)) {
              that.renderCalendar(newDate);
            }

            that.focusElementByDate(newDate);
          },

          getStartOfWeek(dayInWeek) {
            return that.getStartOfWeek(dayInWeek);
          },

          focusFirstFocusableElement() {
            that.template.querySelector('lightning-button-icon').focus();
          },

          focusLastFocusableElement() {
            that.template.querySelector('button[name="today"]').focus();
          },

          selectDate(dateElement) {
            that.selectDateInCalendarAndDispatchSelect(dateElement);
          }

        };
      }

      formatDate(date) {
        return getISODateString(date);
      }

      parseDate(dateString) {
        return parseDateTime(dateString, STANDARD_DATE_FORMAT, true);
      }

      isSame(date1, date2) {
        if (!date1 || !date2) {
          return false;
        }

        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate() // getDate returns the day in month whereas getDay returns the weekday number
        ;
      }

      isBetween(date, date1, date2) {
        let isBeforeEndDate = true;
        let isAfterStartDate = true;

        if (date2) {
          isBeforeEndDate = isBefore(date, date2, 'day') || this.isSame(date, date2);
        }

        if (date1) {
          isAfterStartDate = isAfter(date, date1, 'day') || this.isSame(date, date1);
        }

        return isBeforeEndDate && isAfterStartDate;
      }

      getCalendarCacheKey(renderDate, selectedDate) {
        let key = renderDate.getFullYear() + '-' + renderDate.getMonth(); // Having the key include min/max seems enough for now.
        // We're not going to complicate things by checking if renderDate falls before/after the min/max.

        key += this.min ? 'min' + this.min : '';
        key += this.max ? 'max' + this.max : '';

        if (selectedDate && this.dateInCalendar(selectedDate, renderDate)) {
          key += '_' + selectedDate.getDate();
        }

        return key;
      }

    }

    lwc.registerDecorators(LightningCalendar, {
      publicProps: {
        min: {
          config: 0
        },
        max: {
          config: 0
        },
        value: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        calendarYear: 1,
        calendarMonth: 1
      }
    });

    var _lightningCalendar = lwc.registerComponent(LightningCalendar, {
      tmpl: _tmpl$b
    });

    function tmpl$b($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16,
        _m17,
        _m18,
        _m19,
        _m20,
        _m21,
        _m22,
        _m23
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-dropdown-trigger": true,
          "slds-dropdown-trigger_click": true,
          "slds-size_1-of-1": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 7
      }, [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-input-has-icon": true,
          "slds-input-has-icon_right": true
        },
        key: 6
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("input"),
          "name": $cmp.name,
          "placeholder": $cmp.placeholder,
          "aria-label": $cmp.ariaLabel,
          "autocomplete": $cmp.autocomplete
        },
        props: {
          "value": $cmp.displayValue,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 3,
        on: {
          "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInput)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
          "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleFocus)),
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleInputBlur)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeydown)),
          "keyup": _m5 || ($ctx._m5 = api_bind($cmp.allowBlur)),
          "mousedown": _m6 || ($ctx._m6 = api_bind($cmp.cancelBlur)),
          "mouseup": _m7 || ($ctx._m7 = api_bind($cmp.allowBlur)),
          "click": _m8 || ($ctx._m8 = api_bind($cmp.handleInputClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "iconName": "utility:event",
          "variant": "bare",
          "disabled": $cmp.computedIconDisabledState,
          "title": $cmp.i18n.selectDate,
          "alternativeText": $cmp.i18n.selectDate
        },
        key: 4,
        on: {
          "click": _m9 || ($ctx._m9 = api_bind($cmp.handleDatePickerIconClick)),
          "keydown": _m10 || ($ctx._m10 = api_bind($cmp.handleDatePickerIconKeyDown)),
          "keyup": _m11 || ($ctx._m11 = api_bind($cmp.allowBlur)),
          "focus": _m12 || ($ctx._m12 = api_bind($cmp.handleFocus)),
          "blur": _m13 || ($ctx._m13 = api_bind($cmp.handleBlur)),
          "mousedown": _m14 || ($ctx._m14 = api_bind($cmp.cancelBlur)),
          "mouseup": _m15 || ($ctx._m15 = api_bind($cmp.allowBlur))
        }
      }, []), $cmp.isCalendarVisible ? api_custom_element("lightning-calendar", _lightningCalendar, {
        props: {
          "value": $cmp.value,
          "min": $cmp.min,
          "max": $cmp.max
        },
        key: 5,
        on: {
          "select": _m16 || ($ctx._m16 = api_bind($cmp.handleDateSelect)),
          "ready": _m17 || ($ctx._m17 = api_bind($cmp.startPositioning)),
          "keydown": _m18 || ($ctx._m18 = api_bind($cmp.handleCalendarKeyDown)),
          "keyup": _m19 || ($ctx._m19 = api_bind($cmp.allowBlur)),
          "enter": _m20 || ($ctx._m20 = api_bind($cmp.handleCalendarEnter)),
          "leave": _m21 || ($ctx._m21 = api_bind($cmp.handleBlur)),
          "mousedown": _m22 || ($ctx._m22 = api_bind($cmp.cancelBlur)),
          "mouseup": _m23 || ($ctx._m23 = api_bind($cmp.allowBlur))
        }
      }, []) : null])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true,
          "aria-live": "assertive"
        },
        key: 8
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var _tmpl$c = lwc.registerTemplate(tmpl$b);
    tmpl$b.stylesheets = [];
    tmpl$b.stylesheetTokens = {
      hostAttribute: "lightning-datepicker_datepicker-host",
      shadowAttribute: "lightning-datepicker_datepicker"
    };

    var labelInvalidDate = 'Your entry does not match the allowed format {0}.';

    var labelRangeOverflow$1 = 'Value must be {0} or earlier.';

    var labelRangeUnderflow$1 = 'Value must be {0} or later.';

    var labelSelectDate = 'Select a date';

    var shortDateFormat = 'M/d/yyyy';

    var longDateFormat = 'MMMM d, yyyy';

    function handleKeyDownOnDatePickerIcon(event, datepickerInterface) {
      switch (normalizeKeyValue(event.key)) {
        case 'Enter':
        case ' ':
          preventDefaultAndStopPropagation$1(event);
          datepickerInterface.showCalendar();
          break;

        case 'Escape':
          preventDefaultAndStopPropagation$1(event);
          datepickerInterface.hideCalendar();
          break;

        case 'Tab':
          if (!event.shiftKey && !datepickerInterface.isCalendarVisible()) {
            datepickerInterface.leave();
          }

          break;
      }
    }
    function handleInputKeyDownBehaviour(event, datepickerInterface) {
      if (normalizeKeyValue(event.key) === 'Tab' && event.shiftKey) {
        datepickerInterface.leave();
        return;
      }

      handleBasicKeyDownBehaviour(event, datepickerInterface);
    }
    function handleBasicKeyDownBehaviour(event, datepickerInterface) {
      if (!datepickerInterface.isCalendarVisible()) {
        return;
      }

      if (normalizeKeyValue(event.key) === 'Escape') {
        preventDefaultAndStopPropagation$1(event);
        datepickerInterface.hideCalendar();
      }
    }

    function preventDefaultAndStopPropagation$1(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    const i18n$6 = {
      invalidDate: labelInvalidDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired,
      selectDate: labelSelectDate
    };
    const ARIA_CONTROLS = 'aria-controls';
    const ARIA_LABEL = 'aria-label';
    const ARIA_LABELLEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$1 = 'aria-describedby';
    const DATE_STYLE = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };

    class LightningDatePicker extends lwc.LightningElement {
      get messageWhenBadInput() {
        return this._messageWhenBadInput || this.formatString(this.i18n.invalidDate, this.dateFormat);
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this.formatString(this.i18n.rangeOverflow, this.max);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(this.i18n.rangeUnderflow, this.min);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      } // setter is required to properly trigger update


      get ariaLabel() {
        return this._ariaLabel;
      }

      set ariaLabel(val) {
        this._ariaLabel = val;
        this.synchronizeA11y();
      }

      set ariaLabelledByElement(el) {
        this._ariaLabelledBy = el;
        this.synchronizeA11y();
      }

      get ariaLabelledByElement() {
        return this._ariaLabelledBy;
      }

      set ariaControlsElement(el) {
        this._ariaControls = el;
        this.synchronizeA11y();
      }

      get ariaControlsElement() {
        return this._ariaControls;
      }

      set ariaDescribedByElements(el) {
        if (Array.isArray(el)) {
          this._ariaDescribedBy = el;
        } else {
          this._ariaDescribedBy = [el];
        }

        this.synchronizeA11y();
      }

      get ariaDescribedByElements() {
        return this._ariaDescribedBy;
      }

      get ariaLabelledbyId() {
        return getRealDOMId(this._ariaLabelledBy);
      }

      get ariaControlsId() {
        return getRealDOMId(this.ariaControlsElement);
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELLEDBY]: this.ariaLabelledbyId,
          [ARIA_DESCRIBEDBY$1]: this.computedAriaDescribedby,
          [ARIA_CONTROLS]: this.ariaControlsId,
          [ARIA_LABEL]: this._ariaLabel
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          const normalizedDate = normalizeISODate(normalizedValue, this.dateFormat);
          this._value = normalizedDate.isoValue;
          this._displayValue = normalizedDate.displayValue;
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }

      focus() {
        if (this.connected) {
          this.inputElement.focus();
        }
      }

      blur() {
        if (this.connected) {
          this.inputElement.blur();
        }
      }

      showHelpMessage(message) {
        if (!message) {
          this.classList.remove('slds-has-error');
          this._errorMessage = '';
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = message;
        }
      }

      hasBadInput() {
        return !!this._displayValue && this._value === null;
      }

      get dateStyle() {
        return this._dateStyle;
      }

      set dateStyle(value) {
        this._dateStyle = normalizeString(value, {
          fallbackValue: DATE_STYLE.MEDIUM,
          validValues: [DATE_STYLE.SHORT, DATE_STYLE.MEDIUM, DATE_STYLE.LONG]
        });
        this.dateFormat = this.getDateFormatFromStyle(this._dateStyle);
        const normalizedDate = normalizeISODate(this._value, this.dateFormat);
        this._displayValue = normalizedDate.displayValue;
      }

      constructor() {
        super();
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._value = null;
        this._calendarVisible = false;
        this._displayValue = null;
        this._errorMessage = '';
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this.label = void 0;
        this.name = void 0;
        this.max = void 0;
        this.min = void 0;
        this.placeholder = void 0;
        this.autocomplete = void 0;
        this.messageWhenValueMissing = void 0;
        this._ariaLabelledBy = void 0;
        this._ariaControls = void 0;
        this._ariaDescribedBy = [];
        this.uniqueId = generateUniqueId();
      }

      connectedCallback() {
        this.connected = true;
        this.keyboardInterface = this.datepickerKeyboardInterface();
      }

      disconnectedCallback() {
        this._cancelBlur = false;
        this._hasFocus = false;
        this.connected = false;
      }

      get i18n() {
        return i18n$6;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedUniqueErrorMessageElementId() {
        const el = this.template.querySelector('[data-error-message]');
        return getRealDOMId(el);
      }

      get isCalendarVisible() {
        return this._calendarVisible;
      }

      get displayValue() {
        return this._displayValue;
      }

      get errorMessage() {
        return this._errorMessage;
      }

      get computedIconDisabledState() {
        return this.disabled || this.readOnly;
      }

      get computedAriaDescribedby() {
        const ariaValues = [];

        if (this.errorMessage) {
          ariaValues.push(this.computedUniqueErrorMessageElementId);
        }

        this._ariaDescribedBy.forEach(item => {
          const id = getRealDOMId(item);

          if (id) {
            ariaValues.push(id);
          }
        });

        return normalizeAriaAttribute(ariaValues);
      }

      handleInputChange(event) {
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.currentTarget.value;
        this._value = this.parseFormattedDate(this._displayValue);
        this.dispatchChangeEvent();
      }

      handleInput() {
        // keeping the display value in sync with the element's value
        this._displayValue = this.inputElement.value; // IE11 fires an input event along with the click event when the element has a placeholder.
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/101220/
        // remove this block when we stop support for IE11

        if (isIE11 && this.placeholder !== undefined) {
          return;
        } // Making sure that the focus remains on the input and we're not triggering leave


        this.hideCalendarAndFocusTrigger();
      }

      handleInputBlur() {
        if (this._value !== null) {
          const normalizedDate = normalizeISODate(this._value, this.dateFormat);
          this._displayValue = normalizedDate.displayValue;
        }

        this.handleBlur();
      }

      handleInputClick(event) {
        if (this.readOnly) {
          return;
        }

        this.calendarTrigger = event.target;
        this.showCalendar();
      }

      handleBlur() {
        if (this._cancelBlur) {
          return;
        }

        this.leave();
      }

      handleFocus() {
        if (this._hasFocus) {
          return;
        }

        this._hasFocus = true;
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleCalendarEnter(e) {
        this._focusingCalendar = false;
        this.handleFocus(e);
      }

      cancelBlur() {
        this._cancelBlur = true;
      }

      allowBlur() {
        this._cancelBlur = false;
      }

      leave() {
        if (this._focusingCalendar) {
          return;
        }

        this.hideCalendar();
        this.dispatchEvent(new CustomEvent('blur'));
        this._hasFocus = false;
      }

      handleDatePickerIconClick(event) {
        if (this.readOnly || this.disabled) {
          return;
        }

        this.calendarTrigger = event.target;
        this.showAndFocusCalendar();
      }

      handleInputKeydown(event) {
        this.cancelBlur();
        this.calendarTrigger = event.target;
        handleInputKeyDownBehaviour(event, this.keyboardInterface);
      }

      handleDatePickerIconKeyDown(event) {
        this.cancelBlur();
        this.calendarTrigger = event.target;
        handleKeyDownOnDatePickerIcon(event, this.keyboardInterface);
      }

      handleCalendarKeyDown(event) {
        this.cancelBlur();
        handleBasicKeyDownBehaviour(event, this.keyboardInterface);
      }

      handleDateSelect(event) {
        event.stopPropagation();
        this._value = event.detail.value;
        this._displayValue = normalizeISODate(this._value, this.dateFormat).displayValue;
        this.hideCalendarAndFocusTrigger();
        this.dispatchChangeEvent();
      }

      showAndFocusCalendar() {
        // do not fire blur while we're moving focus to the calendar
        this._focusingCalendar = true;
        this.showCalendar(); // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => {
          this.focusCalendar();
        });
      }

      hideCalendarAndFocusTrigger() {
        this.hideCalendar();

        if (this.calendarTrigger) {
          this.calendarTrigger.focus();
        }
      }

      focusCalendar() {
        const calendar = this.template.querySelector('lightning-calendar');

        if (calendar) {
          calendar.focus();
        }
      }

      startPositioning() {
        if (!this._relationship) {
          this._relationship = startPositioning(this, {
            target: () => this.template.querySelector('input'),
            element: () => this.template.querySelector('lightning-calendar').shadowRoot.querySelector('div'),
            align: {
              horizontal: Direction.Right,
              vertical: Direction.Top
            },
            targetAlign: {
              horizontal: Direction.Right,
              vertical: Direction.Bottom
            },
            autoFlip: true,
            // Auto flip direction if not have enough space
            leftAsBoundary: true // horizontal flip uses target left as boundary

          });
        } else {
          this._relationship.reposition();
        }
      }

      stopPositioning() {
        if (this._relationship) {
          stopPositioning(this._relationship);
          this._relationship = null;
        }
      }

      showCalendar() {
        if (!this.isCalendarVisible) {
          this.rootElement.classList.add('slds-is-open');
          this._calendarVisible = true;
        }
      }

      hideCalendar() {
        if (this.isCalendarVisible) {
          this.rootElement.classList.remove('slds-is-open');
          this.stopPositioning();
          this._calendarVisible = false;
        }
      }

      get rootElement() {
        return this.template.querySelector('div');
      }

      get inputElement() {
        return this.template.querySelector('input');
      }

      get dateFormat() {
        if (!this._dateFormat) {
          this._dateFormat = this.getDateFormatFromStyle();
        }

        return this._dateFormat;
      }

      set dateFormat(value) {
        this._dateFormat = value;
      }

      getDateFormatFromStyle(dateStyle) {
        let dateFormat;

        switch (dateStyle) {
          case DATE_STYLE.SHORT:
            dateFormat = shortDateFormat;
            break;

          case DATE_STYLE.LONG:
            dateFormat = longDateFormat;
            break;

          default:
            dateFormat = mediumDateFormat;
            break;
        }

        return dateFormat;
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      datepickerKeyboardInterface() {
        const that = this;
        return {
          showCalendar() {
            that.showAndFocusCalendar();
          },

          leave() {
            that.leave();
          },

          hideCalendar() {
            that.hideCalendarAndFocusTrigger();
          },

          isCalendarVisible() {
            return that.isCalendarVisible;
          }

        };
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return value;
      }

      parse(dateString) {
        // We cannot use parseDateTimeISO8601 here because that method does not have a strict flag. If the value is not an ISO string, that method will parse using the native Date()
        // Alternatively we could call isValidISODateTimeString and then parseDateTimeISO8601.
        return parseDateTime(dateString, STANDARD_DATE_FORMAT, true);
      }

      get allowedDateFormats() {
        // We should prioritize the long, because a long date matched with the medium format. An issue in aura?
        // Ex: September 8, 2017 when be parsed with the medium format, returns a valid iso date.
        return [longDateFormat, mediumDateFormat, shortDateFormat];
      }
      /**
       * Parses the input date and sets the dateFormat used to parse the displayValue
       * if it is a valid Date.
       *
       * @param {String} displayValue - The input date.
       * @return {null | string} - A normalized formatted date if displayValue is valid. null otherwise.
       */


      parseFormattedDate(displayValue) {
        const allowedFormats = this.allowedDateFormats;
        const n = allowedFormats.length;
        let i = 0,
            value = null;

        do {
          value = normalizeFormattedDate(displayValue, allowedFormats[i]);
          i++;
        } while (value === null && i < n);

        return value;
      }

      formatString(str) {
        const args = ArraySlice.call(arguments, 1);
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningDatePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningDatePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        max: {
          config: 0
        },
        min: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        ariaLabel: {
          config: 3
        },
        ariaLabelledByElement: {
          config: 3
        },
        ariaControlsElement: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        dateStyle: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "showHelpMessage", "hasBadInput"],
      track: {
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _value: 1,
        _calendarVisible: 1,
        _displayValue: 1,
        _errorMessage: 1,
        _fieldLevelHelp: 1,
        _variant: 1
      },
      fields: ["_ariaLabelledBy", "_ariaControls", "_ariaDescribedBy"]
    });

    var _lightningDatepicker = lwc.registerComponent(LightningDatePicker, {
      tmpl: _tmpl$c
    });

    function stylesheet$5(hostSelector, shadowSelector, nativeShadow) {
      return ".slds-inline-logo" + shadowSelector + " {height: 1rem;margin-top: 1rem;margin-bottom: 1rem;}\n";
    }
    var _implicitStylesheets$5 = [stylesheet$5];

    function tmpl$c($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.state.iconName,
          "size": $cmp.size,
          "variant": $cmp.variant,
          "src": $cmp.state.src
        },
        key: 0
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.alternativeText)]) : null];
    }

    var _tmpl$d = lwc.registerTemplate(tmpl$c);
    tmpl$c.stylesheets = [];
    tmpl$c.stylesheetTokens = {
      hostAttribute: "lightning-icon_icon-host",
      shadowAttribute: "lightning-icon_icon"
    };

    /**
     * Represents a visual element that provides context and enhances usability.
     */

    class LightningIcon extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {};
        this.alternativeText = void 0;
      }

      /**
       * A uri path to a custom svg sprite, including the name of the resouce,
       * for example: /assets/icons/standard-sprite/svg/test.svg#icon-heart
       * @type {string}
       */
      get src() {
        return this.privateSrc;
      }

      set src(value) {
        this.privateSrc = value; // if value is not present, then we set the state back
        // to the original iconName that was passed
        // this might happen if the user sets a custom icon, then
        // decides to revert back to SLDS by removing the src attribute

        if (!value) {
          this.state.iconName = this.iconName;
          this.classList.remove('slds-icon-standard-default');
        } // if isIE11 and the src is set
        // we'd like to show the 'standard:default' icon instead
        // for performance reasons.


        if (value && isIE11) {
          this.setDefault();
          return;
        }

        this.state.src = value;
      }
      /**
       * The Lightning Design System name of the icon.
       * Names are written in the format 'utility:down' where 'utility' is the category,
       * and 'down' is the specific icon to be displayed.
       * @type {string}
       * @required
       */


      get iconName() {
        return this.privateIconName;
      }

      set iconName(value) {
        this.privateIconName = value; // if src is set, we don't need to validate
        // iconName

        if (this.src) {
          return;
        }

        if (isValidName(value)) {
          const isAction = getCategory(value) === 'action'; // update classlist only if new iconName is different than state.iconName
          // otherwise classListMutation receives class:true and class: false and removes slds class

          if (value !== this.state.iconName) {
            classListMutation(this.classList, {
              'slds-icon_container_circle': isAction,
              [computeSldsClass(value)]: true,
              [computeSldsClass(this.state.iconName)]: false
            });
          }

          this.state.iconName = value;
        } else {
          console.warn(`<lightning-icon> Invalid icon name ${value}`); // eslint-disable-line no-console
          // Invalid icon names should render a blank icon. Remove any
          // classes that might have been previously added.

          classListMutation(this.classList, {
            'slds-icon_container_circle': false,
            [computeSldsClass(this.state.iconName)]: false
          });
          this.state.iconName = undefined;
        }
      }
      /**
       * The size of the icon. Options include xx-small, x-small, small, medium, or large.
       * The default is medium.
       * @type {string}
       * @default medium
       */


      get size() {
        return normalizeString(this.state.size, {
          fallbackValue: 'medium',
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      set size(value) {
        this.state.size = value;
      }
      /**
       * The variant changes the appearance of a utility icon.
       * Accepted variants include inverse, success, warning, and error.
       * Use the inverse variant to implement a white fill in utility icons on dark backgrounds.
       * @type {string}
       */


      get variant() {
        return normalizeVariant$1(this.state.variant, this.state.iconName);
      }

      set variant(value) {
        this.state.variant = value;
      }

      connectedCallback() {
        this.classList.add('slds-icon_container');
      }

      setDefault() {
        this.state.src = undefined;
        this.state.iconName = 'standard:default';
        this.classList.add('slds-icon-standard-default');
      }

    }

    lwc.registerDecorators(LightningIcon, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        src: {
          config: 3
        },
        iconName: {
          config: 3
        },
        size: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var _lightningIcon = lwc.registerComponent(LightningIcon, {
      tmpl: _tmpl$d
    });

    function normalizeVariant$1(variant, iconName) {
      // Unfortunately, the `bare` variant was implemented to do what the
      // `inverse` variant should have done. Keep this logic for as long as
      // we support the `bare` variant.
      if (variant === 'bare') {
        // TODO: Deprecation warning using strippable assertion
        variant = 'inverse';
      }

      if (getCategory(iconName) === 'utility') {
        return normalizeString(variant, {
          fallbackValue: '',
          validValues: ['error', 'inverse', 'warning', 'success']
        });
      }

      return 'inverse';
    }

    function tmpl$d($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        k: api_key,
        h: api_element,
        i: api_iterator,
        f: api_flatten
      } = $api;
      return api_flatten([$cmp.hasParts ? api_iterator($cmp.text, function (item) {
        return [item.part.highlight ? api_element("strong", {
          key: api_key(0, item.key)
        }, [api_dynamic(item.part.text)]) : null, !item.part.highlight ? api_dynamic(item.part.text) : null];
      }) : [], !$cmp.hasParts ? api_dynamic($cmp.text) : null]);
    }

    var _tmpl$e = lwc.registerTemplate(tmpl$d);
    tmpl$d.stylesheets = [];
    tmpl$d.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxFormattedText_baseComboboxFormattedText-host",
      shadowAttribute: "lightning-baseComboboxFormattedText_baseComboboxFormattedText"
    };

    class LightningBaseComboboxFormattedText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._text = '';
        this.hasParts = void 0;
      }

      get text() {
        return this._text;
      }

      set text(value) {
        this.hasParts = Array.isArray(value) && value.length > 0;

        if (this.hasParts) {
          // Generate keys for LWC DOM
          this._text = value.map((part, i) => ({
            part,
            key: i
          }));
        } else {
          this._text = value;
        }
      }

    }

    lwc.registerDecorators(LightningBaseComboboxFormattedText, {
      publicProps: {
        text: {
          config: 3
        }
      },
      track: {
        _text: 1,
        hasParts: 1
      }
    });

    var _lightningBaseComboboxFormattedText = lwc.registerComponent(LightningBaseComboboxFormattedText, {
      tmpl: _tmpl$e
    });

    function tmpl$e($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      return [api_element("span", {
        classMap: {
          "slds-media__figure": true
        },
        key: 1
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "size": $cmp.iconSize,
          "alternativeText": $cmp.item.iconAlternativeText,
          "iconName": $cmp.item.iconName
        },
        key: 0
      }, [])]), api_element("span", {
        classMap: {
          "slds-media__body": true
        },
        key: 8
      }, [api_element("span", {
        classMap: {
          "slds-listbox__option-text": true,
          "slds-listbox__option-text_entity": true
        },
        key: 4
      }, [!$cmp.textHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.text
        },
        key: 2
      }, [api_dynamic($cmp.item.text)]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "title": $cmp.text,
          "text": $cmp.item.text
        },
        key: 3
      }, []) : null]), $cmp.hasSubText ? api_element("span", {
        classMap: {
          "slds-listbox__option-meta": true,
          "slds-listbox__option-meta_entity": true
        },
        key: 7
      }, [!$cmp.subTextHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.subText
        },
        key: 5
      }, [api_dynamic($cmp.item.subText)]) : null, $cmp.subTextHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "title": $cmp.subText,
          "text": $cmp.item.subText
        },
        key: 6
      }, []) : null]) : null]), $cmp.item.rightIconName ? api_element("span", {
        classMap: {
          "slds-media__figure": true,
          "slds-media__figure_reverse": true
        },
        key: 10
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "size": $cmp.rightIconSize,
          "alternativeText": $cmp.item.rightIconAlternativeText,
          "iconName": $cmp.item.rightIconName
        },
        key: 9
      }, [])]) : null];
    }

    var card = lwc.registerTemplate(tmpl$e);
    tmpl$e.stylesheets = [];
    tmpl$e.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxItem_card-host",
      shadowAttribute: "lightning-baseComboboxItem_card"
    };

    function tmpl$f($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      return [api_element("span", {
        classMap: {
          "slds-media__figure": true,
          "slds-listbox__option-icon": true
        },
        key: 1
      }, [$cmp.item.iconName ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "alternativeText": $cmp.item.iconAlternativeText,
          "iconName": $cmp.item.iconName,
          "size": "x-small"
        },
        key: 0
      }, []) : null]), api_element("span", {
        classMap: {
          "slds-media__body": true
        },
        key: 4
      }, [!$cmp.textHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.text
        },
        key: 2
      }, [api_dynamic($cmp.item.text)]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "text": $cmp.item.text,
          "title": $cmp.text
        },
        key: 3
      }, []) : null])];
    }

    var inline = lwc.registerTemplate(tmpl$f);
    tmpl$f.stylesheets = [];
    tmpl$f.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxItem_inline-host",
      shadowAttribute: "lightning-baseComboboxItem_inline"
    };

    class LightningBaseComboboxItem extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.item = {};
      }

      connectedCallback() {
        // We want to make sure that the item has 'aria-selected' if it's selectable
        if (this.item.selectable) {
          this.setAttribute('aria-selected', 'false');
        }

        if (this.item.type === 'option-inline') {
          this.classList.add('slds-media_small', 'slds-listbox__option_plain');
        } else {
          this.classList.add('slds-listbox__option_entity');
        }
      }

      get textHasParts() {
        const text = this.item.text;
        return text && Array.isArray(text) && text.length > 0;
      }

      get subTextHasParts() {
        const subText = this.item.subText;
        return subText && Array.isArray(subText) && subText.length > 0;
      } // Return html based on the specified item type


      render() {
        if (this.item.type === 'option-card') {
          return card;
        }

        return inline;
      }

      highlight() {
        this.toggleHighlight(true);
      }

      removeHighlight() {
        this.toggleHighlight(false);
      }

      toggleHighlight(highlighted) {
        if (this.item.selectable) {
          this.setAttribute('aria-selected', highlighted ? 'true' : 'false');
          this.classList.toggle('slds-has-focus', highlighted);
        }
      } // Parts are needed for highlighting


      partsToText(parts) {
        if (parts && Array.isArray(parts) && parts.length > 0) {
          return parts.map(part => part.text).join('');
        }

        return parts;
      }

      get rightIconSize() {
        return this.item.rightIconSize || 'small';
      }

      get iconSize() {
        return this.item.iconSize || 'small';
      }

      get text() {
        return this.partsToText(this.item.text);
      }

      get subText() {
        return this.partsToText(this.item.subText);
      }

      get hasSubText() {
        const subText = this.item.subText;
        return subText && subText.length > 0;
      }

    }

    lwc.registerDecorators(LightningBaseComboboxItem, {
      publicProps: {
        item: {
          config: 0
        }
      },
      publicMethods: ["highlight", "removeHighlight"]
    });

    var _lightningBaseComboboxItem = lwc.registerComponent(LightningBaseComboboxItem, {
      tmpl: _tmpl$1
    });

    function tmpl$g($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        gid: api_scoped_id,
        b: api_bind,
        h: api_element,
        d: api_dynamic,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [api_element("div", {
        className: $cmp.computedDropdownTriggerClass,
        attrs: {
          "role": "combobox",
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-haspopup": "listbox"
        },
        key: 29,
        on: {
          "click": _m14 || ($ctx._m14 = api_bind($cmp.handleTriggerClick))
        }
      }, [api_element("div", {
        className: $cmp.computedFormElementClass,
        attrs: {
          "role": "none"
        },
        key: 12
      }, [$cmp.hasInputPill ? api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-combobox__input-entity-icon": true
        },
        props: {
          "iconName": $cmp.inputPill.iconName,
          "alternativeText": $cmp.inputPill.iconAlternativeText,
          "size": "x-small"
        },
        key: 0
      }, []) : null, api_element("input", {
        className: $cmp.computedInputClass,
        attrs: {
          "id": api_scoped_id("input"),
          "type": "text",
          "role": "textbox",
          "autocomplete": "off",
          "name": $cmp.name,
          "placeholder": $cmp.computedPlaceholder,
          "maxlength": $cmp.inputMaxlength,
          "aria-autocomplete": $cmp.computedAriaAutocomplete,
          "aria-label": $cmp.inputLabel
        },
        props: {
          "value": $cmp.computedInputValue,
          "disabled": $cmp.disabled,
          "readOnly": $cmp._inputReadOnly
        },
        key: 1,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleInputSelect)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleTextChange)),
          "input": _m3 || ($ctx._m3 = api_bind($cmp.handleInput)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeyDown)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur))
        }
      }, []), $cmp.hasInputPill ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 5
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true,
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        attrs: {
          "type": "button",
          "title": $cmp.i18n.pillCloseButtonAlternativeText
        },
        key: 4,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handlePillRemove))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:close",
          "variant": "bare",
          "svgClass": "slds-button__icon"
        },
        key: 2
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.i18n.pillCloseButtonAlternativeText)])])]) : null, !$cmp.hasInputPill ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 11
      }, [$cmp.showInputActivityIndicator ? api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_brand": true,
          "slds-spinner_x-small": true,
          "slds-input__spinner": true
        },
        attrs: {
          "role": "status"
        },
        key: 9
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.i18n.loadingText)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 7
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 8
      }, [])]) : null, $cmp.inputIconName ? api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "alternativeText": $cmp.inputIconAlternativeText,
          "iconName": $cmp.inputIconName,
          "size": $cmp.inputIconSize
        },
        key: 10
      }, []) : null]) : null]), api_element("div", {
        className: $cmp.computedDropdownClass,
        attrs: {
          "id": api_scoped_id("dropdown-element"),
          "data-dropdown-element": true,
          "role": "listbox"
        },
        key: 28,
        on: {
          "scroll": _m9 || ($ctx._m9 = api_bind($cmp.handleListboxScroll)),
          "mousedown": _m10 || ($ctx._m10 = api_bind($cmp.handleDropdownMouseDown)),
          "mouseup": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownMouseUp)),
          "mouseleave": _m12 || ($ctx._m12 = api_bind($cmp.handleDropdownMouseLeave)),
          "click": _m13 || ($ctx._m13 = api_bind($cmp.handleOptionClick))
        }
      }, $cmp._hasDropdownOpened ? api_flatten([api_iterator($cmp._items, function (item) {
        return [!item.items ? api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem, {
          classMap: {
            "slds-media": true,
            "slds-listbox__option": true,
            "slds-media_center": true
          },
          attrs: {
            "data-item-id": item.id,
            "data-value": item.value
          },
          props: {
            "role": "option",
            "item": item,
            "id": api_scoped_id(item.id)
          },
          key: api_key(13, item.value),
          on: {
            "mouseenter": _m7 || ($ctx._m7 = api_bind($cmp.handleOptionMouseEnter))
          }
        }, []) : null, item.items ? api_element("ul", {
          attrs: {
            "role": "group",
            "aria-label": item.label
          },
          key: api_key(19, item.label)
        }, api_flatten([item.label ? api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 16
        }, [api_element("div", {
          classMap: {
            "slds-media": true,
            "slds-listbox__option": true,
            "slds-listbox__option_plain": true,
            "slds-media_small": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 15
        }, [api_element("h3", {
          attrs: {
            "role": "presentation",
            "title": item.label
          },
          key: 14
        }, [api_dynamic(item.label)])])]) : null, api_iterator(item.items, function (groupItem) {
          return api_element("li", {
            classMap: {
              "slds-listbox__item": true
            },
            attrs: {
              "role": "presentation"
            },
            key: api_key(18, groupItem.value)
          }, [api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem, {
            classMap: {
              "slds-media": true,
              "slds-listbox__option": true,
              "slds-media_center": true
            },
            attrs: {
              "data-item-id": groupItem.id,
              "data-value": groupItem.value
            },
            props: {
              "role": "option",
              "item": groupItem,
              "id": api_scoped_id(groupItem.id)
            },
            key: 17,
            on: {
              "mouseenter": _m8 || ($ctx._m8 = api_bind($cmp.handleOptionMouseEnter))
            }
          }, [])]);
        })])) : null];
      }), $cmp.showDropdownActivityIndicator ? api_element("div", {
        classMap: {
          "slds-listbox__item": true
        },
        attrs: {
          "role": "presentation"
        },
        key: 25
      }, [api_element("div", {
        classMap: {
          "slds-align_absolute-center": true,
          "slds-p-top_medium": true
        },
        key: 24
      }, [api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_x-small": true,
          "slds-spinner_inline": true
        },
        attrs: {
          "role": "status"
        },
        key: 23
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 20
      }, [api_dynamic($cmp.i18n.loadingText)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 21
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 22
      }, [])])])]) : null, $cmp.showAttribution ? api_element("div", {
        classMap: {
          "slds-align_absolute-center": true
        },
        key: 27
      }, [api_element("img", {
        classMap: {
          "slds-inline-logo": true
        },
        attrs: {
          "src": $cmp.attributionLogoUrl,
          "alt": $cmp.attributionLogoAssistiveText,
          "title": $cmp.attributionLogoAssistiveText
        },
        key: 26
      }, [])]) : null]) : [])])];
    }

    var _tmpl$f = lwc.registerTemplate(tmpl$g);
    tmpl$g.stylesheets = [];

    if (_implicitStylesheets$5) {
      tmpl$g.stylesheets.push.apply(tmpl$g.stylesheets, _implicitStylesheets$5);
    }
    tmpl$g.stylesheetTokens = {
      hostAttribute: "lightning-baseCombobox_baseCombobox-host",
      shadowAttribute: "lightning-baseCombobox_baseCombobox"
    };

    var labelAriaSelectedOptions = 'Selected Options:';

    var labelDeselectOptionKeyboard = 'Press delete or backspace to remove';

    var labelLoadingText = 'Loading';

    var labelPillCloseButtonAlternativeText = 'Clear Selection';

    function preventDefaultAndStopPropagation$2(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function handleEnterKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (dropdownInterface.isDropdownVisible() && currentIndex >= 0) {
        dropdownInterface.selectByIndex(currentIndex);
      } else {
        dropdownInterface.openDropdownIfNotEmpty();
      }
    }

    function handlePageUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      const pageUpDownOptionSkipCount = 10;

      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          let highlightIndex = 0;

          if (event.key === 'PageUp') {
            highlightIndex = Math.max(currentIndex - pageUpDownOptionSkipCount, 0);
          } else {
            // Jump 10 options down
            highlightIndex = Math.min(currentIndex + pageUpDownOptionSkipCount, dropdownInterface.getTotalOptions() - 1);
          }

          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }

    function handleHomeOrEndKey({
      event,
      dropdownInterface
    }) {
      // If not a read-only input we want the default browser behaviour
      if (!dropdownInterface.isInputReadOnly()) {
        return;
      }

      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          const highlightIndex = event.key === 'Home' ? 0 : dropdownInterface.getTotalOptions() - 1;
          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }

    function handleUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      const isUpKey = event.key === 'Up' || event.key === 'ArrowUp';
      let nextIndex;

      if (currentIndex >= 0) {
        nextIndex = isUpKey ? currentIndex - 1 : currentIndex + 1;

        if (nextIndex >= dropdownInterface.getTotalOptions()) {
          nextIndex = 0;
        } else if (nextIndex < 0) {
          nextIndex = dropdownInterface.getTotalOptions() - 1;
        }
      } else {
        nextIndex = isUpKey ? dropdownInterface.getTotalOptions() - 1 : 0;
      }

      if (dropdownInterface.getTotalOptions() > 0) {
        // eslint-disable-next-line @lwc/lwc/no-async-operation
        requestAnimationFrame(() => {
          dropdownInterface.highlightOptionWithIndex(nextIndex);
        });
      }
    }

    function handleEscapeOrTabKey({
      event,
      dropdownInterface
    }) {
      if (dropdownInterface.isDropdownVisible()) {
        event.stopPropagation();
        dropdownInterface.closeDropdown();
      }
    }

    function handleTypedCharacters({
      event,
      currentIndex,
      dropdownInterface
    }) {
      if (event.key && event.key.length > 1) {
        // not a printable character
        return;
      }

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      if (dropdownInterface.isInputReadOnly()) {
        // The element should be read only, it's a work-around for IE11 as it will still make editable an input
        // that has focus and was dynamically changed to be readonly on focus change. Remove once we no longer
        // support IE11
        event.preventDefault(); // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => runActionOnBufferedTypedCharacters(event, dropdownInterface.highlightOptionWithText.bind(this, currentIndex || 0)));
      }
    }

    const eventKeyToHandlerMap = {
      Enter: handleEnterKey,
      PageUp: handlePageUpOrDownKey,
      PageDown: handlePageUpOrDownKey,
      Home: handleHomeOrEndKey,
      End: handleHomeOrEndKey,
      Down: handleUpOrDownKey,
      // IE11/Edge specific
      Up: handleUpOrDownKey,
      // IE11/Edge specific
      ArrowUp: handleUpOrDownKey,
      ArrowDown: handleUpOrDownKey,
      Esc: handleEscapeOrTabKey,
      // IE11/Edge specific
      Escape: handleEscapeOrTabKey,
      Tab: handleEscapeOrTabKey
    };
    function handleKeyDownOnInput({
      event,
      currentIndex,
      dropdownInterface
    }) {
      const parameters = {
        event,
        currentIndex,
        dropdownInterface
      };

      if (eventKeyToHandlerMap[event.key]) {
        eventKeyToHandlerMap[event.key](parameters);
      } else {
        handleTypedCharacters(parameters);
      }
    }

    class BaseComboboxEvents {
      constructor(baseCombobox) {
        this.dispatchEvent = baseCombobox.dispatchEvent.bind(baseCombobox);
      }

      dispatchPillRemove(pill) {
        this.dispatchEvent(new CustomEvent('pillremove', {
          detail: {
            item: pill
          }
        }));
      }

      dispatchEndReached() {
        this.dispatchEvent(new CustomEvent('endreached'));
      }

      dispatchFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      dispatchBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      dispatchTextInput(text) {
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            text
          }
        }));
      }

      dispatchTextChange(text) {
        this.dispatchEvent(new CustomEvent('textchange', {
          detail: {
            text
          }
        }));
      }

      dispatchSelect(value) {
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value
          }
        }));
      }

      dispatchDropdownOpen() {
        this.dispatchEvent(new CustomEvent('dropdownopen'));
      }

      dispatchDropdownOpenRequest() {
        this.dispatchEvent(new CustomEvent('dropdownopenrequest'));
      }

    }

    const i18n$7 = {
      ariaSelectedOptions: labelAriaSelectedOptions,
      deselectOptionKeyboard: labelDeselectOptionKeyboard,
      pillCloseButtonAlternativeText: labelPillCloseButtonAlternativeText,
      loadingText: labelLoadingText
    };
    const SMALL_MIN_HEIGHT = '2.25rem';
    const MEDIUM_MIN_HEIGHT = '6.75rem';
    const ARIA_CONTROLS$1 = 'aria-controls';
    const ARIA_LABELLEDBY$1 = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$2 = 'aria-describedby';
    const ARIA_LABEL$1 = 'aria-label';
    const ARIA_ACTIVEDESCENDANT = 'aria-activedescendant';

    class LightningBaseCombobox extends lwc.LightningElement {
      constructor() {
        super();
        this.inputText = '';
        this.inputIconName = 'utility:down';
        this.inputIconSize = 'x-small';
        this.inputIconAlternativeText = void 0;
        this.inputMaxlength = void 0;
        this.showInputActivityIndicator = false;
        this.dropdownAlignment = 'left';
        this.placeholder = 'Select an Item';
        this.inputLabel = void 0;
        this.name = void 0;
        this.inputPill = void 0;
        this.attributionLogoUrl = void 0;
        this.attributionLogoAssistiveText = void 0;
        this._showDropdownActivityIndicator = false;
        this._items = [];
        this._disabled = false;
        this._dropdownVisible = false;
        this._hasDropdownOpened = false;
        this._highlightedOptionElementId = null;
        this._variant = void 0;
        this._dropdownHeight = 'standard';
        this._readonly = false;
        this._logoLoaded = false;
        this._inputDescribedBy = [];
        this._inputAriaControls = void 0;
        this._activeElementDomId = void 0;
        this._events = new BaseComboboxEvents(this);
      }

      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready', {
          detail: {
            id: this.inputId,
            name: this.name
          }
        }));
        this.synchronizeA11y();
      }

      connectedCallback() {
        this.classList.add('slds-combobox_container');
        this._connected = true;
        this._keyboardInterface = this.dropdownKeyboardInterface();
      }

      disconnectedCallback() {
        this._connected = false;
        this._listBoxElementCache = undefined;
      }

      get inputControlsElement() {
        return this._inputAriaControls;
      }

      set inputControlsElement(el) {
        this._inputAriaControls = el;
        this.synchronizeA11y();
      }

      get inputDescribedByElements() {
        return this._inputDescribedBy;
      }

      set inputDescribedByElements(elements) {
        if (Array.isArray(elements)) {
          this._inputDescribedBy = elements;
        } else {
          this._inputDescribedBy = [elements];
        }

        this.synchronizeA11y();
      }

      get inputLabelledByElement() {
        return this._inputLabelledBy;
      }

      set inputLabelledByElement(el) {
        this._inputLabelledBy = el;
        this.synchronizeA11y();
      }

      get inputLabelledById() {
        return getRealDOMId(this._inputLabelledBy);
      }

      get inputAriaControlsId() {
        return getRealDOMId(this._inputAriaControls);
      }

      get inputId() {
        return getRealDOMId(this.template.querySelector('input'));
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        this._inputDescribedBy.forEach(el => {
          ariaValues.push(getRealDOMId(el));
        });

        return normalizeAriaAttribute(ariaValues);
      }

      get dropdownHeight() {
        return this._dropdownHeight;
      }

      set dropdownHeight(height) {
        this._dropdownHeight = normalizeString(height, {
          fallbackValue: 'standard',
          validValues: ['standard', 'small']
        });
      }

      get showDropdownActivityIndicator() {
        return this._showDropdownActivityIndicator;
      }

      set showDropdownActivityIndicator(value) {
        this._showDropdownActivityIndicator = normalizeBoolean(value);

        if (this._connected) {
          if (this._showDropdownActivityIndicator) {
            if (this._shouldOpenDropDown) {
              this.openDropdownIfNotEmpty();
            }
          } else if (this._dropdownVisible && this.isDropdownEmpty) {
            this.closeDropdown();
          }
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        if (this._disabled && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);

        if (this._readonly && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: VARIANT.STANDARD,
          validValues: [VARIANT.STANDARD, 'lookup']
        });
      }

      get items() {
        return this._unprocessedItems;
      }

      set items(items = []) {
        this._unprocessedItems = items;

        if (this._connected) {
          if (this._hasDropdownOpened) {
            // The dropdown has already been opened at least once, so process the items immediately
            this.updateItems(items);

            if (this._dropdownVisible) {
              // The dropdown is visible but there are no items to show, close it
              if (this.isDropdownEmpty) {
                this.closeDropdown();
              } else {
                // We have new items, update highlight
                this.highlightDefaultItem(); // Since the items have changed, the positioning should be recomputed
                // remove-next-line-for-c-namespace

                this.startDropdownAutoPositioning();
              }
            }
          }

          if (this._shouldOpenDropDown) {
            this.openDropdownIfNotEmpty();
          }
        }
      }

      highlightInputText() {
        if (this._connected) {
          // Safari has issues with invoking set selection range immediately in the 'focus' handler, instead
          // we'd be doing it in an animation frame. Remove the requestAnimationFrame once/if this is fixed
          // in Safari
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          requestAnimationFrame(() => {
            const {
              inputElement
            } = this;
            inputElement.setSelectionRange(0, inputElement.value.length);
          });
        }
      }

      get showAttribution() {
        return this.attributionLogoUrl;
      }

      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }

      focusAndOpenDropdownIfNotEmpty() {
        if (this._connected) {
          if (!this._inputHasFocus) {
            this.focus();
          }

          this.openDropdownIfNotEmpty();
        }
      }

      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELLEDBY$1]: this.inputLabelledById,
          [ARIA_DESCRIBEDBY$2]: this.computedAriaDescribedBy,
          [ARIA_ACTIVEDESCENDANT]: this._activeElementDomId,
          [ARIA_CONTROLS$1]: this.computedInputControls,
          [ARIA_LABEL$1]: this.inputLabel
        });
      }

      itemId(index) {
        return this.inputId + '-' + index;
      }

      itemIndexFromId(id) {
        // Extracts the index from an item id.
        return parseInt(id.substring(id.lastIndexOf('-') + 1), 10);
      }

      processItem(item) {
        const itemCopy = {}; // Supported item properties:
        // 'type' (string): option-inline, option-card
        // 'highlight' (boolean): Whether to highlight the item when dropdown opens
        // 'iconName': left icon name
        // 'iconSize': left icon size
        // 'iconAlternativeText': assistive text for the left icon
        // 'rightIconName': right icon name
        // 'rightIconSize': right icon size
        // 'rightIconAlternativeText': assistive text for the right icon
        // 'text': text to display
        // 'subText': sub-text to display (only option-card supports it)
        // 'value': value associated with the option

        itemCopy.type = item.type;
        itemCopy.iconName = item.iconName;
        itemCopy.iconSize = item.iconSize;
        itemCopy.iconAlternativeText = item.iconAlternativeText;
        itemCopy.rightIconName = item.rightIconName;
        itemCopy.rightIconSize = item.rightIconSize;
        itemCopy.rightIconAlternativeText = item.rightIconAlternativeText;
        itemCopy.text = item.text;
        itemCopy.subText = item.subText;
        itemCopy.value = item.value; // extra metadata needed

        itemCopy.selectable = ['option-card', 'option-inline'].indexOf(item.type) >= 0;

        if (itemCopy.selectable) {
          itemCopy.index = this._selectableItems;
          itemCopy.id = this.itemId(itemCopy.index);
          this._selectableItems += 1;

          if (item.highlight) {
            this._highlightedItemIndex = itemCopy.index;
          }
        }

        return itemCopy;
      }

      get _inputReadOnly() {
        return this._readonly || this.variant === VARIANT.STANDARD || this.hasInputPill;
      }

      get computedAriaAutocomplete() {
        if (this.hasInputPill) {
          // no aria-autocomplete when pill is showing
          return null;
        }

        return this._inputReadOnly ? 'none' : 'list';
      }

      get computedPlaceholder() {
        return this.hasInputPill ? this.inputPill.label : this.placeholder;
      }

      get computedInputValue() {
        return this.hasInputPill ? this.inputPill.label : this.inputText;
      }

      handleListboxScroll(event) {
        // We don't want this to bubble up to the modal which due to event retargeting wouldn't be able
        // to know what is actually being scrolled and thus may lead to the scrolling of the modal
        event.stopPropagation();
        const listbox = event.target;
        const height = listbox.getBoundingClientRect().height;
        const maxScroll = listbox.scrollHeight - height; // Account for variation between browsers when it comes to calculation of margins/padding

        const buffer = 20;
        const bottomReached = listbox.scrollTop + buffer >= maxScroll;

        if (bottomReached) {
          this._events.dispatchEndReached();
        }
      }

      get listboxElement() {
        if (!this._listBoxElementCache) {
          this._listBoxElementCache = this.template.querySelector('[role="listbox"]');
        }

        return this._listBoxElementCache;
      }

      get computedUniqueElementId() {
        return this.inputId;
      }

      get computedUniqueDropdownElementId() {
        return getRealDOMId(this.template.querySelector('[data-dropdown-element]'));
      }

      get computedInputControls() {
        const ariaValues = [this.computedUniqueDropdownElementId];

        if (this.inputControlsElement) {
          ariaValues.push(this.inputAriaControlsId);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get i18n() {
        return i18n$7;
      }

      get computedDropdownTriggerClass() {
        return classSet('slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click').add({
          'slds-is-open': this._dropdownVisible
        }).toString();
      }

      get computedDropdownClass() {
        const alignment = this.dropdownAlignment;
        return classSet('slds-listbox slds-listbox_vertical slds-dropdown slds-dropdown_fluid').add({
          'slds-dropdown_length-with-icon-10': this._dropdownHeight === 'standard',
          'slds-dropdown_length-with-icon-5': this._dropdownHeight === 'small',
          'slds-dropdown_left': alignment === 'left' || alignment === 'auto',
          'slds-dropdown_center': alignment === 'center',
          'slds-dropdown_right': alignment === 'right',
          'slds-dropdown_bottom': alignment === 'bottom-center',
          'slds-dropdown_bottom slds-dropdown_right slds-dropdown_bottom-right': alignment === 'bottom-right',
          'slds-dropdown_bottom slds-dropdown_left slds-dropdown_bottom-left': alignment === 'bottom-left'
        }).toString();
      }

      get computedInputClass() {
        const classes = classSet('slds-input slds-combobox__input');

        if (this.hasInputPill) {
          classes.add('slds-combobox__input-value');
        } else {
          classes.add({
            'slds-input-has-icon_group-right': this.showInputActivityIndicator
          });
        }

        return classes.toString();
      }

      get _shouldOpenDropDown() {
        // If items were empty and through a user interaction the dropdown should have opened, and if the
        // component still has the focus we'll open it on items update instead.
        return !this.dropdownDisabled && this._inputHasFocus && this._requestedDropdownOpen;
      }

      get dropdownDisabled() {
        return this.readOnly || this.disabled;
      }

      handleOptionClick(event) {
        if (event.target.hasAttribute('aria-selected')) {
          event.stopPropagation();
          event.preventDefault();
          this.selectOptionAndCloseDropdown(event.target);
        }
      }

      handleOptionMouseEnter(event) {
        if (event.target.hasAttribute('aria-selected')) {
          this.highlightOption(event.target);
        }
      }

      handleDropdownMouseLeave() {
        this.removeHighlight(); // This is to account for when a user makes a mousedown press on the dropdown and then leaves the dropdown
        // area, it would leave the dropdown open even though the focus would no longer be on the input

        if (!this._inputHasFocus) {
          this.closeDropdown();
        }
      }

      handleTriggerClick(event) {
        event.stopPropagation();
        this.allowBlur();

        if (this.dropdownDisabled) {
          return;
        }

        if (!this.hasInputPill) {
          // toggle dropdown only for readonly combobox, only open the dropdown otherwise
          // if it's not already opened.
          if (this._inputReadOnly) {
            if (this._dropdownVisible) {
              this.closeDropdown();
            } else {
              this.openDropdownIfNotEmpty();
            }
          } else {
            this.openDropdownIfNotEmpty();
          }

          this.inputElement.focus();
        }
      }

      handlePillKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        } // 'Del' is IE11 specific, remove once IE11 is no longer supported


        if (event.key === 'Delete' || event.key === 'Del') {
          this.handlePillRemove();
        }
      }

      handleInputKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        }

        if (this.hasInputPill) {
          this.handlePillKeyDown(event);
        } else {
          handleKeyDownOnInput({
            event,
            currentIndex: this.getCurrentHighlightedOptionIndex(),
            dropdownInterface: this._keyboardInterface
          });
        }
      }

      handleTextChange() {
        this._events.dispatchTextChange(this.inputElement.value);
      }

      handleFocus() {
        this._inputHasFocus = true;

        this._events.dispatchFocus();
      }

      handleInput() {
        // Do not dispatch any events if the pill is showing, this is specifically an IE11 problem,
        // which fires an 'input' event when the placeholder on an input is changed (which is what happens when
        // the pill is shown). The check can be removed when IE11 is no longer supported.
        if (!this.hasInputPill) {
          this._events.dispatchTextInput(this.inputElement.value);
        }
      }

      handleBlur() {
        this._inputHasFocus = false;

        if (this._cancelBlur) {
          return;
        }

        this.closeDropdown();

        this._events.dispatchBlur();
      }

      handleDropdownMouseDown(event) {
        const mainButton = 0;

        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }

      handleDropdownMouseUp() {
        // We need this to make sure that if a scrollbar is being dragged with the mouse, upon release
        // of the drag we allow blur, otherwise the dropdown would not close on blur since we'd have cancel blur
        // set
        this.allowBlur();
      }

      highlightOption(option) {
        this.removeHighlight();

        if (option) {
          option.highlight();
          this._highlightedOptionElement = option;
          this._highlightedOptionElementId = option.getAttribute('data-item-id'); // active element is a component id getter works properly

          this._activeElementDomId = option.id;
        }

        this.synchronizeA11y();
      }

      highlightOptionAndScrollIntoView(optionElement) {
        if (this._selectableItems.length === 0 || !optionElement) {
          return;
        }

        this.highlightOption(optionElement);
        scrollIntoViewIfNeeded(optionElement, this.listboxElement);
      }

      removeHighlight() {
        const option = this._highlightedOptionElement;

        if (option) {
          option.removeHighlight();
          this._highlightedOptionElement = null;
          this._highlightedOptionElementId = null;
          this._activeElementDomId = null;
        }
      }

      selectOptionAndCloseDropdown(optionElement) {
        this.closeDropdown();
        this.inputElement.focus();
        const value = optionElement.getAttribute('data-value');

        this._events.dispatchSelect(value);
      }

      handleInputSelect(event) {
        event.stopPropagation();
      }

      openDropdownIfNotEmpty() {
        if (this._dropdownVisible) {
          // Already visible
          return;
        }

        const noOptions = !Array.isArray(this.items) || this.items.length === 0; // Do not dispatch the open request event if there already was a request to open

        if (noOptions && !this._requestedDropdownOpen) {
          // Dispatch dropdown open request
          this._events.dispatchDropdownOpenRequest();
        } // Do not open if there's nothing to show in the dropdown (eg. no options and no dropdown activity indicator)


        if (this.isDropdownEmpty) {
          // We use this attribute to flag whether an attempt has been made via user-interaction
          // to open the dropdown
          this._requestedDropdownOpen = true;
          return;
        }

        if (!this._hasDropdownOpened) {
          if (this._unprocessedItems) {
            this.updateItems(this._unprocessedItems);
          }

          this._hasDropdownOpened = true;
        }

        this._requestedDropdownOpen = false;
        this._dropdownVisible = true; // remove-next-line-for-c-namespace

        this.startDropdownAutoPositioning();
        this.highlightDefaultItem();

        this._events.dispatchDropdownOpen();
      }

      closeDropdown() {
        if (!this._dropdownVisible) {
          // Already closed
          return;
        } // remove-next-line-for-c-namespace


        this.stopDropdownPositioning();
        this.removeHighlight();
        this._dropdownVisible = false;
      }

      findOptionElementByIndex(index) {
        return this.template.querySelector(`[data-item-id="${this.itemId(index)}"]`);
      }

      allowBlur() {
        this._cancelBlur = false;
      }

      cancelBlur() {
        this._cancelBlur = true;
      }

      getCurrentHighlightedOptionIndex() {
        if (this._highlightedOptionElementId && this._highlightedOptionElementId.length > 0) {
          return this.itemIndexFromId(this._highlightedOptionElementId);
        }

        return -1;
      }

      get inputElement() {
        return this.template.querySelector('input');
      } // remove-next-line-for-c-namespace


      startDropdownAutoPositioning() {
        if (this.dropdownAlignment !== 'auto') {
          return;
        }

        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this);
        }

        this._autoPosition.start({
          target: () => this.template.querySelector('input'),
          element: () => this.template.querySelector('div.slds-dropdown'),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Bottom
          },
          autoFlip: true,
          alignWidth: true,
          autoShrinkHeight: true,
          minHeight: this.isDropdownHeightSmall ? SMALL_MIN_HEIGHT : MEDIUM_MIN_HEIGHT
        });
      } // remove-next-line-for-c-namespace


      stopDropdownPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      get hasInputPill() {
        return this.inputPill && Object.keys(this.inputPill).length > 0;
      }

      handlePillRemove() {
        this.inputElement.focus();

        this._events.dispatchPillRemove(this.inputPill);
      }

      get computedFormElementClass() {
        const hasIcon = this.hasInputPill && this.inputPill.iconName;
        return classSet('slds-combobox__form-element slds-input-has-icon').add({
          'slds-input-has-icon_right': !hasIcon,
          'slds-input-has-icon_left-right': hasIcon
        }).toString();
      }

      get computedAriaExpanded() {
        return this._dropdownVisible ? 'true' : 'false';
      }

      updateItems(items) {
        if (!items) {
          return;
        }

        assert(Array.isArray(items), '"items" must be an array');
        this._selectableItems = 0;
        this._highlightedItemIndex = 0;
        this._items = items.map(item => {
          if (item.items) {
            // This is a group
            const groupCopy = {
              label: item.label
            };
            groupCopy.items = item.items.map(groupItem => {
              return this.processItem(groupItem);
            });
            return groupCopy;
          }

          return this.processItem(item);
        });
      }

      highlightDefaultItem() {
        this.removeHighlight(); // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(() => {
          this.highlightOptionAndScrollIntoView(this.findOptionElementByIndex(this._highlightedItemIndex));
        });
      }

      get isDropdownEmpty() {
        // If the activity indicator is showing then it's not empty
        return !this.showDropdownActivityIndicator && (!Array.isArray(this.items) || this.items.length === 0);
      }

      get isDropdownHeightSmall() {
        if (this.isDropdownEmpty) {
          return true;
        } // Check how many items could be present in dropdown.
        // >= 3, will be have MEDIUM_MIN_HEIGHT
        // < 3, will be have SMALL_MIN_HEIGHT


        let count = this._items ? this._items.length : 0;

        if (count === 1) {
          count += this._items[0].items ? this._items[0].items.length : 0;
        } else if (count === 2) {
          count += this._items[0].items ? this._items[0].items.length : 0;
          count += this._items[1].items ? this._items[1].items.length : 0;
        }

        return count < 3;
      }

      dropdownKeyboardInterface() {
        const that = this;
        return {
          getTotalOptions() {
            return that._selectableItems;
          },

          selectByIndex(index) {
            that.selectOptionAndCloseDropdown(that.findOptionElementByIndex(index));
          },

          highlightOptionWithIndex(index) {
            that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
          },

          isInputReadOnly() {
            return that._inputReadOnly;
          },

          highlightOptionWithText(currentIndex, text) {
            // This only supports a flat structure, groups are not supported
            for (let index = currentIndex + 1; index < that._items.length; index++) {
              const option = that._items[index];

              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }

            for (let index = 0; index < currentIndex; index++) {
              const option = that._items[index];

              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }
          },

          isDropdownVisible() {
            return that._dropdownVisible;
          },

          openDropdownIfNotEmpty() {
            that.openDropdownIfNotEmpty();
          },

          closeDropdown() {
            that.closeDropdown();
          }

        };
      }

    }

    LightningBaseCombobox.delegatesFocus = true;

    lwc.registerDecorators(LightningBaseCombobox, {
      publicProps: {
        inputText: {
          config: 0
        },
        inputIconName: {
          config: 0
        },
        inputIconSize: {
          config: 0
        },
        inputIconAlternativeText: {
          config: 0
        },
        inputMaxlength: {
          config: 0
        },
        showInputActivityIndicator: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        inputLabel: {
          config: 0
        },
        name: {
          config: 0
        },
        inputPill: {
          config: 0
        },
        attributionLogoUrl: {
          config: 0
        },
        attributionLogoAssistiveText: {
          config: 0
        },
        inputControlsElement: {
          config: 3
        },
        inputDescribedByElements: {
          config: 3
        },
        inputLabelledByElement: {
          config: 3
        },
        dropdownHeight: {
          config: 3
        },
        showDropdownActivityIndicator: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        variant: {
          config: 3
        },
        items: {
          config: 3
        }
      },
      publicMethods: ["highlightInputText", "focus", "focusAndOpenDropdownIfNotEmpty", "blur"],
      track: {
        _showDropdownActivityIndicator: 1,
        _items: 1,
        _disabled: 1,
        _dropdownVisible: 1,
        _hasDropdownOpened: 1,
        _highlightedOptionElementId: 1,
        _variant: 1,
        _dropdownHeight: 1,
        _readonly: 1,
        _logoLoaded: 1
      },
      fields: ["_inputDescribedBy", "_inputAriaControls", "_activeElementDomId"]
    });

    var _lightningBaseCombobox = lwc.registerComponent(LightningBaseCombobox, {
      tmpl: _tmpl$f
    });

    function scrollIntoViewIfNeeded(element, scrollingParent) {
      const parentRect = scrollingParent.getBoundingClientRect();
      const findMeRect = element.getBoundingClientRect();

      if (findMeRect.top < parentRect.top) {
        if (element.offsetTop + findMeRect.height < parentRect.height) {
          // If element fits by scrolling to the top, then do that
          scrollingParent.scrollTop = 0;
        } else {
          // Otherwise, top align the element
          scrollingParent.scrollTop = element.offsetTop;
        }
      } else if (findMeRect.bottom > parentRect.bottom) {
        // bottom align the element
        scrollingParent.scrollTop += findMeRect.bottom - parentRect.bottom;
      }
    }

    function tmpl$h($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 4
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        props: {
          "dropdownHeight": "small",
          "name": $cmp.name,
          "variant": "lookup",
          "placeholder": $cmp.placeholder,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "items": $cmp.items,
          "inputText": $cmp.displayValue,
          "inputIconName": "utility:clock",
          "inputLabel": $cmp.ariaLabel,
          "inputControlsElement": $cmp.ariaControlsElement,
          "inputLabelledByElement": $cmp.ariaLabelledByElement,
          "dropdownAlignment": "auto"
        },
        key: 3,
        on: {
          "ready": _m0 || ($ctx._m0 = api_bind($cmp.handleReady)),
          "textchange": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
          "textinput": _m2 || ($ctx._m2 = api_bind($cmp.handleTextInput)),
          "dropdownopenrequest": _m3 || ($ctx._m3 = api_bind($cmp.handleDropdownOpenRequest)),
          "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
          "select": _m6 || ($ctx._m6 = api_bind($cmp.handleTimeSelect))
        }
      }, [])]), $cmp._errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true,
          "aria-live": "assertive"
        },
        key: 5
      }, [api_dynamic($cmp._errorMessage)]) : null];
    }

    var _tmpl$g = lwc.registerTemplate(tmpl$h);
    tmpl$h.stylesheets = [];
    tmpl$h.stylesheetTokens = {
      hostAttribute: "lightning-timepicker_timepicker-host",
      shadowAttribute: "lightning-timepicker_timepicker"
    };

    var shortTimeFormat = 'h:mm a';

    /* returns the closes time in the list that should be highlighted in case the value is not in the list. E.g.
    - if value is 16:18 and the list has 15 minute intervals, returns 16:30
    */

    function getTimeToHighlight(value, step) {
      const selectedTime = parseTime(value);

      if (!selectedTime) {
        return null;
      }

      selectedTime.setSeconds(0, 0);
      let closestHour = selectedTime.getHours();
      let closestMinute = selectedTime.getMinutes();
      const mod = closestMinute % step;
      const quotient = Math.floor(closestMinute / step);

      if (mod !== 0) {
        const multiplier = mod < step / 2 ? quotient : quotient + 1;
        closestMinute = multiplier * step;

        if (closestMinute >= 60) {
          if (closestHour === 23) {
            closestMinute -= step;
          } else {
            closestMinute = 0;
            closestHour++;
          }
        }

        selectedTime.setHours(closestHour);
        selectedTime.setMinutes(closestMinute);
      }

      return getISOTimeString(selectedTime);
    }

    const i18n$8 = {
      invalidDate: labelInvalidDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired
    };
    const STEP = 15; // in minutes

    const TIME_STYLE = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };

    class LightningTimePicker extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._disabled = false;
        this._required = false;
        this._displayValue = null;
        this._value = null;
        this._min = void 0;
        this._max = void 0;
        this._items = [];
        this._fieldLevelHelp = void 0;
        this._variant = 'lookup';
        this._mainInputId = void 0;
        this._errorMessage = void 0;
        this._readonly = true;
        this._describedByElements = [];
        this.label = void 0;
        this.name = void 0;
        this.placeholder = '';
        this.ariaLabelledByElement = void 0;
        this.ariaControlsElement = void 0;
        this.ariaLabel = void 0;
        this.messageWhenValueMissing = void 0;
        this._ariaDescribedByElements = void 0;
      }

      get messageWhenBadInput() {
        return this._messageWhenBadInput || this.formatString(i18n$8.invalidDate, this.timeFormat);
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        // using isoValue since the manually entered time could have seconds/milliseconds and the locale format generally doesn't have this precision
        return this._messageWhenRangeOverflow || this.formatString(i18n$8.rangeOverflow, normalizeISOTime(this.max, this.timeFormat).isoValue);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(i18n$8.rangeUnderflow, normalizeISOTime(this.min, this.timeFormat).isoValue);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }

      set ariaDescribedByElements(el) {
        if (Array.isArray(el)) {
          this._ariaDescribedByElements = el;
        } else {
          this.ariaDescribedByElements = [el];
        }
      }

      get ariaDescribedByElements() {
        return this._ariaDescribedByElements;
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          const normalizedTime = normalizeISOTime(normalizedValue, this.timeFormat);
          this._value = normalizedTime.isoValue;
          this._displayValue = normalizedTime.displayValue;
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);

        if (this._readonly) {
          this._variant = VARIANT.STANDARD;
        }
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      hasBadInput() {
        return !!this._displayValue && this._value === null;
      }

      showHelpMessage(message) {
        if (!message) {
          this.classList.remove('slds-has-error');
          this._errorMessage = '';
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = message;
        }
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }

      get max() {
        return this._max;
      }

      set max(newValue) {
        this._max = newValue;

        if (this.connected) {
          this.rebuildAndUpdateTimeList();
        }
      }

      get min() {
        return this._min;
      }

      set min(newValue) {
        this._min = newValue;

        if (this.connected) {
          this.rebuildAndUpdateTimeList();
        }
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this.connected) {
          this.getCombobox().focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this.connected) {
          this.getCombobox().blur();
        }
      }

      get timeStyle() {
        return this._timeStyle;
      }

      set timeStyle(value) {
        this._timeStyle = normalizeString(value, {
          fallbackValue: TIME_STYLE.SHORT,
          validValues: [TIME_STYLE.SHORT, TIME_STYLE.MEDIUM, TIME_STYLE.LONG]
        });
        this.timeFormat = this.getTimeFormatFromStyle(this._timeStyle);
        const normalizedDate = normalizeISOTime(this._value, this.timeFormat);
        this._displayValue = normalizedDate.displayValue;
      }

      connectedCallback() {
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      synchronizeA11y() {
        const label = this.template.querySelector('label');
        const comboBox = this.template.querySelector('lightning-base-combobox');
        let describedByElements = [];

        if (this._ariaDescribedByElements) {
          describedByElements = describedByElements.concat(this._ariaDescribedByElements);
        }

        const errorMessage = this.template.querySelector('[data-error-message]');

        if (errorMessage) {
          describedByElements.push(errorMessage);
        }

        comboBox.inputDescribedByElements = describedByElements;
        synchronizeAttrs(label, {
          for: this._mainInputId
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      get displayValue() {
        return this._displayValue;
      }

      get items() {
        return this._items;
      }

      get i18n() {
        return i18n$8;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleReady(e) {
        this._mainInputId = e.detail.id;
      }

      buildTimeList() {
        // We should always display the options in the short style since m/l will add an extra :00 to the options.
        const optionsTimeFormat = shortTimeFormat;
        const timeList = [];
        const minTime = parseTime(this.normalizeInputValue(this.min));
        const minHour = minTime ? minTime.getHours() : 0;
        const maxTime = parseTime(this.normalizeInputValue(this.max));
        const maxHour = maxTime ? maxTime.getHours() + 1 : 24;
        const date = new Date();

        for (let hour = minHour; hour < maxHour; hour++) {
          for (let minutes = 0; minutes < 60; minutes += STEP) {
            date.setHours(hour, minutes);
            date.setSeconds(0, 0);

            if (this.isBeforeMinTime(date, minTime)) {
              continue; // eslint-disable-line no-continue
            }

            if (this.isAfterMaxTime(date, maxTime)) {
              break;
            } // @todo: should we always display it short in the combobox given that it makes no sense?


            timeList.push({
              type: 'option-inline',
              text: this.format(date, optionsTimeFormat),
              value: this.format(date)
            });
          }
        }

        return timeList;
      }

      get timeList() {
        if (!this._timeList) {
          this._timeList = this.buildTimeList();
        }

        if (!this._value) {
          return this._timeList;
        }

        const timeToHighlight = getTimeToHighlight(this._value, STEP);

        const timeList = this._timeList.map(item => {
          const itemCopy = Object.assign({}, item);

          if (item.value === this._value) {
            itemCopy.iconName = 'utility:check';
          }

          if (item.value === timeToHighlight) {
            itemCopy.highlight = true;
          }

          return itemCopy;
        });

        return timeList;
      }

      rebuildAndUpdateTimeList() {
        // forcing the time list to be rebuilt
        this._timeList = null;
        this._items = this.timeList;
      }

      get timeFormat() {
        if (!this._timeFormat) {
          this._timeFormat = this.getTimeFormatFromStyle();
        }

        return this._timeFormat;
      }

      set timeFormat(value) {
        this._timeFormat = value;
      }

      getCombobox() {
        return this.template.querySelector('lightning-base-combobox');
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleInputChange(event) {
        event.preventDefault();
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.detail.text;
        this._value = this.parseFormattedTime(this._displayValue);
        this._items = this.timeList;
        this.dispatchChangeEvent();
      }

      handleTextInput(event) {
        event.preventDefault();
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.detail.text;
      }

      handleTimeSelect(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from grouped-combobox

        if (!event.detail) {
          return;
        }

        this._value = event.detail.value;
        this._displayValue = normalizeISOTime(this._value, this.timeFormat).displayValue;
        this._items = this.timeList;
        this.dispatchChangeEvent();
      }

      handleDropdownOpenRequest() {
        this._items = this.timeList;
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return removeTimeZoneSuffix(value);
      }

      format(date, formatString) {
        if (formatString) {
          return formatTime(date, formatString);
        }

        return getISOTimeString(date);
      }

      isBeforeMinTime(date, minTime) {
        const minDate = minTime || parseTime(this.normalizeInputValue(this.min));
        return minDate ? isBefore(date, minDate, 'minute') : false;
      }

      isAfterMaxTime(date, maxTime) {
        const maxDate = maxTime || parseTime(this.normalizeInputValue(this.max));
        return maxDate ? isAfter(date, maxDate, 'minute') : false;
      }

      getTimeFormatFromStyle(timeStyle) {
        let timeFormat;

        switch (timeStyle) {
          case TIME_STYLE.MEDIUM:
          case TIME_STYLE.LONG:
            timeFormat = mediumTimeFormat;
            break;

          default:
            timeFormat = shortTimeFormat;
            break;
        }

        return timeFormat;
      }

      get allowedTimeFormats() {
        // the locale.timeFormat is the medium format. Locale dont supports a large
        // time format at the moment.
        return [mediumTimeFormat, shortTimeFormat];
      }
      /**
       * Parses the input time and sets the timeFormat used to parse the displayValue
       * if it is a valid time.
       *
       * @param {String} displayValue - The input date.
       * @return {null | string} - A normalized formatted time if displayValue is valid. null otherwise.
       */


      parseFormattedTime(displayValue) {
        const allowedFormats = this.allowedTimeFormats;
        const n = allowedFormats.length;
        let i = 0,
            value = null;

        do {
          value = normalizeFormattedTime(displayValue, allowedFormats[i]);
          i++;
        } while (value === null && i < n);

        if (value !== null) {
          this.timeFormat = allowedFormats[i - 1];
        }

        return value;
      }

      formatString(str) {
        const args = ArraySlice.call(arguments, 1);
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningTimePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningTimePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        ariaLabelledByElement: {
          config: 0
        },
        ariaControlsElement: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        timeStyle: {
          config: 3
        }
      },
      publicMethods: ["hasBadInput", "showHelpMessage", "focus", "blur"],
      track: {
        _disabled: 1,
        _required: 1,
        _displayValue: 1,
        _value: 1,
        _min: 1,
        _max: 1,
        _items: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _mainInputId: 1,
        _errorMessage: 1,
        _readonly: 1,
        _describedByElements: 1
      },
      fields: ["_ariaDescribedByElements"]
    });

    var _lightningTimepicker = lwc.registerComponent(LightningTimePicker, {
      tmpl: _tmpl$g
    });

    function tmpl$i($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-form": true,
          "slds-form_compound": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 10
      }, [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 9
      }, [api_element("legend", {
        className: $cmp.computedLabelClass,
        key: 1
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 2
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-form-element__row": true
        },
        key: 5
      }, [api_custom_element("lightning-datepicker", _lightningDatepicker, {
        classMap: {
          "slds-form-element": true
        },
        props: {
          "value": $cmp.dateValue,
          "min": $cmp.dateMin,
          "max": $cmp.dateMax,
          "label": $cmp.i18n.date,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled,
          "autocomplete": $cmp.autocomplete,
          "dateStyle": $cmp.dateStyle
        },
        key: 3,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleDatepickerFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleDatepickerBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleDateChange))
        }
      }, []), api_custom_element("lightning-timepicker", _lightningTimepicker, {
        classMap: {
          "slds-form-element": true
        },
        props: {
          "value": $cmp.timeValue,
          "label": $cmp.i18n.time,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 4,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleTimepickerFocus)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleTimepickerBlur)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleTimeChange))
        }
      }, [])])])]), $cmp.customErrorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "data-error-message": true,
          "id": api_scoped_id("errormessage"),
          "aria-live": "assertive"
        },
        key: 8
      }, [api_dynamic($cmp.customErrorMessage)]) : null])])];
    }

    var _tmpl$h = lwc.registerTemplate(tmpl$i);
    tmpl$i.stylesheets = [];
    tmpl$i.stylesheetTokens = {
      hostAttribute: "lightning-datetimepicker_datetimepicker-host",
      shadowAttribute: "lightning-datetimepicker_datetimepicker"
    };

    var labelDate = 'Date';

    var labelTime = 'Time';

    const i18n$9 = {
      date: labelDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired,
      time: labelTime
    };

    class LightningDateTimePicker extends lwc.LightningElement {
      // getters and setters necessary to trigger sync
      set timeAriaControls(val) {
        this._timeAriaControls = val;
        this.synchronizeA11y();
      }

      get timeAriaControls() {
        return this._timeAriaControls;
      }

      set timeAriaLabelledBy(val) {
        this._timeAriaLabelledBy = val;
        this.synchronizeA11y();
      }

      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }

      set timeAriaDescribedBy(val) {
        this._timeAriaDescribedBy = val;
        this.synchronizeA11y();
      }

      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }

      get messageWhenBadInput() {
        if (this._messageWhenBadInput) {
          return this._messageWhenBadInput;
        } else if (this.hasBadDateInput) {
          return this.getDatepicker().messageWhenBadInput;
        } else if (this.hasBadTimeInput) {
          return this.getTimepicker().messageWhenBadInput;
        }

        return null;
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this.formatString(i18n$9.rangeOverflow, this.formattedMax);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(i18n$9.rangeUnderflow, this.formattedMin);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }

      get max() {
        return this.maxValue;
      }

      set max(newValue) {
        this.maxValue = newValue;
        this.calculateFormattedMaxValue();
      }

      get min() {
        return this.minValue;
      }

      set min(newValue) {
        this.minValue = newValue;
        this.calculateFormattedMinValue();
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          if (!this.connected) {
            // we set the values in connectedCallback to make sure timezone is available.
            this._initialValue = normalizedValue;
            return;
          }

          this.setDateAndTimeValues(normalizedValue);
        }
      }

      get timezone() {
        return this._timezone;
      }

      set timezone(newValue) {
        this._timezone = newValue;

        if (this.connected) {
          this.updateValuesForTimezone();
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);
      }
      /**
       * Sets focus on the date input element.
       */


      focus() {
        if (this.connected) {
          this.getDatepicker().focus();
        }
      }
      /**
       * Removes keyboard focus from the input elements.
       */


      blur() {
        if (this.connected) {
          this.getDatepicker().blur();
          this.getTimepicker().blur();
        }
      }

      hasBadInput() {
        return this.connected && (this.hasBadDateInput || this.hasBadTimeInput);
      }

      get hasBadDateInput() {
        return this.getDatepicker().hasBadInput();
      }

      get hasBadTimeInput() {
        const timeBadInput = this.getTimepicker().hasBadInput();
        const timeMissing = this.required && this._dateValue && !this._timeValue;
        return timeMissing || timeBadInput;
      }

      showHelpMessage(message) {
        if (!this.connected) {
          return;
        }

        if (!message) {
          this.clearHelpMessage();
          return;
        }

        if (this.hasBadDateInput && !this._messageWhenBadInput) {
          this.clearHelpMessage();
          this.getDatepicker().showHelpMessage(message);
          return;
        }

        if (this.hasBadTimeInput && !this._messageWhenBadInput) {
          this.clearHelpMessage();
          this.getTimepicker().showHelpMessage(message);
          return;
        }

        this.classList.add('slds-has-error');
        this._customErrorMessage = message;
      }

      clearHelpMessage() {
        this.classList.remove('slds-has-error');
        this._customErrorMessage = '';
        this.getDatepicker().showHelpMessage('');
        this.getTimepicker().showHelpMessage('');
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__legend slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get i18n() {
        return i18n$9;
      }

      get dateValue() {
        return this._dateValue;
      }

      get timeValue() {
        return this._timeValue;
      }

      get customErrorMessage() {
        return this._customErrorMessage;
      }

      get dateMin() {
        return this._dateMin;
      }

      get dateMax() {
        return this._dateMax;
      }

      get errorMessageElementId() {
        return getRealDOMId(this.template.querySelector('[data-error-message'));
      }

      get computedDateAriaDescribedBy() {
        const ariaValues = [];

        if (this.customErrorMessage) {
          ariaValues.push(this.errorMessageElementId);
        }

        if (this.dateAriaDescribedBy) {
          ariaValues.push(this.dateAriaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedTimeAriaDescribedBy() {
        const ariaValues = [];

        if (this.customErrorMessage) {
          ariaValues.push(this.errorMessageElementId);
        }

        if (this.timeAriaDescribedBy) {
          ariaValues.push(this.timeAriaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      constructor() {
        super();
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this._value = null;
        this._timezone = null;
        this._dateValue = null;
        this._timeValue = null;
        this._customErrorMessage = '';
        this._dateMin = void 0;
        this._dateMax = void 0;
        this.label = void 0;
        this.name = void 0;
        this.placeholder = '';
        this.dateStyle = void 0;
        this.timeStyle = void 0;
        this.timeAriaLabel = void 0;
        this.autocomplete = void 0;
        this.dateAriaControls = void 0;
        this.dateAriaLabel = void 0;
        this.dateAriaLabelledBy = void 0;
        this.dateAriaDescribedBy = void 0;
        this.messageWhenValueMissing = void 0;
        this.uniqueId = generateUniqueId();
      }

      synchronizeA11y() {
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');

        if (datepicker) {
          synchronizeAttrs(datepicker, {
            ariaLabelledByElement: this.dateAriaLabelledBy,
            ariaDescribedByElements: this.computedDateAriaDescribedBy,
            ariaControlsElement: this.dateAriaControls,
            'aria-label': this.dateAriaLabel
          });
        }

        if (timepicker) {
          synchronizeAttrs(timepicker, {
            ariaLabelledByElement: this.timeAriaLabelledBy,
            ariaDescribedByElements: this.computedTimeAriaDescribedBy,
            ariaControlsElement: this.timeAriaControls,
            'aria-label': this.timeAriaLabel
          });
        }
      }

      connectedCallback() {
        this.classList.add('slds-form_compound');
        this.connected = true; // we set the initial values here in order to make sure timezone is available.

        this.updateValuesForTimezone(this._initialValue);
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this.connected = false;
      }

      getTimepicker() {
        return this.template.querySelector('lightning-timepicker');
      }

      getDatepicker() {
        return this.template.querySelector('lightning-datepicker');
      }

      handleDatepickerFocus() {
        this._dateFocus = true;
        this.interactingState.enter();
      }

      handleTimepickerFocus() {
        this._timeFocus = true;
        this.interactingState.enter();
      }

      handleDatepickerBlur() {
        this._dateFocus = false; // timepicker fires focus before datepicker fires blur

        if (!this._timeFocus) {
          this.interactingState.leave();
        }
      }

      handleTimepickerBlur() {
        this._timeFocus = false; // datepicker fires focus before timepicker fires blur

        if (!this._dateFocus) {
          this.interactingState.leave();
        }
      }

      handleDateChange(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from listbox

        if (!event.detail) {
          return;
        }

        this._dateValue = event.detail.value;

        if (this._dateValue) {
          this._timeValue = this._timeValue || getCurrentTime(this.timezone);
        }

        this.updateValue();
      }

      handleTimeChange(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from listbox

        if (!event.detail) {
          return;
        }

        this._timeValue = event.detail.value;
        this.updateValue();
      }

      updateValue() {
        const dateValue = this._dateValue;
        const timeValue = this._timeValue;

        if (dateValue && timeValue) {
          const dateTimeString = dateValue + TIME_SEPARATOR + timeValue;
          this._value = normalizeFormattedDateTime(dateTimeString, this.timezone);
          this.dispatchChangeEvent();
        } else if (!dateValue) {
          this._value = null;
          this._timeValue = null;
          this.dispatchChangeEvent();
        }
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return value;
      }

      updateValuesForTimezone(datetimeValue) {
        this.setDateAndTimeValues(datetimeValue || this._value);
        this.calculateFormattedMinValue();
        this.calculateFormattedMaxValue();
      }

      setDateAndTimeValues(value) {
        const normalizedValue = normalizeISODateTime(value, this.timezone).isoValue;
        const isDateOnly = normalizedValue && value.indexOf(TIME_SEPARATOR) < 0;

        if (isDateOnly) {
          this._dateValue = value;
          this._value = this._dateValue;
          return;
        }

        const dateAndTime = this.separateDateTime(normalizedValue);
        this._dateValue = dateAndTime && dateAndTime[0];
        this._timeValue = dateAndTime && dateAndTime[1];
        this._value = value;
      }

      calculateFormattedMinValue() {
        if (!this.min) {
          return;
        }

        const normalizedDate = normalizeISODateTime(this.min, this.timezone);
        this._dateMin = this.separateDateTime(normalizedDate.isoValue)[0];
        this.formattedMin = normalizedDate.displayValue;
      }

      calculateFormattedMaxValue() {
        if (!this.max) {
          return;
        }

        const normalizedDate = normalizeISODateTime(this.max, this.timezone);
        this._dateMax = this.separateDateTime(normalizedDate.isoValue)[0];
        this.formattedMax = normalizedDate.displayValue;
      }

      separateDateTime(isoString) {
        return typeof isoString === 'string' ? isoString.split(TIME_SEPARATOR) : null;
      }

      formatString(str) {
        const args = ArraySlice.call(arguments, 1);
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningDateTimePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningDateTimePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        timeAriaLabel: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        timeAriaControls: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        dateAriaLabelledBy: {
          config: 0
        },
        dateAriaDescribedBy: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        value: {
          config: 3
        },
        timezone: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "hasBadInput", "showHelpMessage"],
      track: {
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _value: 1,
        _timezone: 1,
        _dateValue: 1,
        _timeValue: 1,
        _customErrorMessage: 1,
        _dateMin: 1,
        _dateMax: 1
      }
    });

    var _lightningDatetimepicker = lwc.registerComponent(LightningDateTimePicker, {
      tmpl: _tmpl$h
    });

    function tmpl$j($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element,
        t: api_text,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16,
        _m17,
        _m18,
        _m19,
        _m20,
        _m21,
        _m22,
        _m23,
        _m24,
        _m25,
        _m26,
        _m27,
        _m28,
        _m29,
        _m30,
        _m31,
        _m32,
        _m33,
        _m34,
        _m35,
        _m36,
        _m37,
        _m38,
        _m39
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "data-aria": true
        },
        key: 0
      }, []), $cmp.isTypeSimple ? api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 1
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.isTypeSimple ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 3
      }, []) : null : null, $cmp.isTypeSimple ? api_element("div", {
        className: $cmp.computedFormElementClass,
        key: 14
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": $cmp._internalType,
          "id": api_scoped_id("input"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "autocomplete": $cmp.autocomplete,
          "max": $cmp.normalizedMax,
          "min": $cmp.normalizedMin,
          "inputmode": $cmp._inputMode,
          "step": $cmp.step,
          "maxlength": $cmp.maxLength,
          "minlength": $cmp.minLength,
          "pattern": $cmp.pattern,
          "placeholder": $cmp.placeholder,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 4,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange)),
          "input": _m3 || ($ctx._m3 = api_bind($cmp.handleInput)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleKeyDown))
        }
      }, []), $cmp.isTypeSearch ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:search",
          "variant": "bare",
          "svgClass": "slds-input__icon slds-input__icon_left slds-icon-text-default"
        },
        key: 5
      }, []) : null, $cmp.isTypeSearch ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 13
      }, [$cmp.isLoading ? api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_brand": true,
          "slds-spinner_x-small": true,
          "slds-input__spinner": true
        },
        attrs: {
          "role": "status"
        },
        key: 9
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.i18n.loading)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 7
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 8
      }, [])]) : null, $cmp._showClearButton ? api_element("button", {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true,
          "slds-button": true,
          "slds-button_icon": true
        },
        attrs: {
          "data-element-id": "searchClear"
        },
        key: 12,
        on: {
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
          "click": _m6 || ($ctx._m6 = api_bind($cmp.clearAndSetFocusOnInput))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:clear",
          "variant": "bare",
          "svgClass": "slds-button__icon"
        },
        key: 10
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 11
      }, [api_dynamic($cmp.i18n.clear)])]) : null]) : null]) : null, $cmp.isTypeToggle ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 23
      }, [api_element("label", {
        classMap: {
          "slds-checkbox_toggle": true,
          "slds-grid": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox-toggle")}`
        },
        key: 22
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 15
      }, [api_text("*")]) : null, api_element("span", {
        className: $cmp.computedLabelClass,
        key: 16
      }, [api_dynamic($cmp.label)]), api_element("input", {
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox-toggle"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 17,
        on: {
          "blur": _m7 || ($ctx._m7 = api_bind($cmp.handleBlur)),
          "focus": _m8 || ($ctx._m8 = api_bind($cmp.handleFocus)),
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-checkbox_faux_container": true
        },
        attrs: {
          "id": api_scoped_id("toggle-description"),
          "data-toggle-description": true,
          "aria-live": "assertive"
        },
        key: 21
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 18
      }, []), api_element("span", {
        classMap: {
          "slds-checkbox_on": true
        },
        key: 19
      }, [api_dynamic($cmp.messageToggleActive)]), api_element("span", {
        classMap: {
          "slds-checkbox_off": true
        },
        key: 20
      }, [api_dynamic($cmp.messageToggleInactive)])])])]) : null, $cmp.isTypeCheckbox ? !$cmp.isStandardVariant ? api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox")}`
        },
        key: 26
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 24
      }, [api_text("*")]) : null, api_element("span", {
        className: $cmp.computedLabelClass,
        key: 25
      }, [api_dynamic($cmp.label)])]) : null : null, $cmp.isTypeCheckbox ? !$cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 27
      }, []) : null : null : null, $cmp.isTypeCheckbox ? api_element("div", {
        className: $cmp.computedFormElementClass,
        key: 36
      }, [api_element("span", {
        className: $cmp.computedCheckboxClass,
        key: 35
      }, [$cmp.isStandardVariant ? $cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 28
      }, [api_text("*")]) : null : null, api_element("input", {
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 29,
        on: {
          "blur": _m10 || ($ctx._m10 = api_bind($cmp.handleBlur)),
          "focus": _m11 || ($ctx._m11 = api_bind($cmp.handleFocus)),
          "change": _m12 || ($ctx._m12 = api_bind($cmp.handleChange))
        }
      }, []), !$cmp.isStandardVariant ? api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 30
      }, []) : null, $cmp.isStandardVariant ? api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox")}`
        },
        key: 33
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 31
      }, []), api_element("span", {
        className: $cmp.computedLabelClass,
        key: 32
      }, [api_dynamic($cmp.label)])]) : null, $cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 34
      }, []) : null : null])]) : null, $cmp.isTypeCheckboxButton ? api_element("div", {
        classMap: {
          "slds-checkbox_add-button": true
        },
        key: 40
      }, [api_element("input", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox-button"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 37,
        on: {
          "blur": _m13 || ($ctx._m13 = api_bind($cmp.handleBlur)),
          "focus": _m14 || ($ctx._m14 = api_bind($cmp.handleFocus)),
          "change": _m15 || ($ctx._m15 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-checkbox_faux": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox-button")}`
        },
        key: 39
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 38
      }, [api_dynamic($cmp.label)])])]) : null, $cmp.isTypeRadio ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 46
      }, [api_element("span", {
        classMap: {
          "slds-radio": true
        },
        key: 45
      }, [api_element("input", {
        attrs: {
          "type": "radio",
          "id": api_scoped_id("radio"),
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 41,
        on: {
          "blur": _m16 || ($ctx._m16 = api_bind($cmp.handleBlur)),
          "focus": _m17 || ($ctx._m17 = api_bind($cmp.handleFocus)),
          "change": _m18 || ($ctx._m18 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-radio__label": true
        },
        attrs: {
          "for": `${api_scoped_id("radio")}`
        },
        key: 44
      }, [api_element("span", {
        classMap: {
          "slds-radio_faux": true
        },
        key: 42
      }, []), api_element("span", {
        className: $cmp.computedLabelClass,
        key: 43
      }, [api_dynamic($cmp.label)])])])]) : null, $cmp.isTypeFile ? api_element("span", {
        className: $cmp.computedLabelClass,
        attrs: {
          "id": api_scoped_id("form-label"),
          "data-form-label": true
        },
        key: 48
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 47
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.isTypeFile ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 56
      }, [api_element("div", {
        classMap: {
          "slds-file-selector": true,
          "slds-file-selector_files": true
        },
        key: 55,
        on: {
          "drop": _m23 || ($ctx._m23 = api_bind($cmp.handleDropFiles))
        }
      }, [api_custom_element("lightning-primitive-file-droppable-zone", _lightningPrimitiveFileDroppableZone, {
        props: {
          "multiple": $cmp.multiple,
          "disabled": $cmp.disabled
        },
        key: 54
      }, [api_element("input", {
        classMap: {
          "slds-file-selector__input": true,
          "slds-assistive-text": true
        },
        attrs: {
          "type": "file",
          "id": api_scoped_id("input-file"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "accept": $cmp.accept,
          "name": $cmp.name
        },
        props: {
          "multiple": $cmp.multiple,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 49,
        on: {
          "blur": _m19 || ($ctx._m19 = api_bind($cmp.handleBlur)),
          "click": _m20 || ($ctx._m20 = api_bind($cmp.handleFileClick)),
          "focus": _m21 || ($ctx._m21 = api_bind($cmp.handleFocus)),
          "change": _m22 || ($ctx._m22 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-file-selector__body": true
        },
        attrs: {
          "id": api_scoped_id("file-selector-label"),
          "data-file-selector-label": true,
          "for": `${api_scoped_id("input-file")}`
        },
        key: 53
      }, [api_element("span", {
        classMap: {
          "slds-file-selector__button": true,
          "slds-button": true,
          "slds-button_neutral": true
        },
        key: 51
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:upload",
          "variant": "bare",
          "svgClass": "slds-button__icon slds-button__icon_left"
        },
        key: 50
      }, []), api_dynamic($cmp.i18n.inputFileButtonLabel)]), api_element("span", {
        classMap: {
          "slds-file-selector__text": true,
          "slds-medium-show": true
        },
        key: 52
      }, [api_dynamic($cmp.i18n.inputFileBodyText)])])])])]) : null, $cmp.isTypeColor ? api_element("div", {
        classMap: {
          "slds-color-picker": true
        },
        key: 65
      }, [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-color-picker__summary": true
        },
        key: 64
      }, [api_element("label", {
        className: $cmp.computedColorLabelClass,
        attrs: {
          "for": `${api_scoped_id("color")}`
        },
        key: 58
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 57
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 62
      }, [api_custom_element("lightning-primitive-colorpicker-button", _lightningPrimitiveColorpickerButton, {
        props: {
          "value": $cmp.value,
          "disabled": $cmp.disabled
        },
        key: 59,
        on: {
          "blur": _m24 || ($ctx._m24 = api_bind($cmp.handleBlur)),
          "focus": _m25 || ($ctx._m25 = api_bind($cmp.handleFocus)),
          "change": _m26 || ($ctx._m26 = api_bind($cmp.handleColorChange))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-color-picker__summary-input": true
        },
        key: 61
      }, [api_element("input", {
        classMap: {
          "slds-input": true,
          "slds-m-right_x-small": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("color"),
          "name": $cmp.name,
          "autocomplete": $cmp.autocomplete,
          "accesskey": $cmp.accesskey,
          "aria-label": $cmp.computedAriaLabel,
          "minlength": "4",
          "maxlength": "7",
          "placeholder": $cmp.placeholder,
          "pattern": $cmp.pattern
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 60,
        on: {
          "blur": _m27 || ($ctx._m27 = api_bind($cmp.handleBlur)),
          "focus": _m28 || ($ctx._m28 = api_bind($cmp.handleFocus)),
          "change": _m29 || ($ctx._m29 = api_bind($cmp.handleChange)),
          "input": _m30 || ($ctx._m30 = api_bind($cmp.handleInput))
        }
      }, [])])]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 63
      }, []) : null])]) : null, $cmp.isTypeDesktopDate ? api_custom_element("lightning-datepicker", _lightningDatepicker, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "ariaLabel": $cmp.ariaLabel,
          "dateStyle": $cmp.dateStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 66,
        on: {
          "change": _m31 || ($ctx._m31 = api_bind($cmp.handleChange)),
          "blur": _m32 || ($ctx._m32 = api_bind($cmp.handleBlur)),
          "focus": _m33 || ($ctx._m33 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp.isTypeDesktopTime ? api_custom_element("lightning-timepicker", _lightningTimepicker, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "ariaLabel": $cmp.ariaLabel,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 67,
        on: {
          "change": _m34 || ($ctx._m34 = api_bind($cmp.handleChange)),
          "blur": _m35 || ($ctx._m35 = api_bind($cmp.handleBlur)),
          "focus": _m36 || ($ctx._m36 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp.isTypeDesktopDateTime ? api_custom_element("lightning-datetimepicker", _lightningDatetimepicker, {
        props: {
          "dateAriaControls": $cmp.dateAriaControls,
          "dateAriaLabel": $cmp.dateAriaLabel,
          "dateAriaLabelledBy": $cmp.dateAriaLabelledBy,
          "dateAriaDescribedBy": $cmp.dateAriaDescribedBy,
          "dateStyle": $cmp.dateStyle,
          "timeStyle": $cmp.timeStyle,
          "timeAriaControls": $cmp.timeAriaControls,
          "timeAriaLabel": $cmp.timeAriaLabel,
          "timeAriaLabelledBy": $cmp.timeAriaLabelledBy,
          "timeAriaDescribedBy": $cmp.timeAriaDescribedBy,
          "max": $cmp.max,
          "min": $cmp.min,
          "timezone": $cmp.timezone,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 68,
        on: {
          "change": _m37 || ($ctx._m37 = api_bind($cmp.handleChange)),
          "blur": _m38 || ($ctx._m38 = api_bind($cmp.handleBlur)),
          "focus": _m39 || ($ctx._m39 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "role": "alert"
        },
        key: 69
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$i = lwc.registerTemplate(tmpl$j);
    tmpl$j.stylesheets = [];

    if (_implicitStylesheets$1) {
      tmpl$j.stylesheets.push.apply(tmpl$j.stylesheets, _implicitStylesheets$1);
    }
    tmpl$j.stylesheetTokens = {
      hostAttribute: "lightning-input_input-host",
      shadowAttribute: "lightning-input_input"
    };

    var labelInputFileBodyText = 'Or drop files';

    var labelInputFileButtonLabel = 'Upload Files';

    var labelMessageToggleActive = 'Active';

    var labelMessageToggleInactive = 'Inactive';

    var labelClearInput = 'Clear';

    var labelLoadingIndicator = 'Loading';

    var labelNumberIncrementCounter = 'Increase number';

    var labelNumberDecrementCounter = 'Decrease number';

    var userTimeZone = 'America/Los_Angeles';

    function normalizeInput(value) {
      if (typeof value === 'number' || typeof value === 'string') {
        return String(value);
      }

      return '';
    }

    function normalizeDate(value) {
      return normalizeISODate(value).isoValue || '';
    } // Converts value to the user's timezone and formats it in a way that will be accepted by the input

    function normalizeUTCDateTime(value, timezone) {
      return normalizeISODateTime(value, timezone).isoValue || '';
    }
    function normalizeTime(value) {
      return normalizeISOTime(value).isoValue || '';
    } // parses the input value and converts it back to UTC from the user's timezone

    function normalizeDateTimeToUTC(value, timezone) {
      return normalizeFormattedDateTime(value, timezone) || '';
    }

    function toIsoDecimal(numberAsString) {
      const result = transformLocalizedNumberToIsoDecimal(numberAsString, getLocaleSeparators());

      if (isNaN(result)) {
        return '';
      }

      return result;
    }
    function isValidNumber(numberAsString) {
      return !isNaN(transformLocalizedNumberToIsoDecimal(numberAsString, getLocaleSeparators()));
    }
    function fromIsoDecimal(numberAsString) {
      const decimalSeparator = configProvider.getLocale().decimal;
      return toLocalizedDigits(numberAsString.replace('.', decimalSeparator));
    } // TODO: Too many options, simplify

    function increaseNumberByStep({
      value,
      increment,
      step,
      fractionDigits
    }) {
      const startingValue = value === '' || value == null ? '0' : value;
      const stepAsFloat = parseFloat(step);
      let result;

      if (isNaN(stepAsFloat)) {
        result = parseFloat(startingValue) + increment;
      } else {
        // ideally we'd round the value to the closest correct step, so that if say the step is '2', and the
        // current value is '1' it would increment to '2' instead of '3', since the former would be the valid
        // number given the step constraint, however this would significantly complicate the code, keeping
        // it simple for now.
        const increaseBy = increment * stepAsFloat;
        result = parseFloat(startingValue) + increaseBy;
      }

      return result.toFixed(fractionDigits);
    }
    function calculateFractionDigitsFromStep(step) {
      let calculatedFractionDigits;

      if (step) {
        const stepAsString = String(step).toLowerCase();

        if (stepAsString !== 'any') {
          // lowering the case because we're checking for exponent format as well
          let fractionDigits = 0;

          if (stepAsString.indexOf('.') >= 0 && stepAsString.indexOf('e') < 0) {
            const fractionalPart = stepAsString.split('.')[1]; // we're parsing to account for cases where the step is
            // '1.0', or '1.000', etc.

            if (parseInt(fractionalPart, 10) > 0) {
              fractionDigits = fractionalPart.length;
            }
          } else if (stepAsString.indexOf('e-') > 0) {
            // exponent form eg. 1.5e-5
            const splitOnExponent = stepAsString.split('e-');
            const fractionalPart = splitOnExponent[0].split('.')[1];
            const exponentPart = splitOnExponent[1];
            const fractionalPartLength = fractionalPart ? fractionalPart.length : 0;
            fractionDigits = parseInt(exponentPart, 10) + fractionalPartLength;
          }

          calculatedFractionDigits = fractionDigits;
        }
      }

      return calculatedFractionDigits;
    }
    function formatNumber(numberAsString, options) {
      if (isEmptyString(numberAsString)) {
        return '';
      }

      let formattedValue = numberAsString;
      let inputValue = numberAsString; // set formatter style & default options

      const formatStyle = options.style;
      const formatOptions = {
        style: formatStyle
      };
      formatOptions.minimumFractionDigits = options.minimumFractionDigits;
      formatOptions.maximumFractionDigits = options.maximumFractionDigits;

      if (formatStyle === 'percent-fixed') {
        // percent-fixed just uses percent format and divides the value by 100
        // before passing to the library, this is to deal with the
        // fact that percentages in salesforce are 0-100, not 0-1
        formatOptions.style = 'percent';
        const inputValueAsString = inputValue.toString();
        const normalisedNumberInPercent = parseFloat(inputValue) / 100; // If the number contains fraction digits and is not in an exponent format

        if (inputValueAsString.indexOf('.') > 0 && inputValueAsString.indexOf('e') < 0) {
          // Depending on the input number, division by 100 may lead to rounding errors
          // (e.g 0.785 / 100 is 0.007850000000000001), so we need to round back
          // to the correct precision, that is - existing number of fractional digits
          // plus extra 2 for division by 100.
          inputValue = normalisedNumberInPercent.toFixed(inputValueAsString.split('.')[1].length + 2);
        } else {
          inputValue = normalisedNumberInPercent;
        }
      }

      try {
        formattedValue = numberFormat$1(formatOptions).format(inputValue) || '';
      } catch (ignore) {// ignore any errors
      }

      return formattedValue;
    } // Exporting only to test

    function transformLocalizedNumberToIsoDecimal(numberAsString, {
      decimalSeparator,
      groupSeparator
    }) {
      if (numberAsString == null || numberAsString.length === 0) {
        return '';
      } // remove the grouping separator


      let result = numberAsString.split(groupSeparator).join('');

      if (decimalSeparator !== '.') {
        // replace the local decimal separator with a
        result = result.replace(decimalSeparator, '.');
      }

      return fromLocalizedDigits(addLeadingZeroIfNeeded(result));
    }
    function normalizeNumber(value) {
      if (value === undefined || value === null || isNaN(value)) {
        return '';
      }

      return String(value);
    }

    function addLeadingZeroIfNeeded(result) {
      // If the number starts with +. OR  -. OR . ; insert a 0 before the decimal separator.
      // eg. -.2 -> -0.2
      const decimalSeparatorLocation = result.indexOf('.');

      if (decimalSeparatorLocation === 0 || decimalSeparatorLocation === 1) {
        const firstCharacter = result.charAt(0);

        if (firstCharacter === '+' || firstCharacter === '-' || firstCharacter === '.') {
          result = result.substring(0, decimalSeparatorLocation) + '0' + result.substring(decimalSeparatorLocation);
        }
      }

      return result;
    }

    function getLocaleSeparators() {
      const decimalSeparator = configProvider.getLocale().decimal;
      const groupSeparator = configProvider.getLocale().grouping;
      return {
        decimalSeparator,
        groupSeparator
      };
    }

    const i18n$a = {
      a11yTriggerText: labelA11yTriggerText,
      inputFileBodyText: labelInputFileBodyText,
      inputFileButtonLabel: labelInputFileButtonLabel,
      messageToggleActive: labelMessageToggleActive,
      messageToggleInactive: labelMessageToggleInactive,
      numberIncrementCounter: labelNumberIncrementCounter,
      numberDecrementCounter: labelNumberDecrementCounter,
      required: labelRequired,
      clear: labelClearInput,
      loading: labelLoadingIndicator
    };
    const ARIA_CONTROLS$2 = 'aria-controls';
    const ARIA_LABEL$2 = 'aria-label';
    const ARIA_LABELEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$3 = 'aria-describedby';
    /*
    * This component supports the regular native input types, with the addition of toggle, checkbox-button and color.
    * Furthermore the file type supports a droppable zone, search has a clear button, number has formatting.
    * Input changes (native oninput event) triggers an onchange event,
    *     the native even is stopped, the dispatched custom event has a value that points to the state of the component
    *     in case of files it's the files uploaded (via droppable zone or through the upload button),
    *     checked for radio and checkbox, checkbox-button, and just straight input's value for everything else
    *
    *
    * _Toggle_ (always has an aria-describedby, on error has an additional one, default label text for active and inactive
    * states)
    * _File_ (as it has a droppable zone, the validity returned would have to be valid - unless a custom error message was
    *    passed)
    * _Search_ (it has the clear button and the icon)
    * _Number_ (formatting when not in focus, when in focus shows raw value)
    *
    * */

    const VALID_NUMBER_FORMATTERS = ['decimal', 'percent', 'percent-fixed', 'currency'];
    const DEFAULT_COLOR$1 = '#000000';
    const DEFAULT_FORMATTER = VALID_NUMBER_FORMATTERS[0];
    /**
     * Returns an aria string with all the non-autolinked values removed
     * @param {String} values space sperated list of ids
     * @returns {String} The aria values with the non-auto linked ones removed
     */

    function filterNonAutoLink(values) {
      const ariaValues = values && values.split(/\s+/);
      return ariaValues && ariaValues.filter(value => {
        return !!value.match(/^auto-link/);
      }).join(' ');
    }
    /**
     * Represents interactive controls that accept user input depending on the type attribute.
     */


    class LightningInput extends lwc.LightningElement {
      /**
       * Text that is displayed when the field is empty, to prompt the user for a valid entry.
       * @type {string}
       *
       */

      /**
       * Specifies the name of an input element.
       * @type {string}
       *
       */

      /**
       * Text label for the input.
       * @type {string}
       * @required
       *
       */

      /**
       * Error message to be displayed when a bad input is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a pattern mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a range overflow is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a range underflow is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a step mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is too short.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is too long.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a type mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is missing.
       * @type {string}
       *
       */

      /**
       * Text shown for the active state of a toggle. The default is "Active".
       * @type {string}
       */

      /**
       * Text shown for the inactive state of a toggle. The default is "Inactive".
       * @type {string}
       */

      /**
       * Describes the input to assistive technologies.
       * @type {string}
       */

      /**
       * Controls auto-filling of the field. Use this attribute with
       * email, search, tel, text, and url input types only. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * @type {string}
       */
      constructor() {
        super();
        this.placeholder = void 0;
        this.name = void 0;
        this.label = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenPatternMismatch = void 0;
        this.messageWhenRangeOverflow = void 0;
        this.messageWhenRangeUnderflow = void 0;
        this.messageWhenStepMismatch = void 0;
        this.messageWhenTooShort = void 0;
        this.messageWhenTooLong = void 0;
        this.messageWhenTypeMismatch = void 0;
        this.messageWhenValueMissing = void 0;
        this.messageToggleActive = i18n$a.messageToggleActive;
        this.messageToggleInactive = i18n$a.messageToggleInactive;
        this.ariaLabel = void 0;
        this.autocomplete = void 0;
        this._timeAriaDescribedBy = void 0;
        this._timeAriaLabelledBy = void 0;
        this._timeAriaControls = void 0;
        this._dateAriaControls = void 0;
        this._dateAriaDescribedBy = void 0;
        this._dateAriaLabelledBy = void 0;
        this._value = '';
        this._type = 'text';
        this._pattern = void 0;
        this._max = void 0;
        this._min = void 0;
        this._step = void 0;
        this._disabled = false;
        this._readOnly = false;
        this._required = false;
        this._checked = false;
        this._isLoading = false;
        this._multiple = false;
        this._timezone = false;
        this._helpMessage = null;
        this._isColorPickerPanelOpen = false;
        this._fieldLevelHelp = void 0;
        this._accesskey = void 0;
        this._maxLength = void 0;
        this._minLength = void 0;
        this._accept = void 0;
        this._variant = void 0;
        this._numberRawValue = '';
        this._formatter = DEFAULT_FORMATTER;
        this._showRawNumber = false;
        this._initialValueSet = false;
        this._files = null;
        this._rendered = void 0;
        this.dateStyle = void 0;
        this.timeStyle = void 0;
        this.dateAriaLabel = void 0;
        this.ariaObserver = new ContentMutation(this); // Native Shadow Root will return [native code].
        // Our synthetic method will return the function source.

        this.isNative = this.template.querySelector.toString().match(/\[native code\]/);
      }
      /**
       * Reserved for internal use.
       * @type {number}
       *
       */


      get formatFractionDigits() {
        return this._formatFractionDigits;
      }

      set formatFractionDigits(value) {
        this._formatFractionDigits = value;

        if (this._rendered && this.isTypeNumber) {
          this.inputElement.value = this.displayedValue;
        }
      }

      set timeAriaControls(refs) {
        this._timeAriaControls = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaControls = ref;
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * time input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and date-aria-controls to describe the native date time input.
       * @type {string}
       */


      get timeAriaControls() {
        return this._timeAriaControls;
      }
      /**
       * The display style of the date when type='date' or type='datetime'. Valid values are
       * short, medium (default), and long. The format of each style is specific to the locale.
       * On mobile devices this attribute has no effect.
       * @type {string}
       * @default medium
       */


      set dateAriaLabelledBy(refs) {
        this._dateAriaLabelledBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaLabelledBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide labels for the date input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and time-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       */


      get dateAriaLabelledBy() {
        return this._dateAriaLabelledBy;
      }

      set timeAriaLabelledBy(refs) {
        this._timeAriaLabelledBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaLabelledBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide labels for the time input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and date-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       *
       */


      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }

      set timeAriaDescribedBy(refs) {
        this._timeAriaDescribedBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaDescribedBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the time input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and date-aria-described-by
       * to describe the native date time input.
       *  @type {string}
       *
       */


      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }

      set dateAriaControls(refs) {
        this._dateAriaControls = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaControls = ref;
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * date input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and time-aria-controls to describe the native date time input.
       * @type {string}
       *
       */


      get dateAriaControls() {
        return this._dateAriaControls;
      }

      set dateAriaDescribedBy(refs) {
        this._dateAriaDescribedBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaDescribedBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the date input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and time-aria-described-by
       * to describe the native date time input.
       * @type {string}
       */


      get dateAriaDescribedBy() {
        return this._dateAriaDescribedBy;
      }

      set ariaControls(refs) {
        this._ariaControls = refs;
        this.ariaObserver.link('input', 'aria-controls', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the input.
       * @type {string}
       */


      get ariaControls() {
        return this._ariaControls;
      }

      set ariaLabelledBy(refs) {
        this._ariaLabelledBy = refs;
        this.ariaObserver.link('input', 'aria-labelledby', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs that provide labels for the input.
       * @type {string}
       */


      get ariaLabelledBy() {
        // native version returns the auto linked value
        if (this.isNative) {
          const ariaValues = this.template.querySelector('input').getAttribute('aria-labelledby');
          return filterNonAutoLink(ariaValues);
        }

        return this._ariaLabelledBy;
      }

      set ariaDescribedBy(refs) {
        this._ariaDescribedBy = refs;
        this.ariaObserver.link('input', 'aria-describedby', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the input.
       * @type {string}
       */


      get ariaDescribedBy() {
        if (this.isNative) {
          // in native case return the linked value
          const ariaValues = this.template.querySelector('input').getAttribute('aria-describedby');
          return filterNonAutoLink(ariaValues);
        }

        return this._ariaDescribedBy;
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');

        if (datepicker) {
          synchronizeAttrs(datepicker, {
            ariaLabelledByElement: this.ariaLabelledBy,
            ariaDescribedByElements: this.ariaDescribedBy,
            ariaControlsElement: this.ariaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
          return;
        }

        if (timepicker) {
          synchronizeAttrs(timepicker, {
            ariaLabelledByElement: this.ariaLabelledBy,
            ariaDescribedByElements: this.ariaDescribedBy,
            ariaControlsElement: this.ariaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
          return;
        }

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELEDBY]: this.computedAriaLabelledBy,
          [ARIA_DESCRIBEDBY$3]: this.computedAriaDescribedBy,
          [ARIA_CONTROLS$2]: this.computedAriaControls,
          [ARIA_LABEL$2]: this.computedAriaLabel
        });
      }

      connectedCallback() {
        this.classList.add('slds-form-element');

        this._updateClassList();

        this._validateRequiredAttributes();

        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.reportValidity());

        if (this.isTypeNumber) {
          this._updateNumberValue(this._value);
        }
      }

      disconnectedCallback() {
        this._rendered = false;
        this._initialValueSet = false;
        this._inputElement = undefined;
      }

      renderedCallback() {
        if (!this._initialValueSet && this.inputElement) {
          this._rendered = true;

          if (this.isTypeNumber) {
            this._numberRawValue = fromIsoDecimal(this._value);
          }

          this.inputElement.value = this.displayedValue;

          if (this.isTypeCheckable) {
            this.inputElement.checked = this._checked;
          }

          this._initialValueSet = true;
        }

        this.ariaObserver.sync();
        this.synchronizeA11y();
      }
      /**
       * String value with the formatter to be used for number input. Valid values include
       * decimal, percent, percent-fixed, and currency.
       * @type {string}
       */


      get formatter() {
        return this._formatter;
      }

      set formatter(value) {
        this._formatter = normalizeString(value, {
          fallbackValue: DEFAULT_FORMATTER,
          validValues: VALID_NUMBER_FORMATTERS
        });

        this._updateInputDisplayValueIfTypeNumber();
      }
      /**
       * The type of the input. This value defaults to text.
       * @type {string}
       * @default text
       */


      get type() {
        return this._type;
      }

      set type(value) {
        const normalizedValue = normalizeString(value);
        this._type = normalizedValue === 'datetime' ? 'datetime-local' : normalizedValue;
        this.validateType(normalizedValue);
        this._inputElementRefreshNeeded = true;

        if (this._rendered) {
          // The type is being changed after render, which means the input element may be different (eg. changing
          // from text to 'checkbox', so we need to set the initial value again
          this._initialValueSet = false;

          if (this.isTypeNumber) {
            // If the type has changed, we need to re-parse the value as a number
            this._updateNumberValue(this._value);
          }
        }

        this._updateProxyInputAttributes(['type', 'value', 'max', 'min', 'required', 'pattern']);
      }
      /**
       * For the search type only. If present, a spinner is displayed to indicate that data is loading.
       * @type {boolean}
       * @default false
       */


      get isLoading() {
        return this._isLoading;
      }

      set isLoading(value) {
        this._isLoading = normalizeBoolean(value);
      }
      /**
       * Specifies the regular expression that the input's value is checked against.
       * This attribute is supported for email, password, search, tel, text, and url types.
       * @type {string}
       *
       */


      get pattern() {
        if (this.isTypeColor) {
          return '^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$';
        }

        return this._pattern;
      }

      set pattern(value) {
        this._pattern = value;

        this._updateProxyInputAttributes('pattern');
      }
      /**
       * The maximum number of characters allowed in the field.
       * Use this attribute with email, password, search, tel, text, and url input types only.
       * @type {number}
       */


      get maxLength() {
        return this._maxLength;
      }

      set maxLength(value) {
        this._maxLength = value;

        this._updateProxyInputAttributes('maxlength');
      }
      /**
       * Specifies the types of files that the server accepts. Use this attribute with file input type only.
       * @type {string}
       */


      get accept() {
        return this._accept;
      }

      set accept(value) {
        this._accept = value;

        this._updateProxyInputAttributes('accept');
      }
      /**
       * The minimum number of characters allowed in the field.
       * Use this attribute with email, password, search, tel, text, and url input types only.
       * @type {number}
       */


      get minLength() {
        return this._minLength;
      }

      set minLength(value) {
        this._minLength = value;

        this._updateProxyInputAttributes('minlength');
      } // number and date/time

      /**
       * The maximum acceptable value for the input.  Use this attribute with number,
       * range, date, time, and datetime input types only. For number and range type, the max value is a
       * decimal number. For the date, time, and datetime types, the max value must use a valid string for the type.
       * @type {decimal|string}
       */


      get max() {
        return this._max;
      }

      set max(value) {
        this._max = value;

        this._updateProxyInputAttributes('max');
      }
      /**
       * The minimum acceptable value for the input. Use this attribute with number,
       * range, date, time, and datetime input types only. For number and range types, the min value
       * is a decimal number. For the date, time, and datetime types, the min value must use a valid string for the type.
       * @type {decimal|string}
       */


      get min() {
        return this._min;
      }

      set min(value) {
        this._min = value;

        this._updateProxyInputAttributes('min');
      }
      /**
       * Granularity of the value, specified as a positive floating point number.
       * Use this attribute with number and range input types only.
       * Use 'any' when granularity is not a concern. This value defaults to 1.
       * @type {decimal|string}
       * @default 1
       */


      get step() {
        // This should be reconsidered as it in effect disabled any step support for datetime/time types on mobile
        if (this.isTypeDateTime || this.isTypeTime) {
          return 'any';
        } // It should probably default to '1' instead, but this means that we'd be explicitly passing step='1' to the
        // native input


        return this._step;
      }

      set step(value) {
        if (typeof value === 'string' && value.toLowerCase() === 'any') {
          this._step = 'any';
        } else {
          this._step = isUndefinedOrNull(value) || isNaN(value) ? undefined : String(value);
        }

        this._updateProxyInputAttributes('step');

        this._updateInputDisplayValueIfTypeNumber();
      }
      /**
       * If present, the checkbox is selected.
       * @type {boolean}
       * @default false
       */


      get checked() {
        // checkable inputs can be part of a named group, in that case there won't be a change event thrown and so
        // the internal tracking _checked would be out of sync with the actual input value.
        if (this.isTypeCheckable && this._initialValueSet) {
          return this.inputElement.checked;
        }

        return this._checked;
      }

      set checked(value) {
        this._checked = normalizeBoolean(value);

        this._updateProxyInputAttributes('checked');

        if (this._rendered) {
          this.inputElement.checked = this._checked;
        }
      }
      /**
       * Specifies that a user can enter more than one value. Use this attribute with file and email input types only.
       * @type {boolean}
       * @default false
       */


      get multiple() {
        return this._multiple;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);

        this._updateProxyInputAttributes('multiple');
      }
      /**
       * Specifies the value of an input element.
       * @type {object}
       */


      get value() {
        return this._value;
      }

      set value(value) {
        const previousValue = this._value;
        this._value = normalizeInput(value);

        if (this._rendered && this.isTypeNumber) {
          if (this.validity.badInput || normalizeNumber(value) !== previousValue) {
            this._updateNumberValue(value);
          }
        }

        this._updateProxyInputAttributes('value'); // Setting value of a type file isn't allowed, but due to the design of Aura/LWC interop layer
        // it will try to set the value after a change event


        if (!this.isTypeFile) {
          // Again, due to the interop layer we need to check whether the value being set
          // is different, otherwise we're duplicating the sets on the input, which result
          // in different bugs like Japanese IME duplication of characters in Safari (likely a browser bug) or
          // character position re-set in IE11.
          if (this._rendered && this.inputElement.value !== this.displayedValue) {
            this.inputElement.value = this.displayedValue;
          }
        }
      }
      /**
       * The variant changes the appearance of an input field.
       * Accepted variants include standard, label-inline, label-hidden, and label-stacked.
       * This value defaults to standard, which displays the label above the field.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and input field.
       * Use label-stacked to place the label above the input field.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant(value);

        this._updateClassList();
      }
      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        this._updateProxyInputAttributes('disabled');
      }
      /**
       * If present, the input field is read-only and cannot be edited by users.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readOnly;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);

        this._updateProxyInputAttributes('readonly');
      }
      /**
       * If present, the input field must be filled out before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);

        this._updateProxyInputAttributes('required');
      }
      /**
       * Specifies the time zone used when type='datetime' only. This value defaults to the user's Salesforce time zone setting.
       * @type {string}
       *
       */


      get timezone() {
        return this._timezone || userTimeZone;
      }

      set timezone(value) {
        this._timezone = value; // mobile date/time normalization of value/max/min depends on timezone, so we need to update here as well

        this._updateProxyInputAttributes(['value', 'max', 'min']);
      }
      /**
       * A FileList that contains selected files. Use this attribute with the file input type only.
       * @type {object}
       *
       */


      get files() {
        if (this.isTypeFile) {
          return this._files;
        }

        return null;
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Checks if the input is valid.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Sets a custom error message to be displayed when a form is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          if (this._rendered && !this.isNativeInput) {
            this.inputElement.showHelpMessage(message);
          } else {
            this._helpMessage = message;
          }
        });
      }

      get isNativeInput() {
        return !(this.isTypeDesktopDate || this.isTypeDesktopDateTime || this.isTypeDesktopTime);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * This attribute isn't supported for file, radio, toggle, and checkbox-button types.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this._rendered) {
          this.inputElement.focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this._rendered) {
          this.inputElement.blur();
        }
      }
      /**
       * Displays error messages on invalid fields.
       * An invalid field fails at least one constraint validation and returns false when checkValidity() is called.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      get computedAriaControls() {
        const ariaValues = []; // merge all date & time arias on mobile since it's displayed as a single field

        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaControls);
          ariaValues.push(this.timeAriaControls);
        }

        if (this.ariaControls) {
          ariaValues.push(this.ariaControls);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaLabel() {
        const ariaValues = []; // merge all date & time arias on mobile since it's displayed as a single field

        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabel);
          ariaValues.push(this.timeAriaLabel);
        }

        if (this.ariaLabel) {
          ariaValues.push(this.ariaLabel);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaLabelledBy() {
        const ariaValues = [];

        if (this.isTypeFile) {
          ariaValues.push(this.computedUniqueFileElementLabelledById);
        } // merge all date & time arias on mobile since it's displayed as a single field


        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabelledBy);
          ariaValues.push(this.timeAriaLabelledBy);
        }

        if (this.ariaLabelledBy) {
          ariaValues.push(this.ariaLabelledBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        if (this._helpMessage) {
          ariaValues.push(this.computedUniqueHelpElementId);
        } // The toggle type is described by a secondary element


        if (this.isTypeToggle) {
          ariaValues.push(this.computedUniqueToggleElementDescribedById);
        } // merge all date & time arias on mobile since it's displayed as a single field


        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaDescribedBy);
          ariaValues.push(this.timeAriaDescribedBy);
        }

        if (this.ariaDescribedBy) {
          ariaValues.push(this.ariaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }
      /**
       * Specifies a shortcut key to activate or focus an element.
       * @type {string}
       *
       */


      get accessKey() {
        return this._accesskey;
      }

      set accessKey(newValue) {
        this._accesskey = newValue;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get isLabelStacked() {
        return this.variant === VARIANT.LABEL_STACKED;
      }

      get accesskey() {
        return this._accesskey;
      }

      get colorInputElementValue() {
        return this.validity.valid && this.value ? this.value : DEFAULT_COLOR$1;
      }

      get colorInputStyle() {
        return `background: ${this.value || '#5679C0'};`;
      }

      get computedUniqueHelpElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get computedUniqueToggleElementDescribedById() {
        if (this.isTypeToggle) {
          const toggle = this.template.querySelector('[data-toggle-description]');
          return getRealDOMId(toggle);
        }

        return null;
      }

      get computedUniqueFormLabelId() {
        if (this.isTypeFile) {
          const formLabel = this.template.querySelector('[data-form-label]');
          return getRealDOMId(formLabel);
        }

        return null;
      }

      get computedUniqueFileSelectorLabelId() {
        if (this.isTypeFile) {
          const fileBodyLabel = this.template.querySelector('[data-file-selector-label]');
          return getRealDOMId(fileBodyLabel);
        }

        return null;
      }

      get computedUniqueFileElementLabelledById() {
        if (this.isTypeFile) {
          const labelIds = [this.computedUniqueFormLabelId, this.computedUniqueFileSelectorLabelId];
          return labelIds.join(' ');
        }

        return null;
      }

      get computedFormElementClass() {
        const classes = classSet('slds-form-element__control slds-grow');

        if (this.isTypeSearch) {
          classes.add('slds-input-has-icon slds-input-has-icon_left-right');
        }

        return classes.toString();
      }

      get i18n() {
        return i18n$a;
      }

      get computedLabelClass() {
        const classnames = classSet('slds-form-element__label');

        if (this.isTypeCheckable || this.isTypeFile) ; else if (this.isTypeToggle) {
          classnames.add('slds-m-bottom_none');
        } else {
          classnames.add('slds-no-flex');
        }

        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedNumberClass() {
        return classSet('slds-input').add({
          'slds-is-disabled': this.disabled
        }).toString();
      }

      get computedColorLabelClass() {
        return classSet('slds-form-element__label slds-color-picker__summary-label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedCheckboxClass() {
        return classSet('slds-checkbox').add({
          'slds-checkbox_standalone': !this.isStandardVariant
        }).toString();
      }

      get normalizedMax() {
        return this.normalizeDateTimeString(this.max);
      }

      get normalizedMin() {
        return this.normalizeDateTimeString(this.min);
      }

      get isTypeNumber() {
        return this.type === 'number';
      }

      get isTypeCheckable() {
        return this.isTypeCheckbox || this.isTypeCheckboxButton || this.isTypeRadio || this.isTypeToggle;
      }

      get isTypeSearch() {
        return this.type === 'search';
      }

      get isTypeToggle() {
        return this.type === 'toggle';
      }

      get isTypeText() {
        return this.type === 'text';
      }

      get isTypeCheckbox() {
        return this.type === 'checkbox';
      }

      get isTypeRadio() {
        return this.type === 'radio';
      }

      get isTypeCheckboxButton() {
        return this.type === 'checkbox-button';
      }

      get isTypeFile() {
        return this.type === 'file';
      }

      get isTypeColor() {
        return this.type === 'color';
      }

      get isTypeDate() {
        return this.type === 'date';
      }

      get isTypeDateTime() {
        return this.type === 'datetime' || this.type === 'datetime-local';
      }

      get isTypeTime() {
        return this.type === 'time';
      }

      get isTypeMobileDate() {
        return this.isTypeDate && !this.isDesktopBrowser();
      }

      get isTypeDesktopDate() {
        return this.isTypeDate && this.isDesktopBrowser();
      }

      get isTypeMobileDateTime() {
        return this.isTypeDateTime && !this.isDesktopBrowser();
      }

      get isTypeDesktopDateTime() {
        return this.isTypeDateTime && this.isDesktopBrowser();
      }

      get isTypeMobileTime() {
        return this.isTypeTime && !this.isDesktopBrowser();
      }

      get isTypeDesktopTime() {
        return this.isTypeTime && this.isDesktopBrowser();
      }

      get isTypeSimple() {
        return !this.isTypeCheckbox && !this.isTypeCheckboxButton && !this.isTypeToggle && !this.isTypeRadio && !this.isTypeFile && !this.isTypeColor && !this.isTypeDesktopDate && !this.isTypeDesktopDateTime && !this.isTypeDesktopTime;
      }

      get inputElement() {
        if (!this._inputElement || this._inputElementRefreshNeeded) {
          let inputElement;

          if (this.isTypeDesktopDate) {
            inputElement = this.template.querySelector('lightning-datepicker');
          } else if (this.isTypeDesktopDateTime) {
            inputElement = this.template.querySelector('lightning-datetimepicker');
          } else if (this.isTypeDesktopTime) {
            inputElement = this.template.querySelector('lightning-timepicker');
          } else {
            inputElement = this.template.querySelector('input');
          }

          this._inputElementRefreshNeeded = false;
          this._inputElement = inputElement;
        }

        return this._inputElement;
      }

      get inputTypeForValidity() {
        let inputType = 'text';

        if (this.isTypeSimple) {
          if (this.isTypeNumber) {
            inputType = 'number';
          } else {
            inputType = this.type;
          }
        } else if (this.isTypeCheckable) {
          inputType = this.isTypeRadio ? 'radio' : 'checkbox';
        } else if (this.isTypeFile) {
          inputType = 'file';
        } else if (this.isTypeDateTime) {
          inputType = 'datetime-local';
        } else if (this.isTypeTime) {
          inputType = 'time';
        } else if (this.isTypeDate) {
          inputType = 'date';
        }

        return inputType;
      }

      clearAndSetFocusOnInput(event) {
        // TODO: Discuss this, it seems the wrong thing to do.
        // button is removed from template, but
        // event still is propagated, For example, captured by panel,
        // then cause panel think is clicked outside.
        event.stopPropagation();
        this.interactingState.enter();
        this.inputElement.value = '';

        this._updateValueAndValidityAttribute('');

        this.inputElement.focus();
        this.dispatchChangeEventWithDetail({
          value: this._value
        });
        this.dispatchCommitEvent();
      }

      dispatchCommitEvent() {
        this.dispatchEvent(new CustomEvent('commit'));
      }

      dispatchChangeEventWithDetail(detail) {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail
        }));
      }

      validateType(type) {
        assert(type !== 'hidden', `<lightning-input> The type attribute value "hidden" is invalid. Use a regular <input type="hidden"> instead.`);
        assert(type !== 'submit' && type !== 'reset' && type !== 'image' && type !== 'button', `<lightning-input> The type attribute value "${type}" is invalid. Use <lightning:button> instead.`);

        if (this.isTypeRadio) {
          assert(!this.required, `<lightning-input> The required attribute is not supported on radio inputs directly. It should be implemented at the radio group level.`);
        }
      }

      _validateRequiredAttributes() {
        const {
          label
        } = this;
        assert(typeof label === 'string' && label.length, `<lightning-input> The required label attribute value "${label}" is invalid.`);
      }

      handleFileClick() {
        this.inputElement.value = null;

        this._updateValueAndValidityAttribute(null);
      }

      handleDropFiles(event) {
        // drop doesn't trigger focus nor blur, so set state to interacting
        // and auto leave when there's no more action
        this.interactingState.interacting();
        this.fileUploadedViaDroppableZone = true;
        this._files = event.dataTransfer && event.dataTransfer.files;

        this._updateProxyInputAttributes('required');

        this.dispatchChangeEventWithDetail({
          files: this._files
        });
      }

      handleFocus() {
        this.interactingState.enter();

        if (this.isTypeColor) {
          this._isColorPickerPanelOpen = false;
        }

        if (this._rendered && this.isTypeNumber) {
          this._showRawNumber = true;
          this.inputElement.value = this.displayedValue; // W-6176985: IE11 input when set value, will move cursor to beginning.
          // This fix is only for input type=number on IE11, and force the cursor to the end.

          if (isIE11) {
            const length = this.inputElement.value.length;
            this.inputElement.selectionStart = length;
            this.inputElement.selectionEnd = length;
          }
        }

        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur(event) {
        this.interactingState.leave();

        if (this._rendered && this.isTypeNumber) {
          this._showRawNumber = false;
          this.inputElement.value = this.displayedValue;
        }

        if (!event.relatedTarget || !this.template.contains(event.relatedTarget)) {
          this.dispatchEvent(new CustomEvent('blur'));
        }
      }

      handleChange(event) {
        event.stopPropagation();
        this.dispatchCommitEvent();

        if (this.isTypeSimple && this.value === event.target.value) {
          return;
        }

        this.dispatchChangeEvent();
      }

      handleInput(event) {
        event.stopPropagation();

        if (this.isTypeNumber) {
          // for invalid numbers the value might stay the same as the user
          // changed the invalid input, so we need to update the raw value
          this._numberRawValue = this.inputElement.value;
        }

        if (this.isTypeSimple && this.value === event.target.value) {
          return;
        }

        this.dispatchChangeEvent();
      }

      handleKeyDown(event) {
        if (this.isTypeNumber && !isShiftMetaOrControlKey(event) && !this.readOnly) {
          const key = normalizeKeyValue(event.key);

          if (key === 'ArrowUp') {
            event.preventDefault();

            this._numberStepUpAndDispatchEvents(1);
          } else if (key === 'ArrowDown') {
            event.preventDefault();

            this._numberStepUpAndDispatchEvents(-1);
          }
        }
      }

      dispatchChangeEvent() {
        this.interactingState.enter();
        const detail = {};

        if (this.isTypeCheckable) {
          this._updateCheckedAndValidityAttribute(this.inputElement.checked);

          detail.checked = this._checked;
        } else if (this.isTypeFile) {
          this._files = this.inputElement.files; // LWC does not proxy dom elements any more. So there is no need to call lwc.unwrap here anymore

          detail.files = this._files;

          this._updateProxyInputAttributes('required');
        }

        if (!this.isTypeCheckable) {
          if (this.isTypeNumber) {
            this._numberRawValue = this.inputElement.value;
            detail.value = toIsoDecimal(this.inputElement.value);
          } else {
            detail.value = this.inputElement.value;
          }

          if (this.isTypeMobileDateTime) {
            detail.value = normalizeDateTimeToUTC(detail.value, this.timezone);
          } else if (this.isTypeMobileTime) {
            detail.value = normalizeTime(detail.value);
          }

          this._updateValueAndValidityAttribute(detail.value);
        }

        this.dispatchChangeEventWithDetail(detail);
      }

      get _showClearButton() {
        return this.isTypeSearch && isNotUndefinedOrNull(this._value) && this._value !== '';
      }

      handleColorPickerToggleClick(event) {
        event.preventDefault(); // Don't want error state inside panel

        if (!this.validity.valid) {
          this.inputElement.value = DEFAULT_COLOR$1;

          this._updateValueAndValidityAttribute(DEFAULT_COLOR$1);

          this._helpMessage = null;
          this.classList.remove('slds-has-error');
          this.dispatchChangeEventWithDetail({
            value: DEFAULT_COLOR$1
          });
        }
      }

      handleColorChange(event) {
        const selectedColor = event.detail.color;

        if (selectedColor !== this.inputElement.value) {
          this.inputElement.value = selectedColor;

          this._updateValueAndValidityAttribute(selectedColor);

          this.focus();
          this.dispatchChangeEventWithDetail({
            value: selectedColor
          });
        }

        this.template.querySelector('lightning-primitive-colorpicker-button').focus();
      }

      isDesktopBrowser() {
        return formFactor === 'Large';
      }

      get displayedValue() {
        if (this.isTypeNumber) {
          // If the number is not valid (bad input, step mismatch, etc.) show the raw number as
          // well, otherwise the formatted value ends up being 'NaN' which makes it hard to
          // see mistakes
          if (this._showRawNumber || !this.validity.valid) {
            return this._numberRawValue;
          }

          return formatNumber(this._value, this._buildFormatNumberOptions());
        }

        if (this.isTypeMobileDate || this.isTypeMobileDateTime || this.isTypeMobileTime) {
          return this.normalizeDateTimeString(this._value);
        }

        return this._value;
      }

      get _internalType() {
        if (this.isTypeNumber) {
          return 'text';
        }

        return this._type;
      }

      get isStandardVariant() {
        return this.variant === VARIANT.STANDARD || this.variant === VARIANT.LABEL_HIDDEN;
      }

      _updateValueAndValidityAttribute(value) {
        this._value = value;

        this._updateProxyInputAttributes('value');
      }

      _updateCheckedAndValidityAttribute(value) {
        this._checked = value;

        this._updateProxyInputAttributes('checked');
      }

      get _ignoreRequired() {
        // If uploading via the drop zone or via the input directly, we should
        // ignore the required flag as a file has been uploaded
        return this.isTypeFile && this._required && (this.fileUploadedViaDroppableZone || this._files && this._files.length > 0);
      }

      get _inputMode() {
        if (this.isTypeNumber) {
          return 'decimal';
        }

        return null;
      }

      _updateProxyInputAttributes(attributes) {
        if (this._constraintApiProxyInputUpdater) {
          this._constraintApiProxyInputUpdater(attributes);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          const overrides = {
            badInput: () => {
              if (!this._rendered) {
                return false;
              }

              if (this.isTypeNumber) {
                return !isValidNumber(this._numberRawValue);
              }

              if (!this.isNativeInput) {
                return this.inputElement.hasBadInput();
              }

              return this.inputElement.validity.badInput;
            },
            tooLong: () => // since type=number is type=text in the dom when not in focus
            // we should always return false as maxlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._rendered && this.inputElement.validity.tooLong,
            tooShort: () => // since type=number is type=text in the dom when not in focus
            // we should always return false as minlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._rendered && this.inputElement.validity.tooShort,
            patternMismatch: () => this.isNativeInput && this._rendered && this.inputElement.validity.patternMismatch
          }; // FF, IE and Safari don't support type datetime-local,
          // IE and Safari don't support type date or time
          // we need to defer to the base component to check rangeOverflow/rangeUnderflow.
          // Due to the custom override, changing the type to or from datetime/time would affect the validation

          if (this.isTypeDesktopDateTime || this.isTypeDesktopTime || this.isTypeDesktopDate) {
            overrides.rangeOverflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const max = this.isTypeDesktopTime ? normalizeTime(this.max) : this.max;
              return isAfter(this.value, max);
            };

            overrides.rangeUnderflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const min = this.isTypeDesktopTime ? normalizeTime(this.min) : this.min;
              return isBefore(this.value, min);
            };

            overrides.stepMismatch = () => false;
          }

          if (this.isIE11) {
            overrides.stepMismatch = () => false;
          }

          this._constraintApi = new FieldConstraintApiWithProxyInput(() => {
            // The date/time components display their own errors and have custom messages for badInput and rangeOverflow/Underflow.
            if (!this.isNativeInput) {
              return this.inputElement;
            }

            return this;
          }, overrides);
          this._constraintApiProxyInputUpdater = this._constraint.setInputAttributes({
            type: () => this.inputTypeForValidity,
            // We need to normalize value so that it's consumable by the proxy input (otherwise the value
            // will be invalid for the native input)
            value: () => this.normalizeDateTimeString(this.value),
            checked: () => this.checked,
            maxlength: () => this.maxLength,
            minlength: () => this.minLength,
            // 'pattern' depends on type
            pattern: () => this.pattern,
            // 'max' and 'min' depend on type and timezone
            max: () => this.normalizedMax,
            min: () => this.normalizedMin,
            step: () => this.step,
            accept: () => this.accept,
            multiple: () => this.multiple,
            disabled: () => this.disabled,
            readonly: () => this.readOnly,
            // depends on type and whether an upload has been made
            required: () => this.required && !this._ignoreRequired
          });
        }

        return this._constraintApi;
      }

      _updateInputDisplayValueIfTypeNumber() {
        // Displayed value depends on the format number, so if we're not showing the raw
        // number we should update the value
        if (this._rendered && this.isTypeNumber && !this._showRawNumber && this.inputElement) {
          this.inputElement.value = this.displayedValue;
        }
      }
      /**
       * Increases (if increment is positive, decreases otherwise) the number value of the input by the increment
       * multiple of the given 'step'. Additionally dispatches the 'change' and 'commit' events.
       *
       * @param {Number} increment A multiple of the step to increase, when step is 'any',
       * the step is assumed to be 1.
       * @private
       */


      _numberStepUpAndDispatchEvents(increment) {
        if (this._readOnly || this._disabled) {
          return;
        }

        this._value = increaseNumberByStep({
          value: this._value,
          step: this.step,
          increment,
          fractionDigits: this._buildFormatNumberOptions().minimumFractionDigits
        }); // Raw value is the value the user entered (we preserve a user's input),
        // since we're generating a new value we're overriding it

        this._numberRawValue = fromIsoDecimal(this._value);
        this.inputElement.value = this.displayedValue;
        this.dispatchChangeEvent();
        this.dispatchCommitEvent();
      }

      _updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      _updateNumberValue(value) {
        const newValue = normalizeNumber(value);
        this._value = newValue;
        this._numberRawValue = fromIsoDecimal(newValue);
      }

      _buildFormatNumberOptions() {
        const options = {
          style: this.formatter
        }; // Use the min/max fraction digits from the formatFractionDigits provided by the user if available.
        // Otherwise, use the number of digits calculated from step

        if (this._formatFractionDigits !== undefined) {
          options.minimumFractionDigits = this._formatFractionDigits;
          options.maximumFractionDigits = this._formatFractionDigits;
        } else {
          let digitsFromStep = calculateFractionDigitsFromStep(this._step); // if formatting percentages, when calculating digits from step, take into
          // consideration that the formatted number is effectively multiplied by 10^2, ie. 0.1 is 10%
          // so we need to subtract 2 digits;

          if (this.formatter === 'percent' && typeof digitsFromStep === 'number') {
            digitsFromStep -= 2;

            if (digitsFromStep < 0) {
              digitsFromStep = 0;
            }
          }

          options.minimumFractionDigits = digitsFromStep;
          options.maximumFractionDigits = digitsFromStep;
        }

        return options;
      }

      normalizeDateTimeString(value) {
        let result = value;

        if (this.isTypeDate) {
          result = normalizeDate(value);
        } else if (this.isTypeTime) {
          result = normalizeTime(value);
        } else if (this.isTypeDateTime) {
          result = normalizeUTCDateTime(value, this.timezone);
        }

        return result;
      }

    }

    LightningInput.delegatesFocus = true;

    lwc.registerDecorators(LightningInput, {
      publicProps: {
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        label: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenPatternMismatch: {
          config: 0
        },
        messageWhenRangeOverflow: {
          config: 0
        },
        messageWhenRangeUnderflow: {
          config: 0
        },
        messageWhenStepMismatch: {
          config: 0
        },
        messageWhenTooShort: {
          config: 0
        },
        messageWhenTooLong: {
          config: 0
        },
        messageWhenTypeMismatch: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageToggleActive: {
          config: 0
        },
        messageToggleInactive: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        formatFractionDigits: {
          config: 3
        },
        timeAriaControls: {
          config: 3
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        dateAriaLabelledBy: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 3
        },
        dateAriaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        formatter: {
          config: 3
        },
        type: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        pattern: {
          config: 3
        },
        maxLength: {
          config: 3
        },
        accept: {
          config: 3
        },
        minLength: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        step: {
          config: 3
        },
        checked: {
          config: 3
        },
        multiple: {
          config: 3
        },
        value: {
          config: 3
        },
        variant: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        timezone: {
          config: 3
        },
        files: {
          config: 1
        },
        validity: {
          config: 1
        },
        fieldLevelHelp: {
          config: 3
        },
        accessKey: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "setCustomValidity", "reportValidity", "focus", "blur", "showHelpMessageIfInvalid"],
      track: {
        _timeAriaDescribedBy: 1,
        _timeAriaLabelledBy: 1,
        _timeAriaControls: 1,
        _dateAriaControls: 1,
        _dateAriaDescribedBy: 1,
        _dateAriaLabelledBy: 1,
        _value: 1,
        _type: 1,
        _pattern: 1,
        _max: 1,
        _min: 1,
        _step: 1,
        _disabled: 1,
        _readOnly: 1,
        _required: 1,
        _checked: 1,
        _isLoading: 1,
        _multiple: 1,
        _timezone: 1,
        _helpMessage: 1,
        _isColorPickerPanelOpen: 1,
        _fieldLevelHelp: 1,
        _accesskey: 1,
        _maxLength: 1,
        _minLength: 1,
        _accept: 1,
        _variant: 1,
        _numberRawValue: 1
      },
      fields: ["_formatter", "_showRawNumber", "_initialValueSet", "_files", "_rendered"]
    });

    var _lightningInput = lwc.registerComponent(LightningInput, {
      tmpl: _tmpl$i
    });
    LightningInput.interopMap = {
      exposeNativeEvent: {
        change: true,
        focus: true,
        blur: true
      }
    };

    function tmpl$k($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        gid: api_scoped_id,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "name": $cmp.name,
          "accesskey": $cmp.computedAccessKey,
          "title": $cmp.computedTitle,
          "type": $cmp.normalizedType,
          "value": $cmp.value,
          "aria-describedby": api_scoped_id($cmp.computedAriaDescribedBy),
          "aria-label": $cmp.computedAriaLabel,
          "aria-controls": api_scoped_id($cmp.computedAriaControls),
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-live": $cmp.computedAriaLive,
          "aria-atomic": $cmp.computedAriaAtomic
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonBlur))
        }
      }, [$cmp.showIconLeft ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 0
      }, []) : null, api_dynamic($cmp.label), $cmp.showIconRight ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 1
      }, []) : null])];
    }

    var _tmpl$j = lwc.registerTemplate(tmpl$k);
    tmpl$k.stylesheets = [];
    tmpl$k.stylesheetTokens = {
      hostAttribute: "lightning-button_button-host",
      shadowAttribute: "lightning-button_button"
    };

    /**
     * A clickable element used to perform an action.
     */

    class LightningButton extends LightningPrimitiveButton$1 {
      constructor(...args) {
        super(...args);
        this.name = void 0;
        this.value = void 0;
        this.label = void 0;
        this.variant = 'neutral';
        this.iconName = void 0;
        this.iconPosition = 'left';
        this.type = 'button';
        this.title = null;
        this._order = null;
      }

      render() {
        return _tmpl$j;
      }

      get computedButtonClass() {
        return classSet('slds-button').add({
          'slds-button_neutral': this.normalizedVariant === 'neutral',
          'slds-button_brand': this.normalizedVariant === 'brand',
          'slds-button_outline-brand': this.normalizedVariant === 'brand-outline',
          'slds-button_destructive': this.normalizedVariant === 'destructive',
          'slds-button_text-destructive': this.normalizedVariant === 'destructive-text',
          'slds-button_inverse': this.normalizedVariant === 'inverse',
          'slds-button_success': this.normalizedVariant === 'success',
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedTitle() {
        return this.title;
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: 'neutral',
          validValues: ['base', 'neutral', 'brand', 'brand-outline', 'destructive', 'destructive-text', 'inverse', 'success']
        });
      }

      get normalizedType() {
        return normalizeString(this.type, {
          fallbackValue: 'button',
          validValues: ['button', 'reset', 'submit']
        });
      }

      get normalizedIconPosition() {
        return normalizeString(this.iconPosition, {
          fallbackValue: 'left',
          validValues: ['left', 'right']
        });
      }

      get showIconLeft() {
        return this.iconName && this.normalizedIconPosition === 'left';
      }

      get showIconRight() {
        return this.iconName && this.normalizedIconPosition === 'right';
      }

      get computedIconClass() {
        return classSet('slds-button__icon').add({
          'slds-button__icon_left': this.normalizedIconPosition === 'left',
          'slds-button__icon_right': this.normalizedIconPosition === 'right'
        }).toString();
      }

      handleButtonFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleButtonBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        if (this._connected) {
          this.template.querySelector('button').focus();
        }
      }
      /**
       * Clicks the button.
       */


      click() {
        if (this._connected) {
          this.template.querySelector('button').click();
        }
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * Once we are connected, we fire a register event so the button-group (or other) component can register
       * the buttons.
       */


      connectedCallback() {
        this._connected = true;
        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

    }

    LightningButton.delegatesFocus = true;

    lwc.registerDecorators(LightningButton, {
      publicProps: {
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        label: {
          config: 0
        },
        variant: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        type: {
          config: 0
        }
      },
      publicMethods: ["focus", "click"],
      track: {
        title: 1,
        _order: 1
      }
    });

    var _lightningButton = lwc.registerComponent(LightningButton, {
      tmpl: _tmpl$j
    });
    LightningButton.interopMap = {
      exposeNativeEvent: {
        click: true,
        focus: true,
        blur: true
      }
    };

    function tmpl$l($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        s: api_slot
      } = $api;
      return [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true,
          "slds-col": true,
          "slds-grow-none": true,
          "slds-m-right_xx-small": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 0
      }, [api_text("*")]) : null, api_slot("", {
        key: 1
      }, [], $slotset)];
    }

    var _tmpl$k = lwc.registerTemplate(tmpl$l);
    tmpl$l.slots = [""];
    tmpl$l.stylesheets = [];
    tmpl$l.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditInputWrapper_primitiveDatatableIeditInputWrapper-host",
      shadowAttribute: "lightning-primitiveDatatableIeditInputWrapper_primitiveDatatableIeditInputWrapper"
    };

    /**
     * @TODO: This component should be removed once the issue with label is solved in SLDS or IO
     */

    class LightningPrimitiveDatatableIeditInputWrapper extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.required = void 0;
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableIeditInputWrapper, {
      publicProps: {
        required: {
          config: 0
        }
      }
    });

    var _lightningPrimitiveDatatableIeditInputWrapper = lwc.registerComponent(LightningPrimitiveDatatableIeditInputWrapper, {
      tmpl: _tmpl$k
    });

    function tmpl$m($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-text",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var TextTpl = lwc.registerTemplate(tmpl$m);
    tmpl$m.stylesheets = [];
    tmpl$m.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_text-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_text"
    };

    function tmpl$n($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "tel",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-phone",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var PhoneTpl = lwc.registerTemplate(tmpl$n);
    tmpl$n.stylesheets = [];
    tmpl$n.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_phone-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_phone"
    };

    function tmpl$o($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "email",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-email",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var EmailTpl = lwc.registerTemplate(tmpl$o);
    tmpl$o.stylesheets = [];
    tmpl$o.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_email-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_email"
    };

    function tmpl$p($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "number",
          "formatter": "percent",
          "step": "0.01",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-percent",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var PercentTpl = lwc.registerTemplate(tmpl$p);
    tmpl$p.stylesheets = [];
    tmpl$p.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_percent-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_percent"
    };

    function tmpl$q($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "url",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-url",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var UrlTpl = lwc.registerTemplate(tmpl$q);
    tmpl$q.stylesheets = [];
    tmpl$q.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_url-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_url"
    };

    function tmpl$r($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "number",
          "formatter": "currency",
          "step": "0.01",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-currency",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var CurrencyTpl = lwc.registerTemplate(tmpl$r);
    tmpl$r.stylesheets = [];
    tmpl$r.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_currency-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_currency"
    };

    function tmpl$s($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "number",
          "label": $cmp.columnLabel,
          "step": "any",
          "name": "dt-inline-edit-number",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var NumberTpl = lwc.registerTemplate(tmpl$s);
    tmpl$s.stylesheets = [];
    tmpl$s.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_number-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_number"
    };

    function tmpl$t($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "checkbox",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-text",
          "checked": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var BooleanTpl = lwc.registerTemplate(tmpl$t);
    tmpl$t.stylesheets = [];
    tmpl$t.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_boolean-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_boolean"
    };

    function tmpl$u($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        classMap: {
          "datatable-inline-edit": true
        },
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "type": "date",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-dateLocal",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 0
      }, [])];
    }

    var DateLocalTpl = lwc.registerTemplate(tmpl$u);
    tmpl$u.stylesheets = [];
    tmpl$u.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_dateLocal-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_dateLocal"
    };

    function tmpl$v($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "type": "datetime",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-datetime",
          "variant": "label-hidden",
          "value": $cmp.editedDateValue
        },
        key: 0
      }, [])];
    }

    var DateTpl = lwc.registerTemplate(tmpl$v);
    tmpl$v.stylesheets = [];
    tmpl$v.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_date-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_date"
    };

    function tmpl$w($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var DefaultTpl = lwc.registerTemplate(tmpl$w);
    tmpl$w.stylesheets = [];
    tmpl$w.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_default-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_default"
    };

    const TYPE_TPL_MAPPINGS = {
      text: TextTpl,
      phone: PhoneTpl,
      email: EmailTpl,
      percent: PercentTpl,
      url: UrlTpl,
      currency: CurrencyTpl,
      number: NumberTpl,
      boolean: BooleanTpl,
      'date-local': DateLocalTpl,
      date: DateTpl
    };
    const INVALID_TYPE_FOR_EDIT = 'column type not supported for inline edit';

    class LightningPrimitiveDatatableIeditTypeFactory extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.columnLabel = void 0;
        this.editedValue = void 0;
        this.required = void 0;
      }

      get columnDef() {
        return this._columnDef;
      }

      set columnDef(value) {
        assert( // eslint-disable-next-line no-prototype-builtins
        TYPE_TPL_MAPPINGS.hasOwnProperty(value.type), INVALID_TYPE_FOR_EDIT);
        this._columnDef = value;
        this.columnLabel = value.label;
      }

      get columnType() {
        return this._columnDef.type;
      }

      render() {
        return TYPE_TPL_MAPPINGS[this.columnType] || DefaultTpl;
      }

      connectedCallback() {
        this._blurHandler = this.handleComponentBlur.bind(this);
        this._focusHandler = this.handleComponentFocus.bind(this);
        this._changeHandler = this.handleComponentChange.bind(this);
      }

      renderedCallback() {
        this.concreteComponent.addEventListener('blur', this._blurHandler);
        this.concreteComponent.addEventListener('focus', this._focusHandler);
        this.concreteComponent.addEventListener('change', this._changeHandler);
      }

      get concreteComponent() {
        return this.template.querySelector('[data-inputable="true"]');
      }

      focus() {
        if (this.concreteComponent) {
          this.concreteComponent.focus();
        }
      }

      get value() {
        if (this.columnDef.type === 'boolean') {
          return this.concreteComponent.checked;
        }

        return this.concreteComponent.value;
      }

      get validity() {
        return this.concreteComponent.validity;
      }

      showHelpMessageIfInvalid() {
        this.concreteComponent.showHelpMessageIfInvalid();
      }

      get editedDateValue() {
        const dateValue = new Date(this.editedValue);

        if (this.editedValue === null || isNaN(dateValue.getTime())) {
          return '';
        }

        return dateValue.toISOString();
      }

      handleComponentFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleComponentBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleComponentChange() {
        this.showHelpMessageIfInvalid();
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableIeditTypeFactory, {
      publicProps: {
        editedValue: {
          config: 0
        },
        required: {
          config: 0
        },
        columnDef: {
          config: 3
        },
        value: {
          config: 1
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "showHelpMessageIfInvalid"],
      track: {
        columnLabel: 1
      }
    });

    var _lightningPrimitiveDatatableIeditTypeFactory = lwc.registerComponent(LightningPrimitiveDatatableIeditTypeFactory, {
      tmpl: _tmpl$1
    });

    function tmpl$x($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element,
        k: api_key,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16
      } = $ctx;
      return [$cmp.visible ? api_element("section", {
        classMap: {
          "slds-popover": true,
          "slds-popover_edit": true
        },
        style: $cmp.computedStyle,
        attrs: {
          "role": "dialog",
          "tabindex": "-1"
        },
        key: 12,
        on: {
          "blur": _m14 || ($ctx._m14 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m15 || ($ctx._m15 = api_bind($cmp.handleTypeElemFocus)),
          "keydown": _m16 || ($ctx._m16 = api_bind($cmp.handleCellKeydown))
        }
      }, [api_element("span", {
        classMap: {
          "inline-edit-form-start": true
        },
        attrs: {
          "tabindex": "0"
        },
        key: 0,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFormStartFocus))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        key: 6
      }, [api_element("form", {
        props: {
          "noValidate": true
        },
        key: 5,
        on: {
          "submit": _m6 || ($ctx._m6 = api_bind($cmp.handleEditFormSubmit))
        }
      }, [api_custom_element("lightning-primitive-datatable-iedit-input-wrapper", _lightningPrimitiveDatatableIeditInputWrapper, {
        classMap: {
          "slds-grid": true,
          "slds-p-left_xx-small": true
        },
        props: {
          "required": $cmp.required
        },
        key: 2
      }, [api_custom_element("lightning-primitive-datatable-iedit-type-factory", _lightningPrimitiveDatatableIeditTypeFactory, {
        classMap: {
          "dt-type-edit-factory": true,
          "slds-col": true
        },
        props: {
          "required": $cmp.required,
          "columnDef": $cmp.columnDef,
          "editedValue": $cmp.editedValue
        },
        key: api_key(1, $cmp.inputKey),
        on: {
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleTypeElemFocus))
        }
      }, [])]), $cmp.isMassEditEnabled ? api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-mass-selection": "true"
        },
        props: {
          "type": "checkbox",
          "name": "dt-iedit-mass-edit",
          "label": $cmp.massEditCheckboxLabel
        },
        key: 3,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleMassCheckboxChange)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m5 || ($ctx._m5 = api_bind($cmp.handleTypeElemFocus))
        }
      }, []) : null, !$cmp.isMassEditEnabled ? api_element("button", {
        classMap: {
          "slds-hide": true
        },
        attrs: {
          "type": "submit",
          "aria-hidden": "true",
          "tabindex": "-1",
          "value": "save"
        },
        key: 4
      }, []) : null])]), $cmp.isMassEditEnabled ? api_element("div", {
        classMap: {
          "slds-popover__footer": true
        },
        key: 10
      }, [api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-grid_align-end": true
        },
        key: 9
      }, [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "label": $cmp.cancelLabel
        },
        key: 7,
        on: {
          "blur": _m7 || ($ctx._m7 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m8 || ($ctx._m8 = api_bind($cmp.handleTypeElemFocus)),
          "click": _m9 || ($ctx._m9 = api_bind($cmp.cancelEdition))
        }
      }, []), api_custom_element("lightning-button", _lightningButton, {
        styleMap: {
          "marginLeft": ".25rem"
        },
        attrs: {
          "data-form-last-element": "true"
        },
        props: {
          "label": $cmp.applyLabel,
          "variant": "brand"
        },
        key: 8,
        on: {
          "blur": _m10 || ($ctx._m10 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m11 || ($ctx._m11 = api_bind($cmp.handleTypeElemFocus)),
          "click": _m12 || ($ctx._m12 = api_bind($cmp.processSubmission))
        }
      }, [])])]) : null, api_element("div", {
        classMap: {
          "inline-edit-form-end": true
        },
        attrs: {
          "tabindex": "0"
        },
        key: 11,
        on: {
          "focus": _m13 || ($ctx._m13 = api_bind($cmp.handleFormEndsFocus))
        }
      }, [])]) : null];
    }

    var _tmpl$l = lwc.registerTemplate(tmpl$x);
    tmpl$x.stylesheets = [];
    tmpl$x.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditPanel_primitiveDatatableIeditPanel-host",
      shadowAttribute: "lightning-primitiveDatatableIeditPanel_primitiveDatatableIeditPanel"
    };

    var labelUpdateSelectedItems = 'Update {0} selected items';

    var labelCancel = 'Cancel';

    var labelApply = 'Apply';

    const i18n$b = {
      updateSelectedItems: labelUpdateSelectedItems,
      cancel: labelCancel,
      apply: labelApply
    };

    class PrimitiveDatatableIeditPanel extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.visible = void 0;
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.editedValue = void 0;
        this.columnDef = void 0;
        this.isMassEditEnabled = false;
        this.numberOfSelectedRows = void 0;
      }

      connectedCallback() {
        this.interactingState = new InteractingState({
          duration: 10,
          debounceInteraction: true
        });
        this.interactingState.onleave(() => this.handlePanelLoosedFocus());
      }

      get computedStyle() {
        const styleHash = {
          'z-index': 1000,
          'background-color': 'white',
          'margin-top': '1px'
        };
        styleHash.display = this.visible ? 'block' : 'none';
        return Object.keys(styleHash).map(styleProp => `${styleProp}:${styleHash[styleProp]}`).join(';');
      }

      get inputKey() {
        return this.rowKeyValue + this.colKeyValue;
      }

      get massEditCheckboxLabel() {
        return this.formatString(i18n$b.updateSelectedItems, this.numberOfSelectedRows);
      }

      get applyLabel() {
        return i18n$b.apply;
      }

      get cancelLabel() {
        return i18n$b.cancel;
      }

      get required() {
        return this.columnDef.typeAttributes && this.columnDef.typeAttributes.required;
      }

      handleFormStartFocus() {
        this.interactingState.enter();

        if (this.isMassEditEnabled) {
          // on mass edit the panel dont loses the focus with the keyboard.
          this.focusLastElement();
        } else {
          this.triggerEditFinished({
            reason: 'tab-pressed-prev'
          });
        }
      }

      handleFormEndsFocus() {
        this.interactingState.enter();

        if (this.isMassEditEnabled) {
          // on mass edit the panel dont loses the focus with the keyboard.
          this.focus();
        } else {
          this.triggerEditFinished({
            reason: 'tab-pressed-next'
          });
        }
      }

      triggerEditFinished(detail) {
        detail.rowKeyValue = detail.rowKeyValue || this.rowKeyValue;
        detail.colKeyValue = detail.colKeyValue || this.colKeyValue;
        const event = new CustomEvent('ieditfinished', {
          detail
        });
        this.dispatchEvent(event);
      }

      focus() {
        const elem = this.inputableElement;
        this.interactingState.enter();

        if (elem) {
          elem.focus();
        }
      }

      get inputableElement() {
        return this.template.querySelector('.dt-type-edit-factory');
      }

      get value() {
        return this.inputableElement.value;
      }

      get validity() {
        return this.inputableElement.validity;
      }

      get isMassEditChecked() {
        return this.isMassEditEnabled && this.template.querySelector('[data-mass-selection="true"]').checked;
      }

      getPositionedElement() {
        return this.template.querySelector('section');
      }

      handleTypeElemBlur() {
        if (this.visible && !this.template.activeElement) {
          this.interactingState.leave();
        }
      }

      handleTypeElemFocus() {
        this.interactingState.enter();
      }

      handleEditFormSubmit(event) {
        event.preventDefault();
        event.stopPropagation();

        if (!this.isMassEditEnabled) {
          this.processSubmission();
        }

        return false;
      }

      handleCellKeydown(event) {
        const {
          keyCode
        } = event;

        if (keyCode === 27) {
          // Esc key
          event.stopPropagation();
          this.cancelEdition();
        }
      }

      handlePanelLoosedFocus() {
        if (this.visible) {
          this.triggerEditFinished({
            reason: 'loosed-focus'
          });
        }
      }

      formatString(str) {
        const args = ArraySlice.call(arguments, 1);
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

      focusLastElement() {
        this.template.querySelector('[data-form-last-element="true"]').focus();
      }

      processSubmission() {
        if (this.validity.valid) {
          this.triggerEditFinished({
            reason: 'submit-action'
          });
        } else {
          this.inputableElement.showHelpMessageIfInvalid();
        }
      }

      cancelEdition() {
        this.triggerEditFinished({
          reason: 'edit-canceled'
        });
      }

      handleMassCheckboxChange(event) {
        const customEvent = new CustomEvent('masscheckboxchange', {
          detail: {
            checked: event.detail.checked
          }
        });
        this.dispatchEvent(customEvent);
      }

    }

    lwc.registerDecorators(PrimitiveDatatableIeditPanel, {
      publicProps: {
        visible: {
          config: 0
        },
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        editedValue: {
          config: 0
        },
        columnDef: {
          config: 0
        },
        isMassEditEnabled: {
          config: 0
        },
        numberOfSelectedRows: {
          config: 0
        },
        value: {
          config: 1
        },
        validity: {
          config: 1
        },
        isMassEditChecked: {
          config: 1
        }
      },
      publicMethods: ["focus", "getPositionedElement"]
    });

    var _lightningPrimitiveDatatableIeditPanel = lwc.registerComponent(PrimitiveDatatableIeditPanel, {
      tmpl: _tmpl$l
    });

    var labelChooseARow = 'Choose a Row to Select';

    var labelSelectAll = 'Select All';

    var labelSort = 'Sort by:';

    var labelSortAsc = 'Sorted Ascending';

    var labelSortDesc = 'Sorted Descending';

    var labelSortNone = 'Sorted: None';

    function tmpl$y($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var _tmpl$m = lwc.registerTemplate(tmpl$y);
    tmpl$y.stylesheets = [];
    tmpl$y.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableCell_primitiveDatatableCell-host",
      shadowAttribute: "lightning-primitiveDatatableCell_primitiveDatatableCell"
    };

    class PrimitiveDatatableCell extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this._hasFocus = 0;
        this.state = {
          mode: 'NAVIGATION',
          currentInputIndex: 0,
          internalTabIndex: -1
        };
      }

      get hasFocus() {
        return this._hasFocus;
      }

      get keyboardMode() {
        return this.state.mode;
      }

      set hasFocus(value) {
        this._hasFocus = value;

        if (value) {
          this.classList.add('slds-has-focus');
        } else {
          this.classList.remove('slds-has-focus');
        }
      }

      setMode(keyboardMode, info) {
        const normalizedInfo = info || {
          action: 'none'
        };
        this.state.mode = keyboardMode;

        if (keyboardMode === 'ACTION') {
          this.state.internalTabIndex = 0; // focus without changing tabindex doesnt work W-6185168
          // eslint-disable-next-line @lwc/lwc/no-async-operation

          setTimeout(() => {
            this.setFocusToActionableElement(this.state.currentInputIndex);
          }, 0);
          const actionableElements = this.getActionableElements(); // check if we have an edit button first (tab should open the inline edit)

          if (normalizedInfo.action === 'tab') {
            let editActionElement = false;
            actionableElements.some(elem => {
              if (elem.getAttribute('data-action-edit')) {
                editActionElement = elem;
                return true;
              }

              return false;
            });

            if (editActionElement) {
              editActionElement.click();
            }
          } else if (actionableElements.length === 1) {
            const elem = actionableElements[0];
            let defaultActions = elem.getAttribute('data-action-triggers');
            defaultActions = defaultActions || '';

            if (defaultActions.indexOf(normalizedInfo.action) !== -1) {
              actionableElements[this.state.currentInputIndex].click();
            }
          }
        } else {
          this.state.internalTabIndex = -1;
        }
      }

      addFocusStyles() {
        this.classList.add('slds-has-focus');
      }

      removeFocusStyles(setTabIndex) {
        this.classList.remove('slds-has-focus');

        if (setTabIndex) {
          this.state.internalTabIndex = -1;
        }
      }
      /**
       * method to resetCurrentInputIndex when navigating from cell-to-cell
       * called in navigation or action mode
       * @param {number} direction -1, 1, 2
       * @param {string} incomingMode is the new mode, needed because a cell can be in action mode but new mode being
       * set can be navigation mode
       */


      resetCurrentInputIndex(direction, incomingMode) {
        switch (direction) {
          case -1:
            {
              const inputs = this.getActionableElements();
              this.state.currentInputIndex = inputs.length ? inputs.length - 1 : 0;
              break;
            }

          case 1:
          case 2:
            this.state.currentInputIndex = 0;
            break;
        } // when esc is pressed on a cell to enter navigation mode, other cells are still
        // in action mode till we call setMode above. So need to check new incoming mode too if action mode
        // otherwise we try to focus on an inner element with delegatesFocus and tabindex -1 and
        // it moves focus out of table


        if (this.state.mode === 'ACTION' && incomingMode === 'ACTION') {
          this.setFocusToActionableElement(this.state.currentInputIndex);
        }
      }

      connectedCallback() {
        this.addEventListener('focus', this.handleFocus.bind(this));
        this.addEventListener('click', this.handleClick.bind(this));
        this.addEventListener('keydown', this.handleKeydown.bind(this));
      }

      get internalTabIndex() {
        return this.state.internalTabIndex;
      }

      get canMoveBackward() {
        return this.state.currentInputIndex > 0;
      }

      get canMoveForward() {
        return this.state.actionableElementsCount > 1 && this.state.currentInputIndex < this.state.actionableElementsCount - 1;
      }

      get canMoveLeft() {
        return isRTL() ? this.canMoveForward : this.canMoveBackward;
      }

      get canMoveRight() {
        return isRTL() ? this.canMoveBackward : this.canMoveForward;
      }

      moveToNextActionableElement() {
        this.setFocusToActionableElement(this.state.currentInputIndex + 1);
      }

      moveToPrevActionableElement() {
        this.setFocusToActionableElement(this.state.currentInputIndex - 1);
      } // eslint-disable-next-line no-unused-vars


      handleClick(event) {
        this.addFocusStyles();
        this.fireCellFocusByClickEvent();
      }

      handleKeydown(event) {
        const {
          keyCode,
          shiftKey
        } = event;
        const {
          mode
        } = this.state;
        let passThroughEvent = keyCode !== keyCodes.shift; // if it is in Action mode, then traverse to the next or previous
        // focusable element.
        // if there is no focusable element, or reach outside of the range, then move to
        // previous or next cell.

        if (mode === 'ACTION') {
          switch (keyCode) {
            case keyCodes.left:
              if (this.canMoveLeft) {
                // there are still actionable element before the current one
                // move to the previous actionable element.
                event.preventDefault();

                if (isRTL()) {
                  this.moveToNextActionableElement();
                } else {
                  this.moveToPrevActionableElement();
                }

                this.moveToPrevActionableElement();
                passThroughEvent = false;
              }

              break;

            case keyCodes.right:
              if (this.canMoveRight) {
                // there are still actionable element before the current one
                // move to the previous actionable element.
                event.preventDefault();

                if (isRTL()) {
                  this.moveToPrevActionableElement();
                } else {
                  this.moveToNextActionableElement();
                }

                passThroughEvent = false;
              }

              break;

            case keyCodes.tab:
              // if in action mode, try to navigate through the element inside
              // always prevent the default tab behavior
              // so that the tab will not focus outside of the table.
              if (shiftKey) {
                // moving backward
                if (this.canMoveBackward) {
                  event.preventDefault();
                  this.moveToPrevActionableElement();
                  passThroughEvent = false;
                }
              } else {
                // moving forward
                // eslint-disable-next-line no-lonely-if
                if (this.canMoveForward) {
                  event.preventDefault();
                  this.moveToNextActionableElement();
                  passThroughEvent = false;
                }
              }

              break;
          }
        } else if (mode === 'NAVIGATION') {
          // click the header, press enter, it does not go to action mode without this code.
          if (keyCode === keyCodes.left || keyCode === keyCodes.right || keyCode === keyCodes.up || keyCode === keyCodes.down || keyCode === keyCodes.enter) {
            this.fireCellKeydown(event);
          }
        }

        if (passThroughEvent && mode === 'ACTION') {
          this.fireCellKeydown(event);
        }
      }

      getActionableElements() {
        return Array.prototype.slice.call(this.template.querySelectorAll('[data-navigation="enable"]'));
      }

      get resizeElement() {
        return this.template.querySelector('.slds-resizable');
      }

      setFocusToActionableElement(activeInputIndex) {
        const actionableElements = this.getActionableElements();
        this.state.actionableElementsCount = actionableElements.length;

        if (actionableElements.length > 0) {
          if (activeInputIndex > 0 && activeInputIndex < actionableElements.length) {
            // try to locate to the previous active index of previous row.
            actionableElements[activeInputIndex].focus();
            this.state.currentInputIndex = activeInputIndex;
          } else {
            actionableElements[0].focus();
            this.state.currentInputIndex = 0;
          }
        } // TODO: Fire event back to the datatable, so that the activeInputIndex can be
        // stored in the datatable level state.  So that when user use up and down arrow to
        // navigate throught the datatable in ACTION mode, we can rememeber the active input position

      }

      handleFocus() {
        if (this.state.mode === 'ACTION') {
          this.setFocusToActionableElement(this.state.currentInputIndex);
        }
      }

      fireCellKeydown(keyEvent) {
        const {
          rowKeyValue,
          colKeyValue
        } = this;
        const {
          keyCode,
          shiftKey
        } = keyEvent;
        const event = new CustomEvent('privatecellkeydown', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            rowKeyValue,
            colKeyValue,
            keyCode,
            shiftKey,
            keyEvent
          }
        });
        this.dispatchEvent(event);
      }

      fireCellFocusByClickEvent() {
        const {
          rowKeyValue,
          colKeyValue
        } = this;
        const event = new CustomEvent('privatecellfocusedbyclick', {
          bubbles: true,
          composed: true,
          detail: {
            rowKeyValue,
            colKeyValue
          }
        });
        this.dispatchEvent(event);
      }

    }

    lwc.registerDecorators(PrimitiveDatatableCell, {
      publicProps: {
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        hasFocus: {
          config: 3
        }
      },
      publicMethods: ["setMode", "addFocusStyles", "removeFocusStyles", "resetCurrentInputIndex"],
      track: {
        state: 1
      },
      fields: ["_hasFocus"]
    });

    var PrimitiveDatatableCell$1 = lwc.registerComponent(PrimitiveDatatableCell, {
      tmpl: _tmpl$m
    });

    function tmpl$z($api, $cmp, $slotset, $ctx) {
      const {
        gid: api_scoped_id,
        ti: api_tab_index,
        b: api_bind,
        h: api_element,
        d: api_dynamic
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-th__action": true,
          "slds-th__action_form": true,
          "slds-cell-fixed": true
        },
        style: $cmp.columnStyles,
        key: 6
      }, [$cmp.showCheckbox ? api_element("span", {
        classMap: {
          "slds-checkbox": true
        },
        key: 4
      }, [api_element("input", {
        classMap: {
          "datatable-select-all": true
        },
        attrs: {
          "type": "checkbox",
          "name": $cmp.computedOptionName,
          "id": api_scoped_id("lgt-dt-header-factory-id"),
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable"
        },
        props: {
          "disabled": $cmp.def.isBulkSelectionDisabled
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleSelectAllRows))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("lgt-dt-header-factory-id")}`
        },
        key: 3
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 1
      }, []), api_element("span", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        key: 2
      }, [api_dynamic($cmp.i18n.selectAll)])])]) : null, !$cmp.showCheckbox ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 5
      }, [api_dynamic($cmp.i18n.chooseARow)]) : null])];
    }

    var selectable = lwc.registerTemplate(tmpl$z);
    tmpl$z.stylesheets = [];
    tmpl$z.stylesheetTokens = {
      hostAttribute: "lightning-primitiveHeaderFactory_selectableHeader-host",
      shadowAttribute: "lightning-primitiveHeaderFactory_selectableHeader"
    };

    function stylesheet$6(hostSelector, shadowSelector, nativeShadow) {
      return ".slds-dropdown__list" + shadowSelector + " {max-height: 25rem;overflow-y: auto;}\n";
    }
    var _implicitStylesheets$6 = [stylesheet$6];

    function tmpl$A($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_element("div", {
        className: $cmp.computedClass,
        attrs: {
          "role": "status"
        },
        key: 3
      }, [$cmp.validAlternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 0
      }, [api_dynamic($cmp.alternativeText)]) : null, api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 1
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 2
      }, [])])];
    }

    var _tmpl$n = lwc.registerTemplate(tmpl$A);
    tmpl$A.stylesheets = [];
    tmpl$A.stylesheetTokens = {
      hostAttribute: "lightning-spinner_spinner-host",
      shadowAttribute: "lightning-spinner_spinner"
    };

    /**
     * Displays an animated spinner.
     */

    class LightningSpinner extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.alternativeText = void 0;
        this.size = 'medium';
        this.variant = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-spinner_container');
        this.template.addEventListener('mousewheel', this.stopScrolling);
        this.template.addEventListener('touchmove', this.stopScrolling);
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: 'base',
          validValues: ['base', 'brand', 'inverse']
        });
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: 'medium',
          validValues: ['small', 'medium', 'large']
        });
      }

      get computedClass() {
        const {
          normalizedVariant,
          normalizedSize
        } = this;
        const classes = classSet('slds-spinner'); // add variant-specific class

        if (normalizedVariant !== 'base') {
          classes.add(`slds-spinner_${normalizedVariant}`);
        } // add size-specific class


        classes.add(`slds-spinner_${normalizedSize}`);
        return classes.toString();
      } // alternativeText validation


      get validAlternativeText() {
        const hasAlternativeText = !!this.alternativeText; // if we have an empty value output a console warning

        if (!hasAlternativeText) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-spinner> The alternativeText attribute should not be empty. Please add a description of what is causing the wait.`);
        }

        return hasAlternativeText;
      } // prevent scrolling


      stopScrolling(event) {
        event.preventDefault();
      }

    }

    lwc.registerDecorators(LightningSpinner, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        size: {
          config: 0
        },
        variant: {
          config: 0
        }
      }
    });

    var _lightningSpinner = lwc.registerComponent(LightningSpinner, {
      tmpl: _tmpl$n
    });

    function tmpl$B($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        s: api_slot
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "aria-expanded": $cmp.computedAriaExpanded,
          "title": $cmp.computedTitle,
          "accesskey": $cmp.computedAccessKey,
          "value": $cmp.value,
          "aria-haspopup": "true",
          "type": "button"
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 4,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonClick)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonKeyDown)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleFocus)),
          "mousedown": _m4 || ($ctx._m4 = api_bind($cmp.handleButtonMouseDown))
        }
      }, [$cmp.isDraft ? api_element("abbr", {
        classMap: {
          "slds-indicator_unsaved": true,
          "slds-p-right_xx-small": true
        },
        attrs: {
          "title": $cmp.draftAlternativeText
        },
        key: 0
      }, [api_text("*")]) : null, api_dynamic($cmp.label), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": "slds-button__icon",
          "variant": "bare"
        },
        key: 1
      }, []), $cmp.computedShowDownIcon ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:down",
          "svgClass": "slds-button__icon slds-button__icon_x-small slds-m-left_xx-small",
          "variant": "bare"
        },
        key: 2
      }, []) : null, api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.computedAlternativeText)])]), $cmp._dropdownOpened ? api_element("div", {
        className: $cmp.computedDropdownClass,
        key: 8,
        on: {
          "mousedown": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownMouseDown)),
          "mouseup": _m12 || ($ctx._m12 = api_bind($cmp.handleDropdownMouseUp)),
          "mouseleave": _m13 || ($ctx._m13 = api_bind($cmp.handleDropdownMouseLeave)),
          "scroll": _m14 || ($ctx._m14 = api_bind($cmp.handleDropdownScroll))
        }
      }, [$cmp.isLoading ? api_custom_element("lightning-spinner", _lightningSpinner, {
        props: {
          "size": "small",
          "alternativeText": $cmp.computedLoadingStateAlternativeText
        },
        key: 5
      }, []) : null, !$cmp.isLoading ? api_element("div", {
        classMap: {
          "slds-dropdown__list": true
        },
        attrs: {
          "role": "menu"
        },
        key: 7,
        on: {
          "privateselect": _m5 || ($ctx._m5 = api_bind($cmp.handleMenuItemPrivateSelect)),
          "privateblur": _m6 || ($ctx._m6 = api_bind($cmp.handlePrivateBlur)),
          "privatefocus": _m7 || ($ctx._m7 = api_bind($cmp.handlePrivateFocus)),
          "mouseover": _m8 || ($ctx._m8 = api_bind($cmp.handleMouseOverOnMenuItem)),
          "mouseout": _m9 || ($ctx._m9 = api_bind($cmp.allowBlur)),
          "keydown": _m10 || ($ctx._m10 = api_bind($cmp.handleKeyOnMenuItem))
        }
      }, [api_slot("", {
        key: 6
      }, [], $slotset)]) : null]) : null];
    }

    var _tmpl$o = lwc.registerTemplate(tmpl$B);
    tmpl$B.slots = [""];
    tmpl$B.stylesheets = [];

    if (_implicitStylesheets$6) {
      tmpl$B.stylesheets.push.apply(tmpl$B.stylesheets, _implicitStylesheets$6);
    }
    tmpl$B.stylesheetTokens = {
      hostAttribute: "lightning-buttonMenu_buttonMenu-host",
      shadowAttribute: "lightning-buttonMenu_buttonMenu"
    };

    var labelLoading = 'Loading menu items...';

    var labelShowMenu = 'Show menu';

    /*
     * This is following the practices listed in
     *
     * https://www.w3.org/TR/wai-aria-practices/#menu
     *
     * and
     *
     * https://www.w3.org/TR/wai-aria-practices/#menubutton
     */

    function preventDefaultAndStopPropagation$3(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function moveFocusToTypedCharacters(event, menuInterface) {
      runActionOnBufferedTypedCharacters(event, menuInterface.focusMenuItemWithText);
    }

    function handleKeyDownOnMenuItem(event, menuItemIndex, menuInterface) {
      switch (event.keyCode) {
        // W3: Down Arrow and Up Arrow: move focus to the next and previous items, respectively, optionally
        // wrapping from last to first and vice versa.
        case keyCodes.down:
        case keyCodes.up:
          {
            preventDefaultAndStopPropagation$3(event);
            let nextIndex = event.keyCode === keyCodes.up ? menuItemIndex - 1 : menuItemIndex + 1;
            const totalMenuItems = menuInterface.getTotalMenuItems();

            if (nextIndex >= totalMenuItems) {
              nextIndex = 0;
            } else if (nextIndex < 0) {
              nextIndex = totalMenuItems - 1;
            }

            menuInterface.focusOnIndex(nextIndex);
            break;
          }
        // W3: Home and End: If arrow key wrapping is not supported, move focus to first and last item
        // Note: We do support wrapping, but it doesn't hurt to support these keys anyway.

        case keyCodes.home:
          {
            preventDefaultAndStopPropagation$3(event);
            menuInterface.focusOnIndex(0);
            break;
          }

        case keyCodes.end:
          {
            preventDefaultAndStopPropagation$3(event);
            menuInterface.focusOnIndex(menuInterface.getTotalMenuItems() - 1);
            break;
          }
        // W3: Escape: Close the menu and return focus to the element or context, e.g., menu button or
        // parent menu item, from which the menu was opened
        // Tab: Close the menu and all open parent menus and move focus to the next element in the tab sequence.
        // Note: We don't have to do anything special for Tab because we're not stopping the event, we'll first
        // return the focus and the browser will then handle the tab key default event and will move the focus
        // appropriately. It's handy to return focus for 'Tab' anyway for cases where the menu is in a detached
        // popup (one that's using a panel attached directly to the body).

        case keyCodes.escape:
        case keyCodes.tab:
          {
            // hide menu item list if it is visible
            if (menuInterface.isMenuVisible()) {
              // prevent default escape key action only when menu is visible
              if (event.keyCode === keyCodes.escape) {
                preventDefaultAndStopPropagation$3(event);
              }

              menuInterface.toggleMenuVisibility();
            }

            menuInterface.returnFocus();
            break;
          }

        default:
          // W3: Any key that corresponds to a printable character: Move focus to the next menu item in the
          // current menu whose label begins with that printable character.
          // Note: we actually support a buffer, and in the current implementation it would jump to
          // the first menu item that matches not next.
          moveFocusToTypedCharacters(event, menuInterface);
      }
    }
    function handleKeyDownOnMenuTrigger(event, menuInterface) {
      const isVisible = menuInterface.isMenuVisible();

      switch (event.keyCode) {
        // W3 suggests that opening a menu should place the focus on the first item (as we do with Up/Down),
        // but we're not doing that because it would differ from most of the native menus behaviour.
        case keyCodes.enter:
        case keyCodes.space:
          preventDefaultAndStopPropagation$3(event);
          menuInterface.toggleMenuVisibility();
          break;

        case keyCodes.down:
        case keyCodes.up:
          preventDefaultAndStopPropagation$3(event);

          if (!isVisible) {
            // default to first menu item
            let focusNextIndex = 0; // if key was up-arrow then set to last menu item

            if (event.keyCode === keyCodes.up) {
              focusNextIndex = 'LAST';
            }

            menuInterface.setNextFocusIndex(focusNextIndex);
            menuInterface.toggleMenuVisibility();
          }

          break;
        // W3: Home and End: If arrow key wrapping is not supported, move focus to first and last item
        // Note: We do support wrapping, but it doesn't hurt to support these keys anyway.

        case keyCodes.home:
          preventDefaultAndStopPropagation$3(event);
          menuInterface.focusOnIndex(0);
          break;

        case keyCodes.end:
          preventDefaultAndStopPropagation$3(event);
          menuInterface.focusOnIndex(menuInterface.getTotalMenuItems() - 1);
          break;
        // W3: Escape: Close the menu and return focus to the element or context, e.g., menu button or
        // parent menu item, from which the menu was opened

        case keyCodes.escape:
        case keyCodes.tab:
          if (isVisible) {
            preventDefaultAndStopPropagation$3(event);
            menuInterface.toggleMenuVisibility();
          }

          break;

        default:
          if (!isVisible && menuInterface.showDropdownWhenTypingCharacters) {
            preventDefaultAndStopPropagation$3(event);
            menuInterface.toggleMenuVisibility();
          } else if (!isVisible) {
            break;
          } // eslint-disable-next-line @lwc/lwc/no-async-operation


          window.requestAnimationFrame(() => {
            moveFocusToTypedCharacters(event, menuInterface);
          });
      }
    }

    const i18n$c = {
      loading: labelLoading,
      showMenu: labelShowMenu
    }; // CSS class and selectors for menu items

    const menuItemCSSClassName = 'slds-dropdown__item';
    const menuItemCSSSelector = `.slds-dropdown__list .${menuItemCSSClassName}`;
    const validMenuAlignments = ['left', 'center', 'right', 'bottom-left', 'bottom-center', 'bottom-right']; // remove-next-line-for-c-namespace

    validMenuAlignments.push(...['auto', 'auto-right', 'auto-left']);
    /**
     * Represents a dropdown menu with a list of actions or functions.
     * @slot default Placeholder for menu-item
     */

    class LightningButtonMenu extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.iconSize = 'medium';
        this.iconName = 'utility:down';
        this.value = '';
        this.alternativeText = i18n$c.showMenu;
        this.loadingStateAlternativeText = i18n$c.loading;
        this.label = void 0;
        this.draftAlternativeText = void 0;
        this._accesskey = null;
        this._disabled = false;
        this._dropdownVisible = false;
        this._dropdownOpened = false;
        this._nubbin = false;
        this._title = null;
        this._isDraft = false;
        this._isLoading = false;
        this._focusOnIndexDuringRenderedCallback = null;
        this._tabindex = 0;
        this._order = null;
        this._variant = 'border';
        this._positioning = false;
        this._menuAlignment = 'left';
        this._boundingRect = {};
        this._tooltip = null;
        this._needsFocusAfterRender = false;
      }

      connectedCallback() {
        this._connected = true;
        this.keyboardInterface = this.menuKeyboardInterface();
        this.classList.add('slds-dropdown-trigger', 'slds-dropdown-trigger_click');

        if (this.isDraft) {
          this.classList.add('slds-is-unsaved');
        } // button-group necessities


        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

      renderedCallback() {
        // remove-next-line-for-c-namespace
        this.initTooltip(); // if we are using autopositioning focus happens in its own cycle

        if (!this._positioning && this._dropdownVisible) {
          // logic to focus on first menu item after render
          this.focusOnMenuItemAfterRender();
        }
      }
      /**
       * The variant changes the look of the button.
       * Accepted variants include bare, container, border, border-filled, bare-inverse, and border-inverse.
       * This value defaults to border.
       *
       * @type {string}
       * @default border
       */


      get variant() {
        return this._variant;
      }

      set variant(variant) {
        this._variant = normalizeString(variant, {
          fallbackValue: 'border',
          validValues: ['border', 'border-inverse', 'border-filled', 'bare', 'bare-inverse', 'container']
        });
      }
      /**
       * Determines the alignment of the menu relative to the button.
       * Available options are: auto, left, center, right, bottom-left, bottom-center, bottom-right.
       * The auto option aligns the dropdown menu based on available space.
       * This value defaults to left.
       *
       * @type {string}
       * @default left
       */


      get menuAlignment() {
        return this._menuAlignment;
      }

      set menuAlignment(value) {
        this._menuAlignment = normalizeString(value, {
          fallbackValue: 'left',
          validValues: validMenuAlignments
        });
      }
      /**
       * If present, the menu can be opened by users.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, a nubbin is present on the menu.
       * A nubbin is a stub that protrudes from the menu item towards the button menu.
       * The nubbin position is based on the menu-alignment.
       * @type {boolean}
       * @default false
       */


      get nubbin() {
        return this._nubbin;
      }

      set nubbin(value) {
        this._nubbin = normalizeBoolean(value);
      }
      /**
       * Displays tooltip text when the mouse moves over the button menu.
       * @type {string}
       */


      get title() {
        return this._title;
      }

      set title(newValue) {
        this._title = newValue;
      }
      /**
       * If present, the menu trigger shows a draft indicator.
       * @type {boolean}
       * @default false
       */


      get isDraft() {
        return this._isDraft;
      }

      set isDraft(value) {
        this._isDraft = normalizeBoolean(value);
      }
      /**
       * If present, the menu is in a loading state and shows a spinner.
       * @type {boolean}
       * @default false
       */


      get isLoading() {
        return this._isLoading;
      }

      set isLoading(value) {
        const normalizedValue = normalizeBoolean(value);

        if (this.isAutoAlignment()) {
          // stop previous positioning if any as it maintains old position relationship
          this.stopPositioning();

          if (this._isLoading && !normalizedValue) {
            // was loading before and now is not, we need to reposition
            // remove-next-line-for-c-namespace
            this.startPositioning();
          }
        }

        this._isLoading = normalizedValue;
      }
      /**
       * The keyboard shortcut for the button menu.
       * @type {string}
       */


      get accessKey() {
        return this._accesskey;
      }

      set accessKey(newValue) {
        this._accesskey = newValue;
      }
      /**
       * Text to display when the user mouses over or focuses on the button.
       * The tooltip is auto-positioned relative to the button and screen space.
       * @type {string}
       */
      // remove-next-line-for-c-namespace


      get tooltip() {
        return this._tooltip ? this._tooltip.value : undefined;
      } // remove-next-line-for-c-namespace


      set tooltip(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button')
          });

          this._tooltip.initialize();
        }
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        if (this._connected) {
          this.focusOnButton();
        }
      }
      /**
       * Clicks the button.
       */


      click() {
        if (this._connected) {
          this.template.querySelector('button').click();
        }
      }

      get computedAriaExpanded() {
        return String(this._dropdownVisible); // default value must be a string for the attribute to always be present with a string value
      } // remove-next-line-for-c-namespace


      initTooltip() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      focusOnMenuItemAfterRender() {
        // if no menu items are focused then set focus on the first or last one once registered
        // :: this can occur if there's a delay in loading the menu items (loading from server for example)
        // :: revealing the menu in an empty state to later have menu items loaded
        let focusOnIndex = this._focusOnIndexDuringRenderedCallback || 0; // if focus index is greater than the size of the list,
        // or next focus should be on LAST,
        // set to the last item

        const menuItems = this.getMenuItems(); // if specified as 'LAST' set it to a valid numeric value instead

        if (focusOnIndex === 'LAST') {
          focusOnIndex = menuItems.length - 1; // maintain 'LAST' value if menu items aren't available yet

          if (focusOnIndex < 0) {
            focusOnIndex = 'LAST';
          }
        } // only perform operations when we have a valid numeric index


        if (focusOnIndex !== 'LAST') {
          if (focusOnIndex > menuItems.length - 1 && menuItems.length > 0) {
            focusOnIndex = menuItems.length - 1;
          } // set the focus


          this.focusOnMenuItem(focusOnIndex); // reset tracker value

          this._focusOnIndexDuringRenderedCallback = null;
        }
      }

      get computedAccessKey() {
        return this._accesskey;
      }

      get computedTitle() {
        return this._title;
      }

      get computedAlternativeText() {
        return this.alternativeText || i18n$c.showMenu;
      }

      get computedLoadingStateAlternativeText() {
        return this.loadingStateAlternativeText || i18n$c.loading;
      }

      get computedButtonClass() {
        const isDropdownIcon = !this.computedShowDownIcon;
        const isBare = this.variant === 'bare' || this.variant === 'bare-inverse';
        const classes = classSet('slds-button');

        if (this.label) {
          classes.add({
            'slds-button_neutral': this.variant === 'border' && isDropdownIcon,
            'slds-button_inverse': this.variant === 'border-inverse'
          });
        } else {
          // The inverse check is to allow for a combination of a non-default icon and an -inverse variant
          const useMoreContainer = this.variant === 'container' || this.variant === 'bare-inverse' || this.variant === 'border-inverse';
          classes.add({
            'slds-button_icon': !isDropdownIcon,
            'slds-button_icon-bare': isBare,
            'slds-button_icon-more': !useMoreContainer && !isDropdownIcon,
            'slds-button_icon-container-more': useMoreContainer && !isDropdownIcon,
            'slds-button_icon-container': this.variant === 'container' && isDropdownIcon,
            'slds-button_icon-border': this.variant === 'border' && isDropdownIcon,
            'slds-button_icon-border-filled': this.variant === 'border-filled',
            'slds-button_icon-border-inverse': this.variant === 'border-inverse',
            'slds-button_icon-inverse': this.variant === 'bare-inverse',
            'slds-button_icon-xx-small': this.iconSize === 'xx-small' && !isBare,
            'slds-button_icon-x-small': this.iconSize === 'x-small' && !isBare,
            'slds-button_icon-small': this.iconSize === 'small' && !isBare
          });
        }

        return classes.add({
          // order classes when part of a button-group
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedShowDownIcon() {
        return !(this.iconName === 'utility:down' || this.iconName === 'utility:chevrondown');
      }

      get computedDropdownClass() {
        return classSet('slds-dropdown').add({
          'slds-dropdown_left': this.menuAlignment === 'left' || this.isAutoAlignment(),
          'slds-dropdown_center': this.menuAlignment === 'center',
          'slds-dropdown_right': this.menuAlignment === 'right',
          'slds-dropdown_bottom': this.menuAlignment === 'bottom-center',
          'slds-dropdown_bottom slds-dropdown_right slds-dropdown_bottom-right': this.menuAlignment === 'bottom-right',
          'slds-dropdown_bottom slds-dropdown_left slds-dropdown_bottom-left': this.menuAlignment === 'bottom-left',
          'slds-nubbin_top-left': this.nubbin && this.menuAlignment === 'left',
          'slds-nubbin_top-right': this.nubbin && this.menuAlignment === 'right',
          'slds-nubbin_top': this.nubbin && this.menuAlignment === 'center',
          'slds-nubbin_bottom-left': this.nubbin && this.menuAlignment === 'bottom-left',
          'slds-nubbin_bottom-right': this.nubbin && this.menuAlignment === 'bottom-right',
          'slds-nubbin_bottom': this.nubbin && this.menuAlignment === 'bottom-center',
          'slds-p-vertical_large': this.isLoading
        }).toString();
      }

      handleMenuItemPrivateSelect(event) {
        if (this._dropdownVisible) {
          this.toggleMenuVisibility();
          this.focusOnButton();
        }

        event.stopPropagation();
        this.dispatchSelect(event);
      }

      dispatchSelect(event) {
        this.dispatchEvent(new CustomEvent('select', {
          cancelable: true,
          detail: {
            value: event.detail.value // pass value through from original private event

          }
        }));
      }

      handleButtonClick() {
        this.allowBlur();
        this.toggleMenuVisibility(); // Focus on the button even if the browser doesn't do it by default
        // (the behaviour differs between Chrome, Safari, Firefox)

        this.focusOnButton();
      }

      handleButtonKeyDown(event) {
        handleKeyDownOnMenuTrigger(event, this.keyboardInterface);
      }

      handleButtonMouseDown(event) {
        const mainButton = 0;

        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }

      handleDropdownMouseDown(event) {
        // if the menu contais a scrollbar due to large number of menu-items
        // this is needed so that menu doesnt close on dragging the scrollbar with the mouse
        const mainButton = 0;

        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }

      handleDropdownMouseUp() {
        // We need this to make sure that if a scrollbar is being dragged with the mouse, upon release
        // of the drag we allow blur, otherwise the dropdown would not close on blur since we'd have cancel blur
        // set
        this.allowBlur();
      }

      handleDropdownMouseLeave() {
        // this is to close the menu after mousedown happens on scrollbar
        // in this case we close immediately if no menu-items were hovered/focused
        // without this the menu would remain open since the blur on the menuitems has happened already
        // when clicking the scrollbar
        if (!this._menuHasFocus) {
          this.close();
        }
      }

      handleDropdownScroll(event) {
        // We don't want this to bubble up to the modal which due to event retargeting wouldn't be able
        // to know what is actually being scrolled and thus may lead to the scrolling of the modal
        event.stopPropagation();
      }

      focusOnButton() {
        this.template.querySelector('button').focus();
      }

      focusOnMenuItem(itemIndex) {
        if (this._dropdownVisible) {
          const menuItem = this.getMenuItemByIndex(itemIndex);
          this.cancelBlurAndFocusOnMenuItem(menuItem);
        }
      }

      isAutoAlignment() {
        return this.menuAlignment.startsWith('auto');
      } // remove-next-line-for-c-namespace


      startPositioning() {
        if (!this.isAutoAlignment()) {
          return;
        }

        this._positioning = true;
        const align = {
          horizontal: Direction.Left,
          vertical: Direction.Top
        };
        const targetAlign = {
          horizontal: Direction.Left,
          vertical: Direction.Bottom
        };
        let autoFlip = true;
        let autoFlipVertical;

        if (this.menuAlignment === 'auto-right') {
          align.horizontal = Direction.Right;
          targetAlign.horizontal = Direction.Right;
        }

        if (this.menuAlignment === 'auto-right' || this.menuAlignment === 'auto-left') {
          autoFlip = false;
          autoFlipVertical = true;
        } // eslint-disable-next-line @lwc/lwc/no-async-operation


        requestAnimationFrame(() => {
          this.stopPositioning();
          this._autoPosition = startPositioning(this, {
            target: () => this.template.querySelector('button'),
            element: () => this.template.querySelector('.slds-dropdown'),
            align,
            targetAlign,
            autoFlip,
            autoFlipVertical
          });
        }); // focus on the first item in next cycle
        // Use a flag to prevent this async function from executing multiple times in a single lifecycle
        // TODO: add reason why we need to dedupe

        this._needsFocusAfterRender = true; // eslint-disable-next-line @lwc/lwc/no-async-operation

        setTimeout(() => {
          this._positioning = false;

          if (this._needsFocusAfterRender) {
            this.focusOnMenuItemAfterRender();
            this._needsFocusAfterRender = false;
          }
        }, 0);
      } // remove-next-line-for-c-namespace


      stopPositioning() {
        if (this._autoPosition) {
          stopPositioning(this._autoPosition);
          this._autoPosition = null;
        }

        this._positioning = false;
      }

      toggleMenuVisibility() {
        if (!this.disabled) {
          this._dropdownVisible = !this._dropdownVisible;

          if (!this._dropdownOpened && this._dropdownVisible) {
            this._dropdownOpened = true;
          }

          if (this._dropdownVisible) {
            // remove-next-line-for-c-namespace
            this.startPositioning();
            this.dispatchEvent(new CustomEvent('open')); // update the bounding rect when the menu is toggled

            this._boundingRect = this.getBoundingClientRect();
            this.pollBoundingRect();
          } else {
            // remove-next-line-for-c-namespace
            this.stopPositioning();
          }

          this.classList.toggle('slds-is-open');
        }
      }

      getMenuItems() {
        return Array.from(this.querySelectorAll(menuItemCSSSelector));
      }

      getMenuItemByIndex(index) {
        return this.getMenuItems()[index];
      }

      findMenuItemIndex(menuItemElement) {
        return this.getMenuItems().indexOf(menuItemElement);
      }

      findMenuItemFromEventTarget(element) {
        let currentNode = element;
        const stopAtElement = this.template.querySelector("[role='menu']");

        while (currentNode !== stopAtElement) {
          if (currentNode.classList && currentNode.classList.contains(menuItemCSSClassName)) {
            return currentNode;
          }

          if (currentNode.parentNode) {
            currentNode = currentNode.parentNode;
          } else {
            return null;
          }
        }

        return null;
      }

      handleKeyOnMenuItem(event) {
        const menuItem = this.findMenuItemFromEventTarget(event.target);

        if (menuItem) {
          handleKeyDownOnMenuItem(event, this.findMenuItemIndex(menuItem), this.keyboardInterface);
        }
      }

      handleMouseOverOnMenuItem(event) {
        const menuItem = this.findMenuItemFromEventTarget(event.target);

        if (menuItem) {
          const menuItemIndex = this.findMenuItemIndex(menuItem);
          this.focusOnMenuItem(menuItemIndex);
        }
      }

      cancelBlurAndFocusOnMenuItem(menuItem) {
        if (menuItem) {
          // prevent blur during a non-blurring focus change
          // set lock so that while focusing on menutitem, menu doesnt close
          this.cancelBlur();
          menuItem.focus();
        } // allowBlur is called when the menu items receives focus

      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handlePrivateBlur(event) {
        // The event may be synthetic from the menu items
        event.stopPropagation(); // perform common blurring behavior

        this.handleBlur();
        this._menuHasFocus = false;
      }

      handlePrivateFocus(event) {
        // synthetic from the menu items
        event.stopPropagation(); // reset the cancelBlur so any clicks outside the menu can now close the menu

        this.allowBlur();
        this._menuHasFocus = true;
      }

      handleBlur() {
        // Don't handle the blur event if the focus events are inside the menu (see the cancelBlur/allowBlur functions)
        if (this._cancelBlur) {
          return;
        } // Hide only when the focus moved away from the container


        if (this._dropdownVisible) {
          this.toggleMenuVisibility();
        } // dispatch standard blur event


        this.dispatchEvent(new CustomEvent('blur'));
      }

      allowBlur() {
        this._cancelBlur = false;
      }

      cancelBlur() {
        this._cancelBlur = true;
      }

      menuKeyboardInterface() {
        const that = this;
        return {
          getTotalMenuItems() {
            return that.getMenuItems().length;
          },

          focusOnIndex(index) {
            that.focusOnMenuItem(index);
          },

          setNextFocusIndex(index) {
            that._focusOnIndexDuringRenderedCallback = index;
          },

          returnFocus() {
            that.focusOnButton();
          },

          isMenuVisible() {
            return that._dropdownVisible;
          },

          toggleMenuVisibility() {
            that.toggleMenuVisibility();
          },

          focusMenuItemWithText(text) {
            const match = [...that.getMenuItems()].filter(menuItem => {
              const label = menuItem.label;
              return label && label.toLowerCase().indexOf(text) === 0;
            });

            if (match.length > 0) {
              that.focusOnMenuItem(match[0]);
            }
          }

        };
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * {Function} close - Closes the dropdown if it's open
       */


      close() {
        // should only do something if dropdown is visible
        if (this._dropdownVisible) {
          this.toggleMenuVisibility();
        }
      }
      /**
       * Poll for change in bounding rectangle
       * only if it is menuAlignment=auto since that is
       * position:fixed and is opened
       */


      pollBoundingRect() {
        // only poll if the dropdown is auto aligned
        if (this.isAutoAlignment() && this._dropdownVisible) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            if (this._connected) {
              observePosition(this, 300, this._boundingRect, () => {
                this.close();
              }); // continue polling

              this.pollBoundingRect();
            }
          }, 250 // check every 0.25 second
          );
        }
      }

    }

    LightningButtonMenu.delegatesFocus = true;

    lwc.registerDecorators(LightningButtonMenu, {
      publicProps: {
        iconSize: {
          config: 0
        },
        iconName: {
          config: 0
        },
        value: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        loadingStateAlternativeText: {
          config: 0
        },
        label: {
          config: 0
        },
        draftAlternativeText: {
          config: 0
        },
        variant: {
          config: 3
        },
        menuAlignment: {
          config: 3
        },
        disabled: {
          config: 3
        },
        nubbin: {
          config: 3
        },
        title: {
          config: 3
        },
        isDraft: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        tooltip: {
          config: 3
        }
      },
      publicMethods: ["focus", "click"],
      track: {
        _accesskey: 1,
        _disabled: 1,
        _dropdownVisible: 1,
        _dropdownOpened: 1,
        _nubbin: 1,
        _title: 1,
        _isDraft: 1,
        _isLoading: 1,
        _focusOnIndexDuringRenderedCallback: 1,
        _tabindex: 1,
        _order: 1,
        _variant: 1
      },
      fields: ["_positioning", "_menuAlignment", "_boundingRect", "_tooltip", "_needsFocusAfterRender"]
    });

    var _lightningButtonMenu = lwc.registerComponent(LightningButtonMenu, {
      tmpl: _tmpl$o
    });

    function stylesheet$7(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$7 = [stylesheet$7];

    function tmpl$C($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        t: api_text,
        h: api_element,
        d: api_dynamic,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("a", {
        attrs: {
          "href": $cmp.computedHref,
          "role": $cmp.computedRole,
          "tabindex": api_tab_index($cmp.computedTabIndex),
          "accesskey": $cmp.computedAccessKey,
          "aria-checked": $cmp.computedAriaChecked,
          "aria-disabled": $cmp.computedAriaDisabled,
          "download": $cmp.download
        },
        key: 5,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "keydown": _m2 || ($ctx._m2 = api_bind($cmp.handleKeyDown)),
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleBlur))
        }
      }, [api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        key: 3
      }, [$cmp.isMenuItemCheckbox ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:check",
          "size": "x-small",
          "svgClass": $cmp.computedCheckedIconClass,
          "variant": "bare"
        },
        key: 0
      }, []) : null, $cmp.isDraft ? api_element("abbr", {
        classMap: {
          "slds-indicator_unsaved": true
        },
        attrs: {
          "title": $cmp.draftAlternativeText
        },
        key: 1
      }, [api_text("*")]) : null, $cmp.prefixIconName ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.prefixIconName,
          "size": "x-small",
          "svgClass": "slds-icon slds-icon_x-small slds-icon-text-default slds-m-right_x-small",
          "variant": "bare"
        },
        key: 2
      }, []) : null, api_dynamic($cmp.label)]), $cmp.iconName ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "size": "x-small",
          "svgClass": "slds-icon-text-default slds-m-left_small slds-shrink-none",
          "variant": "bare"
        },
        key: 4
      }, []) : null])];
    }

    var _tmpl$p = lwc.registerTemplate(tmpl$C);
    tmpl$C.stylesheets = [];

    if (_implicitStylesheets$7) {
      tmpl$C.stylesheets.push.apply(tmpl$C.stylesheets, _implicitStylesheets$7);
    }
    tmpl$C.stylesheetTokens = {
      hostAttribute: "lightning-menuItem_menuItem-host",
      shadowAttribute: "lightning-menuItem_menuItem"
    };

    /**
     * Represents a list item in a menu.
     */

    class LightningMenuItem extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.label = void 0;
        this.iconName = void 0;
        this.download = void 0;
        this._accesskey = null;
        this._disabled = false;
        this._tabindex = '-1';
        this._checked = undefined;
        this._isDraft = false;
        this.prefixIconName = void 0;
        this.href = void 0;
        this.draftAlternativeText = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-dropdown__item');
        this.setAttribute('role', 'presentation');
      }
      /**
       * If present, a draft indicator is shown on the menu item.
       * A draft indicator is denoted by blue asterisk on the left of the menu item.
       * When you use a draft indicator, include alternative text for accessibility using draft-alternative-text.
       * @type {boolean}
       * @default false
       */


      get isDraft() {
        return this._isDraft;
      }

      set isDraft(value) {
        this._isDraft = normalizeBoolean(value);
      }
      /**
       * The keyboard shortcut for the menu item.
       * @type {string}
       */


      get accessKey() {
        return this._accesskey;
      }

      set accessKey(newValue) {
        this._accesskey = newValue;
        this.handleAccessKeyChange(newValue);
      }
      /**
       * Reserved for internal use. Use tabindex instead to indicate if an element should be focusable.
       * tabindex can be set to 0 or -1.
       * The default tabindex value is 0, which means that the menu item is focusable and
       * participates in sequential keyboard navigation. The value -1 means
       * that the menu item is focusable but does not participate in keyboard navigation.
       * @type {number}
       */


      get tabIndex() {
        return this._tabindex;
      }

      set tabIndex(newValue) {
        this._tabindex = newValue;
        this.handleTabIndexChange(newValue);
      }

      handleAccessKeyChange(value) {
        this._accesskey = value;
      }

      handleTabIndexChange(value) {
        this._tabindex = value;
      }

      get computedAccessKey() {
        return this._accesskey;
      }

      get computedTabIndex() {
        return this._tabindex;
      }
      /**
       * If present, the menu item is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, a check mark displays on the left of the menu item if it's selected.
       * @type {boolean}
       * @default false
       */


      get checked() {
        return this._checked;
      }

      set checked(value) {
        if (typeof value === 'string') {
          // handle string
          value = normalizeString(value, {
            fallbackValue: undefined,
            validValues: ['true', 'false']
          });

          if (value !== undefined) {
            value = value === 'true';
          }
        }

        if (value !== undefined) {
          // handle boolean which is from above or user
          value = normalizeBoolean(value);
        }

        this._checked = value;
        this.classList.toggle('slds-is-selected', this.checked === true);
      }

      get computedCheckedIconClass() {
        // note that what .slds-icon_selected does is to hide the checked icon
        return classSet('slds-icon slds-icon_x-small slds-icon-text-default slds-m-right_x-small').add({
          'slds-icon_selected': !this.checked
        }).toString();
      }

      get computedHref() {
        // eslint-disable-next-line no-script-url
        return this.href ? this.href : 'javascript:void(0)';
      }

      get computedAriaChecked() {
        return this.isMenuItemCheckbox ? this.checked + '' : null;
      }

      get computedAriaDisabled() {
        // Note: Needed to explicitly set aria-disabled="true"
        return this.disabled ? 'true' : 'false';
      }

      get isMenuItemCheckbox() {
        return this.checked !== undefined;
      }

      get computedRole() {
        return this.isMenuItemCheckbox ? 'menuitemcheckbox' : 'menuitem';
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur')); // we need to trigger a private blur to make it bubble and be handled by parent button-menu

        this.dispatchEvent(new CustomEvent('privateblur', {
          composed: true,
          bubbles: true,
          cancelable: true
        }));
      }

      handleFocus() {
        // trigger a private focus to make it bubble and be handled by parent button-menu
        // this is used for resetting cancelBlur in button-menu
        this.dispatchEvent(new CustomEvent('privatefocus', {
          bubbles: true,
          cancelable: true
        }));
      }

      handleClick(event) {
        // no action needed when item is disabled
        if (this.disabled) {
          event.preventDefault(); // do nothing and return

          return;
        } // allow HREF to be followed


        if (this.href) ; else {
          event.preventDefault();
          this.dispatchSelect();
        }
      }

      handleKeyDown(event) {
        // no action needed when item is disabled
        if (this.disabled) {
          // do nothing and return
          return;
        }

        if (event.keyCode === keyCodes.space) {
          // follow HREF if a value was provided
          if (this.href) {
            // trigger click behavior
            this.template.querySelector('a').click();
          } else {
            // if no HREF is provided follow usual select behavior
            this.dispatchSelect();
          }
        }
      }
      /**
       *
       * The select event is a non-navigational event.
       * The purpose of the event is to toggle the selected state of a menu item.
       * It will not be dispatched if a menu item has an HREF value to navigate to (other than the default).
       * This event will be handled by the parent button-menu component.
       *
       **/


      dispatchSelect() {
        if (!this.disabled) {
          this.dispatchEvent(new CustomEvent('privateselect', {
            bubbles: true,
            cancelable: true,
            detail: {
              value: this.value
            }
          }));
        }
      }
      /**
       * Sets focus on the anchor element in the menu item.
       */


      focus() {
        // set the focus on the anchor element
        this.template.querySelector('a').focus(); // dispatch a focus event for the menu item component

        this.dispatchEvent(new CustomEvent('focus'));
      }

    }

    lwc.registerDecorators(LightningMenuItem, {
      publicProps: {
        value: {
          config: 0
        },
        label: {
          config: 0
        },
        iconName: {
          config: 0
        },
        download: {
          config: 0
        },
        prefixIconName: {
          config: 0
        },
        href: {
          config: 0
        },
        draftAlternativeText: {
          config: 0
        },
        isDraft: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        tabIndex: {
          config: 3
        },
        disabled: {
          config: 3
        },
        checked: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _accesskey: 1,
        _disabled: 1,
        _tabindex: 1,
        _checked: 1,
        _isDraft: 1
      }
    });

    var _lightningMenuItem = lwc.registerComponent(LightningMenuItem, {
      tmpl: _tmpl$p
    });

    function stylesheet$8(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$8 = [stylesheet$8];

    function tmpl$D($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var _tmpl$q = lwc.registerTemplate(tmpl$D);
    tmpl$D.stylesheets = [];

    if (_implicitStylesheets$8) {
      tmpl$D.stylesheets.push.apply(tmpl$D.stylesheets, _implicitStylesheets$8);
    }
    tmpl$D.stylesheetTokens = {
      hostAttribute: "lightning-menuDivider_menuDivider-host",
      shadowAttribute: "lightning-menuDivider_menuDivider"
    };

    class LightningMenuDivider extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._variant = 'standard';
      }

      connectedCallback() {
        this.setAttribute('role', 'separator');
        this.updateClass();
      }

      updateClass() {
        classListMutation(this.classList, {
          'slds-has-divider_top-space': this.variant === 'standard',
          'slds-has-divider_top': this.variant === 'compact'
        });
      }

      get variant() {
        return this._variant;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: 'standard',
          validValues: ['standard', 'compact']
        });
        this.updateClass();
      }

    }

    lwc.registerDecorators(LightningMenuDivider, {
      publicProps: {
        variant: {
          config: 3
        }
      },
      track: {
        _variant: 1
      }
    });

    var _lightningMenuDivider = lwc.registerComponent(LightningMenuDivider, {
      tmpl: _tmpl$q
    });

    function tmpl$E($api, $cmp, $slotset, $ctx) {
      const {
        k: api_key,
        c: api_custom_element,
        i: api_iterator,
        f: api_flatten,
        gid: api_scoped_id,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [$cmp.hasActions ? api_custom_element("lightning-button-menu", _lightningButtonMenu, {
        classMap: {
          "slds-th__action-button": true
        },
        styleMap: {
          "zIndex": "1"
        },
        props: {
          "id": api_scoped_id("primitive-header-action-button-menu-id"),
          "iconSize": "x-small",
          "menuAlignment": $cmp.computedMenuAlignment,
          "alternativeText": $cmp.i18n.showActions,
          "variant": "bare",
          "iconName": "utility:chevrondown"
        },
        key: 3,
        on: {
          "open": _m0 || ($ctx._m0 = api_bind($cmp.handleMenuOpen)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleActionSelect))
        }
      }, api_flatten([api_iterator($cmp.state.internalActions, function (action, actionIndex) {
        return api_custom_element("lightning-menu-item", _lightningMenuItem, {
          props: {
            "value": action,
            "label": action.label,
            "iconName": action.iconName,
            "disabled": action.disabled,
            "checked": action.checked
          },
          key: api_key(0, action.label)
        }, []);
      }), $cmp.hasActionsDivider ? api_custom_element("lightning-menu-divider", _lightningMenuDivider, {
        key: 1
      }, []) : null, api_iterator($cmp.state.customerActions, function (action, actionIndex) {
        return api_custom_element("lightning-menu-item", _lightningMenuItem, {
          props: {
            "value": action,
            "label": action.label,
            "iconName": action.iconName,
            "disabled": action.disabled,
            "checked": action.checked
          },
          key: api_key(2, action.label)
        }, []);
      })])) : null];
    }

    var _tmpl$r = lwc.registerTemplate(tmpl$E);
    tmpl$E.stylesheets = [];
    tmpl$E.stylesheetTokens = {
      hostAttribute: "lightning-primitiveHeaderActions_primitiveHeaderActions-host",
      shadowAttribute: "lightning-primitiveHeaderActions_primitiveHeaderActions"
    };

    var labelClipText = 'Clip text';

    var labelShowActions = 'Show actions';

    var labelWrapText = 'Wrap text';

    const i18n$d = {
      clipText: labelClipText,
      showActions: labelShowActions,
      wrapText: labelWrapText
    };

    class PrimitiveHeaderActions extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.colKeyValue = void 0;
        this.containerRect = void 0;
        this.state = {
          internalActions: [],
          customerActions: []
        };
      }

      focus() {
        const btnMenu = this.template.querySelector('lightning-button-menu');

        if (btnMenu) {
          btnMenu.focus();
        }
      }

      get actions() {
        return this._actions;
      }

      set actions(value) {
        this._actions = value;
        this.updateActions();
      }

      get i18n() {
        return i18n$d;
      }

      get computedMenuAlignment() {
        return this.state.actionMenu.menuAlignment;
      }

      updateActions() {
        const actionTypeReducer = type => (actions, action) => {
          const overrides = {
            _type: type,
            _action: action
          };
          actions.push(Object.assign({}, action, overrides));
          return actions;
        };

        this.state.internalActions = this.getActionsByType('internalActions').reduce(actionTypeReducer('internal'), []);
        this.state.customerActions = this.getActionsByType('customerActions').reduce(actionTypeReducer('customer'), []);
        this.state.actionMenu = {
          menuAlignment: this._actions.menuAlignment
        };
      }

      get hasActions() {
        return this.state.internalActions.length > 0 || this.state.customerActions.length > 0;
      }

      get hasActionsDivider() {
        return this.state.internalActions.length > 0 && this.state.customerActions.length > 0;
      }

      getActionsByType(type) {
        return Array.isArray(this._actions[type]) ? this._actions[type] : [];
      }

      handleMenuOpen(event) {
        event.preventDefault();
        event.stopPropagation();
        this.elementRect = this.template.querySelector('lightning-button-menu').getBoundingClientRect();
        this.dispatchEvent(new CustomEvent('privatecellheaderactionmenuopening', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            saveContainerPosition: containerRect => {
              this.containerRect = containerRect;
            }
          }
        }));
      }

      handleActionSelect(evt) {
        const action = evt.detail.value;
        this.dispatchEvent(new CustomEvent('privatecellheaderactiontriggered', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            action: deepCopy(action._action),
            actionType: action._type,
            colKeyValue: this.colKeyValue
          }
        }));
      }

    }

    PrimitiveHeaderActions.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveHeaderActions, {
      publicProps: {
        colKeyValue: {
          config: 0
        },
        actions: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        containerRect: 1,
        state: 1
      }
    });

    var _lightningPrimitiveHeaderActions = lwc.registerComponent(PrimitiveHeaderActions, {
      tmpl: _tmpl$r
    });

    function stylesheet$9(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$9 = [stylesheet$9];

    function tmpl$F($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("input", {
        classMap: {
          "slds-resizable__input": true,
          "slds-assistive-text": true
        },
        attrs: {
          "type": "range",
          "min": $cmp.minWidth,
          "max": $cmp.maxWidth,
          "aria-label": $cmp.resizerLabel
        },
        props: {
          "value": $cmp.value
        },
        key: 0,
        on: {
          "keydown": _m0 || ($ctx._m0 = api_bind($cmp.handleKeydown))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-resizable__handle": true
        },
        styleMap: {
          "willChange": "transform"
        },
        key: 2,
        on: {
          "mousedown": _m1 || ($ctx._m1 = api_bind($cmp.onStart)),
          "click": _m2 || ($ctx._m2 = api_bind($cmp.onClick))
        }
      }, [api_element("span", {
        classMap: {
          "slds-resizable__divider": true
        },
        key: 1
      }, [])])];
    }

    var _tmpl$s = lwc.registerTemplate(tmpl$F);
    tmpl$F.stylesheets = [];

    if (_implicitStylesheets$9) {
      tmpl$F.stylesheets.push.apply(tmpl$F.stylesheets, _implicitStylesheets$9);
    }
    tmpl$F.stylesheetTokens = {
      hostAttribute: "lightning-primitiveResizeHandler_primitiveResizeHandler-host",
      shadowAttribute: "lightning-primitiveResizeHandler_primitiveResizeHandler"
    };

    var labelColumnWidth = 'column width';

    const i18n$e = {
      columnWidth: labelColumnWidth
    };

    class PrimitiveResizeHandler extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.minWidth = 0;
        this.maxWidth = 1000;
        this.label = '';
        this.colIndex = void 0;
        this.internalTabIndex = void 0;
        this.step = 10;
        this.value = void 0;
        this.state = {};
      }

      get resizerLabel() {
        const label = this.label || '';
        return `${label} ${i18n$e.columnWidth}`;
      }

      get resizeElement() {
        return this.template.querySelector('.slds-resizable__handle');
      }

      focus() {
        const inputEle = this.template.querySelector('input');

        if (inputEle) {
          inputEle.focus();
        }
      }

      onClick(event) {
        // capture the click event on button, to prevent the sorting of the column
        this.preventDefaultAndStopPropagation(event);
      }

      onStart(event) {
        // prevent selecting text when mouse down
        event.returnValue = false;
        this.preventDefaultAndStopPropagation(event);
        const headerClientWidth = this.value;
        this.lowRange = this.minWidth - headerClientWidth;
        this.highRange = this.maxWidth - headerClientWidth;
        this.startX = event.pageX;
        this.currentX = this.startX;
        this.touchingResizer = true;
        document.body.addEventListener('mousemove', this.onMove.bind(this));
        document.body.addEventListener('mouseup', this.onEnd.bind(this));
        document.body.addEventListener('mouseleave', this.onEnd.bind(this)); // eslint-disable-next-line @lwc/lwc/no-async-operation

        requestAnimationFrame(this.resizing.bind(this));
      }

      onMove(event) {
        if (!this.touchingResizer) {
          return;
        }

        this.currentX = event.pageX;
      } // eslint-disable-next-line no-unused-vars


      onEnd(event) {
        if (!this.touchingResizer) {
          return;
        }

        this.touchingResizer = false;
        document.body.removeEventListener('mousemove', this.onMove.bind(this));
        document.body.removeEventListener('mouseup', this.onEnd.bind(this));
        document.body.removeEventListener('mouseleave', this.onEnd.bind(this)); // Resize happens in the opposite direction in RTL

        const translateX = document.dir === 'rtl' ? this.startX - this.currentX : this.currentX - this.startX;
        this.resizeElement.style.transform = '';
        this.fireResizeEvent(translateX);
      }

      resizing() {
        if (!this.touchingResizer) {
          return;
        } // eslint-disable-next-line @lwc/lwc/no-async-operation


        requestAnimationFrame(this.resizing.bind(this));
        const translateX = this.currentX - this.startX;

        if (this.lowRange === undefined || translateX >= this.lowRange && translateX <= this.highRange) {
          this.resizeElement.style.transform = `translateX(${translateX}px)`;
        }
      }

      preventDefaultAndStopPropagation(event) {
        event.preventDefault();
        event.stopPropagation();
      }

      handleKeydown(event) {
        switch (event.keyCode) {
          case keyCodes.left:
            this.preventDefaultAndStopPropagation(event);
            this.fireResizeEvent(isRTL() ? this.step : 0 - this.step);
            break;

          case keyCodes.right:
            this.preventDefaultAndStopPropagation(event);
            this.fireResizeEvent(isRTL() ? 0 - this.step : this.step);
            break;

          case keyCodes.up:
          case keyCodes.down:
          case keyCodes.enter:
          case keyCodes.space:
            this.preventDefaultAndStopPropagation(event);
            break;
        }
      }

      fireResizeEvent(widthDelta) {
        const actionName = 'resizecol'; // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments

        const actionEvent = new CustomEvent(actionName, {
          bubbles: true,
          composed: true,
          detail: {
            colIndex: this.colIndex,
            widthDelta
          }
        });
        this.dispatchEvent(actionEvent);
      }

    }

    PrimitiveResizeHandler.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveResizeHandler, {
      publicProps: {
        minWidth: {
          config: 0
        },
        maxWidth: {
          config: 0
        },
        label: {
          config: 0
        },
        colIndex: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        },
        step: {
          config: 0
        },
        value: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      }
    });

    var _lightningPrimitiveResizeHandler = lwc.registerComponent(PrimitiveResizeHandler, {
      tmpl: _tmpl$s
    });

    function tmpl$G($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("span", {
        className: $cmp.computedClass,
        style: $cmp.columnStyles,
        attrs: {
          "tabindex": api_tab_index($cmp.internalTabIndex)
        },
        key: 11
      }, [api_element("a", {
        className: $cmp.computedSortClass,
        style: $cmp.columnStyles,
        attrs: {
          "href": "javascript:void(0);",
          "role": $cmp.headerRole,
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable",
          "data-action-triggers": "enter"
        },
        key: 7,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleSortingClick))
        }
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 0
      }, [api_dynamic($cmp.i18n.sort)]), $cmp.def.iconName ? api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-grid_vertical-align-center": true,
          "slds-has-flexi-truncate": true
        },
        key: 4
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-m-right_xx-small": true
        },
        props: {
          "iconName": $cmp.def.iconName,
          "size": "x-small"
        },
        key: 1
      }, []), api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.label
        },
        key: 2
      }, [api_dynamic($cmp.def.label)]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true
        },
        props: {
          "svgClass": "slds-icon slds-icon-text-default slds-is-sortable__icon",
          "iconName": "utility:arrowdown",
          "size": "x-small"
        },
        key: 3
      }, [])]) : null, !$cmp.def.iconName ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.label
        },
        key: 5
      }, [api_dynamic($cmp.def.label)]) : null, !$cmp.def.iconName ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true
        },
        props: {
          "svgClass": "slds-icon slds-icon-text-default slds-is-sortable__icon",
          "iconName": "utility:arrowdown",
          "size": "x-small"
        },
        key: 6
      }, []) : null]), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "aria-live": "assertive",
          "aria-atomic": "true"
        },
        key: 8
      }, [api_dynamic($cmp.sortedOrderLabel)]), $cmp.hasActions ? api_custom_element("lightning-primitive-header-actions", _lightningPrimitiveHeaderActions, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "colKeyValue": $cmp.def.colKeyValue,
          "actions": $cmp.actions,
          "tabIndex": api_tab_index($cmp.state.internalTabIndex)
        },
        key: 9
      }, []) : null, $cmp.isResizable ? api_custom_element("lightning-primitive-resize-handler", _lightningPrimitiveResizeHandler, {
        classMap: {
          "slds-resizable": true
        },
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "value": $cmp.columnWidth,
          "minWidth": $cmp.def.minWidth,
          "maxWidth": $cmp.def.maxWidth,
          "internalTabIndex": $cmp.internalTabIndex,
          "label": $cmp.def.label,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "colIndex": $cmp.colIndex,
          "step": $cmp.resizeStep
        },
        key: 10
      }, []) : null])];
    }

    var sortable = lwc.registerTemplate(tmpl$G);
    tmpl$G.stylesheets = [];
    tmpl$G.stylesheetTokens = {
      hostAttribute: "lightning-primitiveHeaderFactory_sortableHeader-host",
      shadowAttribute: "lightning-primitiveHeaderFactory_sortableHeader"
    };

    function tmpl$H($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        ti: api_tab_index
      } = $api;
      return [api_element("div", {
        className: $cmp.computedClass,
        style: $cmp.columnStyles,
        key: 8
      }, [api_element("span", {
        classMap: {
          "slds-th__action": true
        },
        key: 7
      }, [$cmp.def.iconName ? api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-grid_vertical-align-center": true,
          "slds-has-flexi-truncate": true
        },
        key: 2
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-m-right_xx-small": true
        },
        props: {
          "iconName": $cmp.def.iconName,
          "size": "x-small"
        },
        key: 0
      }, []), api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.label
        },
        key: 1
      }, [api_dynamic($cmp.def.label)])]) : null, !$cmp.def.iconName ? $cmp.def.label ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.label
        },
        key: 3
      }, [api_dynamic($cmp.def.label)]) : null : null, !$cmp.def.iconName ? !$cmp.def.label ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.ariaLabel
        },
        key: 4
      }, []) : null : null, $cmp.hasActions ? api_custom_element("lightning-primitive-header-actions", _lightningPrimitiveHeaderActions, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "colKeyValue": $cmp.def.colKeyValue,
          "actions": $cmp.actions,
          "tabIndex": api_tab_index($cmp.state.internalTabIndex)
        },
        key: 5
      }, []) : null, $cmp.isResizable ? api_custom_element("lightning-primitive-resize-handler", _lightningPrimitiveResizeHandler, {
        classMap: {
          "slds-resizable": true
        },
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "value": $cmp.columnWidth,
          "minWidth": $cmp.def.minWidth,
          "maxWidth": $cmp.def.maxWidth,
          "internalTabIndex": $cmp.internalTabIndex,
          "label": $cmp.def.label,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "colIndex": $cmp.colIndex,
          "step": $cmp.resizeStep
        },
        key: 6
      }, []) : null])])];
    }

    var nonsortable = lwc.registerTemplate(tmpl$H);
    tmpl$H.stylesheets = [];
    tmpl$H.stylesheetTokens = {
      hostAttribute: "lightning-primitiveHeaderFactory_nonsortableHeader-host",
      shadowAttribute: "lightning-primitiveHeaderFactory_nonsortableHeader"
    };

    const i18n$f = {
      chooseARow: labelChooseARow,
      selectAll: labelSelectAll,
      sort: labelSort,
      sortAsc: labelSortAsc,
      sortDesc: labelSortDesc,
      sortNone: labelSortNone
    };

    function preventDefaultAndStopPropagation$4(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    class PrimitiveHeaderFactory extends PrimitiveDatatableCell$1 {
      constructor(...args) {
        super(...args);
        this.colIndex = void 0;
        this.sorted = void 0;
        this.sortedDirection = void 0;
        this.resizestep = void 0;
        this.columnWidth = void 0;
        this.actions = void 0;
        this.showCheckbox = false;
        this.dtContextId = void 0;
        this._resizable = void 0;
        this._def = {};
        this._sortable = false;
      }

      get resizable() {
        return this._resizable;
      }

      set resizable(value) {
        this._resizable = value;
        this.updateElementClasses();
      }

      get def() {
        return this._def;
      }

      set def(value) {
        this._def = value;
        this.updateElementClasses();
      }

      get sortable() {
        return this._sortable;
      }

      set sortable(value) {
        this._sortable = value;
        this.updateElementClasses();
      }

      render() {
        if (this.isSelectableHeader) {
          return selectable;
        } else if (this.sortable) {
          return sortable;
        }

        return nonsortable;
      }

      renderedCallback() {
        if (this.isSelectableHeader && this.showCheckbox) {
          this.updateBulkSelectionCheckbox();
        }
      }

      updateElementClasses() {
        classListMutation(this.classList, {
          'slds-is-sortable': this.isSortable,
          'slds-is-resizable': this.isResizable
        });
      }

      get columnStyles() {
        const outlineStyle = this.isSortable ? '' : 'outline:none;';
        return `
            width: ${this.columnWidth}px;
            ${outlineStyle}
        `;
      }

      get computedClass() {
        return classSet('slds-cell-fixed').add({
          'slds-has-button-menu': this.hasActions
        }).toString();
      }

      get computedSortClass() {
        return classSet('slds-th__action slds-text-link_reset').add({
          'slds-is-sorted': this.sorted
        }).add({
          'slds-is-sorted_asc': this.isAscSorting
        }).add({
          'slds-is-sorted_desc': this.isDescSorting
        }).toString();
      }

      get isAscSorting() {
        return this.sortedDirection === 'asc';
      }

      get isDescSorting() {
        return this.sortedDirection === 'desc';
      }

      get sortedOrderLabel() {
        if (this.sorted) {
          return this.sortedDirection === 'desc' ? i18n$f.sortDesc : i18n$f.sortAsc;
        }

        return i18n$f.sortNone;
      }

      get isSelectableHeader() {
        return this.def.type === 'SELECTABLE_CHECKBOX';
      }

      get isRegularHeader() {
        return this.def.type !== 'SELECTABLE_CHECKBOX';
      }

      get isResizable() {
        return this.resizable && this.def.resizable !== false;
      }

      get isSortable() {
        return this.sortable;
      }

      get i18n() {
        return i18n$f;
      }

      get headerRole() {
        return this.isResizable || this.sortable ? 'button' : false;
      }

      get resizeStep() {
        return this.resizestep;
      }

      get computedOptionName() {
        return `${this.dtContextId}-options`;
      }

      handleSelectAllRows() {
        const actionName = this.def.bulkSelection === 'none' ? 'selectallrows' : 'deselectallrows'; // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments

        const actionEvent = new CustomEvent(actionName, {
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(actionEvent);
      }

      handleSortingClick(event) {
        event.preventDefault();

        if (this.isSortable) {
          preventDefaultAndStopPropagation$4(event);
          this.fireSortedColumn(this.def.fieldName, this.getTargetSortDirection());
          this.fireCellFocusByClickEvent();
        }
      }

      getTargetSortDirection() {
        if (this.sorted) {
          return this.sortedDirection === 'desc' ? 'asc' : 'desc';
        }

        return this.sortedDirection;
      }

      fireSortedColumn(fieldName, sortDirection) {
        const event = new CustomEvent('privateupdatecolsort', {
          bubbles: true,
          composed: true,
          detail: {
            fieldName,
            sortDirection
          }
        });
        this.dispatchEvent(event);
      }

      get hasActions() {
        return this.actions.customerActions.length > 0 || this.actions.internalActions.length > 0;
      }

      updateBulkSelectionCheckbox() {
        const allCheckbox = this.template.querySelector('.datatable-select-all');
        allCheckbox.indeterminate = this.def.bulkSelection === 'some'; // Note: since we have to handle the indeterminate state,
        //       this is to remove a raptor warning `Unneccessary update of property "checked"`

        allCheckbox.checked = !(this.def.bulkSelection === 'none');
      }

    }

    lwc.registerDecorators(PrimitiveHeaderFactory, {
      publicProps: {
        colIndex: {
          config: 0
        },
        sorted: {
          config: 0
        },
        sortedDirection: {
          config: 0
        },
        resizestep: {
          config: 0
        },
        columnWidth: {
          config: 0
        },
        actions: {
          config: 0
        },
        showCheckbox: {
          config: 0
        },
        dtContextId: {
          config: 0
        },
        resizable: {
          config: 3
        },
        def: {
          config: 3
        },
        sortable: {
          config: 3
        }
      },
      track: {
        _resizable: 1,
        _def: 1,
        _sortable: 1
      }
    });

    var _lightningPrimitiveHeaderFactory = lwc.registerComponent(PrimitiveHeaderFactory, {
      tmpl: _tmpl$1
    });

    var labelSelectItem = 'Select Item';

    function tmpl$I($api, $cmp, $slotset, $ctx) {
      const {
        gid: api_scoped_id,
        ti: api_tab_index,
        b: api_bind,
        h: api_element,
        d: api_dynamic
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-checkbox": true
        },
        key: 4,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleCheckboxContainerClick)),
          "mousedown": _m2 || ($ctx._m2 = api_bind($cmp.handleCheckboxContainerMouseDown))
        }
      }, [api_element("input", {
        attrs: {
          "type": "checkbox",
          "name": $cmp.computedOptionName,
          "id": api_scoped_id("primitive-cell-checkbox-id"),
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable",
          "data-action-triggers": "space"
        },
        props: {
          "disabled": $cmp.isDisabled,
          "checked": $cmp.isSelected
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCheckboxClick))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("primitive-cell-checkbox-id")}`
        },
        key: 3
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 1
      }, []), api_element("span", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        key: 2
      }, [api_dynamic($cmp.selectItemAssistiveText)])])])];
    }

    var checkbox = lwc.registerTemplate(tmpl$I);
    tmpl$I.stylesheets = [];
    tmpl$I.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellCheckbox_checkbox-host",
      shadowAttribute: "lightning-primitiveCellCheckbox_checkbox"
    };

    function tmpl$J($api, $cmp, $slotset, $ctx) {
      const {
        gid: api_scoped_id,
        ti: api_tab_index,
        b: api_bind,
        h: api_element,
        d: api_dynamic
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-radio": true
        },
        key: 4
      }, [api_element("input", {
        attrs: {
          "type": "radio",
          "name": $cmp.computedOptionName,
          "id": api_scoped_id("primitive-checkbox-radio-id"),
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable",
          "data-action-triggers": "space",
          "aria-labelledby": api_scoped_id($cmp.ariaLabelledBy)
        },
        props: {
          "disabled": $cmp.isDisabled,
          "checked": $cmp.isSelected
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRadioClick)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleRadioKeyDown))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-radio__label": true
        },
        attrs: {
          "for": `${api_scoped_id("primitive-checkbox-radio-id")}`
        },
        key: 3
      }, [api_element("span", {
        classMap: {
          "slds-radio_faux": true
        },
        key: 1
      }, []), api_element("span", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        key: 2
      }, [api_dynamic($cmp.selectItemAssistiveText)])])])];
    }

    var radio = lwc.registerTemplate(tmpl$J);
    tmpl$J.stylesheets = [];
    tmpl$J.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellCheckbox_radio-host",
      shadowAttribute: "lightning-primitiveCellCheckbox_radio"
    };

    const i18n$g = {
      selectItem: labelSelectItem
    };

    class PrimitiveCellCheckbox extends PrimitiveDatatableCell$1 {
      constructor(...args) {
        super(...args);
        this.rowIndex = 0;
        this.isSelected = false;
        this.isDisabled = false;
        this.type = 'checkbox';
        this.dtContextId = void 0;
      }

      render() {
        if (this.type === 'radio') {
          return radio;
        }

        return checkbox;
      }

      get selectItemAssistiveText() {
        return `${i18n$g.selectItem} ${this.rowIndex + 1}`;
      }

      get labelId() {
        return `radio-button-label-${this.rowIndex + 1}`;
      }

      get ariaLabelledBy() {
        return `${this.labelId} radio-group-header`;
      }

      get computedOptionName() {
        return `${this.dtContextId}-options`;
      }

      handleRadioClick(event) {
        event.stopPropagation();

        if (!this.isSelected) {
          this.dispatchSelection(false);
        }
      }
      /**
       * We control the checkbox behaviour with the state and we handle it in the container,
       * but we need to prevent default in order to avoid the checkbox to change state
       * with the click and the generated click in the input from the label
       *
       * @param {Object} event - click event of the checkbox
       */


      handleCheckboxClick(event) {
        // click was catch on the input, stop propagation to avoid to be handled in container.
        // ideally you can let it bubble and be handled in there, but there is a raptor issue:
        // https://git.soma.salesforce.com/raptor/raptor/issues/838
        event.stopPropagation();
        this.dispatchSelection(event.shiftKey);
      }

      handleCheckboxContainerClick(event) {
        if (!this.isDisabled) {
          // click was catch in the label, the default its to activate the checkbox,
          // lets prevent it to avoid to send a double event.
          event.preventDefault();
          this.dispatchSelection(event.shiftKey);
        }
      }

      handleCheckboxContainerMouseDown(event) {
        // Prevent selecting text by Shift+click
        if (event.shiftKey) {
          event.preventDefault();
        }
      }

      handleRadioKeyDown(event) {
        const keyCode = event.keyCode;

        if (keyCode === keyCodes.left || keyCode === keyCodes.right) {
          // default behavior for radios is to select the prev/next radio with the same name
          event.preventDefault();
        }
      }

      dispatchSelection(isMultipleSelection) {
        const actionName = !this.isSelected ? 'selectrow' : 'deselectrow'; // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments

        const actionEvent = new CustomEvent(actionName, {
          bubbles: true,
          composed: true,
          detail: {
            rowKeyValue: this.rowKeyValue,
            isMultiple: isMultipleSelection
          }
        });
        this.dispatchEvent(actionEvent);
      }

    }

    lwc.registerDecorators(PrimitiveCellCheckbox, {
      publicProps: {
        rowIndex: {
          config: 0
        },
        isSelected: {
          config: 0
        },
        isDisabled: {
          config: 0
        },
        type: {
          config: 0
        },
        dtContextId: {
          config: 0
        }
      }
    });

    var _lightningPrimitiveCellCheckbox = lwc.registerComponent(PrimitiveCellCheckbox, {
      tmpl: _tmpl$1
    });

    function tmpl$K($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "type": "button",
          "tabindex": api_tab_index($cmp.buttonTabIndex),
          "title": $cmp.buttonTitle
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleChevronClick))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:chevronright",
          "variant": "bare",
          "svgClass": "slds-button__icon slds-button__icon_small"
        },
        key: 0
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.buttonTitle)])])];
    }

    var _tmpl$t = lwc.registerTemplate(tmpl$K);
    tmpl$K.stylesheets = [];
    tmpl$K.stylesheetTokens = {
      hostAttribute: "lightning-primitiveTreegridCellToggle_primitiveTreegridCellToggle-host",
      shadowAttribute: "lightning-primitiveTreegridCellToggle_primitiveTreegridCellToggle"
    };

    var labelCollapseBranch = 'Collapse {0}';

    var labelExpandBranch = 'Expand {0}';

    const i18n$h = {
      collapseBranch: labelCollapseBranch,
      expandBranch: labelExpandBranch
    };

    class PrivateTreeGridCellToggle extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.value = void 0;
        this.state = {
          expanded: false,
          hasChildren: false
        };
        this._tabindex = 0;
      }

      get computedButtonClass() {
        return classSet('slds-button slds-button_icon slds-m-right_x-small').add({
          'slds-is-disabled': !this.hasChildren
        }).toString();
      }

      get tabIndex() {
        return -1;
      }

      set tabIndex(newValue) {
        this.setAttribute('tabindex', newValue);
        this._tabindex = newValue;
      }

      get buttonTabIndex() {
        return this._tabindex;
      }

      get hasChildren() {
        return this.state.hasChildren;
      }

      set hasChildren(value) {
        this.state.hasChildren = normalizeBoolean(value);
      }

      get isExpanded() {
        return this.state.expanded;
      }

      set isExpanded(value) {
        this.state.expanded = normalizeBoolean(value);
      }

      get buttonTitle() {
        if (this.isExpanded) {
          return this.formatString(i18n$h.collapseBranch, this.value);
        }

        return this.formatString(i18n$h.expandBranch, this.value);
      }

      formatString(str) {
        const args = ArraySlice.call(arguments, 1);

        if (str) {
          return str.replace(/{(\d+)}/g, (match, i) => {
            return typeof args[i] !== 'undefined' ? args[i] : match;
          });
        }

        return '';
      }

      handleChevronClick() {
        const customEvent = new CustomEvent('privatetogglecell', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            name: this.rowKeyValue,
            nextState: this.isExpanded ? false : true // True = expanded, False = collapsed

          }
        });
        this.dispatchEvent(customEvent);
      }

      focus() {
        this.template.querySelector('button').focus();
      }

    }

    lwc.registerDecorators(PrivateTreeGridCellToggle, {
      publicProps: {
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        value: {
          config: 0
        },
        tabIndex: {
          config: 3
        },
        hasChildren: {
          config: 3
        },
        isExpanded: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1,
        _tabindex: 1
      }
    });

    var _lightningPrimitiveTreegridCellToggle = lwc.registerComponent(PrivateTreeGridCellToggle, {
      tmpl: _tmpl$t
    });

    function tmpl$L($api, $cmp, $slotset, $ctx) {
      const {
        k: api_key,
        c: api_custom_element,
        i: api_iterator,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_custom_element("lightning-button-menu", _lightningButtonMenu, {
        props: {
          "iconSize": "x-small",
          "alternativeText": $cmp.buttonAlternateText,
          "menuAlignment": $cmp.computedMenuAlignment,
          "isLoading": $cmp.state.isLoadingActions,
          "loadingStateAlternativeText": $cmp.spinnerAlternateText
        },
        key: 1,
        on: {
          "select": _m0 || ($ctx._m0 = api_bind($cmp.handleActionSelect)),
          "open": _m1 || ($ctx._m1 = api_bind($cmp.handleMenuOpen))
        }
      }, api_iterator($cmp.state.actions, function (action) {
        return api_custom_element("lightning-menu-item", _lightningMenuItem, {
          props: {
            "value": action,
            "label": action.label,
            "iconName": action.iconName,
            "disabled": action.disabled
          },
          key: api_key(0, action.label)
        }, []);
      }))];
    }

    var _tmpl$u = lwc.registerTemplate(tmpl$L);
    tmpl$L.stylesheets = [];
    tmpl$L.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellActions_primitiveCellActions-host",
      shadowAttribute: "lightning-primitiveCellActions_primitiveCellActions"
    };

    var labelLoadingActions = 'Loading actions';

    var labelShowActions$1 = 'Show actions';

    const DEFAULT_MENU_ALIGNMENT = 'auto-right';
    const VALID_MENU_ALIGNMENT = ['auto-right', 'auto-left', 'auto', 'left', 'center', 'right', 'bottom-left', 'bottom-center', 'bottom-right'];
    const i18n$i = {
      loadingActions: labelLoadingActions,
      showActions: labelShowActions$1
    };

    class PrimitiveCellActions extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.rowActions = void 0;
        this.containerRect = void 0;
        this.state = {
          actions: [],
          menuAlignment: DEFAULT_MENU_ALIGNMENT,
          internalTabIndex: false
        };
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      }

      get menuAlignment() {
        return this.state.menuAlignment;
      }

      set menuAlignment(value) {
        this.state.menuAlignment = normalizeString(value, {
          fallbackValue: DEFAULT_MENU_ALIGNMENT,
          validValues: VALID_MENU_ALIGNMENT
        });
      }

      focus() {
        if (this._connected) {
          this.template.querySelector('lightning-button-menu').focus();
        }
      }

      click() {
        if (this._connected) {
          // focus/click without changing tabindex doesnt work W-6185168
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            this.template.querySelector('lightning-button-menu').click();
          }, 0);
        }
      }

      get computedMenuAlignment() {
        return this.menuAlignment;
      }

      get buttonAlternateText() {
        return `${i18n$i.showActions}`;
      }

      get spinnerAlternateText() {
        return `${i18n$i.loadingActions}`;
      }

      handleActionSelect(event) {
        this.dispatchEvent(new CustomEvent('privatecellactiontriggered', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            rowKeyValue: this.rowKeyValue,
            colKeyValue: this.colKeyValue,
            action: event.detail.value
          }
        }));
      }

      handleMenuOpen() {
        this.elementRect = this.template.querySelector('lightning-button-menu').getBoundingClientRect();
        const detail = {
          rowKeyValue: this.rowKeyValue,
          colKeyValue: this.colKeyValue,
          doneCallback: this.finishLoadingActions.bind(this),
          saveContainerPosition: containerRect => {
            this.containerRect = containerRect;
          }
        };

        if (typeof this.rowActions === 'function') {
          this.state.isLoadingActions = true;
          this.state.actions = [];
          detail.actionsProviderFunction = this.rowActions; // This callback should always be async

          Promise.resolve().then(() => {
            this.dispatchEvent(new CustomEvent('privatecellactionmenuopening', {
              composed: true,
              bubbles: true,
              cancelable: true,
              detail
            }));
          });
        } else {
          this.state.actions = this.rowActions;
        }
      }

      finishLoadingActions(actions) {
        this.state.isLoadingActions = false;
        this.state.actions = actions;
      }

    }

    PrimitiveCellActions.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveCellActions, {
      publicProps: {
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        rowActions: {
          config: 0
        },
        menuAlignment: {
          config: 3
        }
      },
      publicMethods: ["focus", "click"],
      track: {
        containerRect: 1,
        state: 1
      }
    });

    var _lightningPrimitiveCellActions = lwc.registerComponent(PrimitiveCellActions, {
      tmpl: _tmpl$u
    });

    function tmpl$M($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [$cmp.isButtonIconType ? api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        className: $cmp.buttonClass,
        props: {
          "variant": $cmp.variant,
          "alternativeText": $cmp.alternativeText,
          "iconName": $cmp.iconName,
          "iconClass": $cmp.iconClass,
          "disabled": $cmp.disabled,
          "name": $cmp.buttonName,
          "title": $cmp.computedTitle
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonClick))
        }
      }, []) : null, !$cmp.isButtonIconType ? api_custom_element("lightning-button", _lightningButton, {
        className: $cmp.buttonClass,
        props: {
          "variant": $cmp.variant,
          "label": $cmp.label,
          "iconName": $cmp.iconName,
          "iconPosition": $cmp.iconPosition,
          "disabled": $cmp.disabled,
          "name": $cmp.buttonName,
          "title": $cmp.computedTitle
        },
        key: 1,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonClick))
        }
      }, []) : null];
    }

    var _tmpl$v = lwc.registerTemplate(tmpl$M);
    tmpl$M.stylesheets = [];
    tmpl$M.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellButton_primitiveCellButton-host",
      shadowAttribute: "lightning-primitiveCellButton_primitiveCellButton"
    };

    class PrivateCellButton extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.variant = void 0;
        this.label = void 0;
        this.iconName = void 0;
        this.iconPosition = void 0;
        this.buttonName = void 0;
        this.buttonClass = void 0;
        this.buttonTitle = void 0;
        this.internalTabIndex = void 0;
        this.type = void 0;
        this.alternativeText = void 0;
        this.iconClass = void 0;
        this.initialRender = true;
        this.buttonHasFocus = false;
        this._connected = false;
        this.state = {
          disabled: false
        };
      }

      get computedTitle() {
        return this.buttonTitle || this.label;
      }

      get disabled() {
        return this.state.disabled;
      }

      set disabled(value) {
        const newValue = normalizeBoolean(value);
        const oldValue = this.state.disabled;

        if (oldValue === false && newValue === true && this.buttonHasFocus) {
          this.fireCellFalseBlurred();
        }

        this.state.disabled = newValue;
      }

      get isButtonIconType() {
        return this.type === 'button-icon';
      }

      renderedCallback() {
        if (this.initialRender) {
          this.addListeners();
        }

        this.initialRender = false;
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      }

      get buttonCustomElement() {
        if (this._connected) {
          const qs = this.isButtonIconType ? 'lightning-button-icon' : 'lightning-button';
          return this.template.querySelector(qs);
        }

        return undefined;
      }

      addListeners() {
        const buttonCustomElement = this.buttonCustomElement;
        buttonCustomElement.addEventListener('focus', this.handleButtonFocused.bind(this));
        buttonCustomElement.addEventListener('blur', this.handleButtonBlurred.bind(this));
      }

      focus() {
        if (this.buttonCustomElement) {
          this.buttonCustomElement.focus();
        }
      }

      click() {
        if (this.buttonCustomElement) {
          this.buttonCustomElement.click();
        }
      }

      handleButtonFocused(event) {
        if (event.target.localName.indexOf('button') > -1) {
          this.buttonHasFocus = true;
        }
      }

      handleButtonBlurred(event) {
        if (event.target.localName.indexOf('button') > -1) {
          this.buttonHasFocus = false;
        }
      }

      fireCellFalseBlurred() {
        const {
          rowKeyValue,
          colKeyValue
        } = this;
        this.dispatchEvent(new CustomEvent('privatecellfalseblurred', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            rowKeyValue,
            colKeyValue
          }
        }));
      }

      handleButtonClick() {
        const {
          rowKeyValue,
          colKeyValue
        } = this; // fire this event in the next tick so that dt can do things it has to do for correct focus
        // eslint-disable-next-line @lwc/lwc/no-async-operation

        setTimeout(() => {
          this.dispatchEvent(new CustomEvent('privatecellbuttonclicked', {
            composed: true,
            bubbles: true,
            cancelable: true,
            detail: {
              rowKeyValue,
              colKeyValue
            }
          }));
        }, 0);
      }

    }

    PrivateCellButton.delegatesFocus = true;

    lwc.registerDecorators(PrivateCellButton, {
      publicProps: {
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        variant: {
          config: 0
        },
        label: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        buttonName: {
          config: 0
        },
        buttonClass: {
          config: 0
        },
        buttonTitle: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        },
        type: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        iconClass: {
          config: 0
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus", "click"],
      track: {
        state: 1
      },
      fields: ["initialRender", "buttonHasFocus", "_connected"]
    });

    var _lightningPrimitiveCellButton = lwc.registerComponent(PrivateCellButton, {
      tmpl: _tmpl$v
    });

    function stylesheet$a(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? ("[dir=\"rtl\"] :host {direction: ltr;unicode-bidi: embed;}") : ("[dir=\"rtl\"] " + hostSelector + " {direction: ltr;unicode-bidi: embed;}")) + "\n";
    }
    var _implicitStylesheets$a = [stylesheet$a];

    function tmpl$N($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic
      } = $api;
      return [api_dynamic($cmp.formattedNumber)];
    }

    var _tmpl$w = lwc.registerTemplate(tmpl$N);
    tmpl$N.stylesheets = [];

    if (_implicitStylesheets$a) {
      tmpl$N.stylesheets.push.apply(tmpl$N.stylesheets, _implicitStylesheets$a);
    }
    tmpl$N.stylesheetTokens = {
      hostAttribute: "lightning-formattedNumber_formattedNumber-host",
      shadowAttribute: "lightning-formattedNumber_formattedNumber"
    };

    /**
     * Displays formatted numbers for decimals, currency, and percentages.
     */

    class LightningFormattedNumber extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.formatStyle = 'decimal';
        this.currencyCode = void 0;
        this.currencyDisplayAs = 'symbol';
        this.minimumIntegerDigits = void 0;
        this.minimumFractionDigits = void 0;
        this.maximumFractionDigits = void 0;
        this.minimumSignificantDigits = void 0;
        this.maximumSignificantDigits = void 0;
      }

      get formattedNumber() {
        const value = this.value;
        const options = {
          style: this.formatStyle,
          currency: this.currencyCode,
          currencyDisplay: this.currencyDisplayAs,
          minimumIntegerDigits: this.minimumIntegerDigits,
          minimumFractionDigits: this.minimumFractionDigits,
          maximumFractionDigits: this.maximumFractionDigits,
          minimumSignificantDigits: this.minimumSignificantDigits,
          maximumSignificantDigits: this.maximumSignificantDigits
        };
        const canReturnValue = value !== undefined && value !== null && value !== '' && isFinite(value);

        if (canReturnValue) {
          let valueToFormat = value; // percent-fixed just divides the value by 100
          // before passing to the library, this is to deal with the
          // fact that percentages in salesforce are 0-100, not 0-1

          if (this.formatStyle === 'percent-fixed') {
            options.style = 'percent';
            valueToFormat = parseFloat(value) / 100;
          }

          return numberFormat$1(options).format(valueToFormat);
        }

        return '';
      }

    }

    lwc.registerDecorators(LightningFormattedNumber, {
      publicProps: {
        value: {
          config: 0
        },
        formatStyle: {
          config: 0
        },
        currencyCode: {
          config: 0
        },
        currencyDisplayAs: {
          config: 0
        },
        minimumIntegerDigits: {
          config: 0
        },
        minimumFractionDigits: {
          config: 0
        },
        maximumFractionDigits: {
          config: 0
        },
        minimumSignificantDigits: {
          config: 0
        },
        maximumSignificantDigits: {
          config: 0
        }
      }
    });

    var _lightningFormattedNumber = lwc.registerComponent(LightningFormattedNumber, {
      tmpl: _tmpl$w
    });
    LightningFormattedNumber.interopMap = {
      props: {
        formatStyle: 'style'
      }
    };

    class PrimitiveCustomCell extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.types = void 0;
        this.columnType = void 0;
        this.value = void 0;
        this.columnLabel = void 0;
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.columnSubType = void 0;
        this.typeAttribute0 = void 0;
        this.typeAttribute1 = void 0;
        this.typeAttribute2 = void 0;
        this.typeAttribute3 = void 0;
        this.typeAttribute4 = void 0;
        this.typeAttribute5 = void 0;
        this.typeAttribute6 = void 0;
        this.typeAttribute7 = void 0;
        this.typeAttribute8 = void 0;
        this.typeAttribute9 = void 0;
        this.typeAttribute10 = void 0;
        this.typeAttribute21 = void 0;
        this.typeAttribute22 = void 0;
        this.internalTabIndex = void 0;
        this.keyboardMode = void 0;
        this.wrapText = void 0;
        this.alignment = void 0;
      }

      get type() {
        const type = this.types.getType(this.columnType);
        return type.template;
      }

      render() {
        return this.type;
      }

      get typeAttributes() {
        const typeAttributes = this.types.getType(this.columnType).typeAttributes;

        if (Array.isArray(typeAttributes)) {
          return typeAttributes.reduce((seed, attrName, index) => {
            seed[attrName] = this[`typeAttribute${index}`];
            return seed;
          }, {});
        }

        return {};
      }

      getActionableElements() {
        return queryFocusable(this.template);
      }

    }

    lwc.registerDecorators(PrimitiveCustomCell, {
      publicProps: {
        types: {
          config: 0
        },
        columnType: {
          config: 0
        },
        value: {
          config: 0
        },
        columnLabel: {
          config: 0
        },
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        columnSubType: {
          config: 0
        },
        typeAttribute0: {
          config: 0
        },
        typeAttribute1: {
          config: 0
        },
        typeAttribute2: {
          config: 0
        },
        typeAttribute3: {
          config: 0
        },
        typeAttribute4: {
          config: 0
        },
        typeAttribute5: {
          config: 0
        },
        typeAttribute6: {
          config: 0
        },
        typeAttribute7: {
          config: 0
        },
        typeAttribute8: {
          config: 0
        },
        typeAttribute9: {
          config: 0
        },
        typeAttribute10: {
          config: 0
        },
        typeAttribute21: {
          config: 0
        },
        typeAttribute22: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        },
        keyboardMode: {
          config: 0
        },
        wrapText: {
          config: 0
        },
        alignment: {
          config: 0
        }
      },
      publicMethods: ["getActionableElements"]
    });

    var _lightningPrimitiveCustomCell = lwc.registerComponent(PrimitiveCustomCell, {
      tmpl: _tmpl$1
    });

    function tmpl$O($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic
      } = $api;
      return [api_dynamic($cmp.formattedValue)];
    }

    var _tmpl$x = lwc.registerTemplate(tmpl$O);
    tmpl$O.stylesheets = [];
    tmpl$O.stylesheetTokens = {
      hostAttribute: "lightning-formattedDateTime_formattedDateTime-host",
      shadowAttribute: "lightning-formattedDateTime_formattedDateTime"
    };

    /**
     * Displays formatted date and time.
     */

    class LightningFormattedDateTime extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.weekday = void 0;
        this.era = void 0;
        this.year = void 0;
        this.month = void 0;
        this.day = void 0;
        this.hour = void 0;
        this.minute = void 0;
        this.second = void 0;
        this.timeZoneName = void 0;
        this.timeZone = void 0;
        this._hour12 = false;
        this._hour12Set = false;
      }

      /**
       * Determines whether time is displayed as 12-hour. If false, time displays as 24-hour. The default setting is determined by the user's locale.
       * @type {boolean}
       *
       */
      get hour12() {
        return this._hour12;
      }

      set hour12(value) {
        // If hour12 is not explicitly set, or when it's set to undefined, then locale default is used instead.
        if (value === undefined) {
          this._hour12Set = false;
          this._hour12 = value;
        } else {
          this._hour12Set = true;
          this._hour12 = normalizeBoolean(value);
        }
      }

      get formattedValue() {
        return this.computeFormattedValue();
      }

      computeFormattedValue() {
        const {
          value
        } = this;

        if (!this.isEmpty(value) && this.isValid(value)) {
          const formatted = dateTimeFormat(this.getOptions()).format(value);

          if (formatted) {
            return formatted;
          }
        }

        this.printError(value);
        return '';
      }

      isEmpty(value) {
        return value === undefined || value === null || value === '';
      }

      isValid(value) {
        return isFinite(value) || isValidISODateTimeString(value);
      }

      printError(value) {
        const errorMsg = `<lightning-formatted-date-time> The value attribute accepts either a Date object, a timestamp, or a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`;
        console.warn(errorMsg); // eslint-disable-line no-console
      }

      getOptions() {
        const options = {
          weekday: this.weekday,
          era: this.era,
          year: this.year,
          month: this.month,
          day: this.day,
          hour: this.hour,
          minute: this.minute,
          second: this.second,
          timeZoneName: this.timeZoneName,
          timeZone: this.timeZone
        }; // If hour12 is set, then we use it, otherwise locale defaults will be used

        if (this._hour12Set) {
          options.hour12 = this.hour12;
        }

        return options;
      }

    }

    lwc.registerDecorators(LightningFormattedDateTime, {
      publicProps: {
        value: {
          config: 0
        },
        weekday: {
          config: 0
        },
        era: {
          config: 0
        },
        year: {
          config: 0
        },
        month: {
          config: 0
        },
        day: {
          config: 0
        },
        hour: {
          config: 0
        },
        minute: {
          config: 0
        },
        second: {
          config: 0
        },
        timeZoneName: {
          config: 0
        },
        timeZone: {
          config: 0
        },
        hour12: {
          config: 3
        }
      },
      track: {
        _hour12: 1,
        _hour12Set: 1
      }
    });

    var _lightningFormattedDateTime = lwc.registerComponent(LightningFormattedDateTime, {
      tmpl: _tmpl$x
    });

    function tmpl$P($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        t: api_text,
        ti: api_tab_index
      } = $api;
      return [$cmp.hasValue ? api_element("a", {
        attrs: {
          "href": $cmp.href,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        key: 2
      }, [!$cmp.hideIcon ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:email",
          "size": "x-small"
        },
        key: 0
      }, []) : null, !$cmp.hideIcon ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.i18n.emailLabel)]) : null, api_text(" "), api_dynamic($cmp.computedLabel)]) : null];
    }

    var _tmpl$y = lwc.registerTemplate(tmpl$P);
    tmpl$P.stylesheets = [];
    tmpl$P.stylesheetTokens = {
      hostAttribute: "lightning-formattedEmail_formattedEmail-host",
      shadowAttribute: "lightning-formattedEmail_formattedEmail"
    };

    var labelEmailLabel = 'Email';

    // also be added to the static `labels` prop inside the class.
    // https://git.soma.salesforce.com/raptor/raptor/issues/196

    const i18n$j = {
      emailLabel: labelEmailLabel
    };
    /**
     * Displays an email as a hyperlink with the mailto: URL scheme.
     */

    class LightningFormattedEmail extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.label = void 0;
        this.tabIndex = void 0;
        this.hideIcon = false;
        this._connected = false;
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the element.
       */


      focus() {
        if (this.emailAnchor) {
          this.emailAnchor.focus();
        }
      }
      /**
       * Removes keyboard focus from the element.
       */


      blur() {
        if (this.emailAnchor) {
          this.emailAnchor.blur();
        }
      }
      /**
       * Clicks the email address and opens the default email app.
       */


      click() {
        const anchor = this.emailAnchor;

        if (anchor && anchor.click) {
          anchor.click();
        }
      }

      get emailAnchor() {
        if (this._connected && this.hasValue) {
          return this.template.querySelector('a');
        }

        return undefined;
      }

      get trimmedValue() {
        return (this.value || '').trim();
      }

      get trimmedLabel() {
        return (this.label || '').trim();
      }

      get hasValue() {
        return !!this.trimmedValue;
      }

      get href() {
        return 'mailto:' + this.trimmedValue;
      }

      get computedLabel() {
        return this.trimmedLabel || this.trimmedValue;
      }

      get i18n() {
        return i18n$j;
      }

    }

    lwc.registerDecorators(LightningFormattedEmail, {
      publicProps: {
        value: {
          config: 0
        },
        label: {
          config: 0
        },
        tabIndex: {
          config: 0
        },
        hideIcon: {
          config: 0
        }
      },
      publicMethods: ["focus", "blur", "click"],
      fields: ["_connected"]
    });

    var _lightningFormattedEmail = lwc.registerComponent(LightningFormattedEmail, {
      tmpl: _tmpl$y
    });

    function tmpl$Q($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        t: api_text
      } = $api;
      return [$cmp.isValid ? api_dynamic($cmp.latitude) : null, $cmp.isValid ? api_text(", ") : null, $cmp.isValid ? api_dynamic($cmp.longitude) : null];
    }

    var _tmpl$z = lwc.registerTemplate(tmpl$Q);
    tmpl$Q.stylesheets = [];
    tmpl$Q.stylesheetTokens = {
      hostAttribute: "lightning-formattedLocation_formattedLocation-host",
      shadowAttribute: "lightning-formattedLocation_formattedLocation"
    };

    const MAX_LONGITUDE = 180.0;
    const MAX_LATITUDE = 90.0;

    function isNumber(value) {
      return value !== '' && value !== null && isFinite(value);
    }

    function isLongitude(longitude) {
      return isNumber(longitude) && Math.abs(longitude) <= MAX_LONGITUDE;
    }

    function isLatitude(latitude) {
      return isNumber(latitude) && Math.abs(latitude) <= MAX_LATITUDE;
    }
    /**
     * Displays a geolocation in decimal degrees using the format [latitude, longitude].
     */


    class LightningFormattedLocation extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.latitude = void 0;
        this.longitude = void 0;
      }

      get isValid() {
        const valid = isLatitude(this.latitude) && isLongitude(this.longitude);

        if (!valid) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-formatted-location> expects latitude in range [-90.0, 90.0], longitude in range [-180.0, 180.0].`);
        }

        return valid;
      }

    }

    lwc.registerDecorators(LightningFormattedLocation, {
      publicProps: {
        latitude: {
          config: 0
        },
        longitude: {
          config: 0
        }
      }
    });

    var _lightningFormattedLocation = lwc.registerComponent(LightningFormattedLocation, {
      tmpl: _tmpl$z
    });

    function tmpl$R($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        ti: api_tab_index,
        h: api_element
      } = $api;
      return [$cmp.showLink ? api_element("a", {
        attrs: {
          "href": $cmp.link,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        key: 0
      }, [api_dynamic($cmp.formattedPhoneNumber)]) : null];
    }

    var _tmpl$A = lwc.registerTemplate(tmpl$R);
    tmpl$R.stylesheets = [];
    tmpl$R.stylesheetTokens = {
      hostAttribute: "lightning-formattedPhone_formattedPhone-host",
      shadowAttribute: "lightning-formattedPhone_formattedPhone"
    };

    /**
     * Displays a phone number as a hyperlink with the tel: URL scheme.
     */

    class LightningFormattedPhone extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.tabIndex = void 0;
        this._connected = false;
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the element.
       */


      focus() {
        if (this.phoneAnchor) {
          this.phoneAnchor.focus();
        }
      }
      /**
       * Removes keyboard focus from the element.
       */


      blur() {
        if (this.phoneAnchor) {
          this.phoneAnchor.blur();
        }
      }
      /**
       * Clicks the phone number and opens the default phone app.
       */


      click() {
        const anchor = this.phoneAnchor;

        if (anchor && anchor.click) {
          anchor.click();
        }
      }

      get phoneAnchor() {
        if (this._connected && this.showLink) {
          return this.template.querySelector('a');
        }

        return undefined;
      }

      get showLink() {
        return this.value != null && this.value !== '';
      }

      get formattedPhoneNumber() {
        return toNorthAmericanPhoneNumber(this.value);
      }

      get link() {
        return `tel:${this.value}`;
      }

    }

    lwc.registerDecorators(LightningFormattedPhone, {
      publicProps: {
        value: {
          config: 0
        },
        tabIndex: {
          config: 0
        }
      },
      publicMethods: ["focus", "blur", "click"],
      fields: ["_connected"]
    });

    var _lightningFormattedPhone = lwc.registerComponent(LightningFormattedPhone, {
      tmpl: _tmpl$A
    });

    function tmpl$S($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "data-trigger": "true",
          "tabindex": api_tab_index($cmp.internalTabIndex)
        },
        key: 2,
        on: {
          "mouseover": _m0 || ($ctx._m0 = api_bind($cmp.handleMouseOver)),
          "mouseout": _m1 || ($ctx._m1 = api_bind($cmp.handleMouseOut)),
          "click": _m2 || ($ctx._m2 = api_bind($cmp.handleClick))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.computedHeaderIconName,
          "variant": $cmp.variant,
          "size": $cmp.size
        },
        key: 0
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 1
      }, [api_dynamic($cmp.alternativeText)]) : null])];
    }

    var _tmpl$B = lwc.registerTemplate(tmpl$S);
    tmpl$S.stylesheets = [];
    tmpl$S.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableTooltip_primitiveDatatableTooltip-host",
      shadowAttribute: "lightning-primitiveDatatableTooltip_primitiveDatatableTooltip"
    };

    function tmpl$T($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("section", {
        styleMap: {
          "outline": "none"
        },
        attrs: {
          "role": "dialog",
          "aria-describedby": `${api_scoped_id("primitive-datatable-tooltip-bubble-body-id")}`,
          "aria-labelledby": `${api_scoped_id("primitive-datatable-tooltip-bubble-header-id")}`,
          "tabindex": "0"
        },
        key: 11,
        on: {
          "focusout": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "keydown": _m3 || ($ctx._m3 = api_bind($cmp.handleBubbleKey))
        }
      }, [!$cmp.hideCloseButton ? api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-float_right": true,
          "slds-popover__close": true
        },
        attrs: {
          "data-close": "true"
        },
        props: {
          "iconName": "utility:close",
          "variant": "bare-inverse",
          "size": "small",
          "alternativeText": $cmp.i18n.closeButtonAssistiveText
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCloseButtonClick)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleCloseButtonKey))
        }
      }, []) : null, api_element("header", {
        classMap: {
          "slds-popover__header": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-media": true,
          "slds-media_center": true,
          "slds-has-flexi-truncate": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-media__figure": true
        },
        key: 3
      }, [api_element("span", {
        classMap: {
          "slds-icon_container": true,
          "slds-icon-utility-ban": true
        },
        key: 2
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.computedHeaderIconName,
          "size": "x-small",
          "variant": "inverse"
        },
        key: 1
      }, [])])]), api_element("div", {
        classMap: {
          "slds-media__body": true
        },
        key: 5
      }, [api_element("h2", {
        classMap: {
          "slds-truncate": true,
          "slds-text-heading_medium": true
        },
        attrs: {
          "id": api_scoped_id("primitive-datatable-tooltip-bubble-header-id"),
          "title": $cmp.header
        },
        key: 4
      }, [api_dynamic($cmp.header)])])])]), api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        attrs: {
          "id": api_scoped_id("primitive-datatable-tooltip-bubble-body-id")
        },
        key: 10
      }, [$cmp.isContentList ? api_element("ul", {
        styleMap: {
          "listStyle": "disc",
          "marginLeft": "1.5rem"
        },
        key: 9
      }, api_iterator($cmp.content, function (item, index) {
        return api_element("li", {
          key: api_key(8, item)
        }, [api_dynamic(item)]);
      })) : null, !$cmp.isContentList ? api_dynamic($cmp.content) : null])])];
    }

    var _tmpl$C = lwc.registerTemplate(tmpl$T);
    tmpl$T.stylesheets = [];
    tmpl$T.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableTooltipBubble_primitiveDatatableTooltipBubble-host",
      shadowAttribute: "lightning-primitiveDatatableTooltipBubble_primitiveDatatableTooltipBubble"
    };

    var labelCloseButtonAssistiveText = 'Close dialog';

    const i18n$k = {
      closeButtonAssistiveText: labelCloseButtonAssistiveText
    };
    const DEFAULT_ALIGN$1 = {
      horizontal: 'left',
      vertical: 'bottom'
    };

    class LightningPrimitiveDatatableTooltipBubble extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          inDom: false,
          visible: false,
          align: DEFAULT_ALIGN$1
        };
        this.anchor = void 0;
        this.header = '';
        this.content = '';
        this.variant = 'bare';
        this.hideCloseButton = false;

        this.handleBlur = evt => {
          // A valid blur is when the focus goes to an element outside the bubble.
          // If the element with the focus is inside the bubble, then the component as a whole was not blurred.
          const isValidBlur = evt.relatedTarget === null || !this.template.contains(evt.relatedTarget);

          if (isValidBlur) {
            this.handleBubbleFocusLost();
          }
        };

        this.handleBubbleFocusLost = () => {
          this.dispatchCloseButtonEvent('bubbleLoseFocus');
        };

        this.handleBubbleKey = event => {
          if (keyCodes.escape === event.keyCode) {
            this.dispatchCloseButtonEvent();
          }

          if (keyCodes.tab === event.keyCode) {
            event.preventDefault();
            event.stopPropagation();
            this.focus();
          }
        };

        this.handleCloseButtonClick = () => {
          this.dispatchCloseButtonEvent();
        };

        this.handleCloseButtonKey = event => {
          // block tab and all other keys to keep focus
          event.preventDefault();
          event.stopPropagation();
          const keysToClose = [keyCodes.enter, keyCodes.space, keyCodes.escape];

          if (keysToClose.includes(event.keyCode)) {
            this.dispatchCloseButtonEvent();
          }
        };
      }

      connectedCallback() {
        this.state.inDOM = true;
        this.updateClassList();
      }

      disconnectedCallback() {
        this.state.inDOM = false;
      }

      get align() {
        return this.state.align;
      }

      set align(value) {
        this.state.align = value;

        if (this.state.inDOM) {
          this.updateClassList();
        }
      }

      get visible() {
        return this.state.visible;
      }

      set visible(value) {
        this.state.visible = value;

        if (this.state.inDOM) {
          this.updateClassList();
        }
      }

      focus() {
        this.closeButton.focus();
      }

      get i18n() {
        return i18n$k;
      }

      get isContentList() {
        return Array.isArray(this.content);
      }

      get computedHeaderIconName() {
        switch (this.variant) {
          case 'error':
            return 'utility:ban';

          case 'warning':
            return 'utility:warning';

          case 'bare':
          default:
            return 'utility:info';
        }
      }

      get closeButton() {
        return this.template.querySelector('[data-close="true"]');
      }

      updateClassList() {
        const classes = classSet('slds-popover');
        classes.add({
          'slds-popover_error': this.variant === 'error',
          'slds-popover_warning': this.variant === 'warning'
        }); // apply fading effect

        classes.add({
          'slds-rise-from-ground': this.state.visible === true,
          'slds-fall-into-ground': this.state.visible === false
        }); // apply the proper nubbin CSS class

        const {
          horizontal,
          vertical
        } = this.align;
        classes.add({
          'slds-nubbin_top-left': horizontal === 'left' && vertical === 'top',
          'slds-nubbin_top-right': horizontal === 'right' && vertical === 'top',
          'slds-nubbin_bottom-left': horizontal === 'left' && vertical === 'bottom',
          'slds-nubbin_bottom-right': horizontal === 'right' && vertical === 'bottom'
        });
        classListMutation(this.classList, classes);
      }

      dispatchCloseButtonEvent(reason) {
        this.dispatchEvent(new CustomEvent('close', {
          detail: {
            reason: reason || 'userCloseBubble',
            anchor: this.anchor
          }
        }));
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableTooltipBubble, {
      publicProps: {
        anchor: {
          config: 0
        },
        header: {
          config: 0
        },
        content: {
          config: 0
        },
        variant: {
          config: 0
        },
        hideCloseButton: {
          config: 0
        },
        align: {
          config: 3
        },
        visible: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      },
      fields: ["handleBlur", "handleBubbleFocusLost", "handleBubbleKey", "handleCloseButtonClick", "handleCloseButtonKey"]
    });

    var LightningPrimitiveDatatableTooltipBubble$1 = lwc.registerComponent(LightningPrimitiveDatatableTooltipBubble, {
      tmpl: _tmpl$C
    });

    function getBubbleAlignAndPosition(triggerBoundingClientRect, bubbleBoundingClientRect, defaultAlign, shiftAmounts, availableHeight, availableWidth, xOffset, yOffset) {
      const bubbleOverflows = {};
      const align = {
        horizontal: defaultAlign.horizontal,
        vertical: defaultAlign.vertical
      };
      const positionAt = {
        top: null,
        right: null,
        bottom: null,
        left: null
      };
      bubbleOverflows.right = triggerBoundingClientRect.left + bubbleBoundingClientRect.width > availableWidth;
      bubbleOverflows.left = triggerBoundingClientRect.right - bubbleBoundingClientRect.width < 0;
      bubbleOverflows.top = triggerBoundingClientRect.top - (bubbleBoundingClientRect.height + shiftAmounts.vertical) < 0;
      bubbleOverflows.bottom = triggerBoundingClientRect.bottom + bubbleBoundingClientRect.height + shiftAmounts.vertical > availableHeight;

      if (bubbleOverflows.right) {
        align.horizontal = 'right';
        positionAt.right = availableWidth - triggerBoundingClientRect.right;
      }

      if (bubbleOverflows.left) {
        align.horizontal = 'left';
        positionAt.left = triggerBoundingClientRect.right;
      }

      if (bubbleOverflows.top) {
        align.vertical = 'top';
        positionAt.top = triggerBoundingClientRect.bottom;
      }

      if (bubbleOverflows.bottom) {
        align.vertical = 'bottom';
        positionAt.bottom = availableHeight - triggerBoundingClientRect.top;
      }

      const result = {
        align
      }; // assign default values for position bottom & left based on trigger element if needed
      // - default anchor point of popover is bottom left attached to trigger element's top left

      positionAt.bottom = positionAt.top || positionAt.top === 0 ? null : availableHeight - triggerBoundingClientRect.top;
      positionAt.left = positionAt.right || positionAt.right === 0 ? null : triggerBoundingClientRect.left; // apply calculated position values

      result.top = positionAt.top ? positionAt.top + shiftAmounts.vertical + yOffset + 'px' : positionAt.top;
      result.right = positionAt.right ? positionAt.right - shiftAmounts.horizontal - xOffset + 'px' : positionAt.right;
      result.bottom = positionAt.bottom ? positionAt.bottom + shiftAmounts.vertical - yOffset + 'px' : positionAt.bottom;
      result.left = positionAt.left ? positionAt.left - shiftAmounts.horizontal + xOffset + 'px' : positionAt.left;
      return result;
    }
    function getNubbinShiftAmount(nubbinComputedStyles, triggerWidth) {
      // calculate smallest positive value of horizontal nubbin distance, right or left
      // - the nubbin is the pointy element on the bubble
      const nubbinShiftLeft = parseInt(nubbinComputedStyles.left, 10) || -1;
      const nubbinShiftRight = parseInt(nubbinComputedStyles.right, 10) || -1; // check which measurement is the lesser of the two (closest to edge)

      let nubbinShift = nubbinShiftLeft < nubbinShiftRight ? nubbinShiftLeft : nubbinShiftRight; // use the positive, greater than zero, shift value

      if (nubbinShift < 0 && nubbinShiftLeft < 0 && nubbinShiftRight > 0) {
        nubbinShift = nubbinShiftRight;
      }

      if (nubbinShift < 0 && nubbinShiftRight < 0 && nubbinShiftLeft > 0) {
        nubbinShift = nubbinShiftLeft;
      }

      return {
        horizontal: nubbinShift - triggerWidth / 2,
        // prettier-ignore
        vertical: parseInt(nubbinComputedStyles.height, 10)
      };
    }

    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const CACHED_BUBBLE_ELEMENT$1 = lwc.createElement('lightning-primitive-datatable-tooltip-bubble', {
      is: LightningPrimitiveDatatableTooltipBubble$1
    });
    CACHED_BUBBLE_ELEMENT$1.style.position = 'absolute';
    CACHED_BUBBLE_ELEMENT$1.style.minWidth = '75px';
    const DEFAULT_ANCHORING = {
      trigger: {
        horizontal: 'left',
        vertical: 'top'
      },
      bubble: {
        horizontal: 'left',
        vertical: 'bottom'
      }
    };
    const ZERO_OFFSET = {
      horizontal: 0,
      // right if > 0, left if < 0
      vertical: 0 // down if > 0, up if < 0

    };

    class LightningPrimitiveDatatableTooltip extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.header = '';
        this.content = [];
        this.size = 'medium';
        this.trigger = 'click';
        this.hideCloseButton = false;
        this.variant = 'bare';
        this.alternativeText = void 0;
        this.internalTabIndex = void 0;
        this._uniqueId = `primitive-datatable-tooltip_${guid()}`;
        this.state = {
          showErrorBubble: false,
          offset: ZERO_OFFSET
        };
        this.handleBrowserEvent = raf(() => {
          // only perform changes for the currently focused/active trigger
          if (this.state.showErrorBubble && this.isBubbleAttachedToTrigger()) {
            this.setBubblePosition();
          }
        });

        this.handleBubbleClose = event => {
          // only keep 1 listener at a time and always turn off this.state.showErrorBubble
          // on close
          const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
          bubbleEl.removeEventListener('close', this.handleBubbleClose);

          if (event.detail.anchor === this._uniqueId) {
            this.hideBubble();

            if (event.detail.reason !== 'bubbleLoseFocus') {
              this.triggerElement.focus();
            }
          }
        };
      }

      connectedCallback() {
        // watch for resize & scroll events to recalculate when needed
        window.addEventListener('resize', this.handleBrowserEvent, false);
        window.addEventListener('scroll', this.handleBrowserEvent, true);
      }

      disconnectedCallback() {
        // remove event listeners
        window.removeEventListener('resize', this.handleBrowserEvent, false);
        window.removeEventListener('scroll', this.handleBrowserEvent, true);
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        bubbleEl.removeEventListener('close', this.handleBubbleClose);
      }

      get offset() {
        return this.state.offset;
      }

      set offset(value) {
        this.state.offset = _objectSpread$1({}, ZERO_OFFSET, value);
      }

      focus() {
        this.triggerElement.focus();
      }

      get computedButtonClass() {
        const classes = classSet('slds-button').add('slds-button_icon');
        classes.add({
          'slds-button_icon-error': this.variant === 'error'
        });
        return classes.toString();
      }

      get computedHeaderIconName() {
        switch (this.variant) {
          case 'error':
            return 'utility:ban';

          case 'warning':
            return 'utility:warning';

          case 'bare':
          default:
            return 'utility:info';
        }
      }

      get triggerElement() {
        return this.template.querySelector('[data-trigger="true"]');
      }

      handleMouseOver() {
        if (this.trigger === 'hover') {
          this.showBubble();
        }
      }

      handleMouseOut() {
        if (this.trigger === 'hover') {
          this.hideBubble();
          this.triggerElement.focus();
        }
      }

      handleClick(event) {
        event.preventDefault();

        if (this.trigger === 'click') {
          // since we share bubble element with other tooltip triggers,
          // we need to keep it open if bubble is not attached to the trigger
          if (this.state.showErrorBubble && this.isBubbleAttachedToTrigger()) {
            this.hideBubble();
          } else {
            this.showBubble();
          }
        }
      }

      showBubble() {
        this.state.showErrorBubble = true;
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        this.initBubble();
        this.setBubblePosition();
        bubbleEl.visible = true; // 100ms for bubble to fade in before becoming focusable
        // eslint-disable-next-line @lwc/lwc/no-async-operation

        setTimeout(() => {
          bubbleEl.focus();
        }, 100);
      }

      hideBubble() {
        this.state.showErrorBubble = false;
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        bubbleEl.visible = false; // 25ms for bubble to fade out before trigger becoming focusable
        // eslint-disable-next-line @lwc/lwc/no-async-operation

        setTimeout(() => {
          this.focus();
        }, 25);
      }

      isBubbleAttachedToTrigger() {
        return CACHED_BUBBLE_ELEMENT$1.anchor === this._uniqueId;
      }

      getTriggerBoundingRect() {
        return this.triggerElement ? this.triggerElement.getBoundingClientRect() : null;
      }

      calculateShiftAmounts() {
        // only calculate once
        if (typeof this.shiftAmounts === 'undefined') {
          const bubbleEl = CACHED_BUBBLE_ELEMENT$1; // initialize position in top left corner

          bubbleEl.style.top = 0;
          bubbleEl.style.left = 0;
          bubbleEl.style.bottom = null;
          bubbleEl.style.right = null; // calculate initial position of trigger element

          const triggerElRect = this.getTriggerBoundingRect(); // calculate shift to align nubbin

          const nubbinComputedStyles = window.getComputedStyle(bubbleEl, ':before') || bubbleEl.style;
          this.shiftAmounts = getNubbinShiftAmount(nubbinComputedStyles, triggerElRect.width);
        }
      }

      initBubble() {
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        bubbleEl.anchor = this._uniqueId;
        bubbleEl.content = this.content;
        bubbleEl.header = this.header;
        bubbleEl.variant = this.variant;
        bubbleEl.hideCloseButton = this.hideCloseButton;
        bubbleEl.addEventListener('close', this.handleBubbleClose);

        if (bubbleEl.parentNode === null) {
          document.body.appendChild(bubbleEl);
        }

        this.calculateShiftAmounts();
      }

      setBubblePosition() {
        const rootEl = document.documentElement;
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        const result = getBubbleAlignAndPosition(this.getTriggerBoundingRect(), bubbleEl.getBoundingClientRect(), DEFAULT_ANCHORING.bubble, this.shiftAmounts, rootEl.clientHeight || window.innerHeight, rootEl.clientWidth || window.innerWidth, window.pageXOffset + this.offset.horizontal, window.pageYOffset + this.offset.vertical);
        bubbleEl.align = result.align;
        bubbleEl.style.top = result.top;
        bubbleEl.style.right = result.right;
        bubbleEl.style.bottom = result.bottom;
        bubbleEl.style.left = result.left;
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableTooltip, {
      publicProps: {
        header: {
          config: 0
        },
        content: {
          config: 0
        },
        size: {
          config: 0
        },
        trigger: {
          config: 0
        },
        hideCloseButton: {
          config: 0
        },
        variant: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        },
        offset: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      },
      fields: ["_uniqueId", "handleBrowserEvent", "handleBubbleClose"]
    });

    var _lightningPrimitiveDatatableTooltip = lwc.registerComponent(LightningPrimitiveDatatableTooltip, {
      tmpl: _tmpl$B
    });

    function tmpl$U($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        k: api_key,
        h: api_element,
        i: api_iterator
      } = $api;
      return api_iterator($cmp.formattedParts, function (part) {
        return [part.isLink ? api_element("a", {
          attrs: {
            "target": "_blank",
            "href": part.href,
            "rel": "noopener"
          },
          key: api_key(0, part.key)
        }, [api_dynamic(part.value)]) : null, part.isText ? api_dynamic(part.value) : null, part.isNewline ? api_element("br", {
          key: api_key(1, part.key)
        }, []) : null];
      });
    }

    var _tmpl$D = lwc.registerTemplate(tmpl$U);
    tmpl$U.stylesheets = [];
    tmpl$U.stylesheetTokens = {
      hostAttribute: "lightning-formattedText_formattedText-host",
      shadowAttribute: "lightning-formattedText_formattedText"
    };

    /*
     * Regex was taken from aura lib and refactored
     */

    const linkRegex = new RegExp(`(${newLineRegexString})|${urlRegexString}|${emailRegexString}`, 'gi');
    const emailRegex = new RegExp(emailRegexString, 'gi');
    const newLineRegex = new RegExp(newLineRegexString, 'gi');

    function getTextPart(text) {
      return {
        isText: true,
        value: text
      };
    }

    function getUrlPart(url) {
      return {
        isLink: true,
        value: url,
        href: createHttpHref(url)
      };
    }

    function getEmailPart(email) {
      return {
        isLink: true,
        value: email,
        href: createEmailHref(email)
      };
    }

    function getNewlinePart() {
      return {
        isNewline: true
      };
    }

    function getLinkPart(link) {
      if (link.match(newLineRegex)) {
        return getNewlinePart();
      } else if (link.match(emailRegex)) {
        return getEmailPart(link);
      }

      return getUrlPart(link);
    }

    function parseToFormattedLinkifiedParts(text) {
      const parts = [];
      const re = linkRegex;
      let match;

      while ((match = re.exec(text)) !== null) {
        const indexOfMatch = text.indexOf(match[0]);
        let link = match[0];
        const endsWithQuote = link && link.endsWith('&quot'); // If we found an email or url match, then create a text part for everything
        // up to the match and then create the part for the email or url

        if (indexOfMatch > 0) {
          parts.push(getTextPart(text.slice(0, text.indexOf(match[0]))));
        }

        if (endsWithQuote) {
          link = link.slice(0, link.lastIndexOf('&quot'));
        }

        parts.push(getLinkPart(link));

        if (endsWithQuote) {
          parts.push(getTextPart('&quot'));
        }

        text = text.substring(re.lastIndex);
        re.lastIndex = 0;
      }

      if (text != null && text !== '') {
        parts.push(getTextPart(text));
      }

      return parts;
    }
    function parseToFormattedParts(text) {
      return text.split(newLineRegex).map((part, index) => {
        return index % 2 === 0 ? getTextPart(part) : getNewlinePart();
      });
    }

    /**
     * Displays text, replaces newlines with line breaks, and linkifies if requested.
     */

    class FormattedText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = '';
        this._linkify = false;
      }

      /**
       * If present, URLs and email addresses are displayed in anchor tags.
       * They are displayed in plain text by default.
       * @type {boolean}
       * @default false
       */
      get linkify() {
        return this._linkify;
      }

      set linkify(value) {
        this._linkify = normalizeBoolean(value);
      }

      get formattedParts() {
        if (!this.value || typeof this.value !== 'string') {
          return [];
        }

        return this.linkify ? parseToFormattedLinkifiedParts(this.value) : parseToFormattedParts(this.value);
      }

    }

    lwc.registerDecorators(FormattedText, {
      publicProps: {
        value: {
          config: 0
        },
        linkify: {
          config: 3
        }
      },
      track: {
        _linkify: 1
      }
    });

    var _lightningFormattedText = lwc.registerComponent(FormattedText, {
      tmpl: _tmpl$D
    });

    function tmpl$V($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        ti: api_tab_index,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp.hasValue ? api_element("a", {
        attrs: {
          "href": $cmp.computedUrl,
          "title": $cmp.tooltip,
          "target": $cmp.target,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        key: 0,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick))
        }
      }, [api_dynamic($cmp.computedLabel)]) : null];
    }

    var _tmpl$E = lwc.registerTemplate(tmpl$V);
    tmpl$V.stylesheets = [];
    tmpl$V.stylesheetTokens = {
      hostAttribute: "lightning-formattedUrl_formattedUrl-host",
      shadowAttribute: "lightning-formattedUrl_formattedUrl"
    };

    const GET_LINK_INFO_EVENT = 'lightningroutingservicegetlinkinfo';
    const urlTypes = {
      standard: 'standard_webPage'
    };
    /*
     * Mock getLinkInfo
     *
     * @returns {Promise[LinkInfo]}
     */

    function getLinkInfo(element, stateRef) {
      return new Promise((resolve, reject) => {
        // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments
        const getLinkInfoEvent = new CustomEvent(GET_LINK_INFO_EVENT, {
          detail: {
            stateRef,
            callback: (err, linkInfo) => {
              if (err) {
                reject(err);
              } else {
                resolve(linkInfo);
              }
            }
          },
          bubbles: true,
          composed: true,
          cancelable: true
        });
        element.dispatchEvent(getLinkInfoEvent);
      });
    }
    /**
     * Determines the route for the given url and updates the element
     * state with the correct url and dispatcher.
     *
     * @param {HTMLElement} element Element from which to dispatch the routing event
     * @param {Object} url Link to route, target Target of the link
     * @param {function} callback on the returned LinkInfo
     *
     * @returns {Promise} Promise[LinkInfo]
     */

    function updateRawLinkInfo(element, {
      url,
      target
    }) {
      if (url === undefined || url === null) {
        // eslint-disable-next-line no-console
        console.error('url must be specified');
      }

      if (target === '_blank') {
        // Have a no-op dispatcher if target is blank
        return new Promise(resolve => {
          resolve({
            url,
            dispatcher: () => {}
          });
        });
      }

      return getLinkInfo(element, {
        stateType: urlTypes.standard,
        attributes: {
          url,
          target
        }
      });
    }

    /**
     * Displays a URL as a hyperlink.
     */

    class LightningFormattedUrl extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.target = void 0;
        this.tooltip = void 0;
        this.label = void 0;
        this.tabIndex = void 0;
        this._url = void 0;
        this._value = void 0;
        this._connected = false;

        this._dispatcher = () => {};
      }

      /**
       * The URL to format.
       * @type {string}
       *
       */
      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;

        if (this._connected) {
          this.updateLinkInfo(value);
        }
      }

      connectedCallback() {
        this._connected = true;
        this.updateLinkInfo(this.value);
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the element.
       */


      focus() {
        if (this.urlAnchor) {
          this.urlAnchor.focus();
        }
      }
      /**
       * Removes keyboard focus from the element.
       */


      blur() {
        if (this.urlAnchor) {
          this.urlAnchor.blur();
        }
      }
      /**
       * Clicks and opens the url using the specified target.
       */


      click() {
        const anchor = this.urlAnchor;

        if (anchor && anchor.click) {
          anchor.click();
        }
      }

      get urlAnchor() {
        if (this._connected && this.hasValue) {
          return this.template.querySelector('a');
        }

        return undefined;
      }

      handleClick(event) {
        // For target blank, use the default browser behaviour (open in a new tab)
        if (this.target !== '_blank') {
          this._dispatcher(event);
        }
      }

      updateLinkInfo(url) {
        updateRawLinkInfo(this, {
          url: this.makeAbsoluteUrl(url),
          target: this.target
        }).then(linkInfo => {
          this._url = linkInfo.url;
          this._dispatcher = linkInfo.dispatcher;
        });
      }

      get computedLabel() {
        const {
          label,
          computedUrl
        } = this;
        return label != null && label !== '' ? label : computedUrl;
      }

      get computedUrl() {
        return this._url || this.makeAbsoluteUrl(this.value);
      }

      get hasValue() {
        const url = this.value;
        return url != null && url !== '';
      }

      makeAbsoluteUrl(url) {
        return isAbsoluteUrl(url) ? url : `http://${url}`;
      }

    }

    lwc.registerDecorators(LightningFormattedUrl, {
      publicProps: {
        target: {
          config: 0
        },
        tooltip: {
          config: 0
        },
        label: {
          config: 0
        },
        tabIndex: {
          config: 0
        },
        value: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "click"],
      track: {
        _url: 1,
        _value: 1
      },
      fields: ["_connected", "_dispatcher"]
    });

    var _lightningFormattedUrl = lwc.registerComponent(LightningFormattedUrl, {
      tmpl: _tmpl$E
    });

    function tmpl$W($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        t: api_text,
        d: api_dynamic,
        ti: api_tab_index,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("span", {
        className: $cmp.computedWrapperClass,
        key: 25
      }, [api_element("div", {
        className: $cmp.computedCellDivClass,
        style: $cmp.computedCssStyles,
        key: 21
      }, [$cmp.hasLeftIcon ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.iconName,
          "size": "x-small",
          "alternativeText": $cmp.iconAlternativeText
        },
        key: 0
      }, []) : null, $cmp.hasLeftIcon ? api_text("\xA0 ") : null, $cmp.hasLeftIcon ? api_dynamic($cmp.iconLabel) : null, $cmp.hasLeftIcon ? api_text(" \xA0") : null, $cmp.hasTreeData ? api_custom_element("lightning-primitive-treegrid-cell-toggle", _lightningPrimitiveTreegridCellToggle, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "value": $cmp.value,
          "hasChildren": $cmp.typeAttribute21,
          "isExpanded": $cmp.typeAttribute22,
          "tabIndex": api_tab_index($cmp.internalTabIndex)
        },
        key: 1
      }, []) : null, $cmp.isAction ? api_custom_element("lightning-primitive-cell-actions", _lightningPrimitiveCellActions, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space"
        },
        props: {
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "menuAlignment": $cmp.typeAttribute0,
          "rowActions": $cmp.typeAttribute1
        },
        key: 2
      }, []) : null, $cmp.isButton ? api_custom_element("lightning-primitive-cell-button", _lightningPrimitiveCellButton, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space"
        },
        props: {
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "variant": $cmp.typeAttribute0,
          "label": $cmp.typeAttribute1,
          "iconName": $cmp.typeAttribute2,
          "iconPosition": $cmp.typeAttribute3,
          "disabled": $cmp.typeAttribute4,
          "buttonName": $cmp.typeAttribute5,
          "buttonClass": $cmp.typeAttribute6,
          "buttonTitle": $cmp.typeAttribute7,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "internalTabIndex": $cmp.internalTabIndex
        },
        key: 3
      }, []) : null, $cmp.isButtonIcon ? api_custom_element("lightning-primitive-cell-button", _lightningPrimitiveCellButton, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space"
        },
        props: {
          "type": "button-icon",
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "variant": $cmp.typeAttribute0,
          "alternativeText": $cmp.typeAttribute1,
          "iconName": $cmp.typeAttribute2,
          "iconClass": $cmp.typeAttribute3,
          "disabled": $cmp.typeAttribute4,
          "buttonName": $cmp.typeAttribute5,
          "buttonClass": $cmp.typeAttribute6,
          "buttonTitle": $cmp.typeAttribute7,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "internalTabIndex": $cmp.internalTabIndex
        },
        key: 4
      }, []) : null, $cmp.isBoolean ? $cmp.isChecked ? api_element("temaplte", {
        key: 6
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "size": "x-small",
          "iconName": "utility:check"
        },
        key: 5
      }, [])]) : null : null, $cmp.isCurrency ? api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        props: {
          "value": $cmp.value,
          "formatStyle": "currency",
          "currencyCode": $cmp.typeAttribute0,
          "currencyDisplayAs": $cmp.typeAttribute1,
          "minimumIntegerDigits": $cmp.typeAttribute2,
          "minimumFractionDigits": $cmp.typeAttribute3,
          "maximumFractionDigits": $cmp.typeAttribute4,
          "minimumSignificantDigits": $cmp.typeAttribute5,
          "maximumSignificantDigits": $cmp.typeAttribute6
        },
        key: 7
      }, []) : null, $cmp.isCustomType ? api_custom_element("lightning-primitive-custom-cell", _lightningPrimitiveCustomCell, {
        props: {
          "types": $cmp.types,
          "keyboardMode": $cmp.keyboardMode,
          "columnType": $cmp.columnType,
          "columnSubType": $cmp.columnSubType,
          "value": $cmp.value,
          "internalTabIndex": $cmp.state.internalTabIndex,
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "wrapText": $cmp.wrapText,
          "alignment": $cmp.alignment,
          "typeAttribute0": $cmp.typeAttribute0,
          "typeAttribute1": $cmp.typeAttribute1,
          "typeAttribute2": $cmp.typeAttribute2,
          "typeAttribute3": $cmp.typeAttribute3,
          "typeAttribute4": $cmp.typeAttribute4,
          "typeAttribute5": $cmp.typeAttribute5,
          "typeAttribute6": $cmp.typeAttribute6,
          "typeAttribute7": $cmp.typeAttribute7,
          "typeAttribute8": $cmp.typeAttribute8,
          "typeAttribute9": $cmp.typeAttribute9,
          "typeAttribute10": $cmp.typeAttribute10
        },
        key: 8
      }, []) : null, $cmp.isDateTime ? api_custom_element("lightning-formatted-date-time", _lightningFormattedDateTime, {
        props: {
          "value": $cmp.dateValue,
          "day": $cmp.typeAttribute0,
          "era": $cmp.typeAttribute1,
          "hour": $cmp.typeAttribute2,
          "hour12": $cmp.typeAttribute3,
          "minute": $cmp.typeAttribute4,
          "month": $cmp.typeAttribute5,
          "second": $cmp.typeAttribute6,
          "timeZone": $cmp.typeAttribute7,
          "timeZoneName": $cmp.typeAttribute8,
          "weekday": $cmp.typeAttribute9,
          "year": $cmp.typeAttribute10
        },
        key: 9
      }, []) : null, $cmp.isDateLocal ? api_custom_element("lightning-formatted-date-time", _lightningFormattedDateTime, {
        props: {
          "value": $cmp.value,
          "day": $cmp.computedDateLocalDay,
          "month": $cmp.computedDateLocalMonth,
          "year": $cmp.computedDateLocalYear,
          "timeZone": "UTC"
        },
        key: 10
      }, []) : null, $cmp.isEmail ? api_custom_element("lightning-formatted-email", _lightningFormattedEmail, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter"
        },
        props: {
          "value": $cmp.value,
          "tabIndex": api_tab_index($cmp.internalTabIndex)
        },
        key: 11
      }, []) : null, $cmp.isLocation ? api_custom_element("lightning-formatted-location", _lightningFormattedLocation, {
        props: {
          "latitude": $cmp.value.latitude,
          "longitude": $cmp.value.longitude
        },
        key: 12
      }, []) : null, $cmp.isNumber ? api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        props: {
          "value": $cmp.value,
          "minimumIntegerDigits": $cmp.typeAttribute0,
          "minimumFractionDigits": $cmp.typeAttribute1,
          "maximumFractionDigits": $cmp.typeAttribute2,
          "minimumSignificantDigits": $cmp.typeAttribute3,
          "maximumSignificantDigits": $cmp.typeAttribute4
        },
        key: 13
      }, []) : null, $cmp.isPercent ? api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        props: {
          "value": $cmp.value,
          "formatStyle": "percent",
          "minimumIntegerDigits": $cmp.typeAttribute0,
          "minimumFractionDigits": $cmp.typeAttribute1,
          "maximumFractionDigits": $cmp.typeAttribute2,
          "minimumSignificantDigits": $cmp.typeAttribute3,
          "maximumSignificantDigits": $cmp.typeAttribute4
        },
        key: 14
      }, []) : null, $cmp.isPhone ? api_custom_element("lightning-formatted-phone", _lightningFormattedPhone, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter"
        },
        props: {
          "value": $cmp.value,
          "tabIndex": api_tab_index($cmp.internalTabIndex)
        },
        key: 15
      }, []) : null, $cmp.isRowNumber ? api_custom_element("lightning-primitive-datatable-tooltip", _lightningPrimitiveDatatableTooltip, {
        className: $cmp.rowNumberErrorClass,
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space"
        },
        props: {
          "size": "xx-small",
          "header": $cmp.typeAttribute0.title,
          "content": $cmp.typeAttribute0.messages,
          "variant": "error",
          "internalTabIndex": $cmp.internalTabIndex,
          "alternativeText": $cmp.typeAttribute0.alternativeText
        },
        key: 16
      }, []) : null, $cmp.isRowNumber ? api_element("span", {
        classMap: {
          "slds-row-number": true,
          "slds-text-body_small": true,
          "slds-text-color_weak": true
        },
        key: 17
      }, []) : null, $cmp.isText ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        props: {
          "value": $cmp.value,
          "linkify": $cmp.typeAttribute0
        },
        key: 18
      }, []) : null, $cmp.isUrl ? api_custom_element("lightning-formatted-url", _lightningFormattedUrl, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter"
        },
        props: {
          "value": $cmp.value,
          "tooltip": $cmp.urlTooltip,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "label": $cmp.typeAttribute0,
          "target": $cmp.urlTarget
        },
        key: 19
      }, []) : null, $cmp.hasRightIcon ? api_text("\xA0") : null, $cmp.hasRightIcon ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.iconName,
          "size": "x-small",
          "alternativeText": $cmp.iconAlternativeText
        },
        key: 20
      }, []) : null, $cmp.hasRightIcon ? api_text("\xA0 ") : null, $cmp.hasRightIcon ? api_dynamic($cmp.iconLabel) : null]), $cmp.isEditable ? api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true,
          "slds-cell-edit__button": true,
          "slds-m-left_x-small": true
        },
        attrs: {
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable",
          "data-action-triggers": "enter,space",
          "data-action-edit": "true"
        },
        key: 24,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleEditButtonClick))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:edit",
          "size": "xx-small",
          "svgClass": "slds-button__icon slds-button__icon_hint slds-button__icon_lock slds-button__icon_small slds-button__icon_edit"
        },
        key: 22
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 23
      }, [api_dynamic($cmp.editIconAssistiveText)])]) : null])];
    }

    var cellWithStandardLayout = lwc.registerTemplate(tmpl$W);
    tmpl$W.stylesheets = [];
    tmpl$W.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellFactory_cellWithStandardLayout-host",
      shadowAttribute: "lightning-primitiveCellFactory_cellWithStandardLayout"
    };

    function tmpl$X($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element
      } = $api;
      return [api_element("div", {
        className: $cmp.computedCellDivClass,
        key: 1
      }, [api_custom_element("lightning-primitive-custom-cell", _lightningPrimitiveCustomCell, {
        props: {
          "types": $cmp.types,
          "keyboardMode": $cmp.keyboardMode,
          "columnType": $cmp.columnType,
          "columnSubType": $cmp.columnSubType,
          "wrapText": $cmp.wrapText,
          "alignment": $cmp.alignment,
          "value": $cmp.value,
          "internalTabIndex": $cmp.state.internalTabIndex,
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "typeAttribute0": $cmp.typeAttribute0,
          "typeAttribute1": $cmp.typeAttribute1,
          "typeAttribute2": $cmp.typeAttribute2,
          "typeAttribute3": $cmp.typeAttribute3,
          "typeAttribute4": $cmp.typeAttribute4,
          "typeAttribute5": $cmp.typeAttribute5,
          "typeAttribute6": $cmp.typeAttribute6,
          "typeAttribute7": $cmp.typeAttribute7,
          "typeAttribute8": $cmp.typeAttribute8,
          "typeAttribute9": $cmp.typeAttribute9,
          "typeAttribute10": $cmp.typeAttribute10
        },
        key: 0
      }, [])])];
    }

    var bareCustomCell = lwc.registerTemplate(tmpl$X);
    tmpl$X.stylesheets = [];
    tmpl$X.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellFactory_bareCustomCell-host",
      shadowAttribute: "lightning-primitiveCellFactory_bareCustomCell"
    };

    var labelEdit = 'Edit';

    var labelEditHasError = 'has error';

    const i18n$l = {
      edit: labelEdit,
      editHasError: labelEditHasError
    };

    function isNumberedBasedType(cellType) {
      return cellType === 'currency' || cellType === 'number' || cellType === 'percent';
    }

    function isTypeCenteredByDefault(cellType) {
      return cellType === 'button-icon';
    }

    class PrivateCellFactory extends PrimitiveDatatableCell$1 {
      constructor(...args) {
        super(...args);
        this.types = void 0;
        this.alignment = void 0;
        this.value = void 0;
        this.iconName = void 0;
        this.iconLabel = void 0;
        this.iconPosition = void 0;
        this.iconAlternativeText = void 0;
        this.editable = void 0;
        this.hasError = void 0;
        this.columnLabel = void 0;
        this.columnSubType = void 0;
        this.typeAttribute0 = void 0;
        this.typeAttribute1 = void 0;
        this.typeAttribute2 = void 0;
        this.typeAttribute3 = void 0;
        this.typeAttribute4 = void 0;
        this.typeAttribute5 = void 0;
        this.typeAttribute6 = void 0;
        this.typeAttribute7 = void 0;
        this.typeAttribute8 = void 0;
        this.typeAttribute9 = void 0;
        this.typeAttribute10 = void 0;
        this.typeAttribute21 = void 0;
        this.typeAttribute22 = void 0;
        this.wrapTextMaxLines = void 0;
      }

      get wrapText() {
        return this.state.wrapText;
      }

      set wrapText(value) {
        if (value) {
          this.classList.add('slds-cell-wrap');
        } else {
          this.classList.remove('slds-cell-wrap');
        }

        this.state.wrapText = value;
      }

      get columnType() {
        return this.state.columnType;
      }

      set columnType(value) {
        if (value === 'tree') {
          this.classList.add('slds-no-space');
        }

        this.state.columnType = value;
      }

      getActionableElements() {
        const result = Array.prototype.slice.call(this.template.querySelectorAll('[data-navigation="enable"]'));
        const customType = this.template.querySelector('lightning-primitive-custom-cell');

        if (customType) {
          const wrapperActionableElements = customType.getActionableElements();
          wrapperActionableElements.forEach(elem => result.push(elem));
        }

        return result;
      }
      /**
       *  Getters for each type used in the template to include the correct formatted component.
       *  When any new type is added, getter should be added here to be used in the template
       */


      isType(typeName) {
        return typeName === this.columnType || typeName === this.columnSubType;
      }

      get isText() {
        return this.isType('text');
      }

      get isNumber() {
        return this.isType('number');
      }

      get isCurrency() {
        return this.isType('currency');
      }

      get isPercent() {
        return this.isType('percent');
      }

      get isEmail() {
        return this.isType('email');
      }

      get isDateTime() {
        return this.isType('date');
      }

      get isPhone() {
        return this.isType('phone');
      }

      get isUrl() {
        return this.isType('url');
      }

      get isLocation() {
        return this.isType('location');
      }

      get isRowNumber() {
        return this.isType('rowNumber');
      }

      get isAction() {
        return this.isType('action');
      }

      get isButton() {
        return this.isType('button');
      }

      get isButtonIcon() {
        return this.isType('button-icon');
      }

      get isBoolean() {
        return this.isType('boolean');
      }

      get isDateLocal() {
        return this.isType('date-local');
      }

      isLtrType() {
        return this.columnType === 'url' || this.columnType === 'email' || this.columnType === 'phone';
      }

      get hasTreeData() {
        return this.columnType === 'tree';
      }

      get isCustomType() {
        return this.types && this.types.isCustomType(this.columnType);
      }

      get isEditable() {
        // return true only for standard cells with editable true
        // TODO 226 custom cells with standardCellLayout should return true if editable is true
        return this.editable && !this.isCustomType;
      }

      render() {
        if (this.isCustomType && !this.types.standardCellLayoutForCustomType(this.columnType)) {
          return bareCustomCell;
        }

        return cellWithStandardLayout;
      }
      /**
       *  Getters related to styling of the wrapper or the types.
       */


      get isSpreadAlignment() {
        const alignment = this.computedAlignment;
        return !alignment || alignment === 'left' || alignment !== 'center' && alignment !== 'right';
      } // Note: this should be passed from above, but we dont have a defined architecture that lets customize / provide defaults
      // on cell attributes per type.


      get computedAlignment() {
        if (!this.alignment && isNumberedBasedType(this.columnType)) {
          return 'right';
        }

        if (!this.alignment && isTypeCenteredByDefault(this.columnType)) {
          return 'center';
        }

        return this.alignment;
      }

      get hasLeftIcon() {
        return !this.hasTreeData && this.iconName && (!this.iconPosition || this.iconPosition === 'left');
      }

      get hasRightIcon() {
        return this.iconName && this.iconPosition === 'right';
      }

      get computedCellDivClass() {
        return classSet().add({
          'slds-truncate': !this.isAction && this.columnType !== 'button-icon' && !this.wrapText
        }).add({
          'slds-hyphenate': this.wrapText
        }).add({
          'slds-line-clamp': this.wrapText && this.wrapTextMaxLines
        }).add({
          'ltr-content-in-rtl': document.dir === 'rtl' && this.isLtrType()
        }).toString();
      }

      get computedWrapperClass() {
        const alignment = this.computedAlignment;
        return classSet('slds-grid').add({
          'slds-no-space': this.hasTreeData,
          'slds-align_absolute-center': this.isAction,
          'slds-grid_align-end': alignment === 'right',
          'slds-grid_align-center': alignment === 'center',
          'slds-grid_align-spread': this.isSpreadAlignment
        }).toString();
      }

      get rowNumberErrorClass() {
        const classes = classSet('slds-m-horizontal_xxx-small');
        const error = this.typeAttribute0;

        if (error) {
          classes.add({
            'slds-hidden': !error.title && !error.messages
          });
        }

        return classes.toString();
      }

      get editIconAssistiveText() {
        const suffix = this.hasError ? ` ${i18n$l.editHasError}` : '';
        return `${i18n$l.edit} ${this.columnLabel}${suffix}`;
      }
      /**
       *  Getters related to manipulating value or attributes of any type go here.
       *  When any new type is added, getter should be added here if there is need.
       */


      get urlTarget() {
        return this.typeAttribute1 || '_self';
      }

      get urlTooltip() {
        if (this.typeAttribute2 === '') {
          return '';
        }

        return this.typeAttribute2 || this.value;
      }

      get isChecked() {
        return !!this.value;
      }

      get dateValue() {
        // new Date(null) returns new Date(0), which is not expected.
        // for undefined, '', or any other invalid values, formatted-date-time
        // just displays ''
        if (this.value === null) {
          return '';
        } // this is temporary, formatted-date-time should accept
        // date time string formats like '2017-03-01 08:45:12Z'
        // it's accepting only timestamp and Date objects


        return new Date(this.value);
      }

      get computedDateLocalDay() {
        return this.typeAttribute0 || 'numeric';
      }

      get computedDateLocalMonth() {
        return this.typeAttribute1 || 'short';
      }

      get computedDateLocalYear() {
        return this.typeAttribute2 || 'numeric';
      }

      get computedCssStyles() {
        if (this.wrapText && this.wrapTextMaxLines) {
          return `${'--lwc-lineClamp'}: ${this.wrapTextMaxLines}`;
        }

        return null;
      }
      /**
       *  Event handlers below this.
       *  If listening to any event on the wrapper or any type add the handler here
       */
      // Inline edit button


      handleEditButtonClick() {
        const {
          rowKeyValue,
          colKeyValue
        } = this;
        const event = new CustomEvent('privateeditcell', {
          bubbles: true,
          composed: true,
          detail: {
            rowKeyValue,
            colKeyValue
          }
        });
        this.dispatchEvent(event);
      } // Overridden click handler from the datatable-cell.


      handleClick() {
        if (!this.classList.contains('slds-has-focus')) {
          this.addFocusStyles();
          this.fireCellFocusByClickEvent();
        }
      }

      fireCellFocusByClickEvent() {
        let needsRefocusOnCellElement = false;
        const wrapperDiv = this.template.querySelector('div:first-child');
        const wrapperSpan = this.template.querySelector('span.slds-grid:first-child');
        const activeElement = this.template.activeElement; // pass a flag for IE11 to refocus on the cell element if the activeElement is not
        // something focusable in the cell or the cell td/th itself

        if (activeElement && (activeElement === wrapperDiv || activeElement === wrapperSpan)) {
          needsRefocusOnCellElement = true;
        }

        const {
          rowKeyValue,
          colKeyValue
        } = this;
        const event = new CustomEvent('privatecellfocusedbyclick', {
          bubbles: true,
          composed: true,
          detail: {
            rowKeyValue,
            colKeyValue,
            needsRefocusOnCellElement
          }
        });
        this.dispatchEvent(event);
      }

    }

    lwc.registerDecorators(PrivateCellFactory, {
      publicProps: {
        types: {
          config: 0
        },
        alignment: {
          config: 0
        },
        value: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconLabel: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        iconAlternativeText: {
          config: 0
        },
        editable: {
          config: 0
        },
        hasError: {
          config: 0
        },
        columnLabel: {
          config: 0
        },
        columnSubType: {
          config: 0
        },
        typeAttribute0: {
          config: 0
        },
        typeAttribute1: {
          config: 0
        },
        typeAttribute2: {
          config: 0
        },
        typeAttribute3: {
          config: 0
        },
        typeAttribute4: {
          config: 0
        },
        typeAttribute5: {
          config: 0
        },
        typeAttribute6: {
          config: 0
        },
        typeAttribute7: {
          config: 0
        },
        typeAttribute8: {
          config: 0
        },
        typeAttribute9: {
          config: 0
        },
        typeAttribute10: {
          config: 0
        },
        typeAttribute21: {
          config: 0
        },
        typeAttribute22: {
          config: 0
        },
        wrapTextMaxLines: {
          config: 0
        },
        wrapText: {
          config: 3
        },
        columnType: {
          config: 3
        }
      }
    });

    var _lightningPrimitiveCellFactory = lwc.registerComponent(PrivateCellFactory, {
      tmpl: _tmpl$1
    });

    function stylesheet$b(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$b = [stylesheet$b];

    function tmpl$Y($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-spinner", _lightningSpinner, {
        styleMap: {
          "height": "40px"
        },
        props: {
          "variant": "brand",
          "alternativeText": $cmp.i18n.loading
        },
        key: 0
      }, [])];
    }

    var _tmpl$F = lwc.registerTemplate(tmpl$Y);
    tmpl$Y.stylesheets = [];

    if (_implicitStylesheets$b) {
      tmpl$Y.stylesheets.push.apply(tmpl$Y.stylesheets, _implicitStylesheets$b);
    }
    tmpl$Y.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableLoadingIndicator_primitiveDatatableLoadingIndicator-host",
      shadowAttribute: "lightning-primitiveDatatableLoadingIndicator_primitiveDatatableLoadingIndicator"
    };

    var labelLoading$1 = 'Loading';

    const i18n$m = {
      loading: labelLoading$1
    };

    class LightningPrimitiveDatatableLoadingIndicator extends lwc.LightningElement {
      get i18n() {
        return i18n$m;
      }

    }

    var _lightningPrimitiveDatatableLoadingIndicator = lwc.registerComponent(LightningPrimitiveDatatableLoadingIndicator, {
      tmpl: _tmpl$F
    });

    function tmpl$Z($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-docked-form-footer": true,
          "slds-is-absolute": true
        },
        key: 4
      }, [api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-grid_align-center": true
        },
        key: 3
      }, [$cmp.showError ? api_custom_element("lightning-primitive-datatable-tooltip", _lightningPrimitiveDatatableTooltip, {
        classMap: {
          "slds-button": true
        },
        props: {
          "size": "small",
          "variant": "error",
          "header": $cmp.error.title,
          "content": $cmp.error.messages,
          "alternativeText": $cmp.i18n.error,
          "offset": $cmp.bubbleOffset
        },
        key: 0
      }, []) : null, api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_neutral": true
        },
        attrs: {
          "type": "button"
        },
        key: 1,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCancelButtonClick))
        }
      }, [api_dynamic($cmp.i18n.cancel)]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true,
          "save-btn": true
        },
        attrs: {
          "type": "button"
        },
        key: 2,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleSaveButtonClick))
        }
      }, [api_dynamic($cmp.i18n.save)])])])];
    }

    var _tmpl$G = lwc.registerTemplate(tmpl$Z);
    tmpl$Z.stylesheets = [];
    tmpl$Z.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableStatusBar_primitiveDatatableStatusBar-host",
      shadowAttribute: "lightning-primitiveDatatableStatusBar_primitiveDatatableStatusBar"
    };

    var labelSave = 'Save';

    var labelError = 'Fix the errors and try saving again';

    const i18n$n = {
      save: labelSave,
      cancel: labelCancel,
      error: labelError
    };

    class LightningPrimitiveDatatableStatusBar extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.privateError = {};
      }

      get error() {
        return this.privateError;
      }

      set error(value) {
        this.privateError = value;

        if (this.showError && this.isSaveBtnFocused()) {
          this.focusOnErrorMessages();
        }
      }

      get i18n() {
        return i18n$n;
      }

      get showError() {
        const {
          error
        } = this;
        return error && (error.title || error.messages);
      }

      get bubbleOffset() {
        // move bubble above the docked bar since docked bar has higher z-index
        // and can block the nubbin of the bubble
        return {
          vertical: -10
        };
      }

      handleCancelButtonClick(event) {
        event.preventDefault();
        event.stopPropagation();
        this.dispatchEvent(new CustomEvent('privatecancel', {
          bubbles: true,
          composed: true,
          cancelable: true
        }));
      }

      handleSaveButtonClick(event) {
        event.preventDefault();
        event.stopPropagation(); // safari and firefox does not focus on click.

        if (document.activeElement !== event.target) {
          event.target.focus();
        }

        this.dispatchEvent(new CustomEvent('privatesave', {
          bubbles: true,
          composed: true,
          cancelable: true
        }));
      }

      isSaveBtnFocused() {
        return this.template.querySelector('button.save-btn:focus') !== null;
      }

      focusOnErrorMessages() {
        Promise.resolve().then(() => {
          const trigger = this.template.querySelector('lightning-primitive-datatable-tooltip');

          if (trigger) {
            trigger.focus();
          }
        });
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableStatusBar, {
      publicProps: {
        error: {
          config: 3
        }
      },
      track: {
        privateError: 1
      }
    });

    var _lightningPrimitiveDatatableStatusBar = lwc.registerComponent(LightningPrimitiveDatatableStatusBar, {
      tmpl: _tmpl$G
    });

    function tmpl$_($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element,
        b: api_bind,
        c: api_custom_element,
        k: api_key,
        ti: api_tab_index,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "dt-width-observer": true
        },
        styleMap: {
          "width": "100%",
          "height": "0px"
        },
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 0
      }, []), api_element("div", {
        styleMap: {
          "height": "100%",
          "position": "relative"
        },
        key: 23
      }, [api_custom_element("lightning-primitive-datatable-iedit-panel", _lightningPrimitiveDatatableIeditPanel, {
        attrs: {
          "data-iedit-panel": "true"
        },
        props: {
          "visible": $cmp.state.inlineEdit.isPanelVisible,
          "rowKeyValue": $cmp.state.inlineEdit.rowKeyValue,
          "colKeyValue": $cmp.state.inlineEdit.colKeyValue,
          "editedValue": $cmp.state.inlineEdit.editedValue,
          "columnDef": $cmp.state.inlineEdit.columnDef,
          "isMassEditEnabled": $cmp.state.inlineEdit.massEditEnabled,
          "numberOfSelectedRows": $cmp.state.inlineEdit.massEditSelectedRows
        },
        key: 1,
        on: {
          "ieditfinished": _m0 || ($ctx._m0 = api_bind($cmp.handleInlineEditFinish)),
          "masscheckboxchange": _m1 || ($ctx._m1 = api_bind($cmp.handleMassCheckboxChange))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-table_header-fixed_container": true,
          "slds-scrollable_x": true
        },
        style: $cmp.scrollerXStyles,
        key: 21,
        on: {
          "scroll": _m9 || ($ctx._m9 = api_bind($cmp.handleHorizontalScroll))
        }
      }, [api_element("div", {
        classMap: {
          "slds-scrollable_y": true
        },
        style: $cmp.computedScrollerStyle,
        key: 20,
        on: {
          "scroll": _m8 || ($ctx._m8 = api_bind($cmp.handleVerticalScroll))
        }
      }, [api_element("div", {
        key: 19
      }, [api_element("table", {
        className: $cmp.computedTableClass,
        style: $cmp.computedTableStyle,
        attrs: {
          "role": $cmp.computedTableRole,
          "tabindex": api_tab_index($cmp.state.tabindex)
        },
        key: 18,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleTableFocus)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleTableKeydown)),
          "click": _m5 || ($ctx._m5 = api_bind($cmp.handleCellClick)),
          "focusin": _m6 || ($ctx._m6 = api_bind($cmp.handleTableFocusIn)),
          "focusout": _m7 || ($ctx._m7 = api_bind($cmp.handleTableFocusOut))
        }
      }, [$cmp.hasValidKeyField ? api_element("thead", {
        className: $cmp.computedTableHeaderClass,
        key: 6
      }, [api_element("tr", {
        classMap: {
          "slds-line-height_reset": true
        },
        key: 5
      }, api_iterator($cmp.state.columns, function (def, colIndex) {
        return api_element("th", {
          style: def.style,
          attrs: {
            "scope": "col",
            "tabindex": api_tab_index(def.tabIndex),
            "aria-label": def.ariaLabel,
            "aria-sort": def.sortAriaLabel
          },
          key: api_key(4, def.colKeyValue)
        }, [def.fixedWidth ? api_custom_element("lightning-primitive-header-factory", _lightningPrimitiveHeaderFactory, {
          style: def.style,
          props: {
            "def": def,
            "dtContextId": $cmp.privateDatatableId,
            "rowKeyValue": "HEADER",
            "colKeyValue": def.colKeyValue,
            "hasFocus": def.hasFocus,
            "columnWidth": def.columnWidth,
            "colIndex": colIndex,
            "sortable": def.sortable,
            "sorted": def.sorted,
            "sortedDirection": def.sortedDirection,
            "showCheckbox": $cmp.showSelectAllCheckbox,
            "actions": def.actions
          },
          key: api_key(2, def.colKeyValue)
        }, []) : null, !def.fixedWidth ? api_custom_element("lightning-primitive-header-factory", _lightningPrimitiveHeaderFactory, {
          style: def.style,
          props: {
            "def": def,
            "dtContextId": $cmp.privateDatatableId,
            "rowKeyValue": "HEADER",
            "colKeyValue": def.colKeyValue,
            "colIndex": colIndex,
            "resizable": $cmp.hasResizebleColumns,
            "sortable": def.sortable,
            "sorted": def.sorted,
            "sortedDirection": def.sortedDirection,
            "hasFocus": def.hasFocus,
            "columnWidth": def.columnWidth,
            "resizestep": $cmp.state.resizeStep,
            "actions": def.actions
          },
          key: api_key(3, def.colKeyValue)
        }, []) : null]);
      }))]) : null, $cmp.hasValidKeyField ? api_element("tbody", {
        style: $cmp.computedTbodyStyle,
        key: 17
      }, api_flatten([api_iterator($cmp.state.rows, function (row, rowIndex) {
        return api_element("tr", {
          className: row.classnames,
          attrs: {
            "data-row-key-value": row.key,
            "aria-selected": row.ariaSelected,
            "aria-level": row.level,
            "aria-expanded": row.isExpanded,
            "aria-setsize": row.setSize,
            "aria-posinset": row.posInSet,
            "tabindex": api_tab_index(row.tabIndex)
          },
          key: api_key(13, row.key),
          on: {
            "keydown": _m2 || ($ctx._m2 = api_bind($cmp.handleTrRowKeyDown))
          }
        }, api_iterator(row.cells, function (cell) {
          return [cell.isCheckbox ? api_element("td", {
            className: cell.class,
            attrs: {
              "role": "gridcell",
              "tabindex": api_tab_index(cell.tabIndex),
              "data-label": cell.dataLabel
            },
            key: api_key(8, cell.colKeyValue)
          }, [api_custom_element("lightning-primitive-cell-checkbox", _lightningPrimitiveCellCheckbox, {
            attrs: {
              "data-label": cell.dataLabel
            },
            props: {
              "dtContextId": $cmp.privateDatatableId,
              "hasFocus": cell.hasFocus,
              "rowKeyValue": row.key,
              "colKeyValue": cell.colKeyValue,
              "rowIndex": rowIndex,
              "type": row.inputType,
              "isSelected": row.isSelected,
              "isDisabled": row.isDisabled
            },
            key: api_key(7, cell.key)
          }, [])]) : null, cell.isDataTypeScope ? api_element("th", {
            className: cell.class,
            style: cell.paddingStyle,
            attrs: {
              "aria-selected": cell.ariaSelected,
              "scope": "row",
              "tabindex": api_tab_index(cell.tabIndex),
              "data-label": cell.dataLabel
            },
            key: api_key(10, cell.colKeyValue)
          }, [api_custom_element("lightning-primitive-cell-factory", _lightningPrimitiveCellFactory, {
            attrs: {
              "data-label": cell.dataLabel
            },
            props: {
              "types": $cmp.privateTypes,
              "ariaSelected": cell.ariaSelected,
              "alignment": cell.alignment,
              "hasError": cell.hasError,
              "hasFocus": cell.hasFocus,
              "columnLabel": cell.dataLabel,
              "columnType": cell.columnType,
              "columnSubType": cell.columnSubType,
              "wrapText": cell.wrapText,
              "wrapTextMaxLines": cell.wrapTextMaxLines,
              "rowKeyValue": row.key,
              "colKeyValue": cell.colKeyValue,
              "value": cell.value,
              "iconName": cell.iconName,
              "iconLabel": cell.iconLabel,
              "iconPosition": cell.iconPosition,
              "iconAlternativeText": cell.iconAlternativeText,
              "editable": cell.editable,
              "typeAttribute0": cell.typeAttribute0,
              "typeAttribute1": cell.typeAttribute1,
              "typeAttribute2": cell.typeAttribute2,
              "typeAttribute3": cell.typeAttribute3,
              "typeAttribute4": cell.typeAttribute4,
              "typeAttribute5": cell.typeAttribute5,
              "typeAttribute6": cell.typeAttribute6,
              "typeAttribute7": cell.typeAttribute7,
              "typeAttribute8": cell.typeAttribute8,
              "typeAttribute9": cell.typeAttribute9,
              "typeAttribute10": cell.typeAttribute10,
              "typeAttribute21": cell.typeAttribute21,
              "typeAttribute22": cell.typeAttribute22
            },
            key: api_key(9, cell.columnType)
          }, [])]) : null, cell.isDataType ? api_element("td", {
            className: cell.class,
            style: cell.paddingStyle,
            attrs: {
              "aria-selected": cell.ariaSelected,
              "role": "gridcell",
              "tabindex": api_tab_index(cell.tabIndex),
              "data-label": cell.dataLabel
            },
            key: api_key(12, cell.colKeyValue)
          }, [api_custom_element("lightning-primitive-cell-factory", _lightningPrimitiveCellFactory, {
            attrs: {
              "data-label": cell.dataLabel
            },
            props: {
              "types": $cmp.privateTypes,
              "ariaSelected": cell.ariaSelected,
              "role": "gridcell",
              "alignment": cell.alignment,
              "hasFocus": cell.hasFocus,
              "hasError": cell.hasError,
              "columnLabel": cell.dataLabel,
              "columnType": cell.columnType,
              "columnSubType": cell.columnSubType,
              "wrapText": cell.wrapText,
              "wrapTextMaxLines": cell.wrapTextMaxLines,
              "rowKeyValue": row.key,
              "colKeyValue": cell.colKeyValue,
              "value": cell.value,
              "iconName": cell.iconName,
              "iconLabel": cell.iconLabel,
              "iconPosition": cell.iconPosition,
              "iconAlternativeText": cell.iconAlternativeText,
              "editable": cell.editable,
              "typeAttribute0": cell.typeAttribute0,
              "typeAttribute1": cell.typeAttribute1,
              "typeAttribute2": cell.typeAttribute2,
              "typeAttribute3": cell.typeAttribute3,
              "typeAttribute4": cell.typeAttribute4,
              "typeAttribute5": cell.typeAttribute5,
              "typeAttribute6": cell.typeAttribute6,
              "typeAttribute7": cell.typeAttribute7,
              "typeAttribute8": cell.typeAttribute8,
              "typeAttribute9": cell.typeAttribute9,
              "typeAttribute10": cell.typeAttribute10,
              "typeAttribute21": cell.typeAttribute21,
              "typeAttribute22": cell.typeAttribute22
            },
            key: api_key(11, cell.columnType)
          }, [])]) : null];
        }));
      }), $cmp.isLoading ? api_element("tr", {
        key: 16
      }, [api_element("td", {
        classMap: {
          "slds-is-relative": true
        },
        attrs: {
          "colspan": $cmp.numberOfColumns
        },
        key: 15
      }, [api_custom_element("lightning-primitive-datatable-loading-indicator", _lightningPrimitiveDatatableLoadingIndicator, {
        key: 14
      }, [])])]) : null])) : null])])])]), $cmp.showStatusBar ? api_custom_element("lightning-primitive-datatable-status-bar", _lightningPrimitiveDatatableStatusBar, {
        props: {
          "error": $cmp.tableError
        },
        key: 22,
        on: {
          "privatesave": _m10 || ($ctx._m10 = api_bind($cmp.handleInlineEditSave)),
          "privatecancel": _m11 || ($ctx._m11 = api_bind($cmp.handleInlineEditCancel))
        }
      }, []) : null])];
    }

    var _tmpl$H = lwc.registerTemplate(tmpl$_);
    tmpl$_.stylesheets = [];
    tmpl$_.stylesheetTokens = {
      hostAttribute: "lightning-datatable_datatable-host",
      shadowAttribute: "lightning-datatable_datatable"
    };

    /**
     * It creates a row key generator based on the keyField passed by the consumer
     * if the keyField does not point to a value row object passed in computeUniqueRowKey
     * it fallback to a generated key using indexes
     *
     * @param {String} keyField  - keyField provided by the consumer
     * @returns {*} - Object with a computeUniqueRowKey method
     */
    const createRowKeysGenerator = function (keyField) {
      let index = 0;
      return {
        computeUniqueRowKey(row) {
          if (row[keyField]) {
            return row[keyField];
          }

          return `row-${index++}`;
        }

      };
    };
    /**
     * It generate a unique column key value.
     *
     * @param {object} columnMetadata - the object for an specific column metadata
     * @param {int} index - optionally, the index of the column.
     * @returns {string} It generate the column key value based on the column field name and type.
     */

    const generateColKeyValue = function (columnMetadata, index) {
      const prefix = columnMetadata.fieldName || index;
      return `${prefix}-${columnMetadata.type}-${index}`;
    };

    const isObjectLike = function (value) {
      return typeof value === 'object' && value !== null;
    };
    const proto$1 = {
      add(className) {
        if (typeof className === 'string') {
          this[className] = true;
        } else {
          Object.assign(this, className);
        }

        return this;
      },

      invert() {
        Object.keys(this).forEach(key => {
          this[key] = !this[key];
        });
        return this;
      },

      toString() {
        return Object.keys(this).filter(key => this[key]).join(' ');
      }

    };
    const classSet$1 = function (config) {
      if (typeof config === 'string') {
        const key = config;
        config = {};
        config[key] = true;
      }

      return Object.assign(Object.create(proto$1), config);
    };
    const clamp = function (num, min, max) {
      return num <= min ? min : num >= max ? max : num;
    };
    /**
     * Tests if the value passed in is a value greater than 0
     * @param {Integer} value - value to test
     * @returns {Boolean} - true if value is > 0
     */

    const isPositiveInteger = function (value) {
      return /^[0-9]*[1-9][0-9]*$/.test(value);
    };
    /**
     * Tests if the value passed in is 0 or a number greater than 0
     * @param {Integer} value - value to test
     * @returns {Boolean} - true if value is >= 0
     */

    const isNonNegativeInteger = function (value) {
      return /^\d+$/.test(value);
    };
    /**
     * Accepts a value which may be an Integer or String and tests that value
     * with respect to the numberType:
     *     a. numberType - positive: if value > 0
     *     b. numberType - non-negative: if value >= 0
     * If the value fails the test, the fallback value is returned
     *
     * @param {String} attrName - name of attribute to normalize
     * @param {Integer/String} value - value to normalize
     * @param {String} numberType - number type to validate against: positive / non-negative
     * @param {Integer} fallback - value to return if validation fails
     * @returns {Integer} - Returns normalized value if validation passes; else returns fallback
     */

    function normalizeNumberAttribute(attrName, value, numberType, fallback) {
      let warningMessage;

      if (numberType === 'positive') {
        if (isPositiveInteger(value)) {
          return parseInt(value, 10);
        }

        warningMessage = `The attribute "${attrName}" value passed in is incorrect.
        "${attrName}" value should be an integer > 0.`;
      } else if (numberType === 'non-negative') {
        if (isNonNegativeInteger(value)) {
          return parseInt(value, 10);
        }

        warningMessage = `The attribute "${attrName}" value passed in is incorrect.
        "${attrName}" value should be an integer >= 0.`;
      } else {
        warningMessage = 'Invalid number type during normalization of number attribute';
      } // eslint-disable-next-line no-console


      console.warn(warningMessage);
      return fallback;
    }

    const STANDARD_TYPES = {
      text: ['linkify'],
      boolean: true,
      number: ['minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits'],
      currency: ['currencyCode', 'currencyDisplayAs', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits'],
      percent: ['minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits'],
      email: true,
      date: ['day', 'era', 'hour', 'hour12', 'minute', 'month', 'second', 'timeZone', 'timeZoneName', 'weekday', 'year'],
      'date-local': ['day', 'month', 'year'],
      phone: true,
      url: ['label', 'target', 'tooltip'],
      location: true,
      rowNumber: ['error'],
      action: ['menuAlignment', 'rowActions'],
      button: ['variant', 'label', 'iconName', 'iconPosition', 'disabled', 'name', 'class', 'title'],
      'button-icon': ['variant', 'alternativeText', 'iconName', 'iconClass', 'disabled', 'name', 'class', 'title'],
      tree: ['hasChildren', 'isExpanded', 'level', 'setSize', 'posInSet', 'subType']
    };
    const TREE_SUPPORTED_TYPES = {
      text: true,
      url: true,
      date: true,
      number: true,
      currency: true,
      percent: true
    };
    function isValidType(typeName) {
      return !!STANDARD_TYPES[typeName];
    }
    function isTreeType(typeName) {
      return typeName === 'tree';
    }
    function getAttributesNames(typeName) {
      assert(isValidType(typeName), `your are trying to access an invalid type (${typeName})`);
      return Array.isArray(STANDARD_TYPES[typeName]) ? STANDARD_TYPES[typeName] : [];
    }
    function isValidTypeForTree(dataType) {
      return !!TREE_SUPPORTED_TYPES[dataType];
    }

    function getStandardTypeAttributesNames(typeName) {
      return Array.isArray(STANDARD_TYPES[typeName]) ? STANDARD_TYPES[typeName] : [];
    }

    class DatatableTypes {
      constructor(types) {
        this.privateCustomTypes = {};
        this.isValidTypeForTree = isValidTypeForTree;

        if (typeof types === 'object' && types !== null) {
          Object.keys(types).reduce((seed, key) => {
            const {
              template,
              typeAttributes = [],
              standardCellLayout = false
            } = types[key];
            seed[key] = {
              template,
              typeAttributes,
              standardCellLayout: standardCellLayout === true,
              type: 'custom'
            };
            return seed;
          }, this.privateCustomTypes);
        }
      }

      getType(typeName) {
        if (this.privateCustomTypes[typeName]) {
          return this.privateCustomTypes[typeName];
        }

        if (STANDARD_TYPES[typeName]) {
          return {
            typeAttributes: getStandardTypeAttributesNames(typeName),
            type: 'standard'
          };
        }

        return undefined;
      }

      isValidType(typeName) {
        return !!this.getType(typeName);
      }

      isCustomType(typeName) {
        return this.getType(typeName) && this.getType(typeName).type === 'custom';
      }

      standardCellLayoutForCustomType(typeName) {
        return this.isCustomType(typeName) && this.getType(typeName).standardCellLayout;
      }

    }

    lwc.registerDecorators(DatatableTypes, {
      fields: ["privateCustomTypes", "isValidTypeForTree"]
    });

    var DatatableTypes$1 = lwc.registerComponent(DatatableTypes, {
      tmpl: _tmpl$1
    });

    function getSortDefaultState() {
      return {
        sortedBy: undefined,
        sortedDirection: undefined,
        defaultSortDirection: 'asc'
      };
    }
    const VALID_SORT_DIRECTIONS = {
      asc: true,
      desc: true
    };
    function isValidSortDirection(value) {
      return !!VALID_SORT_DIRECTIONS[value];
    }
    function getSortedBy(state) {
      return state.sortedBy;
    }
    function setSortedBy(state, value) {
      if (typeof value === 'string') {
        state.sortedBy = value;
      } else {
        state.sortedBy = undefined;
      }
    }
    function getSortedDirection(state) {
      return state.sortedDirection;
    }
    function setSortedDirection(state, value) {
      assert(isValidSortDirection(value), `The "sortedDirection" value passed into lightning:datatable
        is incorrect, "sortedDirection" value should be one of
        ${Object.keys(VALID_SORT_DIRECTIONS).join()}.`);
      state.sortedDirection = isValidSortDirection(value) ? value : undefined;
    }
    function getDefaultSortDirection(state) {
      return state.defaultSortDirection;
    }
    function setDefaultSortDirection(state, value) {
      assert(isValidSortDirection(value), `The "defaultSortDirection" value passed into lightning:datatable
        is incorrect, "defaultSortDirection" value should be one of
        ${Object.keys(VALID_SORT_DIRECTIONS).join()}.`);
      state.defaultSortDirection = isValidSortDirection(value) ? value : getDefaultSortDirection(state);
    }
    function updateSorting(state) {
      const columns = getColumns(state);
      columns.forEach(column => updateColumnSortingState(column, state));
    }
    function updateColumnSortingState(column, state) {
      const {
        sortedBy,
        sortedDirection,
        defaultSortDirection
      } = state;

      if (column.fieldName === sortedBy && column.sortable) {
        Object.assign(column, {
          sorted: true,
          sortAriaLabel: sortedDirection === 'desc' ? 'descending' : 'ascending',
          sortedDirection
        });
      } else {
        Object.assign(column, {
          sorted: false,
          sortAriaLabel: column.sortable ? 'none' : null,
          sortedDirection: defaultSortDirection
        });
      }
    }

    const MAX_ROW_SELECTION_DEFAULT = undefined;
    function getSelectorDefaultState() {
      return {
        selectedRowsKeys: {},
        maxRowSelection: MAX_ROW_SELECTION_DEFAULT
      };
    }
    function handleSelectAllRows(event) {
      event.stopPropagation();
      markAllRowsSelected(this.state);
      this.fireSelectedRowsChange(this.getSelectedRows());
    }
    function handleDeselectAllRows(event) {
      event.stopPropagation();
      markAllRowsDeselected(this.state);
      this.fireSelectedRowsChange(this.getSelectedRows());
    }
    /**
     * Will select the cell identified by rowKeyValue, colKeyValue.
     * This will reflect as aria-selected="true" attribute in the cell td or th.
     *
     * Note: This change is volatile, and will be reset (lost) in the next index regeneration.
     *
     * @param {Object} state - the state of the datatable
     * @param {String} rowKeyValue - the row key of the cell to select
     * @param {String} colKeyValue - the col key of the cell to select
     */

    function markSelectedCell(state, rowKeyValue, colKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const colIndex = getStateColumnIndex(state, colKeyValue);

      if (row && colIndex) {
        row.cells[colIndex].ariaSelected = 'true';
      }
    }
    /**
     * Will deselect the cell identified by rowKeyValue, colKeyValue.
     * This will reflect in removing aria-selected attribute in the cell td or th (if it was previously added).
     *
     * Note: This change is volatile, and will be reset (lost) in the next index regeneration.
     *
     * @param {Object} state - the state of the datatable
     * @param {String} rowKeyValue - the row key of the cell to select
     * @param {String} colKeyValue - the col key of the cell to select
     */

    function markDeselectedCell(state, rowKeyValue, colKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const colIndex = getStateColumnIndex(state, colKeyValue);

      if (row && colIndex) {
        row.cells[colIndex].ariaSelected = false;
      }
    }
    /**
     * Returns the last rowKey that was clicked, false otherwise.
     * @param {Object} state - the datatable state.
     * @return {String | undefined } the row key or false.
     */

    function getLastRowSelection(state) {
      const lastSelectedRowKey = state.selectionLastSelectedRow;
      const keyIsValid = lastSelectedRowKey !== undefined && getRowIndexByKey(state, lastSelectedRowKey) !== undefined;
      return keyIsValid ? lastSelectedRowKey : undefined;
    }

    function setLastRowSelection(state, rowKeyValue) {
      state.selectionLastSelectedRow = rowKeyValue;
    }

    function handleSelectRow(event) {
      event.stopPropagation();
      const {
        rowKeyValue,
        isMultiple
      } = event.detail;
      let fromRowKey = rowKeyValue;

      if (isMultiple) {
        fromRowKey = getLastRowSelection(this.state) || rowKeyValue;
      }

      markSelectedRowsInterval(this.state, fromRowKey, rowKeyValue);
      setLastRowSelection(this.state, rowKeyValue);
      this.fireSelectedRowsChange(this.getSelectedRows());
    }

    function markSelectedRowsInterval(state, startRowKey, endRowKey) {
      const rows = getRows(state);
      const {
        start,
        end
      } = getRowIntervalIndexes(state, startRowKey, endRowKey);
      const maxRowSelection = getMaxRowSelection(state) || getRowsTotal(state);
      let i = start,
          maxSelectionReached;

      do {
        markRowSelected(state, rows[i].key);
        maxSelectionReached = getCurrentSelectionLength(state) >= maxRowSelection;
        i++;
      } while (i <= end && !maxSelectionReached);
    }

    function handleDeselectRow(event) {
      event.stopPropagation();
      const {
        rowKeyValue,
        isMultiple
      } = event.detail;
      let fromRowKey = rowKeyValue;

      if (isMultiple) {
        fromRowKey = getLastRowSelection(this.state) || rowKeyValue;
      }

      markDeselectedRowsInterval(this.state, fromRowKey, rowKeyValue);
      setLastRowSelection(this.state, rowKeyValue);
      this.fireSelectedRowsChange(this.getSelectedRows());
    }

    function getRowIntervalIndexes(state, startRowKey, endRowKey) {
      const start = startRowKey === 'HEADER' ? 0 : getRowIndexByKey(state, startRowKey);
      const end = getRowIndexByKey(state, endRowKey);
      return {
        start: Math.min(start, end),
        end: Math.max(start, end)
      };
    }

    function markDeselectedRowsInterval(state, startRowKey, endRowKey) {
      const rows = getRows(state);
      const {
        start,
        end
      } = getRowIntervalIndexes(state, startRowKey, endRowKey);

      for (let i = start; i <= end; i++) {
        markRowDeselected(state, rows[i].key);
      }
    }

    function getSelectedRowsKeys(state) {
      return Object.keys(state.selectedRowsKeys).filter(key => state.selectedRowsKeys[key]);
    }

    function getSelectedDiff(state, value) {
      const selectedRowsKeys = state.selectedRowsKeys;
      return value.filter(key => !selectedRowsKeys[key]);
    }

    function getDeselectedDiff(state, value) {
      const currentSelectedRowsKeys = state.selectedRowsKeys;
      return Object.keys(currentSelectedRowsKeys).filter(key => currentSelectedRowsKeys[key] && !value[key]);
    }

    function normalizeSelectedRowsKey(value) {
      return value.reduce((map, key) => {
        map[key] = true;
        return map;
      }, {});
    }

    function markRowsSelectedByKeys(state, keys) {
      keys.forEach(rowKeyValue => {
        const row = getRowByKey(state, rowKeyValue);
        row.isSelected = true;
        row.ariaSelected = 'true';
        row.classnames = resolveRowClassNames(row);
      });
    }

    function markRowsDeselectedByKeys(state, keys) {
      keys.forEach(rowKeyValue => {
        const row = getRowByKey(state, rowKeyValue);
        row.isSelected = false;
        row.ariaSelected = false;
        row.classnames = resolveRowClassNames(row);
      });
    }

    function filterValidKeys(state, keys) {
      return keys.filter(key => rowKeyExists(state, key));
    }

    function setSelectedRowsKeys(state, value) {
      if (Array.isArray(value)) {
        const maxRowSelection = getMaxRowSelection(state);
        const previousSelectionLength = getCurrentSelectionLength(state);
        let selectedRows = filterValidKeys(state, value);

        if (selectedRows.length > maxRowSelection) {
          // eslint-disable-next-line no-console
          console.warn(`The number of keys in selectedRows for lightning:datatable
            exceeds the limit defined by maxRowSelection.`);
          selectedRows = selectedRows.slice(0, maxRowSelection);
        }

        const normalizedSelectedRowsKeys = normalizeSelectedRowsKey(selectedRows);
        const selectionOperations = getSelectedDiff(state, selectedRows);
        const deselectionOperations = getDeselectedDiff(state, normalizedSelectedRowsKeys);
        markRowsSelectedByKeys(state, selectionOperations);
        markRowsDeselectedByKeys(state, deselectionOperations);
        state.selectedRowsKeys = normalizedSelectedRowsKeys;

        if (selectedRows.length === maxRowSelection && maxRowSelection > 1) {
          markDeselectedRowDisabled(state);
        } else if (selectedRows.length < maxRowSelection && previousSelectionLength === maxRowSelection) {
          markDeselectedRowEnabled(state);
        }
      } else {
        // eslint-disable-next-line no-console
        console.error(`The "selectedRows" passed into "lightning:datatable"
        must be an Array with the keys of the selected rows. We receive instead ${value}`);
        markAllRowsDeselected(state);
      }
    }
    function getMaxRowSelection(state) {
      return state.maxRowSelection;
    }
    function getHideSelectAllCheckbox(state) {
      return getMaxRowSelection(state) === 1;
    }
    function setMaxRowSelection(state, value) {
      markAllRowsDeselected(state);

      if (isNonNegativeInteger(value)) {
        const previousMaxRowSelection = getMaxRowSelection(state);
        state.maxRowSelection = Number(value);

        if (inputTypeNeedsToChange(previousMaxRowSelection, getMaxRowSelection(state))) {
          updateRowSelectionInputType(state);
          updateSelectionState(state);
        }
      } else {
        state.maxRowSelection = MAX_ROW_SELECTION_DEFAULT; // eslint-disable-next-line no-console

        console.error(`The maxRowSelection value passed into lightning:datatable
            should be a positive integer. We receive instead (${value}).`);
      }
    }
    function inputTypeNeedsToChange(previousMaxRowSelection, newMaxRowSelection) {
      return previousMaxRowSelection === 1 && isMultiSelection(newMaxRowSelection) || isMultiSelection(previousMaxRowSelection) && newMaxRowSelection === 1 || previousMaxRowSelection === 0 || newMaxRowSelection === 0;
    }
    function isMultiSelection(value) {
      return value > 1 || value === undefined;
    }
    function updateRowSelectionInputType(state) {
      const type = getRowSelectionInputType(state);
      const rows = getRows(state);
      resetSelectedRowsKeys(state);
      rows.forEach(row => {
        row.inputType = type;
        row.isSelected = false;
        row.ariaSelected = false;
        row.isDisabled = isDisabledRow(state, row.key);
      });
    }
    function isSelectedRow(state, rowKeyValue) {
      return !!state.selectedRowsKeys[rowKeyValue];
    }
    function isDisabledRow(state, rowKeyValue) {
      if (!isSelectedRow(state, rowKeyValue)) {
        const maxRowSelection = getMaxRowSelection(state); // W-4819182 when selection is 1, we should not disable selection.

        return maxRowSelection !== 1 && getCurrentSelectionLength(state) === maxRowSelection;
      }

      return false;
    }
    function getRowSelectionInputType(state) {
      if (getMaxRowSelection(state) === 1) {
        return 'radio';
      }

      return 'checkbox';
    }
    function markDeselectedRowDisabled(state) {
      const rows = getRows(state);
      rows.forEach(row => {
        if (!isSelectedRow(state, row.key)) {
          row.isDisabled = true;
        }
      });
    }
    function markDeselectedRowEnabled(state) {
      const rows = getRows(state);
      rows.forEach(row => {
        if (!isSelectedRow(state, row.key)) {
          row.isDisabled = false;
        }
      });
    }
    function getCurrentSelectionLength(state) {
      return getSelectedRowsKeys(state).length;
    }
    function markRowSelected(state, rowKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const maxRowSelection = getMaxRowSelection(state) || getRowsTotal(state);
      const previousSelectionLength = getCurrentSelectionLength(state);
      row.isSelected = true;
      row.ariaSelected = 'true';
      row.classnames = resolveRowClassNames(row);

      if (maxRowSelection > 1) {
        addKeyToSelectedRowKeys(state, row.key);

        if (previousSelectionLength + 1 === maxRowSelection) {
          markDeselectedRowDisabled(state);
        }
      } else {
        if (previousSelectionLength === 1) {
          const previousSelectedRow = getRowByKey(state, Object.keys(state.selectedRowsKeys)[0]);
          previousSelectedRow.isSelected = false;
          previousSelectedRow.ariaSelected = false;
          previousSelectedRow.classnames = resolveRowClassNames(previousSelectedRow);
          resetSelectedRowsKeys(state);
        }

        addKeyToSelectedRowKeys(state, row.key);
      }
    }
    function markRowDeselected(state, rowKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const maxRowSelection = getMaxRowSelection(state);
      row.isSelected = false;
      row.ariaSelected = false;
      row.classnames = resolveRowClassNames(row);
      removeKeyFromSelectedRowKeys(state, row.key);

      if (getCurrentSelectionLength(state) === maxRowSelection - 1) {
        markDeselectedRowEnabled(state);
      }
    }
    function resetSelectedRowsKeys(state) {
      state.selectedRowsKeys = {};
    }
    function markAllRowsSelected(state) {
      const rows = getRows(state);
      const maxRowSelection = getMaxRowSelection(state);
      resetSelectedRowsKeys(state);
      rows.forEach((row, index) => {
        if (index < maxRowSelection || maxRowSelection === undefined) {
          row.isSelected = true;
          row.ariaSelected = 'true';
          row.classnames = resolveRowClassNames(row);
          addKeyToSelectedRowKeys(state, row.key);
        } else {
          row.isDisabled = true;
          row.isSelected = false;
          row.ariaSelected = false;
          row.classnames = resolveRowClassNames(row);
        }
      });
    }
    function markAllRowsDeselected(state) {
      const rows = getRows(state);
      resetSelectedRowsKeys(state);
      rows.forEach(row => {
        row.isDisabled = false;
        row.isSelected = false;
        row.ariaSelected = false;
        row.classnames = resolveRowClassNames(row);
      });
      return state;
    }
    function syncSelectedRowsKeys(state, selectedRows) {
      let changed = false;
      const {
        selectedRowsKeys,
        keyField
      } = state;

      if (Object.keys(selectedRowsKeys).length !== selectedRows.length) {
        changed = true;
        state.selectedRowsKeys = updateSelectedRowsKeysFromSelectedRows(selectedRows, keyField);
      } else {
        changed = selectedRows.some(row => !selectedRowsKeys[row[keyField]]);

        if (changed) {
          state.selectedRowsKeys = updateSelectedRowsKeysFromSelectedRows(selectedRows, keyField);
        }
      }

      updateSelectionState(state);
      return {
        ifChanged: callback => {
          if (changed && typeof callback === 'function') {
            callback(selectedRows);
          }
        }
      };
    }
    function handleRowSelectionChange() {
      updateSelectionState(this.state);
    }

    function updateSelectedRowsKeysFromSelectedRows(selectedRows, keyField) {
      return selectedRows.reduce((selectedRowsKeys, row) => {
        selectedRowsKeys[row[keyField]] = true;
        return selectedRowsKeys;
      }, {});
    }

    function addKeyToSelectedRowKeys(state, key) {
      state.selectedRowsKeys[key] = true;
    }

    function removeKeyFromSelectedRowKeys(state, key) {
      // not using delete this.state.selectedRowsKeys[key]
      // because that cause perf issues
      state.selectedRowsKeys[key] = false;
    }

    function updateSelectionState(state) {
      const selectBoxesColumnIndex = getSelectBoxesColumnIndex(state);

      if (selectBoxesColumnIndex >= 0) {
        state.columns[selectBoxesColumnIndex] = Object.assign({}, state.columns[selectBoxesColumnIndex], {
          bulkSelection: getBulkSelectionState(state),
          isBulkSelectionDisabled: isBulkSelectionDisabled(state)
        });
      }
    }
    function getBulkSelectionState(state) {
      const selected = getCurrentSelectionLength(state);
      const total = getMaxRowSelection(state) || getRowsTotal(state);

      if (selected === 0) {
        return 'none';
      } else if (selected === total) {
        return 'all';
      }

      return 'some';
    }
    function isBulkSelectionDisabled(state) {
      return getRowsTotal(state) === 0 || getMaxRowSelection(state) === 0;
    }

    function getSelectBoxesColumnIndex(state) {
      const columns = getColumns(state) || [];
      let selectBoxColumnIndex = -1;
      columns.some((column, index) => {
        if (column.type === SELECTABLE_ROW_CHECKBOX) {
          selectBoxColumnIndex = index;
          return true;
        }

        return false;
      });
      return selectBoxColumnIndex;
    }

    function getTreeStateIndicatorFieldNames() {
      return {
        children: 'hasChildren',
        level: 'level',
        expanded: 'isExpanded',
        position: 'posInSet',
        setsize: 'setSize'
      };
    }
    function hasTreeDataType(state) {
      const columns = getColumns(state);
      return columns.some(column => {
        return isTreeType(column.type);
      });
    }
    function getStateTreeColumn(state) {
      const columns = getColumns(state);

      for (let i = 0; i < columns.length; i++) {
        if (isTreeType(columns[i].type)) {
          return columns[i];
        }
      }

      return null;
    }
    function fireRowToggleEvent(rowKeyValue, expanded) {
      const customEvent = new CustomEvent('privatetogglecell', {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          name: rowKeyValue,
          nextState: expanded ? false : true // True = expanded, False = collapsed

        }
      });
      this.dispatchEvent(customEvent);
    }

    function getErrorsState() {
      return {
        errors: {
          rows: {},
          table: {}
        }
      };
    }
    function getErrors(state) {
      return state.errors;
    }
    function setErrors(state, errors) {
      return state.errors = Object.assign({}, getErrorsState(), errors);
    }
    function getRowError(state, rowKey) {
      const rows = getErrors(state).rows;
      return rows && rows[rowKey] || {};
    }
    function getTableError(state) {
      return getErrors(state).table || {};
    }

    function getRowsDefaultState() {
      return {
        data: [],
        keyField: undefined,
        rows: [],
        indexes: {}
      };
    }
    function setData(state, data) {
      if (Array.isArray(data)) {
        state.data = data;
      } else {
        state.data = [];
      }
    }
    function getData(state) {
      return state.data;
    }
    function getRows(state) {
      return state.rows;
    }
    function setKeyField(state, value) {
      assert(typeof value === 'string', `The "keyField" value expected in lightning:datatable must be type String.`);

      if (typeof value === 'string') {
        state.keyField = value;
      } else {
        state.keyField = undefined;
      }
    }
    function getKeyField(state) {
      return state.keyField;
    }
    function hasValidKeyField(state) {
      const keyField = getKeyField(state);
      return typeof keyField === 'string';
    }
    /**
     * It resolve the css classes for a row based on the row.isSelected state
     * @param {object} row - a row object in state.rows collection
     * @returns {string} the classSet string
     */

    function resolveRowClassNames(row) {
      const classes = classSet$1('slds-hint-parent');

      if (row.isSelected) {
        classes.add('slds-is-selected');
      }

      return classes.toString();
    }
    /**
     *
     * @param {object} state - data table state
     * @param {string} rowKeyValue - computed id for the row
     * @param {string} colKeyValue - computed id for the column
     *
     * @return {object} The user row that its related to the action.
     */

    function getUserRowByCellKeys(state, rowKeyValue, colKeyValue) {
      const rowIndex = state.indexes[rowKeyValue][colKeyValue][0];
      return getData(state)[rowIndex];
    }
    /**
     * It compute the state.rows collection based on the current normalized (data, columns)
     * and generate cells indexes map(state.indexes)
     * @param {object} state - the current datatable state
     */

    function updateRowsAndCellIndexes() {
      const {
        state,
        privateTypes: types
      } = this;
      const {
        keyField
      } = state;
      const data = getData(state);
      const columns = getColumns(state);
      const {
        computeUniqueRowKey
      } = createRowKeysGenerator(keyField);
      const scopeCol = columns.find(colData => types.isValidType(colData.type) && colData.isScopeCol); // initializing indexes

      state.indexes = {};
      state.rows = data.reduce((prev, rowData, rowIndex) => {
        const row = {
          key: computeUniqueRowKey(rowData),
          // attaching unique key to the row
          cells: []
        };
        const rowErrors = getRowError(state, row.key);
        state.indexes[row.key] = {
          rowIndex
        };
        row.inputType = getRowSelectionInputType(state);
        row.isSelected = isSelectedRow(state, row.key);
        row.ariaSelected = row.isSelected ? 'true' : false;
        row.isDisabled = isDisabledRow(state, row.key);
        row.classnames = resolveRowClassNames(row);
        Object.assign(row, getRowStateForTree(rowData, state));
        row.tabIndex = -1;
        columns.reduce((currentRow, colData, colIndex) => {
          const {
            fieldName
          } = colData;
          const colKeyValue = generateColKeyValue(colData, colIndex);
          const dirtyValue = getDirtyValue(state, row.key, colKeyValue);
          const computedCellValue = dirtyValue !== undefined ? dirtyValue : rowData[fieldName]; // cell object creation

          const cell = {
            columnType: colData.type,
            columnSubType: colData.typeAttributes ? colData.typeAttributes.subType : undefined,
            dataLabel: colData.label,
            value: computedCellValue,
            // value based on the fieldName
            rowKeyValue: row.key,
            // unique row key value
            colKeyValue,
            // unique column key value
            tabIndex: -1,
            // tabindex
            isCheckbox: colData.type === 'SELECTABLE_CHECKBOX',
            class: computeCellClassNames(colData, rowErrors, dirtyValue),
            hasError: rowErrors.fieldNames && rowErrors.fieldNames.includes(colData.fieldName),
            isDataType: types.isValidType(colData.type) && !colData.isScopeCol,
            isDataTypeScope: types.isValidType(colData.type) && colData.isScopeCol,
            wrapText: state.wrapText[colKeyValue],
            // wrapText state
            wrapTextMaxLines: state.wrapText[colKeyValue] ? state.wrapTextMaxLines : null,
            paddingStyle: types.isCustomType(colData.type) && !types.standardCellLayoutForCustomType(colData.type) ? 'padding: 0px;' : undefined
          };

          if (isCustomerColumn(colData)) {
            Object.assign(cell, computeCellTypeAttributes(rowData, colData, types), computeCellAttributes(rowData, colData), computeCellEditable(colData));

            if (isTreeType(colData.type)) {
              Object.assign(cell, computeCellStateTypeAttributes(row));
            }
          } else if (isRowNumberColumn(colData)) {
            const scopeColValue = rowData[scopeCol.fieldName];
            const errorColumnDef = getRowNumberErrorColumnDef(rowErrors, scopeColValue);
            Object.assign(cell, computeCellTypeAttributes(rowData, errorColumnDef, types));
          } // adding cell indexes to state.indexes
          // Keeping the hash for backward compatibility, but we need to have 2 indexes, 1 for columns and one for rows,
          // because of memory usage and also at certain point we might have the data but not the columns


          state.indexes[row.key][colKeyValue] = [rowIndex, colIndex];
          currentRow.push(cell);
          return currentRow;
        }, row.cells);
        prev.push(row);
        return prev;
      }, []);
    }
    function computeCellAttributes(row, column) {
      const cellAttributesValues = getCellAttributesValues(column);
      return Object.keys(cellAttributesValues).reduce((attrs, attrName) => {
        const attrValue = cellAttributesValues[attrName];
        attrs[attrName] = resolveAttributeValue(attrValue, row);
        return attrs;
      }, {});
    }
    function computeCellTypeAttributes(row, column, types) {
      if (column.typeAttributes && column.typeAttributes.subType) {
        return computeCellSubTypeAttributes(row, column);
      }

      const attributesNames = types.getType(column.type).typeAttributes;
      const typeAttributesValues = getTypeAttributesValues(column);
      return attributesNames.reduce((attrs, attrName, index) => {
        const typeAttributeName = `typeAttribute${index}`;
        attrs[typeAttributeName] = resolveAttributeValue(typeAttributesValues[attrName], row);
        return attrs;
      }, {});
    }
    function computeCellSubTypeAttributes(row, column) {
      const attributesNames = getAttributesNames(column.typeAttributes.subType);
      const typeAttributesValues = getSubTypeAttributesValues(column);
      return attributesNames.reduce((attrs, attrName, index) => {
        const typeAttributeName = `typeAttribute${index}`;
        attrs[typeAttributeName] = resolveAttributeValue(typeAttributesValues[attrName], row);
        return attrs;
      }, {});
    }

    function computeCellEditable(column) {
      return {
        editable: column.editable
      };
    }

    function computeCellClassNames(column, rowErrors, dirtyValue) {
      const classNames = classSet$1('');
      classNames.add({
        'slds-cell-edit': column.editable === true
      });
      classNames.add({
        'slds-tree__item': isTreeType(column.type)
      });
      classNames.add({
        'slds-has-error': rowErrors.fieldNames && rowErrors.fieldNames.includes(column.fieldName)
      });
      classNames.add({
        'slds-is-edited': dirtyValue !== undefined
      });
      return classNames.toString();
    }
    /**
     * Attaches if the row containing this cell hasChildren or not and isExpanded or not
     * attributes to typeAttribute21 and typeAttribute22 respectively
     * typeAttribute0-typeAttribute20 are reserved for  types supported by tree
     * @param {object}row - current row which is stored in state.rows
     * @returns {{typeAttribute21, typeAttribute22: boolean}} typeAttributes
     * describing state of the row associated
     */


    function computeCellStateTypeAttributes(row) {
      return {
        typeAttribute21: row.hasChildren,
        typeAttribute22: row.isExpanded === 'true'
      };
    }

    function getRowIndexByKey(state, key) {
      if (!state.indexes[key]) {
        return undefined;
      }

      return state.indexes[key].rowIndex;
    }
    function getRowByKey(state, key) {
      const rows = getRows(state);
      return rows[getRowIndexByKey(state, key)];
    }
    function rowKeyExists(state, key) {
      return !!state.indexes[key];
    }
    function getRowsTotal(state) {
      return getRows(state).length;
    }

    function resolveAttributeValue(attrValue, row) {
      if (isObjectLike(attrValue)) {
        const fieldName = attrValue.fieldName;

        if (fieldName) {
          return row[fieldName];
        }
      }

      return attrValue;
    }

    function getRowStateForTree(row, state) {
      const column = getStateTreeColumn(state);

      if (column) {
        return {
          level: getRowLevel(column, row),
          posInSet: getRowPosInSet(column, row),
          setSize: getRowSetSize(column, row),
          isExpanded: isRowExpanded(column, row),
          hasChildren: getRowHasChildren(column, row)
        };
      }

      return {};
    }

    function getRowLevel(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const attrValue = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().level], row);
      return attrValue ? attrValue : 1;
    }

    function getRowPosInSet(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const attrValue = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().position], row);
      return attrValue ? attrValue : 1;
    }

    function getRowSetSize(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const attrValue = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().setsize], row);
      return attrValue ? attrValue : 1;
    }

    function isRowExpanded(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const hasChildren = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().children], row);

      if (hasChildren) {
        const attrValue = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().expanded], row);
        return !!attrValue + '';
      }

      return undefined;
    }
    function getRowHasChildren(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const hasChildren = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().children], row);
      return !!hasChildren;
    }

    const ARROW_RIGHT = 39;
    const ARROW_LEFT = 37;
    const ARROW_DOWN = 40;
    const ARROW_UP = 38;
    const ENTER = 13;
    const ESCAPE = 27;
    const TAB = 9;
    const SPACE = 32;
    const NAVIGATION_DIR = (() => {
      if (isRTL()) {
        return {
          RIGHT: -1,
          LEFT: 1,
          USE_CURRENT: 0,
          RESET: 2,
          TAB_FORWARD: -1,
          TAB_BACKWARD: 1
        };
      }

      return {
        RIGHT: 1,
        LEFT: -1,
        USE_CURRENT: 0,
        RESET: 2,
        TAB_FORWARD: 1,
        TAB_BACKWARD: -1
      };
    })();
    const TOP_MARGIN = 80;
    const BOTTOM_MARGIN = 80;
    const SCROLL_OFFSET = 20;
    const NAVIGATION_MODE = 'NAVIGATION';
    function getKeyboardDefaultState() {
      return {
        keyboardMode: NAVIGATION_MODE,
        rowMode: false,
        activeCell: undefined,
        tabindex: 0,
        cellToFocusNext: null,
        cellClicked: false
      };
    }
    /**
     * It update the current activeCell in the state with the new rowKeyValue, colKeyValue
     * @param {object} state - datatable state
     * @param {string} rowKeyValue  - the unique row key value
     * @param {string} colKeyValue {string} - the unique col key value
     * @returns {object} state - mutated datatable state
     */

    const updateActiveCell = function (state, rowKeyValue, colKeyValue) {
      state.activeCell = {
        rowKeyValue,
        colKeyValue
      };
      return state;
    };
    /**
     * It return if the pair rowKeyValue, colKeyValue are the current activeCell values
     * @param {object} state - datatable state
     * @param {string} rowKeyValue  - the unique row key value
     * @param {string} colKeyValue {string} - the unique col key value
     * @returns {boolean} - true if rowKeyValue, colKeyValue are the current activeCell values.
     */

    const isActiveCell = function (state, rowKeyValue, colKeyValue) {
      if (state.activeCell) {
        const {
          rowKeyValue: currentRowKeyValue,
          colKeyValue: currentColKeyValue
        } = state.activeCell;
        return currentRowKeyValue === rowKeyValue && currentColKeyValue === colKeyValue;
      }

      return false;
    };
    /**
     * It check if in the current (data, columns) the activeCell still valid.
     * When data changed the activeCell could be removed, then we check if there is cellToFocusNext
     * which is calculated from previously focused cell, if so we sync to that
     * If active cell is still valid we keep it the same
     *
     * @param {object} state - datatable state
     * @returns {object} state - mutated datatable state
     */

    const syncActiveCell = function (state) {
      if (!state.activeCell || !stillValidActiveCell(state)) {
        if (state.activeCell && state.cellToFocusNext) {
          // there is previously focused cell
          setNextActiveCellFromPrev(state);
        } else {
          // there is no active cell or there is no previously focused cell
          setDefaultActiveCell(state);
        }
      }

      return state;
    };
    const datatableHasFocus = function (state) {
      return state.tabindex === false || state.cellClicked;
    };
    /**
     * Sets the row and col index of cell to focus next if
     * there is state.activecell
     * datatable has focus
     * there is state.indexes
     * there is no  previously set state.cellToFocusNext
     * Indexes are calculated as to what to focus on next
     * @param {object} state - datatable state
     */

    const setCellToFocusFromPrev = function (state) {
      if (state.activeCell && datatableHasFocus(state) && state.indexes && !state.cellToFocusNext) {
        let {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state);
        colIndex = 0; // default point to the first column

        if (state.rows && rowIndex === state.rows.length - 1) {
          // if it is last row, make it point to its previous row
          rowIndex = state.rows.length - 1;
          colIndex = state.columns ? state.columns.length - 1 : 0;
        }

        state.cellToFocusNext = {
          rowIndex,
          colIndex
        };
      }
    };
    /**
     * if the current new active still is valid ie exists then set the celltofocusnext to null
     * @param {object} state - datatable state
     */

    const updateCellToFocusFromPrev = function (state) {
      if (state.activeCell && state.cellToFocusNext && stillValidActiveCell(state)) {
        // if the previous focused is there and valid,  dont set the prevActiveFocusedCell
        state.cellToFocusNext = null;
      }
    };
    /**
     * reset celltofocusnext to null (used after render)
     * @param {object} state - datatable state
     */

    const resetCellToFocusFromPrev = function (state) {
      state.cellToFocusNext = null;
    };
    /**
     * Sets the next active if there is a previously focused active cell
     * Logic is:
     * if the rowIndex is existing one - cell = (rowIndex, 0)
     * if the rowIndex is > the number of rows (focused was last row or more) = (lastRow, lastColumn)
     * for columns
     * same as above except if the colIndex is > the number of cols (means no data) = set it to null??
     * @param {object} state - datatable state
     */

    function setNextActiveCellFromPrev(state) {
      const {
        rowIndex,
        colIndex
      } = state.cellToFocusNext;
      let nextRowIndex = rowIndex;
      let nextColIndex = colIndex;
      const rowsCount = state.rows ? state.rows.length : 0;
      const colsCount = state.columns.length ? state.columns.length : 0;

      if (nextRowIndex > rowsCount - 1) {
        // row index not existing after update to new 5 > 5-1, 6 > 5-1,
        nextRowIndex = rowsCount - 1;
      }

      if (nextColIndex > colsCount - 1) {
        // col index not existing after update to new
        nextColIndex = colsCount - 1;
      }

      const nextActiveCell = getCellFromIndexes(state, nextRowIndex, nextColIndex);

      if (nextActiveCell) {
        state.activeCell = nextActiveCell;
      } else {
        setDefaultActiveCell(state);
      }

      state.keyboardMode = 'NAVIGATION';
    }
    /**
     * It update the tabIndex value of a cell in the state for the rowIndex, colIndex passed
     * as consequence of this change
     * datatable is gonna re-render the cell affected with the new tabindex value
     *
     * @param {object} state - datatable state
     * @param {number} rowIndex - the row index
     * @param {number} colIndex - the column index
     * @param {number} [index = 0] - the value for the tabindex
     */


    const updateTabIndex = function (state, rowIndex, colIndex, index = 0) {
      if (isHeaderRow(rowIndex)) {
        const {
          columns
        } = state;
        columns[colIndex].tabIndex = index;
      } else {
        state.rows[rowIndex].cells[colIndex].tabIndex = index;
      }
    };
    /**
     * It updates the tabIndex value of a row in the state for the rowIndex passed
     * as consequence of this change
     * datatable is gonna re-render the row affected with the new tabindex value
     *
     * @param {object} state - datatable state
     * @param {number} rowIndex - the row index
     * @param {number} [index = 0] - the value for the tabindex
     */

    const updateTabIndexRow = function (state, rowIndex, index = 0) {
      if (!isHeaderRow(rowIndex)) {
        // TODO what to do when rowIndex is header row
        state.rows[rowIndex].tabIndex = index;
      }
    };
    /**
     * It update the tabindex for the current activeCell.
     * @param {object} state - datatable state
     * @param {number} [index = 0] - the value for the tabindex
     * @returns {object} state - mutated state
     */

    const updateTabIndexActiveCell = function (state, index = 0) {
      if (state.activeCell && !stillValidActiveCell(state)) {
        syncActiveCell(state);
      } // we need to check again because maybe there is no active cell after sync


      if (state.activeCell && !isRowNavigationMode(state)) {
        const {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state);
        updateTabIndex(state, rowIndex, colIndex, index);
      }

      return state;
    };
    /**
     * It updates the tabindex for the row of the current activeCell.
     * This happens in rowMode of NAVIGATION_MODE
     * @param {object} state - datatable state
     * @param {number} [index = 0] - the value for the tabindex
     * @returns {object} state - mutated state
     */

    const updateTabIndexActiveRow = function (state, index = 0) {
      if (state.activeCell && !stillValidActiveCell(state)) {
        syncActiveCell(state);
      } // we need to check again because maybe there is no active cell after sync


      if (state.activeCell && isRowNavigationMode(state)) {
        const {
          rowIndex
        } = getIndexesActiveCell(state);
        updateTabIndexRow(state, rowIndex, index);
      }

      return state;
    };
    /**
     * If new set of columns doesnt have tree data mark it to false, as it
     * could be true earlier
     * Else if it has tree data, check if rowMode is false
     * Earlier it didnt have tree data, set rowMode to true to start
     * if rowMode is false and earlier it has tree data, keep it false
     * if rowMode is true and it has tree data, keep it true
     * @param {boolean} hadTreeDataTypePreviously - state object
     * @param {object} state - state object
     * @returns {object} state - mutated state
     */

    function updateRowNavigationMode(hadTreeDataTypePreviously, state) {
      if (!hasTreeDataType(state)) {
        state.rowMode = false;
      } else if (state.rowMode === false && !hadTreeDataTypePreviously) {
        state.rowMode = true;
      }

      return state;
    }
    /**
     * It return the indexes { rowIndex, colIndex } of a cell based of the unique cell values
     * rowKeyValue, colKeyValue
     * @param {object} state - datatable state
     * @param {string} rowKeyValue - the row key value
     * @param {string} colKeyValue - the column key value
     * @returns {object} - {rowIndex, colIndex}
     */

    const getIndexesByKeys = function (state, rowKeyValue, colKeyValue) {
      if (rowKeyValue === 'HEADER') {
        return {
          rowIndex: -1,
          colIndex: state.headerIndexes[colKeyValue]
        };
      }

      return {
        rowIndex: state.indexes[rowKeyValue][colKeyValue][0],
        colIndex: state.indexes[rowKeyValue][colKeyValue][1]
      };
    };
    /**
     * It set the focus to the current activeCell, this operation imply multiple changes
     * - update the tabindex of the activeCell
     * - set the current keyboard mode
     * - set the focus to the cell
     * @param {node} element - the custom element template `this.template`
     * @param {object} state - datatable state
     * @param {int} direction - direction (-1 left, 1 right and 0 for no direction) its used to know which actionable element to activate.
     * @param {object} info - extra information when setting the cell mode.
     */

    const setFocusActiveCell = function (element, state, direction, info) {
      const {
        keyboardMode
      } = state;
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state);
      updateTabIndex(state, rowIndex, colIndex); // eslint-disable-next-line @lwc/lwc/no-async-operation

      setTimeout(() => {
        const cellElement = getCellElementByIndexes(element, rowIndex, colIndex);

        if (cellElement) {
          if (direction) {
            cellElement.resetCurrentInputIndex(direction, keyboardMode);
          }

          cellElement.addFocusStyles();
          cellElement.parentElement.classList.add('slds-has-focus');
          cellElement.parentElement.focus();
          cellElement.setMode(keyboardMode, info);
          const scrollingParent = element.querySelector('.slds-table_header-fixed_container');
          const scrollableY = element.querySelector('.slds-scrollable_y');
          const parentRect = scrollingParent.getBoundingClientRect();
          const findMeRect = cellElement.getBoundingClientRect();

          if (findMeRect.top < parentRect.top + TOP_MARGIN) {
            scrollableY.scrollTop -= SCROLL_OFFSET;
          } else if (findMeRect.bottom > parentRect.bottom - BOTTOM_MARGIN) {
            scrollableY.scrollTop += SCROLL_OFFSET;
          }
        }
      }, 0);
    };
    /**
     * It adds and the focus classes to the th/td.
     *
     * @param {node} element - the custom element template `this.template`
     * @param {object} state - datatable state
     */

    const addFocusStylesToActiveCell = function (element, state) {
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state);
      const cellElement = getCellElementByIndexes(element, rowIndex, colIndex);

      if (cellElement) {
        cellElement.parentElement.classList.add('slds-has-focus');
      }
    };
    /**
     * It blur to the current activeCell, this operation imply multiple changes
     * - blur the activeCell
     * - update the tabindex to -1
     * @param {node} element - the custom element root `this.template`
     * @param {object} state - datatable state
     */

    const setBlurActiveCell = function (element, state) {
      if (state.activeCell) {
        const {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state); // eslint-disable-next-line @lwc/lwc/no-async-operation

        setTimeout(() => {
          const cellElement = getCellElementByIndexes(element, rowIndex, colIndex); // we need to check because of the tree,
          // at this point it may remove/change the rows/keys because opening or closing a row.

          if (cellElement) {
            if (document.activeElement === cellElement) {
              cellElement.blur();
            }

            cellElement.removeFocusStyles(true);
            cellElement.parentElement.classList.remove('slds-has-focus');
          }
        }, 0);
        updateTabIndex(state, rowIndex, colIndex, -1);
      }
    };
    /**
     * It set the focus to the current activeCell, this operation imply multiple changes
     * - update the tabindex of the activeCell
     * - set the current keyboard mode
     * - set the focus to the cell
     * @param {node} element - the custom element root `this.template`
     * @param {object} state - datatable state
     */

    const setFocusActiveRow = function (element, state) {
      const {
        rowIndex
      } = getIndexesActiveCell(state);
      updateTabIndexRow(state, rowIndex); // eslint-disable-next-line @lwc/lwc/no-async-operation

      setTimeout(() => {
        const row = getRowElementByIndexes(element, rowIndex);
        row.focus();
        const scrollingParent = element.querySelector('.slds-table_header-fixed_container');
        const scrollableY = element.querySelector('.slds-scrollable_y');
        const parentRect = scrollingParent.getBoundingClientRect();
        const findMeRect = row.getBoundingClientRect();

        if (findMeRect.top < parentRect.top + TOP_MARGIN) {
          scrollableY.scrollTop -= SCROLL_OFFSET;
        } else if (findMeRect.bottom > parentRect.bottom - BOTTOM_MARGIN) {
          scrollableY.scrollTop += SCROLL_OFFSET;
        }
      }, 0);
    };
    /**
     * It blur the active Row, this operation imply multiple changes
     * - blur the active row
     * - update the tabindex to -1
     * @param {node} element - the custom element root `this.template`
     * @param {object} state - datatable state
     */

    const setBlurActiveRow = function (element, state) {
      if (state.activeCell) {
        const {
          rowIndex
        } = getIndexesActiveCell(state); // eslint-disable-next-line @lwc/lwc/no-async-operation

        setTimeout(() => {
          const row = getRowElementByIndexes(element, rowIndex);

          if (document.activeElement === row) {
            row.blur();
          }
        }, 0);
        updateTabIndexRow(state, rowIndex, -1);
      }
    };
    /**
     * It changes the datable state based on the keyboard event sent from the cell component,
     * the result of those change may trigger re-render on the table
     * @param {node} element - the custom element root `this.template`
     * @param {object} state - datatable state
     * @param {event} event - custom DOM event sent by the cell
     * @returns {object} - mutated state
     */

    const reactToKeyboard = function (element, state, event) {
      switch (event.detail.keyCode) {
        case ARROW_RIGHT:
          return reactToArrowRight(element, state, event);

        case ARROW_LEFT:
          return reactToArrowLeft(element, state, event);

        case ARROW_DOWN:
          return reactToArrowDown(element, state, event);

        case ARROW_UP:
          return reactToArrowUp(element, state, event);

        case ENTER:
        case SPACE:
          return reactToEnter(element, state, event);

        case ESCAPE:
          return reactToEscape(element, state, event);

        case TAB:
          return reactToTab(element, state, event);

        default:
          return state;
      }
    };

    function reactToKeyboardInNavMode(element, state, event) {
      const mockEvent = {
        detail: {
          rowKeyValue: state.activeCell.rowKeyValue,
          colKeyValue: state.activeCell.colKeyValue,
          keyCode: event.keyCode,
          shiftKey: event.shiftKey
        },
        preventDefault: () => {},
        stopPropagation: () => {}
      };

      switch (event.keyCode) {
        case ARROW_RIGHT:
          event.preventDefault();
          return reactToArrowRight(element, state, mockEvent);

        case ARROW_LEFT:
          event.preventDefault();
          return reactToArrowLeft(element, state, mockEvent);

        case ARROW_DOWN:
          event.preventDefault();
          return reactToArrowDown(element, state, mockEvent);

        case ARROW_UP:
          event.preventDefault();
          return reactToArrowUp(element, state, mockEvent);

        case ENTER:
        case SPACE:
          event.preventDefault();
          return reactToEnter(element, state, mockEvent);

        case ESCAPE:
          // td, th is the active element in the action mode if cell doesnt have action elements
          // hence this can be reached and we should react to escape as exiting from action mode
          mockEvent.detail.keyEvent = event;
          return reactToEscape(element, state, mockEvent);

        case TAB:
          // event.preventDefault();
          return reactToTab(element, state, mockEvent);

        default:
          return state;
      }
    }

    const reactToKeyboardOnRow = function (dt, state, event) {
      if (isRowNavigationMode(state) && event.target.localName.indexOf('tr') !== -1) {
        const element = dt.template;

        switch (event.detail.keyCode) {
          case ARROW_RIGHT:
            return reactToArrowRightOnRow.call(dt, element, state, event);

          case ARROW_LEFT:
            return reactToArrowLeftOnRow.call(dt, element, state, event);

          case ARROW_DOWN:
            return reactToArrowDownOnRow.call(dt, element, state, event);

          case ARROW_UP:
            return reactToArrowUpOnRow.call(dt, element, state, event);

          default:
            return state;
        }
      }

      return state;
    };

    function isRowNavigationMode(state) {
      return state.keyboardMode === 'NAVIGATION' && state.rowMode === true;
    }

    function setRowNavigationMode(state) {
      if (hasTreeDataType(state) && state.keyboardMode === 'NAVIGATION') {
        state.rowMode = true;
      }
    }
    function unsetRowNavigationMode(state) {
      state.rowMode = false;
    }
    function canBeRowNavigationMode(state) {
      return hasTreeDataType(state) && state.keyboardMode === 'NAVIGATION';
    }

    function isHeaderRow(rowIndex) {
      return rowIndex === -1;
    }

    function getCellElementByIndexes(element, rowIndex, colIndex) {
      if (isHeaderRow(rowIndex)) {
        const rowElement = element.querySelector(`thead > tr:nth-child(1)`);
        return rowElement && rowElement.querySelector(`th:nth-child(${colIndex + 1}) :first-child`);
      }

      return element.querySelector(`tbody > tr:nth-child(${rowIndex + 1}) > *:nth-child(${colIndex + 1}) > :first-child`);
    }

    function getRowElementByIndexes(element, rowIndex) {
      if (isHeaderRow(rowIndex)) {
        return element.querySelector(`thead > tr:nth-child(1)`);
      }

      return element.querySelector(`tbody > tr:nth-child(${rowIndex + 1})`);
    }

    function reactToEnter(element, state, event) {
      if (state.keyboardMode === 'NAVIGATION') {
        state.keyboardMode = 'ACTION';
        const {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state);
        const actionsMap = {};
        actionsMap[SPACE] = 'space';
        actionsMap[ENTER] = 'enter';

        if (event.detail.keyEvent) {
          event.detail.keyEvent.preventDefault();
        }

        setModeActiveCell(element, state, {
          action: actionsMap[event.detail.keyCode]
        });
        updateTabIndex(state, rowIndex, colIndex, -1);
      }
    }

    function reactToEscape(element, state, event) {
      if (state.keyboardMode === 'ACTION') {
        // When the table is in action mode this event shouldn't bubble
        // because if the table in inside a modal it should prevent the model closes
        event.detail.keyEvent.stopPropagation();
        state.keyboardMode = 'NAVIGATION';
        setModeActiveCell(element, state);
        setFocusActiveCell(element, state, NAVIGATION_DIR.RESET);
      }
    }
    /**
     * Retrieve the next tab index values for row & column
     * @param {object} state - datatable state
     * @param {string} direction - 'FORWARD' or 'BACKWARD'
     * @returns {object} - nextRowIndex, nextColIndex values, isExitCell boolean
     */


    function getNextTabIndex(state, direction) {
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state); // decide which function to use based on the value of direction

      const nextTabFunc = {
        FORWARD: getNextTabIndexForward,
        BACKWARD: getNextTabIndexBackward
      };
      return nextTabFunc[direction](state, rowIndex, colIndex);
    }
    /**
     * Check if we're in an escape/exit cell (first or last of grid)
     * @param {object} state - datatable state
     * @param {string} direction - 'FORWARD' or 'BACKWARD'
     * @returns {boolean} - if the current cell is or isn't an exit cell
     */


    function isActiveCellAnExitCell(state, direction) {
      // get next tab index values
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state);
      const {
        nextRowIndex,
        nextColIndex
      } = getNextTabIndex(state, direction); // is it an exit cell?

      if ( // if first cell and moving backward
      rowIndex === -1 && colIndex === 0 && nextRowIndex !== -1 && nextColIndex !== 0 || // or if last cell and moving forward
      rowIndex !== -1 && nextRowIndex === -1 && nextColIndex === 0) {
        return true;
      }

      return false;
    }

    function reactToTab(element, state, event) {
      event.preventDefault();
      event.stopPropagation();
      const {
        shiftKey
      } = event.detail;
      const direction = getTabDirection(shiftKey);
      const isExitCell = isActiveCellAnExitCell(state, direction); // if in ACTION mode

      if (state.keyboardMode === 'ACTION') {
        // if not on last or first cell, tab through each cell of the grid
        if (isExitCell === false) {
          // prevent default key event in action mode when actually moving within the grid
          if (event.detail.keyEvent) {
            event.detail.keyEvent.preventDefault();
          } // tab in proper direction based on shift key press


          if (direction === 'BACKWARD') {
            reactToTabBackward(element, state);
          } else {
            reactToTabForward(element, state);
          }
        } else {
          // exit ACTION mode
          state.keyboardMode = 'NAVIGATION';
          setModeActiveCell(element, state);
          state.isExiting = true;
        }
      } else {
        state.isExiting = true;
      }
    }

    function getTabDirection(shiftKey) {
      return shiftKey ? 'BACKWARD' : 'FORWARD';
    }

    function setModeActiveCell(element, state, info) {
      const cellElement = getActiveCellElement(element, state);
      cellElement.setMode(state.keyboardMode, info);
    }

    function getActiveCellElement(element, state) {
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state);
      return getCellElementByIndexes(element, rowIndex, colIndex);
    }

    function getIndexesActiveCell(state) {
      const {
        activeCell: {
          rowKeyValue,
          colKeyValue
        }
      } = state;
      return getIndexesByKeys(state, rowKeyValue, colKeyValue);
    }

    function reactToArrowRight(element, state, event) {
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const {
        colIndex
      } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
      const nextColIndex = getNextIndexRight(state, colIndex);
      const {
        columns
      } = state;

      if (nextColIndex === undefined) {
        return;
      }

      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue,
        colKeyValue: generateColKeyValue(columns[nextColIndex], nextColIndex)
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.RIGHT);
    }

    function reactToArrowLeft(element, state, event) {
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const {
        colIndex
      } = getIndexesByKeys(state, rowKeyValue, colKeyValue);

      if (colIndex === 0 && canBeRowNavigationMode(state)) {
        moveFromCellToRow(element, state);
      } else {
        const nextColIndex = getNextIndexLeft(state, colIndex);

        if (nextColIndex === undefined) {
          return;
        }

        const {
          columns
        } = state;
        setBlurActiveCell(element, state); // update activeCell

        state.activeCell = {
          rowKeyValue,
          colKeyValue: generateColKeyValue(columns[nextColIndex], nextColIndex)
        };
        setFocusActiveCell(element, state, NAVIGATION_DIR.LEFT);
      }
    }

    function reactToArrowRightOnRow(element, state, event) {
      const {
        rowKeyValue,
        rowHasChildren,
        rowExpanded
      } = event.detail; // check if row needs to be expanded
      // expand row if has children and is collapsed
      // otherwise make this.state.rowMode = false
      // move tabindex 0 to first cell in the row and focus there

      if (rowHasChildren && !rowExpanded) {
        fireRowToggleEvent.call(this, rowKeyValue, rowExpanded);
      } else {
        moveFromRowToCell(element, state);
      }
    }

    function reactToArrowLeftOnRow(element, state, event) {
      const {
        rowKeyValue,
        rowHasChildren,
        rowExpanded,
        rowLevel
      } = event.detail; // check if row needs to be collapsed
      // if not go to parent and focus there

      if (rowHasChildren && rowExpanded) {
        fireRowToggleEvent.call(this, rowKeyValue, rowExpanded);
      } else if (rowLevel > 1) {
        const treeColumn = getStateTreeColumn(state);

        if (treeColumn) {
          const colKeyValue = treeColumn.colKeyValue;
          const {
            rowIndex
          } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
          const parentIndex = getRowParent(state, rowLevel, rowIndex);

          if (parentIndex !== -1) {
            const rows = getRows(state);
            setBlurActiveRow(element, state); // update activeCell for the row

            state.activeCell = {
              rowKeyValue: rows[parentIndex].key,
              colKeyValue
            };
            setFocusActiveRow(element, state);
          }
        }
      }
    }

    function reactToArrowDownOnRow(element, state, event) {
      // move tabindex 0 one row down
      const {
        rowKeyValue
      } = event.detail;
      const treeColumn = getStateTreeColumn(state);
      event.detail.keyEvent.stopPropagation();
      event.detail.keyEvent.preventDefault();

      if (treeColumn) {
        const colKeyValue = treeColumn.colKeyValue;
        const {
          rowIndex
        } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
        const nextRowIndex = getNextIndexDownWrapped(state, rowIndex);
        const {
          rows
        } = state;

        if (nextRowIndex !== -1) {
          setBlurActiveRow(element, state); // update activeCell for the row

          state.activeCell = {
            rowKeyValue: rows[nextRowIndex].key,
            colKeyValue
          };
          setFocusActiveRow(element, state);
        }
      }
    }

    function reactToArrowUpOnRow(element, state, event) {
      // move tabindex 0 one row down
      // move tabindex 0 one row down
      const {
        rowKeyValue
      } = event.detail;
      const treeColumn = getStateTreeColumn(state);
      event.detail.keyEvent.stopPropagation();
      event.detail.keyEvent.preventDefault();

      if (treeColumn) {
        const colKeyValue = treeColumn.colKeyValue;
        const {
          rowIndex
        } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
        const prevRowIndex = getNextIndexUpWrapped(state, rowIndex);
        const {
          rows
        } = state;

        if (prevRowIndex !== -1) {
          setBlurActiveRow(element, state); // update activeCell for the row

          state.activeCell = {
            rowKeyValue: rows[prevRowIndex].key,
            colKeyValue
          };
          setFocusActiveRow(element, state);
        }
      }
    }

    function moveFromCellToRow(element, state) {
      setBlurActiveCell(element, state);
      setRowNavigationMode(state);
      setFocusActiveRow(element, state);
    }

    function moveFromRowToCell(element, state) {
      setBlurActiveRow(element, state);
      unsetRowNavigationMode(state);
      setFocusActiveCell(element, state, NAVIGATION_DIR.USE_CURRENT);
    }

    function reactToTabForward(element, state) {
      const {
        nextRowIndex,
        nextColIndex
      } = getNextTabIndex(state, 'FORWARD');
      const {
        columns,
        rows
      } = state;
      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue: nextRowIndex !== -1 ? rows[nextRowIndex].key : 'HEADER',
        colKeyValue: generateColKeyValue(columns[nextColIndex], nextColIndex)
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.TAB_FORWARD, {
        action: 'tab'
      });
    }
    function reactToTabBackward(element, state) {
      const {
        nextRowIndex,
        nextColIndex
      } = getNextTabIndex(state, 'BACKWARD');
      const {
        columns,
        rows
      } = state;
      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue: nextRowIndex !== -1 ? rows[nextRowIndex].key : 'HEADER',
        colKeyValue: generateColKeyValue(columns[nextColIndex], nextColIndex)
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.TAB_BACKWARD, {
        action: 'tab'
      });
    }

    function reactToArrowDown(element, state, event) {
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const {
        rowIndex
      } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
      const nextRowIndex = getNextIndexDown(state, rowIndex);
      const {
        rows
      } = state;

      if (nextRowIndex === undefined) {
        return;
      }

      if (state.hideTableHeader && nextRowIndex === -1) {
        return;
      }

      if (event.detail.keyEvent) {
        event.detail.keyEvent.stopPropagation();
      }

      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue: nextRowIndex !== -1 ? rows[nextRowIndex].key : 'HEADER',
        colKeyValue
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.USE_CURRENT);
    }

    function reactToArrowUp(element, state, event) {
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const {
        rowIndex
      } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
      const nextRowIndex = getNextIndexUp(state, rowIndex);
      const {
        rows
      } = state;

      if (nextRowIndex === undefined) {
        return;
      }

      if (state.hideTableHeader && nextRowIndex === -1) {
        return;
      }

      if (event.detail.keyEvent) {
        event.detail.keyEvent.stopPropagation();
      }

      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue: nextRowIndex !== -1 ? rows[nextRowIndex].key : 'HEADER',
        colKeyValue
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.USE_CURRENT);
    }

    function getNextIndexUp(state, rowIndex) {
      return rowIndex === -1 ? undefined : rowIndex - 1;
    }

    function getNextIndexDown(state, rowIndex) {
      const rowsCount = state.rows.length;
      return rowIndex + 1 < rowsCount ? rowIndex + 1 : undefined;
    }

    function getNextColumnIndex(columnsCount, colIndex) {
      return columnsCount > colIndex + 1 ? colIndex + 1 : undefined;
    }

    function getPrevColumnIndex(colIndex) {
      return colIndex > 0 ? colIndex - 1 : undefined;
    }

    function getNextIndexRight(state, colIndex) {
      if (isRTL()) {
        return getPrevColumnIndex(colIndex);
      }

      return getNextColumnIndex(state.columns.length, colIndex);
    }

    function getNextIndexLeft(state, colIndex) {
      if (isRTL()) {
        return getNextColumnIndex(state.columns.length, colIndex);
      }

      return getPrevColumnIndex(colIndex);
    }

    function getNextIndexUpWrapped(state, rowIndex) {
      const rowsCount = state.rows.length;
      return rowIndex === 0 ? -1 : rowIndex === -1 ? rowsCount - 1 : rowIndex - 1;
    }

    function getNextIndexDownWrapped(state, rowIndex) {
      const rowsCount = state.rows.length;
      return rowIndex + 1 < rowsCount ? rowIndex + 1 : -1;
    }

    function getNextTabIndexForward(state, rowIndex, colIndex) {
      const columnsCount = state.columns.length;

      if (columnsCount > colIndex + 1) {
        return {
          nextRowIndex: rowIndex,
          nextColIndex: colIndex + 1
        };
      }

      return {
        nextRowIndex: getNextIndexDownWrapped(state, rowIndex),
        nextColIndex: 0
      };
    }

    function getNextTabIndexBackward(state, rowIndex, colIndex) {
      const columnsCount = state.columns.length;

      if (colIndex > 0) {
        return {
          nextRowIndex: rowIndex,
          nextColIndex: colIndex - 1
        };
      }

      return {
        nextRowIndex: getNextIndexUpWrapped(state, rowIndex),
        nextColIndex: columnsCount - 1
      };
    }

    function getRowParent(state, rowLevel, rowIndex) {
      const parentIndex = rowIndex - 1;
      const rows = getRows(state);

      for (let i = parentIndex; i >= 0; i--) {
        if (rows[i].level === rowLevel - 1) {
          return i;
        }
      }

      return -1;
    }

    function stillValidActiveCell(state) {
      const {
        activeCell: {
          rowKeyValue,
          colKeyValue
        }
      } = state;

      if (rowKeyValue === 'HEADER') {
        return state.headerIndexes[colKeyValue] !== undefined;
      }

      return !!(state.indexes[rowKeyValue] && state.indexes[rowKeyValue][colKeyValue]);
    }

    function setDefaultActiveCell(state) {
      state.activeCell = getDefaultActiveCell(state);
    }

    function getDefaultActiveCell(state) {
      const {
        columns,
        rows
      } = state;

      if (columns.length > 0) {
        let colIndex;
        const existCustomerColumn = columns.some((column, index) => {
          colIndex = index;
          return isCustomerColumn(column);
        });

        if (!existCustomerColumn) {
          colIndex = 0;
        }

        return {
          rowKeyValue: rows.length > 0 ? rows[0].key : 'HEADER',
          colKeyValue: generateColKeyValue(columns[colIndex], colIndex)
        };
      }

      return undefined;
    }

    function getCellFromIndexes(state, rowIndex, colIndex) {
      const {
        columns,
        rows
      } = state;

      if (columns.length > 0) {
        return {
          rowKeyValue: rowIndex === -1 ? 'HEADER' : rows[rowIndex].key,
          colKeyValue: generateColKeyValue(columns[colIndex], colIndex)
        };
      }

      return undefined;
    }

    function handleCellKeydown(event) {
      event.stopPropagation();
      reactToKeyboard(this.template, this.state, event);
    }
    function handleKeyDown(event) {
      const targetTagName = event.target.tagName.toLowerCase(); // when the event came from the td is cause it has the focus.

      if (targetTagName === 'td' || targetTagName === 'th') {
        reactToKeyboardInNavMode(this.template, this.state, event);
      }
    }
    /**
     * This is needed to check if datatable has lost focus but cell has been clicked recently
     * @param {object} state - datatable state
     */

    const setCellClickedForFocus = function (state) {
      state.cellClicked = true;
    };
    /**
     * Once the dt regains focus there is no need to set this
     *  @param {object} state - datatable state
     */

    const resetCellClickedForFocus = function (state) {
      state.cellClicked = false;
    };
    /**
     * This method is needed in IE11 where clicking on the cell (factory) makes the div or the span active element
     * It refocuses on the cell element td or th
     * @param {object} template - datatable element
     * @param {object} state - datatable state
     * @param {boolean} needsRefocusOnCellElement - flag indicating whether or not to refocus on the cell td/th
     */

    const refocusCellElement = function (template, state, needsRefocusOnCellElement) {
      if (needsRefocusOnCellElement) {
        const {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state);
        const cellElement = getCellElementByIndexes(template, rowIndex, colIndex);

        if (cellElement) {
          cellElement.parentElement.focus();
        } // setTimeout so that focusin happens and then we set state.cellClicked to true
        // eslint-disable-next-line @lwc/lwc/no-async-operation


        setTimeout(() => {
          setCellClickedForFocus(state);
        }, 0);
      } else if (!datatableHasFocus(state)) {
        setCellClickedForFocus(state);
      }
    };
    const handleDatatableLosedFocus = function (event) {
      const {
        state
      } = this; // workarounds for delegatesFocus issues

      if ( // needed for initial focus where relatedTarget is empty
      !event.relatedTarget && state.isExiting || // needed when clicked outside
      event.relatedTarget && !event.currentTarget.contains(event.relatedTarget) || // needed when datatable leaves focus and related target is still within datatable W-6185154
      event.relatedTarget && event.currentTarget.contains(event.relatedTarget) && state.isExiting) {
        if (state.activeCell) {
          if (state.rowMode) {
            const {
              rowIndex
            } = getIndexesActiveCell(state);
            updateTabIndexRow(state, rowIndex, -1);
          } else {
            const {
              rowIndex,
              colIndex
            } = getIndexesActiveCell(state);
            const cellElement = getCellElementByIndexes(this.template, rowIndex, colIndex); // we need to check because of the tree,
            // at this point it may remove/change the rows/keys because opening or closing a row.

            if (cellElement) {
              cellElement.removeFocusStyles();
              cellElement.parentElement.classList.remove('slds-has-focus');
              cellElement.tabindex = -1;
            }
          }
        } // workarounds for delegatesFocus issue W-6220374
        // if tabindex is set to 0 immediately, table element gets focus which in turn focuses on cell
        // eslint-disable-next-line @lwc/lwc/no-async-operation


        setTimeout(() => {
          state.tabindex = 0;
        }, 0);
      }
    };

    function isFocusInside(currentTarget) {
      const activeElements = getShadowActiveElements();
      return activeElements.some(element => {
        return currentTarget.contains(element);
      });
    }

    const handleDatatableFocusIn = function (event) {
      const {
        state
      } = this;
      state.isExiting = false; // workaround for delegatesFocus issue that focusin is called when not supposed to W-6220418

      if (isFocusInside(event.currentTarget) && !datatableHasFocus(state)) {
        if (!state.rowMode && state.activeCell) {
          const {
            rowIndex,
            colIndex
          } = getIndexesActiveCell(state);
          const cellElement = getCellElementByIndexes(this.template, rowIndex, colIndex); // we need to check because of the tree,
          // at this point it may remove/change the rows/keys because opening or closing a row.

          if (cellElement) {
            cellElement.addFocusStyles();
            cellElement.parentElement.classList.add('slds-has-focus');
            cellElement.tabindex = 0;
          }
        }

        state.tabindex = false;
        resetCellClickedForFocus(state);
      }
    };

    const VALID_EDITABLE_TYPE = {
      text: true,
      percent: true,
      phone: true,
      email: true,
      url: true,
      currency: true,
      number: true,
      boolean: true,
      'date-local': true,
      date: true
    };
    const PANEL_SEL = '[data-iedit-panel="true"]';

    function isEditableType(type) {
      return !!VALID_EDITABLE_TYPE[type];
    }

    function getInlineEditDefaultState() {
      return {
        inlineEdit: {
          dirtyValues: {}
        }
      };
    }
    /**
     * @param {Object} state - Datatable instance.
     * @return {Array} - An array of objects, each object describing the dirty values in the form { colName : dirtyValue }.
     *                   A special key is the { [keyField]: value } pair used to identify the row containing this changed values.
     */

    function getDirtyValues(state) {
      return getChangesForCustomer(state, state.inlineEdit.dirtyValues);
    }
    /**
     * Sets the dirty values in the datatable.
     *
     * @param {Object} state Datatable state for the inline edit.
     * @param {Array} value An array of objects, each object describing the dirty values in the form { colName : dirtyValue }.
     *                      A special key is the { [keyField]: value } pair used to identify the row containing this changed values.
     */

    function setDirtyValues(state, value) {
      const keyField = getKeyField(state);
      const dirtyValues = Array.isArray(value) ? value : [];
      state.inlineEdit.dirtyValues = dirtyValues.reduce((result, rowValues) => {
        const changes = getRowChangesFromCustomer(state, rowValues);
        delete changes[keyField];
        result[rowValues[keyField]] = changes;
        return result;
      }, {});
    }
    function normalizeEditable(column) {
      if (isEditableType(column.type)) {
        column.editable = normalizeBoolean(column.editable);
      } else {
        column.editable = false;
      }
    }
    function hasEditableColumn(columns) {
      return columns.some(column => column.editable);
    }
    function isInlineEditTriggered(state) {
      return Object.keys(state.inlineEdit.dirtyValues).length > 0;
    }
    function cancelInlineEdit(dt) {
      dt.state.inlineEdit.dirtyValues = {};
      setErrors(dt.state, {});
      updateRowsAndCellIndexes.call(dt);
    }
    function handleEditCell(event) {
      startPanelPositioning(this, event.target.parentElement);
      const inlineEdit = this.state.inlineEdit;

      if (inlineEdit.isPanelVisible) {
        // A special case when we are trying to open a edit but we have one open. (click on another edit while editing)
        // in this case we will need to process the values before re-open the edit panel with the new values or we may lose the edition.
        processInlineEditFinish(this, 'loosed-focus', inlineEdit.rowKeyValue, inlineEdit.colKeyValue);
      }

      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      inlineEdit.isPanelVisible = true;
      inlineEdit.rowKeyValue = rowKeyValue;
      inlineEdit.colKeyValue = colKeyValue;
      inlineEdit.editedValue = getCellValue(this.state, rowKeyValue, colKeyValue);
      inlineEdit.massEditSelectedRows = getCurrentSelectionLength(this.state);
      inlineEdit.massEditEnabled = isSelectedRow(this.state, rowKeyValue) && inlineEdit.massEditSelectedRows > 1; // pass the column definition

      const colIndex = getStateColumnIndex(this.state, colKeyValue);
      inlineEdit.columnDef = getColumns(this.state)[colIndex];
      markSelectedCell(this.state, rowKeyValue, colKeyValue); // eslint-disable-next-line @lwc/lwc/no-async-operation

      setTimeout(() => {
        this.template.querySelector('lightning-primitive-datatable-iedit-panel').focus();
      }, 0);
    }
    function handleInlineEditFinish(event) {
      stopPanelPositioning(this);
      const {
        reason,
        rowKeyValue,
        colKeyValue
      } = event.detail;
      processInlineEditFinish(this, reason, rowKeyValue, colKeyValue);
    }
    function handleMassCheckboxChange(event) {
      const state = this.state;

      if (event.detail.checked) {
        markAllSelectedRowsAsSelectedCell(state);
      } else {
        markAllSelectedRowsAsDeselectedCell(this.state);
        markSelectedCell(state, state.inlineEdit.rowKeyValue, state.inlineEdit.colKeyValue);
      }
    } // hide panel on scroll

    const HIDE_PANEL_THRESHOLD = 5;
    function handleInlineEditPanelScroll(event) {
      const {
        isPanelVisible,
        rowKeyValue,
        colKeyValue
      } = this.state.inlineEdit;

      if (!isPanelVisible) {
        return;
      }

      let delta = 0;
      const container = event.target;

      if (container.classList.contains('slds-scrollable_x')) {
        const scrollX = container.scrollLeft;

        if (this.privateLastScrollX == null) {
          this.privateLastScrollX = scrollX;
        } else {
          delta = Math.abs(this.privateLastScrollX - scrollX);
        }
      } else {
        const scrollY = container.scrollTop;

        if (this.privateLastScrollY == null) {
          this.privateLastScrollY = scrollY;
        } else {
          delta = Math.abs(this.privateLastScrollY - scrollY);
        }
      }

      if (delta > HIDE_PANEL_THRESHOLD) {
        this.privateLastScrollX = null;
        this.privateLastScrollY = null;
        stopPanelPositioning(this);
        processInlineEditFinish(this, 'loosed-focus', rowKeyValue, colKeyValue);
      } else {
        // we want to keep the panel attached to the cell before
        // reaching the threshold and hiding the panel
        repositionPanel(this);
      }
    }
    function getDirtyValue(state, rowKeyValue, colKeyValue) {
      const dirtyValues = state.inlineEdit.dirtyValues;

      if ( // eslint-disable-next-line no-prototype-builtins
      dirtyValues.hasOwnProperty(rowKeyValue) && // eslint-disable-next-line no-prototype-builtins
      dirtyValues[rowKeyValue].hasOwnProperty(colKeyValue)) {
        return dirtyValues[rowKeyValue][colKeyValue];
      }

      return undefined;
    }
    /**
     * Will update the dirty values specified in rowColKeyValues
     *
     * @param {Object} state - state of the datatable
     * @param {Object} rowColKeyValues - An object in the form of { rowKeyValue: { colKeyValue1: value, ..., colKeyValueN: value } ... }
     */

    function updateDirtyValues(state, rowColKeyValues) {
      const dirtyValues = state.inlineEdit.dirtyValues;
      Object.keys(rowColKeyValues).forEach(rowKey => {
        if (!Object.prototype.hasOwnProperty.call(dirtyValues, rowKey)) {
          dirtyValues[rowKey] = {};
        }

        Object.assign(dirtyValues[rowKey], rowColKeyValues[rowKey]);
      });
    }
    /**
     * Returns the current value of the cell, already takes into account the dirty value
     *
     * @param {Object} state - state of the datatable
     * @param {String} rowKeyValue - row key
     * @param {String} colKeyValue - column key
     *
     * @return {Object} the value for the current cell.
     */


    function getCellValue(state, rowKeyValue, colKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const colIndex = getStateColumnIndex(state, colKeyValue);
      return row.cells[colIndex].value;
    }
    /**
     *
     * @param {Object} state - Datatable state
     * @param {Object} changes - The internal representation of changes in a row
     * @returns {Object} - the list of customer changes in a row
     */


    function getColumnsChangesForCustomer(state, changes) {
      return Object.keys(changes).reduce((result, colKey) => {
        const columns = getColumns(state);
        const columnIndex = getStateColumnIndex(state, colKey);
        result[columns[columnIndex].fieldName] = changes[colKey];
        return result;
      }, {});
    }

    function getRowChangesFromCustomer(state, changes) {
      return Object.keys(changes).reduce((result, fieldName) => {
        const columns = getColumns(state);
        const columnIndex = getColumnIndexByFieldName(state, fieldName);

        if (columnIndex >= 0) {
          const colKey = columns[columnIndex].colKeyValue;
          result[colKey] = changes[fieldName];
        }

        return result;
      }, {});
    }

    function getChangesForCustomer(state, changes) {
      const keyField = getKeyField(state);
      return Object.keys(changes).reduce((result, rowKey) => {
        const rowChanges = getColumnsChangesForCustomer(state, changes[rowKey]);

        if (Object.keys(rowChanges).length > 0) {
          rowChanges[keyField] = rowKey;
          result.push(rowChanges);
        }

        return result;
      }, []);
    }

    function dispatchCellChangeEvent(dtInstance, cellChange) {
      dtInstance.dispatchEvent(new CustomEvent('cellchange', {
        detail: {
          draftValues: getChangesForCustomer(dtInstance.state, cellChange)
        }
      }));
    }

    function closeInlineEdit(dt) {
      const inlineEditState = dt.state.inlineEdit;

      if (inlineEditState.isPanelVisible) {
        processInlineEditFinish(dt, 'loosed-focus', inlineEditState.rowKeyValue, inlineEditState.colKeyValue);
      }
    }

    function isValidCell(state, rowKeyValue, colKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const colIndex = getStateColumnIndex(state, colKeyValue);
      return row && row.cells[colIndex];
    }
    /**
     * It will process when the datatable had finished an edition.
     *
     * @param {Object} dt - the datatable instance
     * @param {string} reason - the reason to finish the edition. valid reasons are: edit-canceled | loosed-focus | tab-pressed | submit-action
     * @param {string} rowKeyValue - the row key of the edited cell
     * @param {string} colKeyValue - the column key of the edited cell
     */


    function processInlineEditFinish(dt, reason, rowKeyValue, colKeyValue) {
      const state = dt.state;
      const inlineEditState = state.inlineEdit;
      const shouldSaveData = reason !== 'edit-canceled' && !(inlineEditState.massEditEnabled && reason === 'loosed-focus') && isValidCell(dt.state, rowKeyValue, colKeyValue);

      if (shouldSaveData) {
        const panel = dt.template.querySelector(PANEL_SEL);
        const editValue = panel.value;
        const isValidEditValue = panel.validity.valid;
        const updateAllSelectedRows = panel.isMassEditChecked;
        const currentValue = getCellValue(state, rowKeyValue, colKeyValue);

        if (isValidEditValue && (editValue !== currentValue || updateAllSelectedRows)) {
          const cellChange = {};
          cellChange[rowKeyValue] = {};
          cellChange[rowKeyValue][colKeyValue] = editValue;

          if (updateAllSelectedRows) {
            const selectedRowKeys = getSelectedRowsKeys(state);
            selectedRowKeys.forEach(rowKey => {
              cellChange[rowKey] = {};
              cellChange[rowKey][colKeyValue] = editValue;
            });
          }

          updateDirtyValues(state, cellChange);
          dispatchCellChangeEvent(dt, cellChange); // @todo: do we need to update all rows in the dt or just the one that was modified?

          updateRowsAndCellIndexes.call(dt);
        }
      }

      if (reason !== 'loosed-focus') {
        switch (reason) {
          case 'tab-pressed-next':
            {
              reactToTabForward(dt.template, state);
              break;
            }

          case 'tab-pressed-prev':
            {
              reactToTabBackward(dt.template, state);
              break;
            }

          default:
            {
              setFocusActiveCell(dt.template, state, 0);
            }
        }
      }

      markAllSelectedRowsAsDeselectedCell(state);
      markDeselectedCell(state, rowKeyValue, colKeyValue);
      inlineEditState.isPanelVisible = false;
    }

    function startPanelPositioning(dt, target) {
      // eslint-disable-next-line @lwc/lwc/no-async-operation
      requestAnimationFrame(() => {
        // we need to discard previous binding otherwise the panel
        // will retain previous alignment
        stopPanelPositioning(dt);
        dt.privatePositionRelationship = startPositioning(dt, {
          target,
          element: () => dt.template.querySelector(PANEL_SEL).getPositionedElement(),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          autoFlip: true
        });
      });
    }

    function stopPanelPositioning(dt) {
      if (dt.privatePositionRelationship) {
        stopPositioning(dt.privatePositionRelationship);
        dt.privatePositionRelationship = null;
      }
    } // reposition inline edit panel
    // this does not realign the element, so it doesn't fix alignment
    // when size of panel changes


    function repositionPanel(dt) {
      // eslint-disable-next-line @lwc/lwc/no-async-operation
      requestAnimationFrame(() => {
        if (dt.privatePositionRelationship) {
          dt.privatePositionRelationship.reposition();
        }
      });
    }

    function markAllSelectedRowsAsSelectedCell(state) {
      const {
        colKeyValue
      } = state.inlineEdit;
      const selectedRowKeys = getSelectedRowsKeys(state);
      selectedRowKeys.forEach(rowKeyValue => {
        markSelectedCell(state, rowKeyValue, colKeyValue);
      });
    }

    function markAllSelectedRowsAsDeselectedCell(state) {
      const {
        colKeyValue
      } = state.inlineEdit;
      const selectedRowKeys = getSelectedRowsKeys(state);
      selectedRowKeys.forEach(rowKeyValue => {
        markDeselectedCell(state, rowKeyValue, colKeyValue);
      });
    }

    var rowActionsDefaultAriaLabel = 'Actions';

    const i18n$o = {
      rowActionsDefaultAriaLabel
    };
    function getColumnsDefaultState() {
      return {
        columns: []
      };
    }
    function getColumns(state) {
      return state.columns;
    }
    function hasColumns(state) {
      return getColumns(state).length > 0;
    }
    const SELECTABLE_ROW_CHECKBOX = 'SELECTABLE_CHECKBOX';
    const SELECTABLE_COLUMN = {
      type: SELECTABLE_ROW_CHECKBOX,
      fixedWidth: 32,
      tabIndex: -1,
      internal: true
    };
    function normalizeColumns(state, columns, types) {
      if (columns.length !== 0) {
        let firstColumnForReaders = 0; // workaround https://git.soma.salesforce.com/raptor/raptor/issues/763

        const normalizedColumns = Object.assign([], columns);

        if (!state.hideCheckboxColumn) {
          firstColumnForReaders++;
          normalizedColumns.unshift(SELECTABLE_COLUMN);
        }

        if (hasRowNumberColumn(state) || hasEditableColumn(columns)) {
          firstColumnForReaders++;
          normalizedColumns.unshift(getRowNumberColumnDef());
        }

        state.columns = normalizedColumns.map((column, index) => {
          const normalizedColumn = Object.assign(getColumnDefaults(column), column);
          normalizedColumn.ariaLabel = normalizedColumn.label || normalizedColumn.ariaLabel || null;

          if (isCustomerColumn(normalizedColumn)) {
            normalizeColumnDataType(normalizedColumn, types);
            normalizeEditable(normalizedColumn);
            updateColumnSortingState(normalizedColumn, state);
          }

          if (isTreeType(normalizedColumn.type)) {
            normalizedColumn.typeAttributes = getNormalizedSubTypeAttribute(normalizedColumn.type, normalizedColumn.typeAttributes);
          }

          return Object.assign(normalizedColumn, {
            tabIndex: -1,
            colKeyValue: generateColKeyValue(normalizedColumn, index),
            isScopeCol: index === firstColumnForReaders
          });
        });
      } else {
        state.columns = [];
      }
    }

    function normalizeColumnDataType(column, types) {
      if (!types.isValidType(column.type)) {
        column.type = getRegularColumnDefaults().type;
      }
    }
    /**
     * Normalizes the subType and subTypeAttributes in the typeAttributes.
     * @param {String} type the type of this column
     * @param {Object} typeAttributes the type attributes of the column
     * @returns {Object} a new typeAttributes object with the sybtype and subTypeAttributes normalized.
     */


    function getNormalizedSubTypeAttribute(type, typeAttributes) {
      const typeAttributesOverrides = {};

      if (!isValidTypeForTree(typeAttributes.subType)) {
        typeAttributesOverrides.subType = getColumnDefaults({
          type
        }).subType;
      }

      if (!typeAttributes.subTypeAttributes) {
        typeAttributesOverrides.subTypeAttributes = {};
      }

      return Object.assign({}, typeAttributes, typeAttributesOverrides);
    }

    function getRegularColumnDefaults() {
      return {
        type: 'text',
        typeAttributes: {},
        cellAttributes: {}
      };
    }

    function getActionColumnDefaults() {
      return {
        fixedWidth: 50,
        resizable: false,
        ariaLabel: i18n$o.rowActionsDefaultAriaLabel
      };
    }

    function getTreeColumnDefaults() {
      return {
        type: 'tree',
        subType: 'text',
        typeAttributes: {},
        cellAttributes: {}
      };
    }

    function getColumnDefaults(column) {
      switch (column.type) {
        case 'action':
          return getActionColumnDefaults();

        case 'tree':
          return getTreeColumnDefaults();

        default:
          return getRegularColumnDefaults();
      }
    }

    function isCustomerColumn(column) {
      return column.internal !== true;
    }
    function getTypeAttributesValues(column) {
      if (isObjectLike(column.typeAttributes)) {
        return column.typeAttributes;
      }

      return {};
    }
    function getSubTypeAttributesValues(column) {
      if (isObjectLike(column.typeAttributes.subTypeAttributes)) {
        return column.typeAttributes.subTypeAttributes;
      }

      return {};
    }
    function getCellAttributesValues(column) {
      if (isObjectLike(column.cellAttributes)) {
        return column.cellAttributes;
      }

      return {};
    }
    /**
     * Return the index in dt.columns (user definition) related to colKeyValue.
     *      -1 if no column with that key exist or if its internal.
     * @param {Object} state The datatable state
     * @param {String} colKeyValue The generated key for the column
     * @return {Number} The index in dt.columns. -1 if not found or if its internal.
     */

    function getUserColumnIndex(state, colKeyValue) {
      const stateColumnIndex = getStateColumnIndex(state, colKeyValue);
      let internalColumns = 0;

      if (state.columns[stateColumnIndex].internal) {
        return -1;
      }

      for (let i = 0; i < stateColumnIndex; i++) {
        if (state.columns[i].internal) {
          internalColumns++;
        }
      }

      return stateColumnIndex - internalColumns;
    }
    /**
     * Return the index in state.columns (internal definition) related to colKeyValue.
     *
     * @param {Object} state The datatable state
     * @param {String} colKeyValue The generated key for the column
     * @return {number} The index in state.columns.
     */

    function getStateColumnIndex(state, colKeyValue) {
      return state.headerIndexes[colKeyValue];
    }
    /**
     *
     * @param {Object} state - The datatable state
     * @param {String} fieldName - the field name of the column
     * @returns {number} The index in state.columns, -1 if it does not exist
     */

    function getColumnIndexByFieldName(state, fieldName) {
      let i = 0;
      const columns = getColumns(state);
      const existFieldName = columns.some((column, index) => {
        i = index;
        return column.fieldName === fieldName;
      });
      return existFieldName ? i : -1;
    }

    /**
     * It return the default portion of state use it for the resizer
     * @returns {{resizer: {columnWidths: Array}}} - resizer default state
     */

    function getResizerDefaultState() {
      return {
        resizeColumnDisabled: false,
        resizeStep: 10,
        columnWidths: [],
        tableWidth: 0,
        minColumnWidth: 50,
        maxColumnWidth: 1000
      };
    } // *******************************
    // states Getters/Setters
    // *******************************

    /**
     * resizeColumnDisabled
     */

    function isResizeColumnDisabled(state) {
      return state.resizeColumnDisabled;
    }
    function setResizeColumnDisabled(state, value) {
      state.resizeColumnDisabled = normalizeBoolean(value);
    }
    /**
     * resizeStep
     */

    function setResizeStep(state, value) {
      state.resizeStep = normalizeNumberAttribute('resizeStep', value, 'non-negative', getResizerDefaultState().resizeStep);
    }
    function getResizeStep(state) {
      return state.resizeStep;
    }
    /**
     * columnWidths
     */

    /**
     * It return true if there are widths store in the state
     * @param {object} state - table state
     * @returns {boolean} - true if there are widths store in the state
     */

    function hasDefinedColumnsWidths(state) {
      return state.columnWidths.length > 0;
    }
    /**
     * It return the columnsWidths saved in the state
     * @param {object} state - table state
     * @returns {Array|*} - list of column widths
     */

    function getColumnsWidths(state) {
      return state.columnWidths;
    }
    /**
     * It set columnWidths to empty array
     * @param {object} state - table state
     */

    function resetColumnWidths(state) {
      state.columnWidths = [];
    }
    /**
     * tableWidth
     */

    /**
     * Get the full width of table
     * @param {object} state - table state
     * @returns {number} - table's width
     */

    function getTableWidth(state) {
      return state.tableWidth;
    }

    function setTableWidth(state, tableWidth) {
      state.tableWidth = tableWidth;
    }
    /**
     * minColumnWidth
     */


    function setMinColumnWidth(state, value) {
      state.minColumnWidth = normalizeNumberAttribute('minColumnWidth', value, 'non-negative', getResizerDefaultState().minColumnWidth);
      updateColumnWidthsMetadata(state);
    }
    function getMinColumnWidth(state) {
      return state.minColumnWidth;
    }
    /**
     * maxColumnWidth
     */

    function getMaxColumnWidth(state) {
      return state.maxColumnWidth;
    }
    function setMaxColumnWidth(state, value) {
      state.maxColumnWidth = normalizeNumberAttribute('maxColumnWidth', value, 'non-negative', getResizerDefaultState().maxColumnWidth);
      updateColumnWidthsMetadata(state);
    } // *******************************
    // Logics
    // *******************************

    /**
     * Get the style to match the full width of table
     * @param {object} state - table state
     * @returns {string} - style string
     */

    function getTableWidthStyle(state) {
      return getWidthStyle(getTableWidth(state));
    }
    /**
     * - It adjust the columns in the DOM, based on the table width and width meta in column definitions
     * - It also update the table and scroller container with the expected width
     *
     * @param {node} root - table root element
     * @param {object} state - table state
     */

    const adjustColumnsSize = function (root, state) {
      const widthsMeta = getTotalWidthsMetadata(state);
      const expectedTableWidth = getExpectedTableWidth(state, root, widthsMeta);
      const expectedFlexibleColumnWidth = getFlexibleColumnWidth(widthsMeta, expectedTableWidth);
      let columnsWidthSum = 0;
      resetColumnWidths(state);
      getColumns(state).forEach((column, colIndex) => {
        const width = getColumnWidthFromDef(column) || expectedFlexibleColumnWidth;
        columnsWidthSum += width;
        updateColumnWidth(state, colIndex, width);
      });
      setTableWidth(state, Math.min(expectedTableWidth, columnsWidthSum));
    };
    /**
     * - It adjusts the columns widths from the state
     * - It is used when there are columnwidths in state but the table is hidden with offsetwidth 0
     * - In this case we reset the columns to the width in state
     *
     * @param {object} state - table state
     */

    const adjustColumnsSizeFromState = function (state) {
      const columnsWidths = getColumnsWidths(state);
      let columnsWidthSum = 0;
      getColumns(state).forEach((column, colIndex) => {
        const width = columnsWidths[colIndex];

        if (typeof columnsWidths[colIndex] !== 'undefined') {
          columnsWidthSum += width;
          column.columnWidth = columnsWidths[colIndex];
          column.style = getWidthStyle(columnsWidths[colIndex]);
        }
      });
      setTableWidth(state, columnsWidthSum);
    };

    function getColumnWidthFromDef(column) {
      let resizedWidth;

      if (column.isResized) {
        resizedWidth = column.columnWidth;
      }

      return column.fixedWidth || resizedWidth || column.initialWidth;
    }
    /**
     * It resize a column width
     * @param {object} state - table state
     * @param {number} colIndex - the index of the column based on state.columns
     * @param {number} width - the new width is gonna be applied
     */


    const resizeColumn = function (state, colIndex, width) {
      const column = getColumns(state)[colIndex];
      const columnsWidths = getColumnsWidths(state);
      const currentWidth = columnsWidths[colIndex];
      const {
        minWidth,
        maxWidth
      } = column;
      const newWidth = clamp(width, minWidth, maxWidth);

      if (currentWidth !== newWidth) {
        const newDelta = newWidth - currentWidth;
        setTableWidth(state, getTableWidth(state) + newDelta);
        updateColumnWidth(state, colIndex, newWidth);
        column.isResized = true;
      }
    };
    /**
     * It resize a column width
     * @param {object} state - table state
     * @param {number} colIndex - the index of the column based on state.columns
     * @param {number} widthDelta - the delta that creates the new width
     */

    const resizeColumnWithDelta = function (state, colIndex, widthDelta) {
      const currentWidth = getColumnsWidths(state)[colIndex];
      resizeColumn(state, colIndex, currentWidth + widthDelta);
    };

    function updateColumnWidth(state, colIndex, newWidth) {
      const columnsWidths = getColumnsWidths(state);
      columnsWidths[colIndex] = newWidth;
      const column = getColumns(state)[colIndex];
      column.columnWidth = newWidth;
      column.style = getWidthStyle(newWidth);
    }

    function getExpectedTableWidth(state, root, widthsMeta) {
      const availableWidth = getAvailableWidthFromDom(root);
      const minExpectedTableWidth = getMinExpectedTableWidth(widthsMeta);
      return hasNoFlexibleColumns(widthsMeta) ? minExpectedTableWidth : Math.max(minExpectedTableWidth, availableWidth);
    }
    /**
     * It return the current widths for customer columns
     * @param {object} state - table state
     * @returns {Array} - the widths collection, every element
     * belong to a column with the same index in column prop
     */


    function getCustomerColumnWidths(state) {
      const columns = getColumns(state);
      return columns.reduce((prev, column, index) => {
        if (isCustomerColumn(column)) {
          prev.push(state.columnWidths[index]);
        }

        return prev;
      }, []);
    }
    function updateColumnWidthsMetadata(state) {
      getColumns(state).forEach(col => {
        if (!col.internal) {
          col.minWidth = getMinColumnWidth(state);
          col.maxWidth = getMaxColumnWidth(state);
        }

        if (col.initialWidth) {
          col.initialWidth = clamp(col.initialWidth, col.minWidth, col.maxWidth);
        }
      });
    }
    /**
     * It returns if table is rendered and not hidden
     * @param {node} root - table root element
     * @returns {boolean} - true or false if dt is rendered and not hidden on the page
     */

    function isTableRenderedVisible(root) {
      const CONTAINER_SEL = '.slds-scrollable_y';
      const elem = root.querySelector(CONTAINER_SEL);
      return elem && !!(elem.offsetParent || elem.offsetHeight || elem.offsetWidth);
    }

    function getTotalWidthsMetadata(state) {
      const initial = {
        totalFixedWidth: 0,
        totalFixedColumns: 0,
        totalResizedWidth: 0,
        totalResizedColumns: 0,
        totalFlexibleColumns: 0,
        minColumnWidth: state.minColumnWidth,
        maxColumnWidth: state.maxColumnWidth
      };
      return getColumns(state).reduce((prev, col) => {
        if (col.fixedWidth) {
          prev.totalFixedWidth += col.fixedWidth;
          prev.totalFixedColumns += 1;
        } else if (col.isResized) {
          prev.totalResizedWidth += col.columnWidth;
          prev.totalResizedColumns += 1;
        } else if (col.initialWidth) {
          prev.totalResizedWidth += col.initialWidth;
          prev.totalResizedColumns += 1;
        } else {
          prev.totalFlexibleColumns += 1;
        }

        return prev;
      }, initial);
    }

    function getMinExpectedTableWidth(widthsMeta) {
      const {
        totalFixedWidth,
        totalResizedWidth,
        totalFlexibleColumns,
        minColumnWidth
      } = widthsMeta;
      const minTotalFlexibleWidth = totalFlexibleColumns * minColumnWidth;
      return minTotalFlexibleWidth + totalFixedWidth + totalResizedWidth;
    }

    function getFlexibleColumnWidth(widthsMeta, totalTableWidth) {
      const {
        totalFixedWidth,
        totalResizedWidth,
        totalFlexibleColumns,
        minColumnWidth,
        maxColumnWidth
      } = widthsMeta;
      const totalFlexibleWidth = totalTableWidth - totalFixedWidth - totalResizedWidth;
      const avgFlexibleColumnWidth = Math.floor(totalFlexibleWidth / totalFlexibleColumns);
      const allowedSpace = Math.max(avgFlexibleColumnWidth, minColumnWidth);
      return Math.min(maxColumnWidth, allowedSpace);
    }

    function hasNoFlexibleColumns(widthsMeta) {
      return widthsMeta.totalFlexibleColumns === 0;
    }
    /**
     * Get width of dom element.
     * @param  {node} element - target dom element
     * @returns {number} - integer width of element
     */


    function getDomWidth(element) {
      return element.offsetWidth;
    }

    const CONTAINER_SEL = '.slds-scrollable_x';

    function getAvailableWidthFromDom(root) {
      return getDomWidth(root.querySelector(CONTAINER_SEL));
    }

    function getWidthStyle(pixels) {
      return pixels > 0 ? `width:${pixels}px` : '';
    }

    var labelRowLevelErrorAssistiveText = '{0} has {1} errors';

    const CHAR_WIDTH = 10;
    const COLUMN_TYPE = 'rowNumber';
    const i18n$p = {
      rowLevelErrorAssistiveText: labelRowLevelErrorAssistiveText
    };
    function isRowNumberColumn(column) {
      return column.type === COLUMN_TYPE;
    }
    function getRowNumberColumnDef() {
      return {
        type: COLUMN_TYPE,
        sortable: false,
        initialWidth: 52,
        minWidth: 52,
        maxWidth: 1000,
        tabIndex: -1,
        internal: true,
        resizable: false
      };
    }
    function getRowNumberState() {
      return {
        showRowNumberColumn: false,
        rowNumberOffset: 0
      };
    }
    /**
     * showRowNumberColumn
     */

    function hasRowNumberColumn(state) {
      return state.showRowNumberColumn;
    }
    function setShowRowNumberColumn(state, value) {
      state.showRowNumberColumn = normalizeBoolean(value);
    }
    /**
     * rowNumberOffset
     */

    function getRowNumberOffset(state) {
      return state.rowNumberOffset;
    }
    function setRowNumberOffset(state, value) {
      state.rowNumberOffset = normalizeNumberAttribute('rowNumberOffset', value, 'non-negative', getRowNumberState().rowNumberOffset);
    }
    /**
     * Functions to adjusting row number column width
     */

    function adjustRowNumberColumnWidth(root, state) {
      const colIndex = getRowNumberColumnIndex(state);

      if (colIndex > -1) {
        const rowNumberCol = getColumns(state)[colIndex];
        const newWidth = getAdjustedRowNumberColumnWidth(state);

        if (rowNumberCol.initialWidth !== newWidth) {
          rowNumberCol.initialWidth = Math.max(newWidth, rowNumberCol.minWidth);

          if (hasDefinedColumnsWidths(state)) {
            // when columns are resized with the resizer, a horizontal scroller appears.
            // adjusting the columns size, will respect widths already set and try to fit this column
            adjustColumnsSize(root, state);
          }
        }
      }
    }

    function getAdjustedRowNumberColumnWidth(state) {
      const numOfRows = state.rows.length;
      const offset = state.rowNumberOffset;
      const numberOfChars = String(numOfRows + offset).length;
      return CHAR_WIDTH * numberOfChars + 12
      /* padding */
      + 20
      /* primitive-tootlip */
      ;
    }

    function getRowNumberColumnIndex(state) {
      if (hasRowNumberColumn(state) && hasColumns(state)) {
        const columns = getColumns(state);

        for (let i = 0; i < columns.length; i++) {
          const column = columns[i];

          if (column.type === COLUMN_TYPE) {
            return i;
          }
        }
      }

      return -1;
    }

    function formatString(str) {
      const args = ArraySlice.call(arguments, 1);

      if (str) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return typeof args[i] !== 'undefined' ? args[i] : match;
        });
      }

      return '';
    }

    function getRowNumberErrorColumnDef(rowErrors, rowTitle) {
      const {
        title,
        messages
      } = rowErrors;
      const alternativeText = formatString(i18n$p.rowLevelErrorAssistiveText, rowTitle || '', rowErrors.fieldNames ? rowErrors.fieldNames.length : '');
      return {
        type: COLUMN_TYPE,
        typeAttributes: {
          error: {
            title,
            messages,
            alternativeText
          }
        }
      };
    }

    const nonWrapableTypes = ['action', 'boolean', 'button', 'button-icon', 'date-local', 'rowNumber'];
    const i18n$q = {
      clipText: labelClipText,
      wrapText: labelWrapText
    };

    function isWrapableType(type) {
      return nonWrapableTypes.indexOf(type) < 0;
    }

    function setWrapTextMaxLines(state, value) {
      state.wrapTextMaxLines = normalizeNumberAttribute('wrapTextMaxLines', value, 'positive', null);
    }

    function updateCellsWrapperText(state, colIndex, colKeyValue) {
      state.rows.forEach(row => {
        row.cells[colIndex].wrapText = state.wrapText[colKeyValue];
      });
    }

    function updateWrapTextState(state, colKeyValue) {
      const columns = getColumns(state);
      const colIndex = getStateColumnIndex(state, colKeyValue);
      const colData = columns[colIndex];
      colData.actions.internalActions.forEach(action => {
        if (action.name === 'wrapText') {
          action.checked = state.wrapText[colKeyValue];
        }

        if (action.name === 'clipText') {
          action.checked = !state.wrapText[colKeyValue];
        }
      });
      updateCellsWrapperText(state, colIndex, colKeyValue); // lets force a refresh on this column, because the wrapText checked value changed.

      colData.actions = Object.assign({}, colData.actions);
    }

    function getActions(state, columnDefinition) {
      const actions = [];

      if (isWrapableType(columnDefinition.type)) {
        state.wrapText[columnDefinition.colKeyValue] = normalizeBoolean(columnDefinition.wrapText) || false;
      }

      if (isWrapableType(columnDefinition.type)) {
        actions.push({
          label: `${i18n$q.wrapText}`,
          title: `${i18n$q.wrapText}`,
          checked: state.wrapText[columnDefinition.colKeyValue],
          name: 'wrapText'
        });
        actions.push({
          label: `${i18n$q.clipText}`,
          title: `${i18n$q.clipText}`,
          checked: !state.wrapText[columnDefinition.colKeyValue],
          name: 'clipText'
        });
      }

      return actions;
    }
    function handleTriggeredAction(state, action, colKeyValue) {
      if (action.name === 'wrapText' || action.name === 'clipText') {
        // If will change state
        if (state.wrapText[colKeyValue] !== (action.name === 'wrapText')) {
          state.wrapText[colKeyValue] = action.name === 'wrapText';
          updateWrapTextState(state, colKeyValue);
        }
      }
    }
    function getDefaultState() {
      return {
        wrapText: {}
      };
    }

    function getInternalActions(state, columnDefinition) {
      const internalActions = []; // just wrapper text for now.

      Array.prototype.push.apply(internalActions, getActions(state, columnDefinition));
      return internalActions;
    }

    function handleTriggeredInternalAction(dt, action, colKeyValue) {
      handleTriggeredAction(dt.state, action, colKeyValue);
      dispatchHeaderActionEvent(dt, action, colKeyValue);
    }

    function handleTriggeredCustomerAction(dt, action, colKeyValue) {
      dispatchHeaderActionEvent(dt, action, colKeyValue);
    }

    function dispatchHeaderActionEvent(dt, action, colKeyValue) {
      const userColumnIndex = getUserColumnIndex(dt.state, colKeyValue);
      const customerColumnDefinition = dt.columns[userColumnIndex];
      dt.dispatchEvent(new CustomEvent('headeraction', {
        detail: {
          action: deepCopy(action),
          columnDefinition: deepCopy(customerColumnDefinition)
        }
      }));
    }

    function getMenuAlignment(columns, index) {
      const isLastColumn = index === columns.length - 1;
      return isLastColumn || columns[index + 1].type === 'action' ? 'auto-right' : 'auto-left';
    }
    /**
     * Overrides the actions with the internal ones, plus the customer ones.
     *
     * @param {Object} state The state of the datatable.
     */


    function updateHeaderActions(state) {
      const columns = getColumns(state);
      columns.forEach((column, idx) => {
        column.actions = {
          menuAlignment: getMenuAlignment(columns, idx),
          customerActions: Array.isArray(column.actions) ? column.actions : [],
          internalActions: getInternalActions(state, column)
        };
      });
    }
    function handleHeaderActionTriggered(event) {
      const {
        action,
        actionType,
        colKeyValue
      } = event.detail;
      event.stopPropagation();

      if (actionType === 'customer') {
        handleTriggeredCustomerAction(this, action, colKeyValue);
      } else {
        handleTriggeredInternalAction(this, action, colKeyValue);
      }
    }
    function getColumnActionsDefaultState() {
      return Object.assign({}, getDefaultState());
    }
    function handleHeaderActionMenuOpening(event) {
      event.stopPropagation();
      event.preventDefault();
      event.detail.saveContainerPosition(this.getViewableRect());
    }

    const SCROLLABLE_CONTAINER_SEL = '.slds-scrollable_y';
    const SCROLL_ALLOWANCE = 2;
    function getInfiniteLoadingDefaultState() {
      return {
        enableInfiniteLoading: false,
        loadMoreOffset: 20,
        isLoading: false
      };
    }
    function isLoading(state) {
      return state.isLoading;
    }
    function setLoading(state, value) {
      state.isLoading = normalizeBoolean(value);
    }
    function isInfiniteLoadingEnabled(state) {
      return state.enableInfiniteLoading;
    }
    function setInfiniteLoading(state, value) {
      state.enableInfiniteLoading = normalizeBoolean(value);
    }
    function getLoadMoreOffset(state) {
      return state.loadMoreOffset;
    }
    function setLoadMoreOffset(state, value) {
      if (!isNonNegativeInteger(value)) {
        // eslint-disable-next-line no-console
        console.warn(`The "loadMoreOffset" value passed into lightning:datatable
            is incorrect. "loadMoreOffset" value should be an integer >= 0.`);
      }

      state.loadMoreOffset = isNonNegativeInteger(value) ? parseInt(value, 10) : getInfiniteLoadingDefaultState().loadMoreOffset;
    }
    function handleLoadMoreCheck(event) {
      if (isLoading(this.state)) {
        return;
      }

      const contentContainer = event.target.firstChild;

      if (!contentContainer) {
        return;
      }

      const offset = getOffsetFromTableEnd(contentContainer);
      const threshold = getLoadMoreOffset(this.state);

      if (offset < threshold) {
        this.dispatchEvent(new CustomEvent('loadmore'));
      }
    }

    function isScrollable(element) {
      // scrollHeight should be greater than clientHeight by some allowance
      return element && element.scrollHeight > element.clientHeight + SCROLL_ALLOWANCE;
    }

    function isScrollerVisible(elem) {
      return elem && !!(elem.offsetParent || elem.offsetHeight || elem.offsetWidth);
    }

    function hasData(root) {
      return root.querySelectorAll('tbody > tr').length > 0;
    }

    function handlePrefetch(root, state) {
      if (!isInfiniteLoadingEnabled(state) || isLoading(state) || !hasData(root)) {
        // dont prefetch if already loading or data is not set yet
        return;
      }

      const elem = root.querySelector(SCROLLABLE_CONTAINER_SEL);

      if (isScrollerVisible(elem) && !isScrollable(elem)) {
        this.dispatchEvent(new CustomEvent('loadmore'));
      }
    }

    function getOffsetFromTableEnd(el) {
      return el.scrollHeight - el.parentNode.scrollTop - el.parentNode.clientHeight;
    }

    function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }

    function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    const DEFAULTS = _objectSpread$2({}, getColumnsDefaultState(), getRowsDefaultState(), getSelectorDefaultState(), {
      headerIndexes: {}
    }, getKeyboardDefaultState(), {
      normalized: false
    }, getColumnActionsDefaultState(), getSortDefaultState(), getRowNumberState(), getResizerDefaultState(), getInfiniteLoadingDefaultState(), getInlineEditDefaultState(), getErrorsState(), {
      hideTableHeader: false,
      wrapTextMaxLines: null
    });

    const getDefaultState$1 = function () {
      return JSON.parse(JSON.stringify(DEFAULTS));
    };
    /**
     * It generate headerIndexes based in the current metadata
     * headerIndexes represent the position of the header(column)
     * based on the unique colKeyValue
     * @param {object} columns - the current normalized column metadata
     * @returns {object} headerIndexes e.g. { 'name-text' 0, 'amount-number': 1 }
     */

    const generateHeaderIndexes = function (columns) {
      return columns.reduce((prev, col, index) => {
        prev[generateColKeyValue(col, index)] = index;
        return prev;
      }, {});
    };

    /**
     *
     * @param {CustomEvent} event - row action
     */

    function handleRowActionTriggered(event) {
      const {
        rowKeyValue,
        colKeyValue,
        action
      } = event.detail;
      const selectedRow = getUserRowByCellKeys(this.state, rowKeyValue, colKeyValue);
      event.stopPropagation();
      this.dispatchEvent(new CustomEvent('rowaction', {
        detail: {
          row: deepCopy(selectedRow),
          action: deepCopy(action)
        }
      }));
    }
    /**
     *
     * @param {CustomEvent} event - load dynamic actions
     */

    function handleLoadDynamicActions(event) {
      const {
        rowKeyValue,
        colKeyValue,
        actionsProviderFunction,
        doneCallback,
        saveContainerPosition
      } = event.detail;
      const selectedRow = getUserRowByCellKeys(this.state, rowKeyValue, colKeyValue);
      saveContainerPosition(this.getViewableRect());
      event.stopPropagation();
      actionsProviderFunction(deepCopy(selectedRow), doneCallback);
    }
    /**
     *
     * @param {CustomEvent} event - fire `rowaction` on cell-button click
     */

    function handleCellButtonClick(event) {
      event.stopPropagation();
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const row = getUserRowByCellKeys(this.state, rowKeyValue, colKeyValue);
      const userColumnIndex = getUserColumnIndex(this.state, colKeyValue);
      const userColumnDefinition = this._columns[userColumnIndex];
      this.dispatchEvent(new CustomEvent('rowaction', {
        detail: {
          row: deepCopy(row),
          action: deepCopy(userColumnDefinition.typeAttributes)
        }
      }));
    }

    /**
     * Based on Marc J. Schmidt library: https://github.com/marcj/css-element-queries/blob/master
     */
    class EventQueue {
      constructor() {
        this.q = [];
      }

      add(ev) {
        this.q.push(ev);
      }

      call(sizeInfo) {
        for (let i = 0, j = this.q.length; i < j; i++) {
          this.q[i].call(this, sizeInfo);
        }
      }

      remove(ev) {
        const newQueue = [];

        for (let i = 0, j = this.q.length; i < j; i++) {
          if (this.q[i] !== ev) {
            newQueue.push(this.q[i]);
          }
        }

        this.q = newQueue;
      }

      length() {
        return this.q.length;
      }

    }
    /**
     * Get element size
     * @param {HTMLElement} element - element to return the size.
     * @returns {Object} {width, height}
     */


    lwc.registerDecorators(EventQueue, {
      fields: ["q"]
    });

    function getElementSize(element) {
      const rect = element.getBoundingClientRect();
      return {
        width: Math.round(rect.width),
        height: Math.round(rect.height)
      };
    }

    function createResizeSensor() {
      const resizeSensor = document.createElement('div');
      resizeSensor.dir = 'ltr';
      resizeSensor.className = 'resize-sensor';
      const style = 'position: absolute; left: -10px; top: -10px; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';
      const styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';
      resizeSensor.style.cssText = style; // eslint-disable-next-line @lwc/lwc/no-inner-html

      resizeSensor.innerHTML = `<div class="resize-sensor-expand" style="${style}">` + `<div style="${styleChild}"></div>` + `</div>` + `<div class="resize-sensor-shrink" style="${style}">` + `<div style="${styleChild} width: 200%; height: 200%"></div>` + `</div>`;
      return resizeSensor;
    }
    /**
     *
     * @param {HTMLElement} element - element to listen resize.
     * @param {Function}    resizeListener - resize event listener.
     */


    function attachResizeEvent(element, resizeListener) {
      if (!element) {
        return;
      }

      if (element.resizedAttached) {
        element.resizedAttached.add(resizeListener);
        return;
      }

      element.resizedAttached = new EventQueue();
      element.resizedAttached.add(resizeListener);
      const resizeSensor = createResizeSensor();
      element.resizeSensor = resizeSensor;
      element.appendChild(resizeSensor);
      const position = (window.getComputedStyle(element) || element.style).getPropertyValue('position');

      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
        element.style.position = 'relative';
      }

      const expand = resizeSensor.childNodes[0];
      const expandChild = expand.childNodes[0];
      const shrink = resizeSensor.childNodes[1];
      let dirty, rafId;
      let size = getElementSize(element);
      let lastWidth = size.width;
      let lastHeight = size.height;
      let initialHiddenCheck = true,
          resetRafId;

      const resetExpandShrink = function () {
        expandChild.style.width = '100000px';
        expandChild.style.height = '100000px';
        expand.scrollLeft = 100000;
        expand.scrollTop = 100000;
        shrink.scrollLeft = 100000;
        shrink.scrollTop = 100000;
      };

      const reset = function () {
        // Check if element is hidden
        if (initialHiddenCheck) {
          if (!expand.scrollTop && !expand.scrollLeft) {
            // reset
            resetExpandShrink(); // Check in next frame

            if (!resetRafId) {
              // eslint-disable-next-line @lwc/lwc/no-async-operation
              resetRafId = requestAnimationFrame(() => {
                resetRafId = 0;
                reset();
              });
            }

            return;
          }

          initialHiddenCheck = false;
        }

        resetExpandShrink();
      };

      resizeSensor.resetSensor = reset;

      const onResized = function () {
        rafId = 0;

        if (!dirty) {
          return;
        }

        lastWidth = size.width;
        lastHeight = size.height;

        if (element.resizedAttached) {
          element.resizedAttached.call(size);
        }
      };

      const onScroll = function () {
        size = getElementSize(element);
        dirty = size.width !== lastWidth || size.height !== lastHeight;

        if (dirty && !rafId) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          rafId = requestAnimationFrame(onResized);
        }

        reset();
      };

      const addEvent = function (el, name, cb) {
        el.addEventListener(name, cb);
      };

      addEvent(expand, 'scroll', onScroll);
      addEvent(shrink, 'scroll', onScroll); // Fix for custom Elements
      // eslint-disable-next-line @lwc/lwc/no-async-operation

      requestAnimationFrame(reset);
    }

    function detach(elem, ev) {
      if (!elem) {
        return;
      }

      if (elem.resizedAttached && typeof ev === 'function') {
        elem.resizedAttached.remove(ev);

        if (elem.resizedAttached.length()) {
          return;
        }
      }

      if (elem.resizeSensor) {
        if (elem.contains(elem.resizeSensor)) {
          elem.removeChild(elem.resizeSensor);
        }

        delete elem.resizeSensor;
        delete elem.resizedAttached;
      }
    }

    class ResizeSensor {
      constructor(element, resizeListener) {
        this.targetElement = element;
        this.resizeListener = resizeListener;
        attachResizeEvent(this.targetElement, this.resizeListener);
      }

      detach() {
        detach(this.targetElement, this.resizeListener);
      }

      reset() {
        this.targetElement.resizeSensor.resetSensor();
      }

    }

    const typesMap = new WeakMap();

    class LightningDatatable extends lwc.LightningElement {
      constructor() {
        super();
        this.hasDetachedListeners = true;
        this._columns = [];
        this._hideCheckboxColumn = false;
        this._draftValues = [];
        this.customerSelectedRows = null;
        this.privateDatatableId = generateUniqueId('lgt-datatable');
        this.privateSuppressBottomBar = false;
        this.state = getDefaultState$1();

        if (!typesMap.has(this.constructor)) {
          const privateTypes = new DatatableTypes$1(this.constructor.customTypes);
          typesMap.set(this.constructor, privateTypes);
        }

        this.updateRowsAndCellIndexes = updateRowsAndCellIndexes.bind(this);
      }

      get privateTypes() {
        return typesMap.get(this.constructor);
      }

      set columns(value) {
        this._columns = Array.isArray(value) ? value : [];
        this.updateColumns(this._columns);
      }
      /**
       * Array of the columns object that's used to define the data types.
       * Required properties include 'label', 'fieldName', and 'type'. The default type is 'text'.
       * See the Documentation tab for more information.
       * @type {array}
       */


      get columns() {
        return this._columns;
      }
      /**
       * This value specifies the number of lines after which the
       * content will be cut off and hidden. It must be at least 1 or more.
       * The text in the last line is truncated and shown with an ellipsis.
       * @type {integer}
       */


      get wrapTextMaxLines() {
        return this.state.wrapTextMaxLines;
      }

      set wrapTextMaxLines(value) {
        setWrapTextMaxLines(this.state, value);
        this.updateRowsAndCellIndexes(this.state);
      }

      set data(value) {
        setData(this.state, value);

        if (hasValidKeyField(this.state)) {
          this.updateRowsState();
        }

        if (this.customerSelectedRows) {
          this.setSelectedRows(this.customerSelectedRows);
        }
      }
      /**
       * The array of data to be displayed.
       * @type {array}
       */


      get data() {
        return getData(this.state);
      }

      set keyField(value) {
        setKeyField(this.state, value);
        setDirtyValues(this.state, this._draftValues);
        this.updateRowsState();
      }
      /**
       * Required for better performance.
       * Associates each row with a unique ID.
       * @type {string}
       * @required
       */


      get keyField() {
        return getKeyField(this.state);
      }

      set hideCheckboxColumn(value) {
        this._hideCheckboxColumn = value;
        this.state.hideCheckboxColumn = normalizeBoolean(value); // update the columns metadata again to update the status.

        this.updateColumns(this._columns);
      }
      /**
       * If present, the checkbox column for row selection is hidden.
       * @type {boolean}
       * @default false
       */


      get hideCheckboxColumn() {
        return this._hideCheckboxColumn;
      }

      set showRowNumberColumn(value) {
        setShowRowNumberColumn(this.state, value);
        this.updateColumns(this._columns);
      }
      /**
       * If present, the row numbers are shown in the first column.
       * @type {boolean}
       * @default false
       */


      get showRowNumberColumn() {
        return hasRowNumberColumn(this.state);
      }

      set rowNumberOffset(value) {
        const {
          state
        } = this;
        setRowNumberOffset(state, value);
        adjustRowNumberColumnWidth(this.template, state);
      }
      /**
       * Determines where to start counting the row number.
       * The default is 0.
       * @type {number}
       * @default 0
       */


      get rowNumberOffset() {
        return getRowNumberOffset(this.state);
      }

      set resizeColumnDisabled(value) {
        setResizeColumnDisabled(this.state, value);
      }
      /**
       * If present, column resizing is disabled.
       * @type {boolean}
       * @default false
       */


      get resizeColumnDisabled() {
        return isResizeColumnDisabled(this.state);
      }

      set minColumnWidth(value) {
        setMinColumnWidth(this.state, value);
      }
      /**
       * The minimum width for all columns.
       * The default is 50px.
       * @type {number}
       * @default 50px
       */


      get minColumnWidth() {
        return getMinColumnWidth(this.state);
      }

      set maxColumnWidth(value) {
        setMaxColumnWidth(this.state, value);
      }
      /**
       * The maximum width for all columns.
       * The default is 1000px.
       * @type {number}
       * @default 1000px
       */


      get maxColumnWidth() {
        return getMaxColumnWidth(this.state);
      }

      set resizeStep(value) {
        setResizeStep(this.state, value);
      }
      /**
       * The width to resize the column when a user presses left or right arrow.
       * The default is 10px.
       * @type {number}
       * @default 10px
       */


      get resizeStep() {
        return getResizeStep(this.state);
      }

      set sortedBy(value) {
        setSortedBy(this.state, value);
        updateSorting(this.state);
      }
      /**
       * The column fieldName that controls the sorting order.
       * Sort the data using the onsort event handler.
       * @type {string}
       */


      get sortedBy() {
        return getSortedBy(this.state);
      }

      set sortedDirection(value) {
        setSortedDirection(this.state, value);
        updateSorting(this.state);
      }
      /**
       * Specifies the sorting direction.
       * Sort the data using the onsort event handler.
       * Valid options include 'asc' and 'desc'.
       * @type {string}
       */


      get sortedDirection() {
        return getSortedDirection(this.state);
      }

      set defaultSortDirection(value) {
        setDefaultSortDirection(this.state, value);
        updateSorting(this.state);
      }
      /**
       * Specifies the default sorting direction on an unsorted column.
       * Valid options include 'asc' and 'desc'.
       * The default is 'asc' for sorting in ascending order.
       * @type {string}
       * @default asc
       */


      get defaultSortDirection() {
        return getDefaultSortDirection(this.state);
      }

      set enableInfiniteLoading(value) {
        setInfiniteLoading(this.state, value);
      }
      /**
       * If present, you can load a subset of data and then display more
       * when users scroll to the end of the table.
       * Use with the onloadmore event handler to retrieve more data.
       * @type {boolean}
       * @default false
       */


      get enableInfiniteLoading() {
        return isInfiniteLoadingEnabled(this.state);
      }

      set loadMoreOffset(value) {
        setLoadMoreOffset(this.state, value);
      }
      /**
       * Determines when to trigger infinite loading based on
       * how many pixels the table's scroll position is from the bottom of the table.
       * The default is 20.
       * @type {number}
       * @default 20
       */


      get loadMoreOffset() {
        return getLoadMoreOffset(this.state);
      }

      set isLoading(value) {
        setLoading(this.state, value);
      }
      /**
       * If present, a spinner is shown to indicate that more data is loading.
       * @type {boolean}
       * @default false
       */


      get isLoading() {
        return isLoading(this.state);
      }

      set maxRowSelection(value) {
        const previousSelectionLenght = getCurrentSelectionLength(this.state);
        setMaxRowSelection(this.state, value);

        if (previousSelectionLenght > 0) {
          this.fireSelectedRowsChange(this.getSelectedRows());
        }
      }
      /**
       * The maximum number of rows that can be selected.
       * Checkboxes are used for selection by default,
       * and radio buttons are used when maxRowSelection is 1.
       * @type {number}
       */


      get maxRowSelection() {
        return getMaxRowSelection(this.state);
      }

      set selectedRows(value) {
        this.customerSelectedRows = value;
        this.setSelectedRows(value);
      }
      /**
       * Enables programmatic row selection with a list of key-field values.
       * @type {list}
       */


      get selectedRows() {
        return getSelectedRowsKeys(this.state);
      }

      set errors(value) {
        setErrors(this.state, value);
        this.updateRowsState();
      }
      /**
       * Specifies an object containing information about cell level, row level, and table level errors.
       * When it's set, error messages are displayed on the table accordingly.
       * @type {object}
       */


      get errors() {
        return getErrors(this.state);
      }
      /**
       * The current values per row that are provided during inline edit.
       * @type {object}
       */


      get draftValues() {
        return getDirtyValues(this.state);
      }

      set draftValues(value) {
        this._draftValues = value;
        setDirtyValues(this.state, value);

        if (hasValidKeyField(this.state)) {
          this.updateRowsAndCellIndexes(this.state);
        }
      }
      /**
       * If present, the table header is hidden.
       * @type {boolean}
       * @default false
       */


      get hideTableHeader() {
        return this.state.hideTableHeader;
      }

      set hideTableHeader(value) {
        this.state.hideTableHeader = !!value;
      }

      get hasValidKeyField() {
        if (hasValidKeyField(this.state)) {
          return true;
        } // eslint-disable-next-line no-console


        console.error(`The "keyField" is a required attribute of lightning:datatable.`);
        return false;
      }

      get showSelectAllCheckbox() {
        return !getHideSelectAllCheckbox(this.state);
      }
      /**
       * If present, the footer that displays the Save and Cancel buttons is hidden during inline editing.
       * @type {boolean}
       * @default false
       */


      get suppressBottomBar() {
        return this.privateSuppressBottomBar;
      }

      set suppressBottomBar(value) {
        this.privateSuppressBottomBar = !!value;
      }

      connectedCallback() {
        const {
          handleResizeColumn,
          handleUpdateColumnSort,
          handleCellFocusByClick,
          handleFalseCellBlur
        } = this;
        this.template.addEventListener('selectallrows', handleSelectAllRows.bind(this));
        this.template.addEventListener('deselectallrows', handleDeselectAllRows.bind(this));
        this.template.addEventListener('selectrow', handleSelectRow.bind(this));
        this.template.addEventListener('deselectrow', handleDeselectRow.bind(this));
        this.addEventListener('rowselection', handleRowSelectionChange.bind(this));
        this.template.addEventListener('resizecol', handleResizeColumn.bind(this));
        this.template.addEventListener('privateupdatecolsort', handleUpdateColumnSort.bind(this));
        this.template.addEventListener('privatecellkeydown', handleCellKeydown.bind(this));
        this.template.addEventListener('privatecellfocusedbyclick', handleCellFocusByClick.bind(this));
        this.template.addEventListener('privatecellfalseblurred', handleFalseCellBlur.bind(this)); // row-level-actions

        this.template.addEventListener('privatecellactiontriggered', handleRowActionTriggered.bind(this));
        this.template.addEventListener('privatecellactionmenuopening', handleLoadDynamicActions.bind(this));
        this.template.addEventListener('privatecellbuttonclicked', handleCellButtonClick.bind(this)); // header-actions

        this.template.addEventListener('privatecellheaderactionmenuopening', handleHeaderActionMenuOpening.bind(this));
        this.template.addEventListener('privatecellheaderactiontriggered', handleHeaderActionTriggered.bind(this)); // inline-edit

        this.template.addEventListener('privateeditcell', handleEditCell.bind(this));
      }

      render() {
        return _tmpl$H;
      }

      handleTrRowKeyDown(event) {
        // we probably should not be doing this unless we actually are interested in it
        if (this.state.keyboardMode === 'NAVIGATION' && this.state.rowMode === true) {
          event.stopPropagation();
          const tr = event.currentTarget;
          const rowKeyValue = tr.getAttribute('data-row-key-value');
          const keyCode = event.keyCode;
          const rowHasChildren = !!tr.getAttribute('aria-expanded');
          const rowExpanded = tr.getAttribute('aria-expanded') === 'true';
          const rowLevel = tr.getAttribute('aria-level');
          const evt = {
            target: tr,
            detail: {
              rowKeyValue,
              keyCode,
              rowHasChildren,
              rowExpanded,
              rowLevel,
              keyEvent: event
            }
          };
          reactToKeyboardOnRow(this, this.state, evt);
        }
      }

      disconnectedCallback() {
        // raptor does the removeEventListeners, so no need to detach them.
        this.hasDetachedListeners = true;
        const resizeTarget = this.template.querySelector('.dt-width-observer');
        this.privateWidthObserver.detach(resizeTarget);
      }

      renderedCallback() {
        if (this.hasDetachedListeners) {
          this.attachListeners();
        }

        const {
          state
        } = this;

        if (hasColumns(state) && !hasDefinedColumnsWidths(state)) {
          adjustColumnsSize(this.template, state);
          this.fireOnResize(false);
        }

        handlePrefetch.call(this, this.template, state); // customerSelectedRows is only valid till render, after it, the one used should be the one from the state.

        this.customerSelectedRows = null; // set the previous focused cell to null after render is done

        resetCellToFocusFromPrev(state);
      }

      setSelectedRows(value) {
        setSelectedRowsKeys(this.state, value);
        handleRowSelectionChange.call(this);
      }

      updateRowsState() {
        const {
          state
        } = this; // calculate cell to focus next before indexes are updated

        setCellToFocusFromPrev(state);
        this.updateRowsAndCellIndexes(state);
        adjustRowNumberColumnWidth(this.template, state); // update celltofocus next to null if the row still exists after indexes calculation

        updateCellToFocusFromPrev(state);
        syncSelectedRowsKeys(state, this.getSelectedRows()).ifChanged(selectedRows => this.fireSelectedRowsChange(selectedRows));
        syncActiveCell(state);

        if (state.keyboardMode === 'NAVIGATION') {
          updateTabIndexActiveCell(state);
          updateTabIndexActiveRow(state);
        } // if there is previously focused cell which was deleted set focus from celltofocus next


        if (state.cellToFocusNext && state.activeCell) {
          setFocusActiveCell(this.template, this.state);
        }
      }

      updateColumns(columns) {
        const {
          state
        } = this;
        const hadTreeDataTypePreviously = hasTreeDataType(state); // calculate cell to focus next before indexes are updated

        setCellToFocusFromPrev(state);
        normalizeColumns(state, columns, this.privateTypes);
        setDirtyValues(state, this._draftValues);
        updateRowNavigationMode(hadTreeDataTypePreviously, state);
        state.headerIndexes = generateHeaderIndexes(getColumns(state)); // Updates wrapText value in state and checked value in header action dropdown

        updateHeaderActions(state);
        this.updateRowsAndCellIndexes(state);
        updateSelectionState(state);
        adjustRowNumberColumnWidth(this.template, state);
        updateColumnWidthsMetadata(state); // set the celltofocus next to null if the column still exists after indexes calculation

        updateCellToFocusFromPrev(state);

        if (getColumns(state).length !== getColumnsWidths(state).length) {
          resetColumnWidths(state);

          if (getData(state).length > 0) {
            // when there are column changes, update the active cell
            syncActiveCell(state);
          }
        } else if (hasDefinedColumnsWidths(state)) {
          // try to adjust column size if previous size in the state and table is visible (not hidden)
          if (isTableRenderedVisible(this.template)) {
            adjustColumnsSize(this.template, state);
          } else {
            adjustColumnsSizeFromState(state);
          }
        }

        if (state.keyboardMode === 'NAVIGATION') {
          updateTabIndexActiveCell(state);
          updateTabIndexActiveRow(state);
        } // if there is previously focused cell which was deleted set focus from celltofocus next


        if (state.cellToFocusNext && state.activeCell) {
          setFocusActiveCell(this.template, this.state);
        }
      }

      get computedTableHeaderClass() {
        if (this.state.hideTableHeader) {
          return 'slds-assistive-text';
        }

        return undefined;
      }

      get computedScrollerStyle() {
        return getTableWidthStyle(this.state);
      }

      get computedTableClass() {
        return classSet('slds-table slds-table_header-fixed slds-table_bordered slds-table_edit').add({
          'slds-table_resizable-cols': this.hasResizebleColumns
        }).add({
          'slds-tree slds-table_tree': hasTreeDataType(this.state)
        }).toString();
      }

      get computedTableRole() {
        return hasTreeDataType(this.state) ? 'treegrid' : 'grid';
      }

      get computedTableStyle() {
        return ['table-layout:fixed', getTableWidthStyle(this.state)].join(';');
      }

      get computedTbodyStyle() {
        if (hasRowNumberColumn(this.state) && getRowNumberOffset(this.state) >= 0) {
          return 'counter-reset: row-number ' + getRowNumberOffset(this.state);
        }

        return '';
      }

      get hasSelectableRows() {
        return !this.state.hideCheckboxColumn;
      }

      get hasResizebleColumns() {
        return !isResizeColumnDisabled(this.state);
      }

      get numberOfColumns() {
        return getColumns(this.state).length;
      }

      get showLoadingIndicator() {
        return isLoading(this.state);
      }

      get scrollerXStyles() {
        const styles = {
          height: '100%'
        };

        if (this.showStatusBar) {
          styles['padding-bottom'] = '3rem';
        }

        return Object.entries(styles).map(([key, value]) => key + ':' + value).join(';');
      }

      get showStatusBar() {
        return isInlineEditTriggered(this.state) && !this.suppressBottomBar;
      }

      get tableError() {
        return getTableError(this.state);
      }

      handleUpdateColumnSort(event) {
        event.stopPropagation();
        const {
          fieldName,
          sortDirection
        } = event.detail;
        this.fireSortedColumnChange(fieldName, sortDirection);
      }

      handleHorizontalScroll(event) {
        handleInlineEditPanelScroll.call(this, event);
      }

      handleVerticalScroll(event) {
        if (this.enableInfiniteLoading) {
          handleLoadMoreCheck.call(this, event);
        }

        handleInlineEditPanelScroll.call(this, event);
      }

      fireSelectedRowsChange(selectedRows) {
        const event = new CustomEvent('rowselection', {
          detail: {
            selectedRows
          }
        });
        this.dispatchEvent(event);
      }

      fireSortedColumnChange(fieldName, sortDirection) {
        const event = new CustomEvent('sort', {
          detail: {
            fieldName,
            sortDirection
          }
        });
        this.dispatchEvent(event);
      }

      fireOnResize(isUserTriggered) {
        const event = new CustomEvent('resize', {
          detail: {
            columnWidths: getCustomerColumnWidths(this.state),
            isUserTriggered: !!isUserTriggered
          }
        });
        this.dispatchEvent(event);
      }

      safariHeaderFix() {
        // W-6363867 Safari Refresh Bug
        if (isSafari) {
          const thead = this.template.querySelector('thead');
          const ths = thead.querySelectorAll('th[aria-label]');
          const columns = Array.prototype.slice.call(ths);
          columns.forEach(column => {
            column.style.display = 'none'; // eslint-disable-next-line @lwc/lwc/no-async-operation

            requestAnimationFrame(() => {
              column.style.display = '';
            });
          });
        }
      }

      handleResizeColumn(event) {
        event.stopPropagation();
        const {
          colIndex,
          widthDelta
        } = event.detail;

        if (widthDelta !== 0) {
          resizeColumnWithDelta(this.state, colIndex, widthDelta);
          this.fireOnResize(true);
          this.safariHeaderFix();
        }
      }

      get tableTabIndex() {
        return this.state.focusIsInside ? '-1' : '0';
      }

      handleTableFocus() {
        // dont modify the state if we can't focus on elements within the table
        if (!this.state.activeCell) {
          return;
        }

        this.state.tabindex = false; // Safari don't like tabindex=-1

        if (this.state.rowMode) {
          setFocusActiveRow(this.template, this.state);
        } else {
          setFocusActiveCell(this.template, this.state, NAVIGATION_DIR.USE_CURRENT);
        }
      }

      handleCellFocusByClick(event) {
        event.stopPropagation();
        const {
          rowKeyValue,
          colKeyValue,
          needsRefocusOnCellElement
        } = event.detail;
        const {
          state
        } = this;

        if (!isActiveCell(state, rowKeyValue, colKeyValue)) {
          if (state.rowMode && state.activeCell) {
            unsetRowNavigationMode(state);
            const {
              rowIndex
            } = getIndexesActiveCell(state);
            updateTabIndexRow(state, rowIndex, -1);
          }

          this.setActiveCell(rowKeyValue, colKeyValue);
          refocusCellElement(this.template, state, needsRefocusOnCellElement);
        }
      }

      handleCellClick(event) {
        // handles the case when clicking on the margin/pading of the td/th
        const targetTagName = event.target.tagName.toLowerCase();

        if (targetTagName === 'td' || targetTagName === 'th') {
          // get the row/col key value from the primitive cell.
          const {
            rowKeyValue,
            colKeyValue
          } = event.target.querySelector(':first-child');
          const {
            state
          } = this;

          if (state.rowMode || !isActiveCell(state, rowKeyValue, colKeyValue)) {
            if (state.rowMode && state.activeCell) {
              unsetRowNavigationMode(state);
              const {
                rowIndex
              } = getIndexesActiveCell(state);
              updateTabIndexRow(state, rowIndex, -1);
            }

            this.setActiveCell(rowKeyValue, colKeyValue);
          }

          if (!datatableHasFocus(state)) {
            setCellClickedForFocus(state);
          }
        }
      }

      setActiveCell(rowKeyValue, colKeyValue) {
        const {
          template,
          state
        } = this;
        const {
          rowIndex,
          colIndex
        } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
        setBlurActiveCell(template, state);
        updateActiveCell(state, rowKeyValue, colKeyValue);
        addFocusStylesToActiveCell(template, state);
        updateTabIndex(state, rowIndex, colIndex, 0);
      }

      handleFalseCellBlur(event) {
        event.stopPropagation();
        const {
          template,
          state
        } = this;
        const {
          rowKeyValue,
          colKeyValue
        } = event.detail;

        if (!isActiveCell(state, rowKeyValue, colKeyValue)) {
          this.setActiveCell(rowKeyValue, colKeyValue);
        }

        setFocusActiveCell(template, state);
      }
      /**
       * Returns data in each selected row.
       * @returns {array} An array of data in each selected row.
       */


      getSelectedRows() {
        const data = deepCopy(getData(this.state));
        return this.state.rows.reduce((prev, row, index) => {
          if (row.isSelected) {
            prev.push(data[index]);
          }

          return prev;
        }, []);
      }

      attachListeners() {
        const resizeTarget = this.template.querySelector('.dt-width-observer');
        this.privateWidthObserver = new ResizeSensor(resizeTarget, debounce(() => {
          // since this event handler is debounced, it might be the case that at the time the handler is called,
          // the element is disconnected (this.hasDetachedListeners)
          // the scroll event which the ResizeSensor uses can happen when table is hidden (as in console when switching tabs)
          // and hence the need for isTableRenderedVisible check
          if (!this.hasDetachedListeners && isTableRenderedVisible(this.template)) {
            adjustColumnsSize(this.template, this.state);
          }
        }, 200));
        this.hasDetachedListeners = false;
      }

      handleTableFocusIn(event) {
        handleDatatableFocusIn.call(this, event);
      }

      handleTableFocusOut(event) {
        handleDatatableLosedFocus.call(this, event);
      }
      /**
       * @return {Object} containing the visible dimensions of the table { left, right, top, bottom, }
       */


      getViewableRect() {
        const scrollerX = this.template.querySelector('.slds-scrollable_x').getBoundingClientRect();
        const scrollerY = this.template.querySelector('.slds-scrollable_y').getBoundingClientRect();
        return {
          left: scrollerX.left,
          right: scrollerX.right,
          top: scrollerY.top,
          bottom: scrollerY.bottom
        };
      }

      handleInlineEditFinish(event) {
        handleInlineEditFinish.call(this, event);
      }

      handleMassCheckboxChange(event) {
        handleMassCheckboxChange.call(this, event);
      }

      handleInlineEditSave(event) {
        event.stopPropagation();
        event.preventDefault();
        closeInlineEdit(this);
        const draftValues = this.draftValues;
        this.dispatchEvent(new CustomEvent('save', {
          detail: {
            draftValues
          }
        }));
      }

      handleInlineEditCancel(event) {
        event.stopPropagation();
        event.preventDefault();
        closeInlineEdit(this);
        const customerEvent = new CustomEvent('cancel', {
          cancelable: true
        });
        this.dispatchEvent(customerEvent);

        if (!customerEvent.defaultPrevented) {
          cancelInlineEdit(this);
        }
      }

      handleTableKeydown(event) {
        handleKeyDown.call(this, event);
      }

    }

    lwc.registerDecorators(LightningDatatable, {
      publicProps: {
        columns: {
          config: 3
        },
        wrapTextMaxLines: {
          config: 3
        },
        data: {
          config: 3
        },
        keyField: {
          config: 3
        },
        hideCheckboxColumn: {
          config: 3
        },
        showRowNumberColumn: {
          config: 3
        },
        rowNumberOffset: {
          config: 3
        },
        resizeColumnDisabled: {
          config: 3
        },
        minColumnWidth: {
          config: 3
        },
        maxColumnWidth: {
          config: 3
        },
        resizeStep: {
          config: 3
        },
        sortedBy: {
          config: 3
        },
        sortedDirection: {
          config: 3
        },
        defaultSortDirection: {
          config: 3
        },
        enableInfiniteLoading: {
          config: 3
        },
        loadMoreOffset: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        maxRowSelection: {
          config: 3
        },
        selectedRows: {
          config: 3
        },
        errors: {
          config: 3
        },
        draftValues: {
          config: 3
        },
        hideTableHeader: {
          config: 3
        },
        suppressBottomBar: {
          config: 3
        }
      },
      publicMethods: ["getSelectedRows"],
      track: {
        privateSuppressBottomBar: 1,
        state: 1
      },
      fields: ["hasDetachedListeners", "_columns", "_hideCheckboxColumn", "_draftValues", "customerSelectedRows", "privateDatatableId"]
    });

    var _lightningDatatable = lwc.registerComponent(LightningDatatable, {
      tmpl: _tmpl$H
    });

    function tmpl$$($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        s: api_slot
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_slot("", {
        key: 0,
        on: {
          "slotchange": _m0 || ($ctx._m0 = api_bind($cmp.handleSlotChange))
        }
      }, [], $slotset)];
    }

    var _tmpl$I = lwc.registerTemplate(tmpl$$);
    tmpl$$.slots = [""];
    tmpl$$.stylesheets = [];
    tmpl$$.stylesheetTokens = {
      hostAttribute: "lightning-buttonGroup_buttonGroup-host",
      shadowAttribute: "lightning-buttonGroup_buttonGroup"
    };

    class LightningButtonGroup extends lwc.LightningElement {
      constructor() {
        super(); // listen for button registration events

        this.privateButtons = [];
        this.template.addEventListener('privatebuttonregister', this.handleButtonRegister.bind(this));
      }

      connectedCallback() {
        this.classList.add('slds-button-group');
        this.setAttribute('role', 'group');
      }
      /**
       * Handles the registration for all the items inside the button-group that have been
       * loaded via <slot></slot>.
       * @param {Object} event - The event object
       */


      handleButtonRegister(event) {
        event.stopPropagation();
        const button = event.detail;
        const ref = event.target; // set the deregistration callback

        button.callbacks.setDeRegistrationCallback(() => {
          const indexToDelete = this.privateButtons.findIndex(el => el.ref === ref);
          this.privateButtons.splice(indexToDelete, 1);
        }); // add button to registered array

        this.privateButtons.push({
          button,
          ref
        });
      }
      /**
       * Handles the updates to slotted elements when the content of the slot changes.
       */


      handleSlotChange() {
        // sort registered buttons based on DOM location
        // :: sorting allows us to determine order/position in the group
        this.privateButtons = this.getSortedButtons(this.privateButtons); // if we only have a single button reset it to a plain button

        if (this.privateButtons.length === 1) {
          // pass down the position via a CSS class
          this.privateButtons[0].button.callbacks.setOrder(null);
        } else {
          // if we have more than one button iterate and set the order state
          for (let i = 0; i < this.privateButtons.length; i++) {
            let dataValue;

            if (i === 0) {
              dataValue = 'first';
            } else if (i === this.privateButtons.length - 1) {
              dataValue = 'last';
            } else {
              dataValue = 'middle';
            } // pass down the position via a CSS class


            this.privateButtons[i].button.callbacks.setOrder(dataValue);
          }
        }
      }

      getSortedButtons(buttons) {
        const sortedButtons = Object.values(buttons);
        sortedButtons.sort((a, b) => {
          const position = a.ref.compareDocumentPosition(b.ref);

          if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            return -1;
          } else if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
            return 1;
          }

          return 0;
        });
        return sortedButtons;
      }

    }

    lwc.registerDecorators(LightningButtonGroup, {
      fields: ["privateButtons"]
    });

    var _lightningButtonGroup = lwc.registerComponent(LightningButtonGroup, {
      tmpl: _tmpl$I
    });

    function tmpl$10($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        b: api_bind,
        h: api_element,
        t: api_text
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("div", {
        key: 15
      }, [api_element("div", {
        classMap: {
          "slds-m-around_medium": true,
          "slds-grid": true
        },
        key: 3
      }, [api_element("div", {
        classMap: {
          "slds-col": true,
          "slds-size_1-of-3": true
        },
        key: 1,
        on: {
          "keyup": _m0 || ($ctx._m0 = api_bind($cmp.searchAccount))
        }
      }, [api_custom_element("lightning-input", _lightningInput, {
        props: {
          "name": "enter-search",
          "label": "Search when user hits the 'enter' key",
          "type": "search"
        },
        key: 0
      }, [])]), api_element("br", {
        key: 2
      }, [])]), $cmp.showError ? api_element("div", {
        classMap: {
          "slds-m-around_medium": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-text-heading_medium": true,
          "slds-text-color_error": true
        },
        key: 5
      }, [api_text("Didn't find the matching Account in Salesforce, Do you want to create a new Account"), api_custom_element("lightning-button", _lightningButton, {
        classMap: {
          "slds-m-left_x-small": true,
          "table-test": true
        },
        props: {
          "variant": "brand",
          "label": "Create Account"
        },
        key: 4,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.showAccountModal))
        }
      }, [])])]) : null, api_element("div", {
        classMap: {
          "slds-m-around_medium": true
        },
        key: 8
      }, [api_custom_element("lightning-datatable", _lightningDatatable, {
        classMap: {
          "table-test": true
        },
        props: {
          "data": $cmp.pageList,
          "columns": $cmp.columns,
          "keyField": "Id",
          "hideCheckboxColumn": "true"
        },
        key: 7
      }, [])]), api_element("div", {
        classMap: {
          "slds-float_right": true,
          "slds-m-around_medium": true
        },
        key: 12
      }, [api_custom_element("lightning-button-group", _lightningButtonGroup, {
        key: 11
      }, [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "label": "Previous",
          "iconName": "utility:back",
          "variant": "brand",
          "disabled": $cmp.validPrevious
        },
        key: 9,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.previous))
        }
      }, []), api_custom_element("lightning-button", _lightningButton, {
        props: {
          "label": "Next",
          "iconName": "utility:forward",
          "variant": "brand",
          "disabled": $cmp.validNext,
          "iconPosition": "right"
        },
        key: 10,
        on: {
          "click": _m3 || ($ctx._m3 = api_bind($cmp.next))
        }
      }, [])])]), $cmp.showModal ? api_element("div", {
        key: 14
      }, [api_custom_element("c-account-modal", _cAccountModal, {
        props: {
          "showModal": $cmp.showModal
        },
        key: 13
      }, [])]) : null])];
    }

    var _tmpl$J = lwc.registerTemplate(tmpl$10);
    tmpl$10.stylesheets = [];

    if (_implicitStylesheets) {
      tmpl$10.stylesheets.push.apply(tmpl$10.stylesheets, _implicitStylesheets);
    }
    tmpl$10.stylesheetTokens = {
      hostAttribute: "lwc-listOfAccounts_listOfAccounts-host",
      shadowAttribute: "lwc-listOfAccounts_listOfAccounts"
    };

    /* LDS has proxy compat enabled */

    /*
     * Contains general utility functions around types.
     */
    class TypeUtils {
      /*
       * Returns true if the provided value is a function, else false.
       * @param value: any - The value with which to determine if it is a function.
       * @return : boolean - See description.
       */
      isFunction(value) {
        const type = typeof value;

        if (type === 'function') {
          return true;
        }

        return false;
      }
      /*
       * Returns true if the given value is a plain object, else false. A plain object has the following properties:
       * 1. Is not null
       * 2. Has a prototype with a constructor that is "Object".
       * @param value: any - The value with which to determine if it is a plain object.
       * @return : boolean - See description.
       */


      isPlainObject(value) {
        const objectProto = value !== null && typeof value === "object" && Object.getPrototypeOf(value);
        return value !== null && typeof value === "object" && (value.constructor && value.constructor.name === "Object" || objectProto && objectProto.constructor && objectProto.constructor.name === "Object");
      }
      /**
       * Checks whether the argument is a valid object
       * A valid object: Is not a DOM element, is not a native browser class (XMLHttpRequest)
       * is not falsey, and is not an array, error, function, string, or number.
       *
       * @param {Object} value The object to check for
       * @returns {Boolean} True if the value is an object and not an array, false otherwise
       */


      isObject(value) {
        return typeof value === "object" && value !== null && !this.isArray(value);
      }
      /**
       * Checks whether the specified object is an array.
       *
       * @param {Object} value The object to check for.
       * @returns {Boolean} True if the object is an array, or false otherwise.
       */


      isArray(value) {
        return Array.isArray(value);
      }
      /**
       * Checks if the object is of type string.
       *
       * @param {Object} value The object to check for.
       * @returns {Boolean} True if the object is of type string, or false otherwise.
       */


      isString(value) {
        return typeof value === 'string';
      }
      /**
       * Checks if the object is of type number.
       *
       * @param {Object} value The object to check for.
       * @returns {Boolean} True if the object is of type number, or false otherwise.
       */


      isNumber(value) {
        return typeof value === 'number';
      }
      /* WARNING: This must be used inside asserts only. If you are using this for class check for custom(non native) classes, then you must use an explicit check along with it.
       * e.g. thenables/Promises can be checked by using .then method
       * Returns true if the given value is an instance of the given type, else false. Unlike the built-in javascript instanceof operator, this
       * function treats cross frame/window instances as the same.
       * @param value: Object - The value with which to determine if it is of the given type.
       * @param type: Function - A constructor function to check the value against.
       * @return : boolean - See description.
       */


      isInstanceOf(value, type) {
        // Do native operation first. If it is true we don't need to do the cross frame algorithm. Adding this check results
        // in significant perf improvement when evaluating to true, and only a small perf decrease when evaluating to false.
        if (value instanceof type) {
          return true;
        } // Fallback to cross frame algorithm.


        if (type === null || type === undefined) {
          throw new Error("type must be defined");
        }

        if (!this.isFunction(type)) {
          throw new Error("type must be callable");
        }

        if (typeof type.prototype !== "object" && typeof type.prototype !== "function") {
          throw new Error("type has non-object prototype " + typeof type.prototype);
        }

        if (value === null || typeof value !== "object" && typeof value !== "function") {
          return false;
        }

        const prototypeOfValue = Object.getPrototypeOf(value); // There may be no prototype if an object is created with Object.create(null).

        if (prototypeOfValue) {
          if (prototypeOfValue.constructor.name === type.name) {
            return true;
          } else if (prototypeOfValue.constructor.name !== "Object") {
            // Recurse down the prototype chain.
            return this.isInstanceOf(prototypeOfValue, type);
          }
        } // No match!


        return false;
      }

    }
    /*
     * The singleton instance of the class.
     */


    const typeUtils = new TypeUtils();

    function assert$1(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }

    /*
     * Thenable implements a function chain that mimics the Promise instance API and can degrade to being backed by Promises
     * if necessary. If no Promises are encountered in the chain this will result in better performance because it chains functions
     * without pushing anything into a future tick in the microtask queue, i.e. it can be synchronous. When Promises go into the
     * same microtask queue they can be slowed down by things already ahead of them in the queue. Using Thenables allows us to
     * be synchronous when we can and degrade to being asynchronous (Promises) when we must.
     *
     * Note that Thenables are a notion from the Promise spec, see section 2.3.3 in https://promisesaplus.com/
     *
     * Note also that Promises are interoperable with the Thenable concept -- they have a construtor to convert a Thenable to a
     * Promise as well as a static method to contruct a Promise from a Thenable. See:
     * <pre><code>
     * new Promise((resolve, reject) => {resolve(thenable);}); // (constructor)
     * Promise.resolve(thenable); // (static)
     * </code></pre>
     *
     * Note that with this Promise interoperability, Thenable works with async/await. E.g. just like you can do the following with
     * Promises:
     * <pre><code>
     * async function asyncFunc() {
     *     var value = await Promise.resolve(1)
     *         .then(x => x * 3)
     *         .then(await Promise.resolve(x => x + 5))
     *         .then(x => x / 2);
     *     return value;
     * }
     * asyncFunc().then(x => {console.log(`x: ${x}`); return x;});
     * // log output: x: 4
     * // result: Promise {[[PromiseStatus]]: "resolved", [[PromiseValue]]: 4}
     * </code></pre>
     * you can also do the same thing with Thenable:
     * <pre><code>
     * async function asyncFunc() {
     *     var value = await Thenable.resolve(1)
     *         .then(x => x * 3)
     *         .then(await Thenable.resolve(x => x + 5))
     *         .then(x => x / 2);
     *     return value;
     * }
     * asyncFunc().then(x => {console.log(`x: ${x}`); return x;});
     * // log output: x: 4
     * // result: Promise {[[PromiseStatus]]: "resolved", [[PromiseValue]]: 4}
     * </code></pre>
     * While this interoperability with async/await may prove very handy when necessary, you should be careful using async/await
     * because once you do you will leave the synchronous chain of Thenables and start an asynchronous chain of Promises.
     */

    class Thenable {
      /*
       * Constructor.
       * @param value: any - The value that the thenable should resolve to.
       * @param rejectionReason: any - The rejection reason if the thenable rejects.
       */
      constructor(executor) {
        if (typeof executor != "function") {
          throw new Error("executor must be a function!");
        }

        this.value = undefined;
        this.rejectionReason = undefined; // This is expected to be synchronous.

        executor(this.resolver.bind(this), this.rejector.bind(this));
      }

      resolver(value) {
        this.value = value;
      }

      rejector(value) {
        this.rejectionReason = value;
      }
      /*
       * Returns a Thenable that is resolved with the provided value.
       * @param value: any - The value for the returned Thenable.
       * @returns Thenable<any> - Returns a Thenable that is resolved with the provided value.
       */


      static resolve(value) {
        return new Thenable(resolve => {
          resolve(value);
        });
      }
      /*
       * Returns a Thenable that is rejected for the provided reason.
       * @param rejectionReason: any - The reason for the returned Thenable's rejection.
       * @returns Thenable<any> - Returns a Thenable that is rejected for the provided reason.
       */


      static reject(rejectionReason) {
        return new Thenable((resolve, reject) => {
          reject(rejectionReason);
        });
      }
      /*
       * Behaves like Promise.all() but uses Thenables synchronously if possible. If all Thenables in the chains are non-Promises,
       * then this returns a Thenable that resolves to an array of results. If a Promise is encountered, then a Promise is returned
       * that resolves to an array of results (same as Promise.all()).
       * @param thenables: Iterable<Thenable|Promise> - The iterable of Thenables or Promises for which to wait.
       * @returns Thenable<Array<any>>|Promise<Array<any>> - If all Thenables in the chains are non-Promises, then this returns a
       * Thenable that resolves to an array of results. If a Promise is encountered, then a Promise is returned that resolves to an
       * array of results (same as Promise.all()).
       */


      static all(thenables) {
        assert$1(thenables, `thenables was falsy -- should be defined as an iterable of Thenables: ${thenables}`);
        const thenableArray = [...thenables];
        const thenableResultsArray = [];

        while (thenableArray.length > 0) {
          if (typeUtils.isInstanceOf(thenableArray[0], Promise)) {
            break; // We need to degrade to Promise.all() for the remainder.
          }

          const thenable = thenableArray.shift();

          if (thenable.rejectionReason !== undefined) {
            return Thenable.reject(thenable.rejectionReason);
          }

          const thenableValue = thenable.value; // .then check is added to reduce the noise and limit the instanceOf check to thenables

          if (thenableValue && thenableValue.then !== undefined && (typeUtils.isInstanceOf(thenableValue, Thenable) || typeUtils.isInstanceOf(thenableValue, Promise))) {
            thenableArray.unshift(thenableValue);
          } else {
            thenableResultsArray.push(thenableValue);
          }
        }

        if (thenableArray.length > 0) {
          // We degraded to a Promise.all(). Merge whatever results we have so far.
          return Promise.all(thenableArray).then(promiseResultsArray => {
            thenableResultsArray.push.apply(thenableResultsArray, promiseResultsArray);
            return thenableResultsArray;
          });
        }

        return Thenable.resolve(thenableResultsArray);
      }
      /*
       * Returns a Thenable or a Promise based on the input value or rejectionReason. If the value is a Promise
       * then we have to let this convert to a Promise chain and return Promises from here on, otherwise it will
       * return a Thenable.
       * @param value: any - The value for the returned Thenable.
       * @param rejectionReason: any - The reason for the returned Thenable's rejection.
       * @returns Thenable<any> | Promise<any> - Returns a Thenable or a Promise based on the input value or rejectionReason.
       */


      static _resolveOrReject(value, rejectionReason) {
        if (value && value.then !== undefined) {
          if (typeUtils.isInstanceOf(value, Promise)) {
            // We encountered a Promise, so we have to convert to an async Promise chain from here on.
            return value;
          }

          if (value.rejectionReason) {
            return Thenable.reject(value.rejectionReason);
          }

          return Thenable.resolve(value.value);
        }

        if (rejectionReason) {
          return Thenable.reject(rejectionReason);
        }

        return Thenable.resolve(value);
      }
      /*
       * Appends fulfillment and rejection handlers to the Thenable, and returns a new Thenable resolving to the return value of
       * the called handler, or to its original settled value if the Thenable was not handled (i.e. if the relevant handler onFulfilled
       * or onRejected is not a function).
       *
       * This method mirrors its equivalent in the Promise API, but calls everything synchronously if it can. If it encounters a Promise
       * in the chain, this synchronous Thenable chain will convert to an asynchronous Promise chain at that point.
       * @param onFulfilled: function - A Function called if the Thenable is fulfilled. This function has one argument, the fulfillment value.
       * @param onRejected: function - A Function called if the Thenable is rejected. This function has one argument, the rejection reason.
       * @returns Thenable<any> | Promise<any> - Returns a Thenable or a Promise based on output of the onFulfilled or onRejected handler.
       */


      then(onFulfilled, onRejected) {
        let newValue;
        let newRejectionReason;

        try {
          if (this.value === this || this.rejectionReason === this) {
            throw new TypeError("Thenable cannot resolve to itself.");
          }

          if (this.rejectionReason) {
            if (typeof onRejected === "function") {
              if (typeUtils.isInstanceOf(this.rejectionReason, Promise)) {
                return this.rejectionReason.then(undefined, onRejected);
              }

              newValue = onRejected(this.rejectionReason);
            } else {
              newRejectionReason = this.rejectionReason;
            }
          } else if (typeof onFulfilled === "function") {
            if (typeUtils.isInstanceOf(this.value, Promise)) {
              return this.value.then(onFulfilled);
            }

            newValue = onFulfilled(this.value);
          }
        } catch (e) {
          newRejectionReason = e;
        }

        newValue = newValue || this.value;
        return Thenable._resolveOrReject(newValue, newRejectionReason);
      }
      /*
       * Appends a rejection handler callback to the Thenable, and returns a new Thenable resolving to the return value of the callback if it
       * is called, or to its original fulfillment value if the Thenable is instead fulfilled.
       *
       * This method mirrors its equivalent in the Promise API, but calls everything synchronously if it can. If it encounters a Promise
       * in the chain, this synchronous Thenable chain will convert to an asynchronous Promise chain at that point.
       * @param onRejected: function - A Function called if the Thenable is rejected. This function has one argument, the rejection reason.
       * @returns Thenable<any> | Promise<any> - Returns a Thenable or a Promise based on output of the onRejected handler.
       */


      catch(onRejected) {
        return this.then(undefined, onRejected);
      }

    }

    function _objectSpread$3(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?Object(arguments[i]):{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==='function'){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable;}));}ownKeys.forEach(function(key){_defineProperty$3(target,key,source[key]);});}return target;}function _defineProperty$3(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}function _objectWithoutProperties(source,excluded){if(source==null)return {};var target=_objectWithoutPropertiesLoose(source,excluded);var key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(excluded.indexOf(key)>=0)continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key];}}return target;}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return {};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}const safeValues=new WeakMap();/**
     * Takes a value from LDS and makes it safe for Aura code that could be running in 'compat' mode for IE 11.
     * @param targetObject An object that has been wrapped in a Proxy to make it read only to consumers.
     * @returns An un-proxied but frozen object that can be safely used for read only tasks in Aura code.
     */function getValueForAura(targetObject){if(targetObject===undefined){return targetObject;}// Proxy.getKey should only be defined if we're in compat mode.
    const isCompatMode=Proxy.getKey!==undefined;if(!isCompatMode){// The proxy is safe to return as-is so long as we're not in compat mode or it's already frozen.
    return targetObject;}let safeValue=safeValues.get(targetObject);if(safeValue!==undefined){// We have already unwrapped and frozen something so we don't need to do that again.
    return safeValue;}safeValue=JSON.parse(JSON.stringify(targetObject));safeValues.set(targetObject,safeValue);return safeValue;}/**
     * @see {@link instrumentation.d.ts#markStart}.
     */function markStart(eventName,cacheKeyValueTypeString){const perfKey=_getUniquePerfKey(eventName);const perfContext={cacheKeyValueType:cacheKeyValueTypeString};const perfMarker={perfKey,perfContext};service.markStart(LDS_CACHE_PERF_NAMESPACE,perfKey,perfContext);return perfMarker;}/**
     * @see {@link instrumentation.d.ts#markEnd}.
     */function markEnd(perfMarker){service.markEnd(LDS_CACHE_PERF_NAMESPACE,perfMarker.perfKey,perfMarker.perfContext);}/**
     * @see {@link instrumentation.d.ts#instrumentError}.
     */function instrumentError(error$1,errorSource,errorType,additionalInfo){// Type is any because we are setting fields dynamically on the attribute object at runtime.
    const attributes={additionalInfo:additionalInfo||""};if(error$1.body){attributes.body=JSON.stringify(error$1.body);}if(error$1.stack){attributes.stack=error$1.stack;}if(error$1.message){attributes.message=error$1.message;}try{attributes.error=JSON.stringify(error$1);}catch(exception){// tslint:disable-next-line:no-empty
    }service.error(attributes,errorSource,errorType);}/**
     * @see {@link instrumentation.d.ts#InstrumentationErrorType}.
     */var InstrumentationErrorType;(function(InstrumentationErrorType){InstrumentationErrorType["INFO"]="info";InstrumentationErrorType["WARN"]="warn";InstrumentationErrorType["ERROR"]="error";})(InstrumentationErrorType||(InstrumentationErrorType={}));/**
     * Makes a unique key by appending current time stamp.
     * @param sharedKey - A non-unique key for conversion to unique key.
     * @returns A unique key.
     */function _getUniquePerfKey(sharedKey){// Aura metrics stores transaction and markers using name as a key. This key is an index to all transactions and marks. Requests to LDS
    // for an operation tracked via performance marker can be interleaved leading to override of existing marker of same name.
    // So, LDS needs to use a unique marker name to keep track of key names.
    // Makes a unique perfkey by using MetricsService time which provides high precision time.
    return sharedKey+"."+service.time();}/**
     * LDS Cache namespace for perf markers
     */const LDS_CACHE_PERF_NAMESPACE="lds_cache";/*
     * debug-extension is a private LDS library for internal use by the LDS team ONLY.
     * DO NOT USE!
     */let logsList=[];let debugEnabled=false;// Variable to store reference to the cache. The event listener uses this.
    let _ldsCacheDebug;/*
     * Function to help troubleshoot LDS cache.
     * Only available in debug mode (not in production since asserts are removed).
     * Listens to event requesting cacheData, and does a postMessage with both the cached records and observable data.
     * @param {object} event Event representing request for cache contents.
     */{window.addEventListener("message",event=>{// We only accept messages from ourselves.
    if(event.origin!==window.origin){return;}// Check same window.
    if(event.source!==window){return;}const sendMessage=function(message){window.postMessage(message,window.origin);};if(event.data.type){if(event.data.type==="GET_CACHE_DATA"){const cacheData=[];_ldsCacheDebug._cacheStore.privateMap.forEach((v,k)=>{cacheData.push({key:k,eTag:v.eTag,value:v.value});});const cacheObservablesData=[];_ldsCacheDebug._observablesMap.forEach((v,k)=>{// JSON parse/stringify to avoid serialization error during window.post later.
    cacheObservablesData.push(JSON.parse(JSON.stringify({key:v.root.name,isComplete:v.root.isComplete,lastError:v.root.lastError,lastValue:v.root.lastValue,subscriptionsSize:v.root.subscriptions?v.root.subscriptions.size:null,observablesMapKey:k})));});// Build lru queue order.
    const lruQueueOrder={};let index1=1;if(_ldsCacheDebug._cacheStore.lruQueue&&_ldsCacheDebug._cacheStore.lruQueue._back){let item1=_ldsCacheDebug._cacheStore.lruQueue._back;while(item1){lruQueueOrder[item1.key]=index1;index1++;item1=item1.previous;}}let dependencies={};Object.entries(_ldsCacheDebug.getOrCreateDependencyMap().dependencies).forEach(([key,value])=>{dependencies[key]=Array.from(value);});let dependenciesReverseLookup={};Object.entries(_ldsCacheDebug.getOrCreateDependencyMap().dependenciesReverseLookup).forEach(([key,value])=>{dependenciesReverseLookup[key]=Array.from(value);});let dependenciesResponse={};dependenciesResponse.dependencies=dependencies;dependenciesResponse.dependenciesReverseLookup=dependenciesReverseLookup;sendMessage({type:"CACHE_CONTENTS",cacheData,cacheObservablesData,lruQueueOrder,dependencies:dependenciesResponse});}else if(event.data.type==="ENABLE_DEBUG_CACHE"){handleDebug("ENABLE_DEBUG");sendMessage({type:"DEBUG_MESSAGE",message:"Enabled Debug"});}else if(event.data.type&&event.data.type==="DISABLE_DEBUG_CACHE"){handleDebug("DISABLE_DEBUG");sendMessage({type:"DEBUG_MESSAGE",message:"Disabled Debug"});}else if(event.data.type&&event.data.type==="CLEAR_LOGS_CACHE"){handleDebug("CLEAR_LOGS");sendMessage({type:"DEBUG_MESSAGE",message:"Cleared Logs"});}else if(event.data.type&&event.data.type==="GET_LOGS_CACHE"){const logs=handleDebug("GET_LOGS");sendMessage({type:"DEBUG_MESSAGE",logs,message:"Responded with logs."});}else if(event.data.type&&event.data.type==="GET_VERSION_APP"){sendMessage({type:"APP_VERSION",message:"Version 2"});}}});}/*
     * Prepares logging info.
     * @param actionKey: Type of log.
     * @param parametersProvider: Function which provides data to be logged. Lazily evaluated only if required.
     * @param parameters
     * @returns boolean true
     */function handleDebug(actionKey,parametersProvider){if(actionKey==="ENABLE_DEBUG"){// Flag to indicate debugging is enabled.
    debugEnabled=true;}else if(actionKey==="DISABLE_DEBUG"){// Flag to indicate debugging is disabled.
    debugEnabled=false;}else if(actionKey==="GET_LOGS"){// Return logs accumulated so far in this session.
    return logsList;}else if(actionKey==="CLEAR_LOGS"){// Clear the logs.
    logsList=[];}else if(debugEnabled){// Based on the type of logs capture different attributes.
    const date=new Date();const response={timestamp:date,timestampMillis:date.getMilliseconds()};// Copy all parameters.
    Object.assign(response,parametersProvider());if(actionKey==="record-service_commitPuts1"){response.label="Begin Commit Puts";}else if(actionKey==="record-service_commitPuts2"){response.label="Done Commit Puts";}else if(actionKey==="record-service_stagePut"){response.label="Stage Put";}else if(actionKey==="complete-and-remove-observables"){response.label="Complete And Remove Observable";}else if(actionKey==="emit-value"){response.label="Emit Value";}else if(actionKey==="created-observable"){response.label="Created Observable";}else if(actionKey==="emit-suppressed"){response.label="Emit Filtered";}else if(actionKey==="stage-emit"){response.label="Stage Emit";}// Add to list of logs.
    logsList.push(JSON.stringify(response));}// Since this is called from within an assert, return true.
    return true;}/*
     * Sets the specific LdsCache instance to debug.
     * @param ldsCache: LdsCache - The particular LdsCache instance to debug.
     * @returns void
     */function setLdsCacheToDebug(ldsCache){_ldsCacheDebug=ldsCache;}/**
     * This Subscription is based on the ES Observable reference implementation under consideration
     * for ES spec inclusion:
     * https://github.com/tc39/proposal-observable/blob/master/src/Observable.js
     * It is not the same code because the reference impl currently doesn't have good ways to
     * emit change notifications and also and doesn't have a good implementation for multiplexing,
     * but it has the exact same interface.
     */class Subscription{/**
         * Constructor.
         * @param observer An observer object that should have the next, error, and complete handlers.
         * @param unsubscriber Function called when the subscription is unsubscribed.
         */constructor(observer,unsubscriber){this._isClosed=false;this.observer=observer;this.unsubscriber=unsubscriber;}/**
         * From the Subscription interface.
         * @returns True if the subscription is closed, else false.
         */get closed(){return this._isClosed;}/**
         * Internal method - do not call.
         * @param value The next value.
         */next(value){this.observer.next(value);}/**
         * Internal method - do not call.
         * @param error An error has occurred - this is the message.
         */error(error){if(this.observer.error){this.observer.error(error);}}/**
         * From the Subscription interface.
         */unsubscribe(){if(!this._isClosed){this.unsubscriber.removeSubscriber();this._isClosed=true;}}}/**
     * This is used to remove the subscriptions from the exiting observable
     */class Unsubscriber{constructor(){/**
             * Set of subscriptions from which the subscription is removed from
             */this.subscriptions=new Set();}/**
         * remove the subscriptions
         */removeSubscriber(){this.subscriptions.delete(this.subscription);}}/**
     * Conceptually an entity capable of observing an observable.
     * It is a collection of handlers that for responding to streaming events from the observable stream.
     */class Observer{/**
         * constructor
         * @param next Method to call when observable emits a value
         * @param error Method to call when observable emits an error
         * @param complete Method to call when observable retires the observer
         */constructor(next,error,complete){this.next=next;this.error=error;this.complete=complete;}}/**
     * Set to track the values which are being refreshed in 304 use case
     */const lastValueTracker=new Set();/**
     * This Observable is based on the ES Observable reference implementation under consideration
     * for ES spec inclusion:
     * https://github.com/tc39/proposal-observable/blob/master/src/Observable.js
     * It is not the same code because the reference impl currently doesn't have good ways to
     * emit change notifications and also and doesn't have a good implementation for multiplexing,
     * but it has the exact same interface.
     */class Observable{/**
         * Constructor.
         * @param name Name of the observable.
         */constructor(name){/**
             * Set of tracked subscriptions
             */this.subscriptions=new Set();/**
             * Tells if the observable is complete or not
             */this.isComplete=false;this.name=name;{handleDebug("created-observable",()=>{return {observableName:name};});}}/**
         * Wraps a call to next() in a try/catch with error logging/gacking to ensure subsequent subscriptions will also have
         * their next() methods called.
         * @param subscription The Observer's subscription.
         * @param newValue new value for an Observable of which Observers need to be notified.
         */_nextWithErrorHandling(subscription,newValue){try{subscription.next(newValue);}catch(e){{// tslint:disable-next-line:no-console
    console.log(JSON.stringify(e));}}}/**
         * Wraps a call to error() in a try/catch with error logging/gacking to ensure subsequent subscriptions will also have
         * their error() methods called.
         * @param subscription An Observer's subscription.
         * @param error Error thrown during execution.
         */_errorWithErrorHandling(subscription,error){try{subscription.error(error);}catch(e){{// tslint:disable-next-line:no-console
    console.log(JSON.stringify(e));}}}/**
         * Wraps a call to complete() in a try/catch with error logging/gacking to ensure subsequent Observers will also have
         * their complete() methods called.
         * @param observer A subscribed Observer.
         */_completeWithErrorHandling(observer){try{if(observer.complete){observer.complete();}}catch(e){{// tslint:disable-next-line:no-console
    console.log(JSON.stringify(e));}}}/**
         * From the Observable interface. Subscribers can pass up to 3 functions: 1) a next() function,
         * 2) an error() function, and 3) a complete() function.
         * @param observer Observer to which you are subscribing OR the next handler.
         * @param error The error handler.
         * @param complete The complete handler.
         * @returns The subscription.
         */subscribe(observer,error,complete){let observerObj;if(typeof observer==="object"){observerObj=observer;}else {observerObj=new Observer(observer,error,complete);}// TODO W-5804079 - complete should return a subscription, subscribe() should never return undefined
    if(this.isComplete){if(observerObj.complete){// Hotness for completion.
    this._completeWithErrorHandling(observerObj);}return undefined;}// don't re-subscribe if observer is already subscribed
    let currentSubscription;this.subscriptions.forEach(subscriptionObj=>{const subscriptionObserver=subscriptionObj.observer;if(subscriptionObserver===observerObj||subscriptionObserver.next===observer){currentSubscription=subscriptionObj;}});if(currentSubscription){return currentSubscription;}const unsubscriber=new Unsubscriber();const subscription=new Subscription(observerObj,unsubscriber);unsubscriber.subscriptions=this.subscriptions;unsubscriber.subscription=subscription;this.subscriptions.add(subscription);{observerObj.name="Observer: "+this.name;subscription.name="Subscription for Observer: "+observerObj.name;}// Be a BehaviorSubject (emit lastValue upon subscribe.)
    if(this.lastValue!==undefined){this._nextWithErrorHandling(subscription,this.lastValue);}else if(this.lastError!==undefined){this._errorWithErrorHandling(subscription,this.lastError);}return subscription;}/**
         * Internal method - do not call.
         * Emits a value on the observable.
         * @param newValue a new value to emit to all this Observable's Observers.
         */emitValue(newValue){// Runtime error checking.
    if(this.isComplete){throw new Error(`Cannot emit a value to a completed observable. Observable name: ${this.name}, newValue: ${newValue}`);}if(this.lastError){throw new Error(`Cannot emit a value to a observable in error state. Observable name: ${this.name}, newValue: ${newValue}`);}if(newValue===undefined){throw new Error(`newValue cannot be undefined. Observable name: ${this.name}, newValue: ${newValue}`);}// TODO: root observable will not call emitValue if value to written in cache is same as existing one,
    // move this filtering to child observable with changes for records. W-4045855
    this.lastValue=newValue;this.lastError=undefined;{handleDebug("emit-value",()=>{return {observableName:this.name,emitValue:newValue};});}if(this.subscriptions.size>0){this.subscriptions.forEach(subscription=>{this._nextWithErrorHandling(subscription,newValue);});}}/**
         * Internal method - do not call.
         * Emits an error on the observable.
         * @param error The value to emit to all this Observable's Observers.
         */emitError(error){// Runtime error checking.
    // TODO - only do this if going to throw an error
    const errorStr=typeUtils.isString(error)?error:JSON.stringify(error);if(this.isComplete){throw new Error(`Cannot emit an error on a completed observable. Observable name: ${this.name}, error: ${errorStr}`);}if(this.lastError){instrumentError(error,"LDS_OBSERVABLE_IN_ERROR_STATE",InstrumentationErrorType.ERROR,`Observable Name: ${this.name}`);}if(error===undefined){throw new Error(`error cannot be undefined. Observable name: ${this.name}, error: ${error}`);}this.lastValue=undefined;this.lastError=error;this.subscriptions.forEach(subscription=>{if(this._errorWithErrorHandling){this._errorWithErrorHandling(subscription,error);}else {{// tslint:disable-next-line:no-console
    console.log(`_errorWithErrorHandling undefined during Observable emitError! Observable name: ${this.name}, err= ${JSON.stringify(error)} +  -- err.message=${error.message}`);}}});}/**
         * From the Observable interface.
         * Completes the observable. Nothing else can ever be emitted.
         */complete(){try{this.subscriptions.forEach(subscription=>{const subscriptionObserver=subscription.observer;if(subscriptionObserver.complete){this._completeWithErrorHandling(subscriptionObserver);}if(!subscription.closed){// If the observer didn't unsubscribe during complete(), do it for them to prevent a memory leak.
    subscription.unsubscribe();}});}finally{this.subscriptions.clear();this.lastValue=undefined;this.lastError=undefined;this.isComplete=true;}}/**
         * Stream operator. Transforms items from the caller stream using the specified mapFn.
         * @param mapFn Function which takes a value and returns a new value.
         * @returns A new observable which emits transformed values.
         */map(mapFn){const name=this._constructChainName("Map");const transformedObservable=new Observable(name);this._wireTransformedObservableWithOperation(transformedObservable,value=>{const mappedValue=mapFn(value);transformedObservable.emitValue(mappedValue);});return transformedObservable;}/**
         * Stream operator. Filters items emitted by the source Observable by only emitting an item when it is distinct from the previous item.
         * @param compareFn Function which should return true the previous and new are determined to be different.
         * @returns A new observable which only emits an item when it is distinct from the previous item.
         */distinctUntilChanged(compareFn){const name=this._constructChainName("DistinctUntilChanged");const transformedObservable=new Observable(name);this._wireTransformedObservableWithOperation(transformedObservable,value=>{// TODO: W-5698880 This is not a generic operator anymore because it is using the global lastValueTracker. This needs to be refactored
    // into a custom operator or this operator's name needs to be changed.
    if(compareFn(transformedObservable.lastValue,value)&&!lastValueTracker.has(transformedObservable.lastValue)&&transformedObservable.lastValue!==undefined){this._debugLogEmitSuppressed(value);}else {// The value is different than the last value, so emit or its 304 with new observer
    transformedObservable.emitValue(value);lastValueTracker.delete(transformedObservable.lastValue);}});return transformedObservable;}/**
         * Stream operator. Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.
         * @param predicateFn Function which should return true if the value passes the filter, else false.
         * @returns A new observable which only emits items that satisfy a specified predicate.
         */filter(predicateFn){const name=this._constructChainName("Filter");const transformedObservable=new Observable(name);this._wireTransformedObservableWithOperation(transformedObservable,value=>{if(predicateFn(value)){// The value passed the filter so we need to emit!
    transformedObservable.emitValue(value);}else {this._debugLogEmitSuppressed(value);}});return transformedObservable;}/**
         * Stream operator. Skips a given number of emits and then always emits.
         * @param count How many emits to skip before passing through all emits.
         * @returns A new observable which emits all values after the given number of emits has taken place.
         */skip(count){const name=this._constructChainName("Skip");const transformedObservable=new Observable(name);let emitsSoFar=0;this._wireTransformedObservableWithOperation(transformedObservable,value=>{emitsSoFar+=1;if(emitsSoFar>count){transformedObservable.emitValue(value);}else {this._debugLogEmitSuppressed(value);}});return transformedObservable;}/**
         * Stream operator. Discard items emitted by an Observable until a specified condition becomes false.
         * @param predicateFn Predicate function which governs the skipping process. skipUntil calls this
         *      function for each item emitted by the source Observable until the function returns false,
         *      whereupon skipUntil begins mirroring the source Observable (starting with that item).
         * @returns A new observable which exhibits the behavior described above.
         */skipUntil(predicateFn){const name=this._constructChainName("SkipUntil");const transformedObservable=new Observable(name);let isSkipping=true;this._wireTransformedObservableWithOperation(transformedObservable,value=>{if(isSkipping){isSkipping=predicateFn(value);}if(!isSkipping){transformedObservable.emitValue(value);}else {this._debugLogEmitSuppressed(value);}});return transformedObservable;}/**
         * Stream operator. Discard item emitted by an Observable if the condition is met.
         * @param predicateFn Predicate function which governs the skipping process. skipIf calls this
         *      function for each item emitted by the source Observable. If the condition is not met, the emit is not skipped,
         *      whereupon skipIf begins mirroring the source Observable (starting with that item).
         * @returns A new observable which exhibits the behavior described above.
         */skipIf(predicateFn){const name=this._constructChainName("SkipIf");const transformedObservable=new Observable(name);this._wireTransformedObservableWithOperation(transformedObservable,value=>{if(!predicateFn(value)){transformedObservable.emitValue(value);}else {this._debugLogEmitSuppressed(value);}});return transformedObservable;}/**
         * Stream operator. Discard the first emitted item by an Observable. Generally, this skips the last-value, which is emitted upon subscribe.
         * @returns A new observable which exhibits the behavior described above.
         */skipOnce(){const name=this._constructChainName("SkipOnce");const transformedObservable=new Observable(name);let hasSkipped=false;this._wireTransformedObservableWithOperation(transformedObservable,value=>{if(hasSkipped){transformedObservable.emitValue(value);}else {// Skip once, then set to true, and never skip again
    hasSkipped=true;this._debugLogEmitSuppressed(value);}});return transformedObservable;}/**
         * Stream operator. Transforms items from the caller stream using the specified mapFn. Differs from
         *      map in that the newly created observable is actually a FilterOnSubscribeBehaviorSubject.
         * @param filterOnSubscribeFn Filter function which gets passed to behavior subject instance.
         * @param mapFn Function which takes a value and returns a new value.
         * @returns A new FilterOnSubscribeBehaviorSubject which emits transformed values.
         */mapWithFilterOnSubscribeBehaviorSubject(filterOnSubscribeFn,mapFn){const name=this._constructChainName("MapWithFilterOnSubscribeBehaviorSubject");const transformedObservable=new FilterOnSubscribeBehaviorSubject(name,filterOnSubscribeFn);this._wireTransformedObservableWithOperation(transformedObservable,value=>{transformedObservable.lastValuePreTransformed=value;const mappedValue=mapFn(value);transformedObservable.emitValue(mappedValue);});return transformedObservable;}/**
         * Wires up the given transformedObservable with the given operationFn. Standardizes the error handling
         * and complete handling.
         * @param transformedObservable The new observable which represents another link in the observable chain by performing the given operationFn.
         * @param operationFn The operation to perform for this link in the observable chain.
         */_wireTransformedObservableWithOperation(transformedObservable,operationFn){const observerTransform=new Observer(value=>{if(transformedObservable.lastError===undefined&&!transformedObservable.isComplete){try{transformedObservable.lastValuePreTransformed=value;operationFn(value);}catch(error){this._throwIfJavascriptCoreError(error);transformedObservable.emitError(error);}}},error=>{if(transformedObservable.lastError===undefined&&!transformedObservable.isComplete){transformedObservable.emitError(error);}},()=>{if(transformedObservable.lastError===undefined&&!transformedObservable.isComplete){transformedObservable.complete();}});this._decorateTransformedObservableWithSubscriptionOptimizationLogic(transformedObservable,observerTransform);}/**
         * Throws the given err if it is a javascript core error.
         * @param err
         */_throwIfJavascriptCoreError(err){if(typeUtils.isInstanceOf(err,ReferenceError)||typeUtils.isInstanceOf(err,TypeError)||typeUtils.isInstanceOf(err,RangeError)||typeUtils.isInstanceOf(err,EvalError)||typeUtils.isInstanceOf(err,SyntaxError)||typeUtils.isInstanceOf(err,URIError)){throw err;}}/**
         * Decorate the subscribe method on the transformed observable to take care of the following:
         * 1. If the transformed observable is not connected to the source observable, then connect it.
         * 2. Return a Subscription<T> instance with a decorated unsubscribe method. This method will disconnect
         *      from the source observable if there are no subscriptions left on the transformed observable.
         * @param transformedObservable The instance of the transformed observable to decorate. It will be modified in place.
         * @param observerTransform  The observer to use in the subscription to the source observable. It contains the transform logic.
         */_decorateTransformedObservableWithSubscriptionOptimizationLogic(transformedObservable,observerTransform){transformedObservable.sourceObservable=this;const originalSubscribeFn=transformedObservable.subscribe;transformedObservable.subscribe=(observer,error,complete)=>{// If not connected to the source yet, then connect.
    if(!transformedObservable.sourceSubscription){transformedObservable.sourceSubscription=transformedObservable.sourceObservable.subscribe(observerTransform,error,complete);}// Call the original subscribe method to get the subscription.
    const originalSubscription=originalSubscribeFn.call(transformedObservable,observer,error,complete);// Decorate the Subscription<T> instance with a new unsubscribe method.
    if(originalSubscription){const originalUnsubscribeFn=originalSubscription.unsubscribe;originalSubscription.unsubscribe=()=>{originalUnsubscribeFn.call(originalSubscription);// Disconnect from the source if there are no other subscriptions on the transformed observable.
    if(transformedObservable.subscriptions.size<=0){transformedObservable.sourceSubscription.unsubscribe();transformedObservable.sourceSubscription=undefined;}};}else {throw new Error("Observer subscription was undefined when constructing filtered record observable. Transformed Observable Name = "+transformedObservable.name);}return originalSubscription;};}/**
         * Constructs the name of the observable by adding the given linkName onto the rest of the chain's name.
         * @param linkName The name of the link in the observable chain.
         * @returns The full chain name for the observable.
         */_constructChainName(linkName){return linkName.trim()+" <= "+this.name;}/**
         * Log an entry that an emit was filtered out.
         * @param value Object that was filtered out.
         */_debugLogEmitSuppressed(value){{handleDebug("emit-suppressed",()=>{return {observableName:this.name,emitValue:value};});}}}/**
     * Created a Behavior subject Observable to handle stale emits
     */class FilterOnSubscribeBehaviorSubject extends Observable{constructor(name,filterOnSubscribeFunction){super(name);this._filterOnSubscribeFunction=filterOnSubscribeFunction;}/**
         * From the Observable interface. Subscribers can pass up to 3 functions: 1) a next() function,
         * 2) an error() function, and 3) a complete() function.
         * @param observer Observer to which you are subscribing OR the next handler.
         * @param error The error handler.
         * @param complete The complete handler.
         * @returns The subscription.
         */subscribe(observer,error,complete){// Do all the same subscribe stuff as in Observable up until the emit logic.
    let observerObj;if(typeof observer==="object"){observerObj=observer;}else {observerObj=new Observer(observer,error,complete);}if(this.isComplete){if(observerObj.complete){// Hotness for completion.
    this._completeWithErrorHandling(observerObj);}return undefined;}// don't re-subscribe if observer is already subscribed
    let currentSubscription;this.subscriptions.forEach(subscriptionObj=>{const subscriptionObserver=subscriptionObj.observer;if(subscriptionObserver===observerObj||subscriptionObserver.next===observer){currentSubscription=subscriptionObj;}});if(currentSubscription){return currentSubscription;}const unsubscriber=new Unsubscriber();const subscription=new Subscription(observerObj,unsubscriber);unsubscriber.subscriptions=this.subscriptions;unsubscriber.subscription=subscription;this.subscriptions.add(subscription);{observerObj.name="Observer (FilterOnSubscribeBehaviorSubject): "+this.name;subscription.name="Subscription for Observer (FilterOnSubscribeBehaviorSubject): "+observerObj.name;}// Be a BehaviorSubject (emit lastValue upon subscribe.)
    if(this.lastValue!==undefined&&this._filterOnSubscribeFunction(this.lastValuePreTransformed||this.lastValue)){this._nextWithErrorHandling(subscription,this.lastValue);}else if(this.lastError!==undefined){this._errorWithErrorHandling(subscription,this.lastError);}return subscription;}}/**
     * @param condition Assert condition
     * @param assertMessage Message to include with error if assertion fails
     * @throws Error with assertMessage if assertion condition is false.
     */function assert$2(condition,assertMessage){if(!condition){throw new Error("Assertion Failed!: "+assertMessage+" : "+condition);}}/**
     * Utility functions used in the LDS layer.
     */ /**
     * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
     * @param recordId A 15- or 18-char record id.
     * @returns An 18-char record id, and throws error if an invalid record id was provided.
     */function to18(recordId){{assert$2(recordId.length===15||recordId.length===18,`Id ${recordId} must be 15 or 18 characters.`);}if(recordId.length===15){// Add the 3 character suffix
    const CASE_DECODE_STRING="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456";for(let offset=0;offset<15;offset+=5){let decodeValue=0;for(let bit=0;bit<5;bit++){const c=recordId[offset+bit];if(c>="A"&&c<="Z"){// tslint:disable-next-line:no-bitwise
    decodeValue+=1<<bit;}}recordId+=CASE_DECODE_STRING[decodeValue];}}return recordId;}/**
     * Returns true if the given lastFetchTime is within the given ttl based on the given nowTime.
     * @param nowTime The now time.
     * @param lastFetchTime The time that the thing was last fetched.
     * @param ttl The time to live.
     * @returns See description.
     */function isWithinTtl(nowTime,lastFetchTime,ttl){if(nowTime-lastFetchTime<ttl){return true;}return false;}/**
     * Determines if the specified value is the CacheWrapper. This gets automatically added around
     * values that are cached using the CacheAccessor.
     * @param value the object to check if wrapped.
     * @returns True if the value is the wrapper or false if undefined or not a wrapper.
     */function isCacheWrapper(value){return value&&value.hasOwnProperty("lastFetchTime")&&value.hasOwnProperty("value");}/**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */function getObjectApiName(value){if(typeof value==="string"){return value;}else if(value&&typeof value.objectApiName==="string"){return value.objectApiName;}throw new TypeError("Value is not a string, ObjectId, or FieldId.");}/**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @return The qualified field API name.
     */function getFieldApiName(value){if(typeof value==="string"){return value;}else if(value&&typeof value.objectApiName==="string"&&typeof value.fieldApiName==="string"){return value.objectApiName+"."+value.fieldApiName;}throw new TypeError("Value is not a string or FieldId.");}/**
     * Split the object API name and field API name from a qualified field name.
     * Eg: Opportunity.Title returns ['Opportunity', 'Title']
     * Eg: Opportunity.Account.Name returns ['Opportunity', 'Account.Name']
     * @param fieldApiName The qualified field name.
     * @return The object and field API names.
     */function splitQualifiedFieldApiName(fieldApiName){const idx=fieldApiName.indexOf(".");if(idx<1){// object api name must non-empty
    throw new TypeError("Value does not include an object API name.");}return [fieldApiName.substring(0,idx),fieldApiName.substring(idx+1)];}/**
     * Checks the type of the value and throws an error if it is incorrect.
     * @param value The value to check.
     * @param type The type of the Object. For instance, 5 has the type Number.
     * @throws If value is not of the expected type Or if value is null/undefined.
     */function checkType(value,type){if(value==null){throw new TypeError("Unexpected null or undefined value.");}if(type===Array&&!Array.isArray(value)||type===Object&&!typeUtils.isPlainObject(value)||type===Function&&!typeUtils.isFunction(value)||!type.prototype.isPrototypeOf(Object(value))&&type!==Array){throw new TypeError("Value does not have expected type: "+type.name+", got: "+value+".");}}/**
     * Results the default function for doing recursive equality call,
     * The default function just checks content of inner objects.
     * @param value1 First value to compare.
     * @param value2 Second value to compare.
     * @param depth Current depth of the recursion.
     * @returns True if the objects are equivalent, False otherwise.
     */function _defaultRecurseFunction(value1,value2,depth){{assert$2(depth>=1,"depth should never drop below 1");}const json1=JSON.stringify(value1);const json2=JSON.stringify(value2);// Previously we were using the recurse function to actually deeply compare objects up to a specified
    // depth of recursion. However this was very slow in IE 11. For now we are abandoning this as the default
    // check in favor of a JSON string comparison which performs better in IE 11 due to fewer function calls
    // and less recursion. See P4 history if retrieving the old way is necessary.
    //
    // IE 11 performance workaround until we have a better strategy (using eTags, cacheVersions, etc.);
    return json1===json2;}/**
     * Check if the two values provided are equal.
     * @param value1 The first value to be checked.
     * @param value2 The second value to be checked.
     * @param recurseFn Function that will be called on members of array or object to check equality. Defaults to _defaultRecurseFunction.
     * @param depth The max recursion depth of the object to check. Defaults to 10.
     * @return Boolean whether the objects are equal.
     */function equivalent(value1,value2,recurseFn,depth){recurseFn=recurseFn!==undefined?recurseFn:_defaultRecurseFunction;depth=depth!==undefined&&depth>0?depth:10;const value1IsValueWrapper=isCacheWrapper(value1);const value2IsValueWrapper=isCacheWrapper(value2);let targetValue1=value1;let targetValue2=value2;if(value1IsValueWrapper){targetValue1=value1.value;}if(value2IsValueWrapper){targetValue2=value2.value;}if(targetValue1===targetValue2){return true;}else if(value1IsValueWrapper&&value2IsValueWrapper){// Try checking eTags.
    const value1ETag=value1.eTag;const value2ETag=value2.eTag;if(value1ETag!==null&&value1ETag!==undefined&&value2ETag!==null&&value2ETag!==undefined){return value1ETag===value2ETag;}}if(typeof targetValue1==="object"&&recurseFn){// Plain object, do default comparison for object values.
    return recurseFn(targetValue1,targetValue2,depth);}return false;}/**
     * Returns an array of values constructed from the given collection.
     * @param collection The collection to be converted into an array.
     * @returns See description.
     */function collectionToArray(collection){const arrayFromCollection=[];const collectionArray=Array.from(collection);for(let len=collectionArray.length,n=0;n<len;n++){arrayFromCollection.push(collectionArray[n]);}return arrayFromCollection;}/**
     * Subscribes to the given observable and returns a promise that resolves when the observable emits or completes, and rejects when the observable errors.
     * @param observable The observable to convert into a promise.
     * @param unsubscribeWhenValueReceived True if the promise should unsubscribe from the observable when a value is received in any
     * of the observer callbacks, or false to not unsubscribe.
     * @param resolveNextCount The numbers of emits on the observable required in order to resolve.
     * @returns See description.
     */function observableToPromise(observable,unsubscribeWhenValueReceived,resolveNextCount){resolveNextCount=resolveNextCount!==undefined?resolveNextCount:1;{assert$2(resolveNextCount>0,"resolveNextCount must be greater than 0");}unsubscribeWhenValueReceived=unsubscribeWhenValueReceived!==undefined?unsubscribeWhenValueReceived:false;return new Promise((resolve,reject)=>{let isDone=false;let subscription;let nextCounter=0;const observer=new Observer(value=>{nextCounter+=1;if(resolveNextCount&&nextCounter>=resolveNextCount){// subscription is null when the next handler is called synchronously from the observable.subscribe invocation.
    if(unsubscribeWhenValueReceived&&subscription){subscription.unsubscribe();}isDone=true;resolve(value);}},err=>{// subscription is null when the error handler is called synchronously from the observable.subscribe invocation.
    if(unsubscribeWhenValueReceived&&subscription){subscription.unsubscribe();}isDone=true;reject(err);},()=>{// subscription is null when the complete handler is called synchronously from the observable.subscribe invocation.
    if(unsubscribeWhenValueReceived&&subscription){subscription.unsubscribe();}isDone=true;resolve();});subscription=observable.subscribe(observer);// The following is true when the observable.subscribe invocation above synchronously invokes one of the handlers on the observer.
    // In that case the handler would not have been able to unsubscribe because subscription wouldn't have been defined yet, which
    // means we need to unsubscribe here.
    if(unsubscribeWhenValueReceived&&isDone&&subscription){subscription.unsubscribe();}});}/**
     * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
     * This is needed because insertion order for JSON.stringify(object) affects output:
     * JSON.stringify({a: 1, b: 2})
     *      "{"a":1,"b":2}"
     * JSON.stringify({b: 2, a: 1})
     *      "{"b":2,"a":1}"
     * @param data Data to be JSON-stringified.
     * @returns JSON.stringified value with consistent ordering of keys.
     */function stableJSONStringify(node){// This is for Date values.
    if(node&&node.toJSON&&typeof node.toJSON==="function"){node=node.toJSON();}if(node===undefined){return;}if(typeof node==="number"){return isFinite(node)?""+node:"null";}if(typeof node!=="object"){return JSON.stringify(node);}let i;let out;if(Array.isArray(node)){out="[";for(i=0;i<node.length;i++){if(i){out+=",";}out+=stableJSONStringify(node[i])||"null";}return out+"]";}if(node===null){return "null";}const keys=Object.keys(node).sort();out="";for(i=0;i<keys.length;i++){const key=keys[i];const value=stableJSONStringify(node[key]);if(!value){continue;}if(out){out+=",";}out+=JSON.stringify(key)+":"+value;}return "{"+out+"}";}/**
     * Creates a clone of the object by recursively traversing it.
     * @param objectToClone Object.
     * @returns Cloned object. See description.
     */function cloneDeepCopy(objectToClone){let response=objectToClone;if(objectToClone!==null){if(Array.isArray(objectToClone)){// We want to retain type as Array in the cloned object.
    response=[];for(let len=objectToClone.length,i=0;i<len;i++){response[i]=cloneDeepCopy(objectToClone[i]);}}else if(typeof objectToClone==="object"){response={};const objectToCloneKeys=Object.keys(objectToClone);for(let len=objectToCloneKeys.length,n=0;n<len;n++){const objectToCloneKeysEntry=objectToCloneKeys[n];const objectToCloneEntry=objectToClone[objectToCloneKeysEntry];if(objectToCloneEntry!==undefined){response[objectToCloneKeysEntry]=cloneDeepCopy(objectToCloneEntry);}}}}return response;}/**
     * Deep clones the given valueWrapper (excluding the value property) but uses valueOverride for its value.
     * @param valueWrapper The ValueWrapper instance to copy.
     * @param valueOverride The value to assign to the copied ValueWrapper. Must not be undefined.
     * @param extraInfoObjectOverride Override value for extraInfoObject.
     * @returns The deep cloned ValueWrapper with its value as valueOverride.
     */function cloneWithValueOverride(valueWrapper,valueOverride,extraInfoObjectOverride){return {value:valueOverride,lastFetchTime:valueWrapper.lastFetchTime,eTag:valueWrapper.eTag,extraInfoObject:extraInfoObjectOverride||cloneDeepCopy(valueWrapper.extraInfoObject)};}/**
     * Determines if the given value fulfills the ValueWrapper interface.
     * @param value The value in question.
     * @returns True if the given value fulfills the ValueWrapper interface, else false.
     */function isValueWrapper(value){if(value&&typeof value==="object"&&value.value&&value.lastFetchTime){return true;}return false;}/**
     * A standard delimiter when producing cache keys.
     */const KEY_DELIM=":";/**
     * The valueType to use when building LdsCacheDependenciesCacheKey
     */const LDS_CACHE_DEPENDENCIES_VALUE_TYPE="lds.LdsCacheDependencies";/**
     * Returns the complete string representation of the cache key.
     * @param cacheKey The key we want the string representation for.
     * @returns See description.
     */function serialize(cacheKey){return `${cacheKey.type}${KEY_DELIM}${cacheKey.key}`;}/**
     * Takes a string representation of a cache key and converts it back into a CacheKey object.
     * @param cacheKey The string representation of a cache key.
     * @returns The CacheKey object representation of the cache key string.
     */function deserialize(cacheKey){const firstDelimIndex=cacheKey.indexOf(KEY_DELIM);const key=cacheKey.substr(firstDelimIndex+1);const type=cacheKey.substr(0,firstDelimIndex);{assert$2(type&&type.length>0,`No key found for type ${cacheKey}`);assert$2(key&&key.length>0,`No key existed for ${cacheKey}`);}return {key,type};}/**
     * Check whether this set contains all specified values.
     * @param sourceSet The source set with which to operate.
     * @param targetValues A collection of target values to check to see if they are all contained in the given sourceSet.
     * @returns True if the given sourceSet contains all the given targetValues, else false.
     */function containsAll(sourceSet,targetValues){let doesContainsAll=true;targetValues.forEach(value=>{if(!doesContainsAll){return;}if(!sourceSet.has(value)){doesContainsAll=false;}});return doesContainsAll;}/**
     * Add all the given targetValues to the given sourceSet.
     * @param sourceSet The source set with which to operate.
     * @param targetValues A collection of target values with which to add to the given sourceSet.
     * @returns The sourceSet for chaining calls, like with add().
     */function addAll(sourceSet,targetValues){targetValues.forEach(value=>{sourceSet.add(value);});return sourceSet;}/**
     * Return a new Set that contains all the values of this set combined with the values from the other set.
     * @param sourceSet The source set with which to operate.
     * @param targetValues A collection of target values with which to union to the given sourceSet.
     * @returns A new set of the values that are in both the given sourceSet and the given targetValues.
     */function union(sourceSet,targetValues){const unionSet=new Set(sourceSet);targetValues.forEach(value=>{unionSet.add(value);});return unionSet;}/**
     * Calculates the set of values consisting of values in the given sourceSet that aren't also in the given targetValues.
     * @param sourceSet The source set with which to operate.
     * @param targetValues A collection of target values with which to difference the given sourceSet.
     * @returns A new set consisting of the values in the given sourceSet that aren't also in the given targetValues.
     */function difference(sourceSet,targetValues){const differenceSet=new Set(sourceSet);targetValues.forEach(value=>{differenceSet.delete(value);});return differenceSet;}/**
     * Used to directly access underlying the cache store(s) using during a single cache transaction.
     */class CacheAccessor{/**
         * Constructs a new CacheAccessor.
         * @param ldsCache The LdsCache parent (scope) for this CacheAccessor.
         * @param timeSource The TimeSource for this CacheAccessor.
         */constructor(ldsCache,timeSource){/**
             * Used to track dependencies added by CacheAccessor operations and saved during commitPuts().
             */this._stagedDependencies=Object.create(null);/**
             * An Object holding the key strings of the values that will be put on the Object's key-side, and on the value-side
             * an Object holding the CacheKey, value Object to cache, and value Object to Emit.
             */this._stagedPutsMap=new Map();/**
             * Contains the string representations of cache keys to clear out of the dependency mapping during commitPuts().
             */this._dependencyKeyStringsToClear=new Set();/**
             * Used to track the Observable emits that will be emitted during finish(). The entries are key: CacheKey,
             * value valueToEmit: ValueWrapper
             */this._stagedEmitsMap=new Map();/**
             * Used to cache the cache key strings that have emits staged.
             */this._stagedEmitsKeyStringsSet=new Set();this._ldsCache=ldsCache;this._nowTime=timeSource.now();this._phase=1/* CACHE_ACCESSOR_PHASE_STAGING_PUTS */;{// Used for debugging. Only available in debug mode.
    setLdsCacheToDebug(ldsCache);}}/**
         * Returns the number representing the time snapshot that will be used by this CacheAccessor's transaction. All cache
         * operations in this transaction will share the same timestamp.
         */get nowTime(){{assert$2(this._phase!==2/* CACHE_ACCESSOR_PHASE_FINISHED */,"Cache accessors should not be accessed after they have been finished.");}return this._nowTime;}/**
         * Gets the cached value wrapper using the provided cache key. This will return staged values ahead of values actually in the underlying
         * cache so that cache operations see a consistent view of values that have been manipulated during the operation.
         * @param cacheKey The cache key for the value you want to fetch.
         * @returns The value wrapper if there is a cache hit, otherwise returns undefined.
         */get(cacheKey){const{_phase,_stagedPutsMap,_ldsCache}=this;{assert$2(_phase!==2/* CACHE_ACCESSOR_PHASE_FINISHED */,"Cache accessors should not be accessed after they have been finished.");}const keyString=serialize(cacheKey);const stagedPutItem=_stagedPutsMap.get(keyString);if(stagedPutItem!==undefined){// Staged values should take precedence over values in the cache.
    const stagedValueToCache=stagedPutItem.valueToCache;return stagedValueToCache;}return _ldsCache.getValue(cacheKey);}/**
         * If a value was committed to cache, this will synchronously return it. This must be called after commitPuts() has been called. This is useful
         * for comparing old and new values when handling affected keys to see exactly how they should be handled.
         * @param cacheKey The cache key for the committed cache value you want to fetch - required.
         * @returns Returns the value wrapper if available and part of the cache commit operation, otherwise returns undefined.
         */getCommitted(cacheKey){{assert$2(this._phase!==2/* CACHE_ACCESSOR_PHASE_FINISHED */,"Cache accessors should not be accessed after they have been finished.");}const keyString=serialize(cacheKey);const stagedPutItem=this._stagedPutsMap.get(keyString);if(stagedPutItem){return stagedPutItem.valueToCache;}return undefined;}/**
         * Stages a put to cache and also stages an Observable emit. If the valueToCache is not a ValueWrapper, it will be wrapped on behalf of
         * the caller. One or more dependentCacheKeys should be provided if possible to track dependencies, or [] if putting a root value.
         * @param dependencies An array of zero or more cache keys that depend on the key/value being staged. These are used
         *        by the cache to track dependencies for consumers and let them know what they have affected in the return value of commitPuts().
         * @param cacheKey The cache key for the value you want to put.
         * @param valueToCache The cache value to put. If it is not a ValueWrapper, it will automatically be wrapped.
         * @param valueToEmit The cache value to emit via Observable. Must not be an instance of ValueWrapper since it will automatically be wrapped in an equivalent ValueWrapper as valueToCache.
         * @param valueWrapperOptionalProperties Optional object with properties to set on the ValueWrapper. If valueToCache is a ValueWrapper these will be ignored.
         * @param valueWrapperToEmitExtraInfoObject Optional object with properties to set on the emitted ValueWrapper.extraInfoObject.
         */stagePut(dependencies,cacheKey,valueToCache,valueToEmit,valueWrapperOptionalProperties,valueWrapperToEmitExtraInfoObject){{assert$2(this._phase===1/* CACHE_ACCESSOR_PHASE_STAGING_PUTS */,"Puts can only be staged before commitPuts()");}// Default values.
    valueWrapperOptionalProperties=valueWrapperOptionalProperties?valueWrapperOptionalProperties:{};const keyString=serialize(cacheKey);let valueWrapperToCache;if(isValueWrapper(valueToCache)){valueWrapperToCache=valueToCache;}else {valueWrapperToCache=this.newValueWrapper(valueToCache,valueWrapperOptionalProperties.eTag,valueWrapperOptionalProperties.extraInfoObject);}const valueWrapperToEmit=cloneWithValueOverride(valueWrapperToCache,valueToEmit,valueWrapperToEmitExtraInfoObject);{handleDebug("record-service_stagePut",()=>{return {dependencies:dependencies.map(dependency=>({cacheKeyString:serialize(dependency.cacheKey),type:dependency.type})),cacheKey:keyString,valueToCache:valueWrapperToCache,valueToEmit:valueWrapperToEmit};});}const stagedPutItem={cacheKey,valueToCache:valueWrapperToCache,valueToEmit:valueWrapperToEmit,triggerAffectedKeys:true};this._stagedPutsMap.set(keyString,stagedPutItem);if(dependencies.length>0){this.stageDependencies(dependencies,cacheKey);}}/**
         * Stages a put which updates the lastFetchTime of the valueWrapper of the given cacheKey. This will stage an emit
         * for the cache value but will not trigger affected keys for it. We don't want affected keys triggered because
         * lastFetchTime is cache internal metadata that affected key handlers would not care about. Affected key handlers should only
         * get triggered if the actual value has changed.
         * @param cacheKey The cache key for the value you want to put.
         * @returns True if the lastFetchTime was updated on the valueWrapper for the given cacheKey, else false.
         */stagePutUpdateLastFetchTime(cacheKey){{assert$2(this._phase===1/* CACHE_ACCESSOR_PHASE_STAGING_PUTS */,"Update last fetch time can only be staged before commitPuts()");}const keyString=serialize(cacheKey);const existingValueWrapper=this.get(cacheKey);if(existingValueWrapper){const valueWrapperToCache=this.newValueWrapper(existingValueWrapper.value,existingValueWrapper.eTag,existingValueWrapper.extraInfoObject);{handleDebug("stageUpdateLastFetchTime",()=>{return {cacheKey:keyString};});}const stagedPutItem={cacheKey,valueToCache:valueWrapperToCache,valueToEmit:valueWrapperToCache,triggerAffectedKeys:false};this._stagedPutsMap.set(keyString,stagedPutItem);return true;}else {return false;}}/**
         * Used in cases where a dependencies should be tracked, but puts cannot be staged using stagePut() because the values that would be put are
         * known to be insufficient for other affected objects that will need to be denormed/emitted in response. In these cases we need to know about
         * the dependency so that a full refresh of that insufficient value can trigger everything to get caught up. Example: merging record values
         * where we don't have enough fields but we can tell the value has changed, therefore we must refresh the entire record with all tracked
         * fields. One or more dependentCacheKeys should be provided.
         * @param dependencies An array of zero or more Dependency objects that describe other cache keys that depend on the key/value being staged. These are used
         *        by the cache to track dependencies for consumers and let them know what they have affected in the return value of commitPuts().
         * @param cacheKey The cache key for the value on which the dependent cache keys depend.
         */stageDependencies(dependencies,cacheKey){const keyString=serialize(cacheKey);const{_stagedDependencies}=this;let dependenciesEntry=_stagedDependencies[keyString];if(dependenciesEntry===undefined){dependenciesEntry=new Map();_stagedDependencies[keyString]=dependenciesEntry;}for(let len=dependencies.length,c=0;c<len;c++){const dependencyCopy=Object.assign(Object.create(null),dependencies[c]);dependenciesEntry.set(serialize(dependencyCopy.cacheKey),dependencyCopy);}}/**
         * Clears the direct dependencies of this cache key. Should only be called when a comprehensive replacement is taking place (i.e. not a
         * merged value that may be missing as complete a view as what existed prior). If not, valid dependencies could be lost.
         * @param cacheKey The cache key for the dependencies you want to clear.
         */stageClearDependencies(cacheKey){{assert$2(this._phase===1/* CACHE_ACCESSOR_PHASE_STAGING_PUTS */,"Dependencies can only be cleared while staging puts, before commitPuts() and before finished().");}const keyString=serialize(cacheKey);this._dependencyKeyStringsToClear.add(keyString);}/**
         * Commits all staged puts to underlying cache stores. This should be called after making all necessary stagePut() calls because afterwards
         * stagePut() will fail.
         * @return The set of cache keys affected by committed puts. If the set contains values
         *      the appropriate response is to perform denorm (if applicable) of any affected values and either A) stage further emits for the
         *      affected keys/values if possible with what's in cache (the cache hit case) or B) refresh them using the appropriate API call
         *      (the cache miss case).
         */commitPuts(){{assert$2(this._phase===1/* CACHE_ACCESSOR_PHASE_STAGING_PUTS */,"Puts can only be committed once, and must be committed before calling stageEmit().");}this._phase=3/* CACHE_ACCESSOR_PHASE_PUTS_COMMITTED */;// Need a Map<CacheKey, Object> to call putAll();
    const cacheKeyToValueMap=new Map();const{_stagedPutsMap}=this;{handleDebug("record-service_commitPuts1",()=>{return {_stagedPutsMap};});}const stagedPutItems=Array.from(_stagedPutsMap.values());const{_stagedDependencies,_ldsCache}=this;for(let len=stagedPutItems.length,n=0;n<len;n++){const stagedPutItem=stagedPutItems[n];const{cacheKey,valueToEmit,valueToCache}=stagedPutItem;cacheKeyToValueMap.set(cacheKey,valueToCache);this._stageEmitInternal(cacheKey,valueToEmit);this.getOrCreateObservables(cacheKey,_ldsCache.getService(cacheKey.type).getCacheValueTtl());// Make sure there will be an observable for every value we're putting in the cache.
    }_ldsCache.putAll(cacheKeyToValueMap);const dependencyMap=this._ldsCache.getOrCreateDependencyMap();this._mergeDependencies(dependencyMap,_stagedDependencies,this._dependencyKeyStringsToClear);this._ldsCache.saveDependencyMap(dependencyMap);// Filter down deps to return to what (A) is marked to trigger affected keys and (B) to what wasn't in the puts/emits and (C) what keys have Observables (if there
    // is no root Observable for the key there is nothing to do in response to it).
    const stagedPutKeys=Array.from(_stagedPutsMap.keys()).filter(key=>{const stagedPutItem=_stagedPutsMap.get(key);return stagedPutItem&&stagedPutItem.triggerAffectedKeys===true?true:false;});const keyStringsToOmit=union(new Set(Object.keys(_stagedDependencies)),stagedPutKeys);const affectedCacheKeysArray=_ldsCache.getAffectedKeys(stagedPutKeys,dependencyMap.dependencies,keyStringsToOmit);{handleDebug("record-service_commitPuts2",()=>{return {affectedCacheKeysArray};});}return new Set(affectedCacheKeysArray);}/**
         * Stages an Observable emit, typically in response to the keys affected by commitPuts() or a prior stageEmit(). This should be called only
         * after making all necessary stagePut() calls because afterwards stagePut() is disallowed (it will fail).
         * @param cacheKey The cache key for the value you want to emit.
         * @param valueToEmit The cache key for the value you want to emit.
         */stageEmit(cacheKey,valueToEmit){{assert$2(this._phase===3/* CACHE_ACCESSOR_PHASE_PUTS_COMMITTED */,"Emits can only be staged after commitPuts().");}const keyString=serialize(cacheKey);{handleDebug("stage-emit",()=>{return {cacheKey:keyString,valueToEmit};});assert$2(!Array.from(this._stagedPutsMap.keys()).includes(keyString),`You should not stage an emit for something that was already committed to cache: ${keyString}`);}this._stageEmitInternal(cacheKey,valueToEmit);}/**
         * Can be used to see if there is already an emit staged for the provided cache key.
         * @param cacheKey The cache key for the value you want to emit.
         * @returns True if there is an emit staged for this cache key, else false.
         */isEmitStaged(cacheKey){{assert$2(this._phase!==2/* CACHE_ACCESSOR_PHASE_FINISHED */,"Cache accessors should not be accessed after they have been finished.");}const keyString=serialize(cacheKey);return this._stagedEmitsKeyStringsSet.has(keyString);}/**
         * Will return the number of staged emits from staging puts and emits.
         * @return The number of staged emits from staging puts and emits.
         */get stagedEmitsCount(){return this._stagedEmitsKeyStringsSet.size;}/**
         * WARNING!!!! ONLY FOR USE BY INTERNAL CACHE CORE. SERVICE METHODS SHOULD NOT CALL THIS METHOD EVER!!!
         * Runs all emits and disposes. The cache accessor cannot be used anymore after this has been called.
         *
         * TODO: We don't want this method exposed to users of CacheAccessor. We need a better way of exposing only what we want to people who use the cache accessor.
         * We should consider decoupling the transaction from the state machine driving the transaction.
         */finishCacheAccessor(){{assert$2(this._phase===3/* CACHE_ACCESSOR_PHASE_PUTS_COMMITTED */,"finish() should only be called once, after puts have been committed.");}this._phase=2/* CACHE_ACCESSOR_PHASE_FINISHED */;const _ldsCache=this._ldsCache;const stagedEmitsMapArray=Array.from(this._stagedEmitsMap.entries());for(let len=stagedEmitsMapArray.length,n=0;n<len;n++){const[cacheKey,valueToEmit]=stagedEmitsMapArray[n];const cacheValueTtl=_ldsCache.getService(cacheKey.type).getCacheValueTtl();const observables=_ldsCache.getOrCreateObservables(cacheKey,cacheValueTtl);// Make sure there will be an observable for every value we're putting in the cache.
    try{observables.root.emitValue(valueToEmit);}catch(err){const errorStr="Unexpected error during Observable emit! err="+JSON.stringify(err)+` -- err.message=${err.message}`;{// tslint:disable-next-line:no-console
    console.log(errorStr);// Better console handling when we're not in PROD.
    assert$2(false,errorStr);}}}this._stagedDependencies=Object.create(null);this._dependencyKeyStringsToClear.clear();this._stagedEmitsMap.clear();this._stagedEmitsKeyStringsSet.clear();}/**
         * Gets the observables for the CacheKey, creating them if necessary.
         * @param cacheKey The cache key for the Observable.
         * @param cacheValueTtl TTL for the value to be cached
         * @returns The Observables for the cache key.
         */getOrCreateObservables(cacheKey,cacheValueTtl){{assert$2(this._phase!==2/* CACHE_ACCESSOR_PHASE_FINISHED */,"Cache accessors should not be accessed after they have been finished.");}return this._ldsCache.getOrCreateObservables(cacheKey,cacheValueTtl);}/**
         * Makes a new immutable ValueWrapper with a lastFetchTime consistent with the rest of the CacheAccessor transaction. Optionally an
         * eTag may be provided (if available), as can an arbitrary Object containing information the ValueProvider may desire during a
         * future cache transaction.
         * @param valueToCache The value to be cached - required (must not be undefined). This should not be an already wrapped
         *      value (instanceof ValueWrapper).
         * @param eTag The eTag to be set on the ValueWrapper.
         * @param extraInfoObject An arbitrary object that ValueProviders may use to store additional information about the value being
         *      cached.
         * @returns The provided params wrapped in an immutable ValueWrapper.
         */newValueWrapper(valueToCache,eTag,extraInfoObject){{assert$2(this._phase!==2/* CACHE_ACCESSOR_PHASE_FINISHED */,"Cache accessors should not be accessed after they have been finished.");}return {value:valueToCache,lastFetchTime:this._nowTime,eTag,extraInfoObject};}/**
         * Same as stageEmit() but it doesn't validate lifecycle constraints so it can be called internally from places like stagePut().
         * @param cacheKey The cache key for the value you want to emit.
         * @param valueToEmit The cache key for the value you want to emit.
         */_stageEmitInternal(cacheKey,valueToEmit){const keyString=serialize(cacheKey);this._stagedEmitsKeyStringsSet.add(keyString);this._stagedEmitsMap.set(cacheKey,valueToEmit);}/**
         * Merges the given dependencyMap with the given newDependencies. Clears out old dependencies for those specified by dependenciesToClear.
         * @param dependencyMap The dependency map for the cache.
         * @param newDependencies The keys in the map are string representations of cache
         *      keys and the values are sets of Dependency objects. A given entry value (Set<Dependency>) in
         *      the map represents the known cache keys that are affected when the value represented by the entry key in the
         *      map changes. This map should contain the dependencies for the given cache operation, not everything we've ever
         *      tracked.
         * @param dependenciesToClear The string representations of cache keys that should be cleared out
         *      and replaced by new values in dependencyKeyStringsToClear, if any. Used to reset and recalculated what depends
         *      on a given key.
         */_mergeDependencies(dependencyMap,newDependencies,dependenciesToClear){if(dependenciesToClear.size>0){// Use the reverseLookup index to remove the dependencies.
    const dependenciesToClearArray=Array.from(dependenciesToClear);for(let i=0,length=dependenciesToClearArray.length;i<length;++i){const dependencyToClear=dependenciesToClearArray[i];const reverseLookupEntry=dependencyMap.dependenciesReverseLookup[dependencyToClear];if(reverseLookupEntry){const reverseLookupEntryArray=Array.from(reverseLookupEntry);for(let k=0,reverseLookupEntryArrayLength=reverseLookupEntryArray.length;k<reverseLookupEntryArrayLength;++k){const reverseLookupKey=reverseLookupEntryArray[k];const dependenciesEntryForReverseLookupKey=dependencyMap.dependencies[reverseLookupKey];if(dependenciesEntryForReverseLookupKey){dependenciesEntryForReverseLookupKey.delete(dependencyToClear);if(dependenciesEntryForReverseLookupKey.size===0){delete dependencyMap.dependencies[reverseLookupKey];}}}// Remove the entry.
    delete dependencyMap.dependenciesReverseLookup[dependencyToClear];}}}// Loop through new dependencies and shove them in.
    const newDependenciesKeys=Object.keys(newDependencies);for(let len=newDependenciesKeys.length,n=0;n<len;n++){const newDependenciesKeyString=newDependenciesKeys[n];if(!dependencyMap.dependencies[newDependenciesKeyString]){// Completely new entry.
    dependencyMap.dependencies[newDependenciesKeyString]=new Map(newDependencies[newDependenciesKeyString]);}else {// Existing entry, so merge.
    newDependencies[newDependenciesKeyString].forEach((value,key)=>{dependencyMap.dependencies[newDependenciesKeyString].set(key,value);});}if(dependencyMap.dependencies[newDependenciesKeyString].size>0){// Update the reverse lookup index.
    dependencyMap.dependencies[newDependenciesKeyString].forEach((_dependency,reverseLookupKey)=>{let reverseLookupEntry=dependencyMap.dependenciesReverseLookup[reverseLookupKey];if(!reverseLookupEntry){reverseLookupEntry=new Set();reverseLookupEntry.add(newDependenciesKeyString);dependencyMap.dependenciesReverseLookup[reverseLookupKey]=reverseLookupEntry;}else {reverseLookupEntry.add(newDependenciesKeyString);}});}}}}/**
     * Builds the cache key.
     * @param ldsCacheName The name of the LDS cache used to scope related dependencies.
     * @returns A new cache key representing the LDS_CACHE_DEPENDENCIES_VALUE_TYPE value type.
     */function buildCacheKey(){return {type:LDS_CACHE_DEPENDENCIES_VALUE_TYPE,key:"DEPENDENCY_MAP"};}function fetch(requestUrl,ldsRequestInit){return aura.executeGlobalController(requestUrl,ldsRequestInit.requestParams,ldsRequestInit.options);}/**
     * Mapping between wire name and ui-api resource reference config.
     */const wireAdapterNameToResourceReferenceMapping={"force/lds":{getLayout:{categoryType:"UI_API",valueType:"uiapi.RecordLayoutRepresentation",urlTemplate:{uri:"/services/data/v48.0/ui-api/layout/{objectApiName}",uriMappings:{objectApiName:"objectApiName"},queryMappings:{formFactor:"formFactor",layoutType:"layoutType",mode:"mode",recordTypeId:"recordTypeId"}},prefetch:true,batchable:false},getLayoutUserState:{categoryType:"UI_API",valueType:"uiapi.RecordLayoutUserStateRepresentation",urlTemplate:{uri:"/services/data/v48.0/ui-api/layout/{objectApiName}/user-state",uriMappings:{objectApiName:"objectApiName"},queryMappings:{formFactor:"formFactor",layoutType:"layoutType",mode:"mode",recordTypeId:"recordTypeId"}},prefetch:true,batchable:false},getObjectInfo:{categoryType:"UI_API",valueType:"uiapi.ObjectInfoRepresentation",urlTemplate:{uri:"/services/data/v48.0/ui-api/object-info/{objectApiName}",uriMappings:{objectApiName:"objectApiName"}},prefetch:true,batchable:false},getPicklistValues:{categoryType:"UI_API",valueType:"uiapi.PicklistValuesRepresentation",urlTemplate:{uri:"/services/data/v48.0/ui-api/object-info/{objectApiName}/picklist-values/{recordTypeId}/{fieldApiName}",uriMappings:{fieldApiName:"fieldApiName",objectApiName:"objectApiName",recordTypeId:"recordTypeId"}},prefetch:true,batchable:false},getPicklistValuesByRecordType:{categoryType:"UI_API",valueType:"uiapi.PicklistValuesCollectionRepresentation",urlTemplate:{uri:"/services/data/v48.0/ui-api/object-info/{objectApiName}/picklist-values/{recordTypeId}",uriMappings:{recordTypeId:"recordTypeId",objectApiName:"objectApiName"}},prefetch:true,batchable:false},getRecord:{categoryType:"UI_API",valueType:"uiapi.RecordRepresentation",urlTemplate:{uri:"/services/data/v48.0/ui-api/records/{recordId}",uriMappings:{recordId:"recordId"},queryMappings:{childRelationships:"childRelationships",fields:"fields",mode:"mode",layoutTypes:"layoutTypes",pageSize:"pageSize",optionalFields:"optionalFields"}},prefetch:true,batchable:false},getRecordAvatars:{categoryType:"UI_API",valueType:"uiapi.RecordAvatarBulk",urlTemplate:{uri:"/services/data/v48.0/ui-api/record-avatars/batch/{recordIds}",uriMappings:{recordIds:"recordIds"},queryMappings:{formFactor:"formFactor"}},prefetch:false,batchable:false},getRecordCreateDefaults:{categoryType:"UI_API",valueType:"uiapi.RecordDefaultsRepresentation",urlTemplate:{uri:"/services/data/v48.0/ui-api/record-defaults/create/{objectApiName}",uriMappings:{objectApiName:"objectApiName"},queryMappings:{formFactor:"formFactor",optionalFields:"optionalFields",recordTypeId:"recordTypeId"}},prefetch:true,batchable:false},getRecordUi:{categoryType:"UI_API",valueType:"uiapi.RecordUiRepresentation",urlTemplate:{uri:"/services/data/v48.0/ui-api/record-ui/{recordIds}",uriMappings:{recordIds:"recordIds"},queryMappings:{childRelationships:"childRelationships",formFactor:"formFactor",layoutTypes:"layoutTypes",modes:"modes",optionalFields:"optionalFields",pageSize:"pageSize"}},prefetch:true,batchable:false},getRecordActions:{categoryType:"UI_API",valueType:"lds.RecordActions",urlTemplate:{uri:"/services/data/v48.0/ui-api/actions/record/{recordId}",uriMappings:{recordId:"recordId"},queryMappings:{actionTypes:"actionTypes",apiNames:"apiNames",formFactor:"formFactor",retrievalMode:"retrievalMode",sections:"sections"}},prefetch:true,batchable:false}}};/**
     * Returns object containing mapping for wire adapter name to resource reference configs.
     * @returns Object containing resource reference objects, indexed by wire name.
     */function getResourceReferenceMappings(){return wireAdapterNameToResourceReferenceMapping["force/lds"];}const USE_DEDUPE_KEY="isAggregateUiDedupingEnabled";const USE_DEDUPE_CONFIGURATION_KEY="transport."+USE_DEDUPE_KEY;let getServiceConfiguration;function provideConfiguration(configProvider){getServiceConfiguration=configProvider;}// Ability to check configuration for enablement of features
    /**
     * Class to build a URL Query string.
     */class URLBuilder{constructor(){/**
             * Map containing all of the parameters.
             */this._queryMap=new Map();}/**
         * Setter method for the query string.
         * @param key Key of the parameter.
         * @param value Value of the parameter.
         */set(key,value){this._queryMap.set(key,value);}/**
         * Build method to return the query string.
         * @returns The query string.
         */build(){let queryString="";for(const[key,value]of this._queryMap.entries()){if(queryString.length===0){queryString+="?";}else {queryString+="&";}queryString+=key+"="+value;}return queryString;}}/**
     * Creates and returns a FetchResponse given an fetch promise. Standardizes error responses
     * from Aura actions.
     * TODO: Update CiJ response shape to match REST errors: W-5142315. Once this is completed we can update
     * the logic below to directly consume it instead of generating it.
     * @param fetchResponse - The return value from fetch.
     * @param isAggregateUi Whether its an Aggregate UI API call or not.
     * @param isComposite Whether the caller expects multiple responses
     * @returns Returns a Promise resolved with a FetchResponse object.
     */async function createFetchResponse(fetchResponse,isAggregateUi,isComposite){try{const result=await fetchResponse;if(isAggregateUi){// Aggregate request.
    if(!result.compositeResponse||!result.compositeResponse[0]){throw new Error("Using AggregateUi but received invalid data back from ui-api aggregate-ui endpoint: "+JSON.stringify(result));}if(!isComposite){const compositeResponse=result.compositeResponse[0];const{body,httpStatusCode}=compositeResponse;let ok=true;let statusText="OK";if(httpStatusCode===304){statusText="Not Modified";}else if(httpStatusCode>=400&&httpStatusCode<=599){const errorResponse=body[0];statusText=errorResponse.errorCode;ok=false;}return {ok,status:httpStatusCode,statusText,body};}else {// Return the whole set
    const body=result;// Any individual status may not represent the set; return whatever we get, and the caller must figure out what it means to the composite
    return {ok:true,status:200,statusText:"OK",body};}}// Regular request.
    return getOkFetchResponse(result);}catch(exception){let ok=false;let status=400;let statusText="Bad Request";let body=exception;// Massage the error shape if this error has the ui api error (the data property) wrapped in a bigger error.
    if(exception&&exception.data){// This is an aura controller error shape which has a more specific status.
    // We need to manually assign this value as the status of the FetchResponse
    // and generate the corresponding http status text.
    status=exception.data.statusCode;switch(status){case 304:ok=true;statusText="Not Modified";break;case 404:statusText="Not Found";break;default:statusText="Bad Request";}body=exception.data;}return {ok,status,statusText,body};}}/**
     * From an aggregate bag, extract only the 1 response of interest
     * @param requestUri The URI that identifies which output value (also identified by URI) to extract / return
     * @param aggregateResponse An aggregate (could be 1 or more responses) to inspect
     * @returns The first response from the aggregate that matches the requestUri
     * @throws Error if the requestUri wasn't found in aggregateResponse
     */function extractSingleOperation(requestUri,aggregateResponse){if(aggregateResponse&&aggregateResponse.compositeResponse){for(const response of aggregateResponse.compositeResponse){if(response.url===requestUri){return response;}}}throw new Error("Expected to receive output for "+requestUri+" but it was missing from the response payload");}/**
     * Convert a single-payload operationResponse into a FetchResponse, as used/expected by most wire services
     * @param operationResponse
     * @returns FetchResponse to represent the single payload response
     */function operationResponseToFetchResponse(operationResponse){const{body,httpStatusCode}=operationResponse;let ok=true;let statusText="OK";if(httpStatusCode===304){statusText="Not Modified";}else if(httpStatusCode>=400&&httpStatusCode<=599){const errorResponse=body[0];statusText=errorResponse.errorCode;ok=false;}return {ok,status:httpStatusCode,statusText,body};}/**
     * Type-specific fetch for Aggregate requests. Restructures the input into the right format for the Aura fetch request, with parameters about how to operate
     * @param input Aggregate request
     * @returns Promise to fetch an Aggregate response
     */function fetchAggregate(aggregateRequest){if(aggregateRequest.input.compositeRequest.length===0){throw new Error("Unnecessary request for 0 aggregate requests");}const hotspot=true;const background=false;const longRunning=false;const ldsRequestInit={requestParams:aggregateRequest,options:{hotspot,background,longRunning}};return fetch("RecordUiController.executeAggregateUi",ldsRequestInit).then(response=>{return response;});}const REFERENCE_REGEX=/\$\{\w+\}/g;/**
     * AggregateUi requests may have references to other requests inside the same aggregate request. Given a single request, what are the refernceIds of the dependencies?
     * Example:
     * requestReferences({
     *      httpHeaders: []
     *      referenceId: "ADG_12"
     *      url: ".../object-info?objectApiName=${ADG_4}.objectApiName"
     * })
     *  => ["ADG_4"]
     * This request depends on ADG_4's output to fulfill the objectApiName for this request.
     * @param input OperationInput which may (or may not) reference other requests in the same aggregate request
     * @returns list of referenceIds this request depends on
     */function requestReferences(input){const references=[];let m;do{m=REFERENCE_REGEX.exec(input.url);if(m){references.push(m[1]);}}while(m);return references;}/**
     * @param referenceId unique identifier to a response
     * @param inputs list of responses
     * @returns The operation response that has the same referenceId, or undefined if it's not in the list
     */function getRequestById(referenceId,inputs){return inputs.find(oir=>{return oir.referenceId===referenceId;});}/**
     * Global map between requestUri and the Promise that will contain the data
     * Must span multiple AggregateUiExecutors; truly global
     */const pendingRequestMap=new Map();/**
     * Class to make calls to aggregate-ui. Maintains mapping of requests.
     */class AggregateUiExecutor{constructor(){/**
             * Counter for requests.
             */this._count=0;/**
             * Map between referenceId and valueType for each aggregate-ui request.
             */this.requestValueTypeMapping=new Map();}/**
         * Makes a call to the server for a single representation via aggregate ui for the given wire name and params.
         * Transforms the response into a TransformResponse and rejects if there is a client/server error.
         * @param wireName The name of the wire adapter.
         * @param requestParams Object containing parameters of the ui-api request.
         * @param TTL The TTL of the resource. This is not currently being used in 218. Will be used for mobile.
         * @returns Returns a Promise resolved with a FetchResponse object.
         */executeSingleRequestOverAggregateUi(wireName,requestParams,TTL){this._count++;const resourceReferenceConfig=getResourceReferenceMappings()[wireName];if(!resourceReferenceConfig){throw new Error("Could not find wire mapping for wire adapter: "+wireName+" in wire-name-to-reference-resource-map.ts");}const referenceId="LDS"+"_"+Date.now().toString()+"_"+this._count;const clientOptions=requestParams.clientOptions;const input=this._generateAggregateUiInput(resourceReferenceConfig,requestParams,clientOptions,referenceId,TTL);const aggregateUiInput={input};// Set mapping between reference id and value type. This is only being used for tests
    this.requestValueTypeMapping.set(referenceId,resourceReferenceConfig.valueType);// fetch / filter requested inputs out of the aggregate response
    return this.executeAggregateUi(aggregateUiInput).then(extractSingleOperation.bind(null,input.compositeRequest[0].url)).then(operationResponseToFetchResponse)// Interesting quality of aggregateUi... normally we'd throw an error if the request failed, but AggregateUi fails _individual_ requests, rather than the bucket. So it always succeeds
    .catch(handleFetchException).then(throwIfClientOrServerError);}/**
         * When fetching multiple requests in an aggregate, some may be the same as ones in-flight, and some may need to be freshly requested.
         * Regardless of the details, this function promises to return an Aggregate response of what was asked for in the input
         * @param aggregateRequest A collection of 0 or more UI-API requests to be fetched
         * @returns Promise to gather the requested data; the order of return.compositeResponse is guaranteed to correlate to the order of the request inputs
         */getPromiseForValues(aggregateRequest){const promiseToFulfillOriginalRequest=[];// <inputUri -> OperationInput> of only requests that should be included in the new XHR/batch
    const freshBatch=new Map();// Figure out what we need to freshly request (and what is in-flight)
    for(let i=0;i<aggregateRequest.input.compositeRequest.length;i++){const inputRequest=aggregateRequest.input.compositeRequest[i];if(!pendingRequestMap.has(inputRequest.url)){/*
                    If this request relies on output from other requests, include those in the batch as well

                    Nuance:
                        request: [ getObjectInfo, getRecord(usesObjectInfo)]
                        getObjectInfo is inflight, so we want to wait on that...
                        but the next getRecord USES getObjectInfo (evaluated by aggregateUi on the server). So we need to include it in the batch

                        If we don't we'd dispatch:
                            [ getRecord(missing reference)]
                    */requestReferences(inputRequest).forEach(depReq=>{const dependencyInput=getRequestById(depReq,aggregateRequest.input.compositeRequest);if(!dependencyInput){throw new Error("Request for "+inputRequest.url+" depends on the output of another request ("+depReq+") that's not part of the aggregate");}if(!freshBatch.has(dependencyInput.url)){freshBatch.set(dependencyInput.url,dependencyInput);}});if(!freshBatch.has(inputRequest.url)){freshBatch.set(inputRequest.url,inputRequest);}}}// List version of freshBatch, containing the list of requests
    const freshQueue=Array.from(freshBatch.values());// The promise that kicks off the fresh batch request (or does nothing because all requests are de-duped to in-flight XHRs)
    const promiseFreshValues=freshQueue.length>0?fetchAggregate({input:{compositeRequest:freshQueue}}):new Thenable(()=>undefined);// For each request, check if it's pending
    // - if it's pending, return that promise (for the in-flight XHR)
    // - if it's not pending, depend on the promise for the fresh batch XHR
    for(let i=0;i<aggregateRequest.input.compositeRequest.length;i++){const inputRequest=aggregateRequest.input.compositeRequest[i];// If the request should be requested freshly, depend on the fresh batch & mark that it's pending
    if(!pendingRequestMap.has(inputRequest.url)){// This assumes that the request ID doesn't matter except for setting up the dependencies between things (ensured by the previous phase)
    pendingRequestMap.set(inputRequest.url,promiseFreshValues.then(extractSingleOperation.bind(null,inputRequest.url)));}// Implied else: If the request is in-flight, wait for the value from that XHR (skip)
    promiseToFulfillOriginalRequest.push(pendingRequestMap.get(inputRequest.url));}return Promise.all(promiseToFulfillOriginalRequest).then(this.mergeIntoAggregate);/*
            Some interesting scenarios this section accounts for / handles....

            Scenario 1: fairly normal split-request
                input: [ A, B ]
                A is inflight
                B is fresh

                Promise.all(
                    [
                        XHR1.getA,
                        XHR2.getB
                    ]
                )

            Scenario 2: extracting a single value from an in-flight batch
                input: [getRecord]
                inflight XHR: [ getObjectInfo, getRecord, getRecordAvatars, etc]
                [bigXhr].then(extractSingle) ==> the 1 value you requested

            Scenario 3: timing of whether a dependant should be returned from the latest batch vs the (earlier) in-flight:
            [
                getObjectInfo(A)
                getObjectInfo(A)
                ... huge // downside: depending on this earlier-dispatched request is the slower choice
            ]

            ... what if something changes in the back-end? Early request is out-of-date, but the later one will be "correct"

            [
                getObjectInfo(A)
                getRecord(objectInfo)
                .... but this could be huge, where this is the slower choice. In the end, we don't know which will be better, so we chose to wait on the earlier request
            ]

            [
                getObjectInfo(A)
                // will wait on #2, which may take longer to return than #1
                vs
                // wait on #1 which is in pendingRequestMap
            ]

            
            [
                getObjectInfo(A)
                getRecord(objectInfo)
                .... but this could be huge, where this is the slower choice. In the end, we don't know which will be better, so we chose to wait on the earlier request
            ]
            alternative to re-requesting in-flight dependencies
            [
                getObjectInfo(A)
            ]

            Scenario 4: inner-field list spread
                Unaddressed (needs wire-adapter logic)
                    [getRecord(fields: A, B)]
                    [getRecord(fields: B, C)]
                    [getRecord(fields: A, D)]

                    We (transport layer) don't/can't understand that these fields are mergable; we only do EXACT request URI matches
            */}/**
         * Aggregates responses into a single response, and marks each as having been fulfilled
         * @param responses Collection of individual responses
         * @returns Aggregate response representing the collection of individual responses
         */mergeIntoAggregate(responses){// Clean up request queue
    for(const response of responses){pendingRequestMap.delete(response.url);}return {compositeResponse:responses};}/**
         * Gather multiple datum in a batch. May result in an XHR to fetch all the requests, or may depend on other in-flight requests
         * @param aggregateRequest Aggregate Input
         * @returns Aggregate Response in the same order as they were requested
         */executeAggregateUi(aggregateRequest){// getServiceConfiguration may not be provided during some tests, but should always be provided in production. Default to de-duping
    if(!getServiceConfiguration||getServiceConfiguration(USE_DEDUPE_CONFIGURATION_KEY)){return this.getPromiseForValues(aggregateRequest);}else {return fetchAggregate(aggregateRequest);}}/**
         * Given a ResourceReferenceConfiguration and a parameters object, fetches the config from wire-mapping.ts file and generates the ui-api aggregate ui input. Example shape:
         * {
         *  "input":
         *      {
         *          "compositeRequest":[
         *              {
         *                  "url":"/services/data/v46.0/ui-api/object-info/Opportunity",
         *                  "referenceId":"lds_ObjectInfo"
         *              }
         *          ]
         *      }
         * }
         *
         * @param resourceReferenceConfig The ResourceReferenceConfiguration for the wire adapter.
         * @param params Object containing parameters of the ui-api request.
         * @param referenceId Unique identifier for the request.
         * @param TTL The TTL of the resource.
         * @returns A composite request representing the valueProvider parameters.
         */_generateAggregateUiInput(resourceReferenceConfig,requestParams,clientOptions,referenceId,_TTL){const aggregateInputRepresentation={compositeRequest:[]};const operationInput=_generateOperationInputRequest(resourceReferenceConfig,requestParams,clientOptions,referenceId);aggregateInputRepresentation.compositeRequest.push(operationInput);return aggregateInputRepresentation;}}/**
     * Creates an emittable error object for when an internal LDS error occurs (eg a programmer error).
     * @param errorCode Error code to assist with post-mortem analysis. Generally unique per call site.
     * @param message Error message to assist with post-mortem analysis.
     * @param enableLogging Enable logging a gack to the server.
     * @returns An emittable error object.
     */function getLdsInternalError(errorCode,message,enableLogging){// Capture the stack for internal telemetry
    let stack;try{throw new Error(message);}catch(err){stack=err.stack;}const response={ok:false,status:500,statusText:"Internal Server Error",body:{errorCode,message,stack}};// Send the error to the server to create a gack.
    if(enableLogging){logger.logError(JSON.stringify(response));}return lwc.readonly(response);}/**
     * Creates an emittable error object matching UIAPI's response when a record is not found (eg has been deleted).
     * @returns An emittable error object.
     */function get404FetchResponse(){return lwc.readonly({ok:false,status:404,statusText:"NOT_FOUND",body:[{errorCode:"NOT_FOUND",message:"The requested resource does not exist"}]});}/**
     * Creates a OK status FetchResponse with the provided body.
     * @param body The value to set as the body of the FetchResponse.
     * @returns A 200 OK FetchResponse object with the provided body.
     */function getOkFetchResponse(body){return {ok:true,status:200,statusText:"OK",body};}/**
     * Throws if the given fetchResponse has a status code between 400 and 599 inclusive; otherwise
     * returns the given fetchResponse.
     * @param fetchResponse - The fetchResponse to evaluate.
     * @returns See description.
     * @throws FetchResponse - See description.
     */function throwIfClientOrServerError(fetchResponse){if(fetchResponse.status>=400&&fetchResponse.status<=599){throw lwc.readonly(fetchResponse);}else {return fetchResponse;}}/**
     * Degrade an exception during a fetch into an error-response
     * @param exception
     * @returns FetchResponse with an errored statusCode & the exception as the body
     */function handleFetchException(exception){let ok=false;let status=400;let statusText="Bad Request";let body=exception;// Massage the error shape if this error has the ui api error (the data property) wrapped in a bigger error.
    if(exception&&exception.data){// This is an aura controller error shape which has a more specific status.
    // We need to manually assign this value as the status of the FetchResponse
    // and generate the corresponding http status text.
    status=exception.data.statusCode;switch(status){case 304:ok=true;statusText="Not Modified";break;case 404:statusText="Not Found";break;default:statusText="Bad Request";}body=exception.data;}return {ok,status,statusText,body};}/**
     * Makes a call to the requestUrl using params and options. Transforms the response into a TransformResponse and rejects if there is a client/server error.
     * TODO: Instead of hard coding requests to aura global controller, let's abstract the transport mechanism.
     * Details in this user story: W-5153607.
     * @param requestUrl The request url.
     * @param requestParams Record containing the parameter name string and corressponding value.
     * @param options Object containing Aura actions config in the format { background, hotspot, longRunning }.
     * @returns Returns a Promise resolved with a FetchResponse object.
     */function executeAuraGlobalController(requestUrl,requestParams,options){let hotspot=true;let background=true;let longRunning=false;let storable;if(options){hotspot=options.hotspot;background=options.background;longRunning=options.longRunning;storable=options.storable;}const ldsRequestInit={requestParams,options:{hotspot,background,longRunning,storable}};const transportPerfMarker=markStart("lds_transport",requestParams.type);return createFetchResponse(fetch(requestUrl,ldsRequestInit)).then(transportResponse=>{markEnd(transportPerfMarker);throwIfClientOrServerError(transportResponse);return transportResponse;});}/**
     * The singleton instance of the AggregateUiExecutor.
     */const aggregateUiExecutor=new AggregateUiExecutor();/**
     * Assemble a bag of configs and params into a UI-API OperationInputRequest, primarily by building a URI to the server resource with params
     * @param resourceReferenceConfig Configuration mapping for how the resource URI should be built & have its params mapped
     * @param requestParams Config bag
     * @param clientOptions Can describe whether the eTag header should be set
     * @param referenceId An ID used to lookup the request
     * @param _TTL unused?
     * @returns OperationInputRequest
     */function _generateOperationInputRequest(resourceReferenceConfig,requestParams,clientOptions,referenceId,_TTL){delete requestParams.clientOptions;// Remove clientOptions from the requestParams object since we don't want to parse it.
    let generatedUri=resourceReferenceConfig.urlTemplate.uri;// Fill out uri values - these are all required.
    const uriMappings=resourceReferenceConfig.urlTemplate.uriMappings;if(uriMappings){const uriMappingKeys=Object.keys(uriMappings);for(let n=0,len=uriMappingKeys.length;n<len;n++){const uriMappingKey=uriMappingKeys[n];const uriValueKey=uriMappings[uriMappingKey];const uriValue=requestParams[uriValueKey];if(uriValue!==undefined){generatedUri=generatedUri.replace("{"+uriValueKey+"}",uriValue);delete requestParams[uriValueKey];}}}// Fill out query string parameters.
    const requestParamKeys=Object.keys(requestParams).sort();// sorting the params gives easy comparability by URIs for the pendingRequestMap
    const queryMappings=resourceReferenceConfig.urlTemplate.queryMappings;const queryParameterBuilder=new URLBuilder();if(queryMappings){for(let n=0,len=requestParamKeys.length;n<len;n++){const requestParamKey=requestParamKeys[n];const queryMappingValue=queryMappings[requestParamKey];if(queryMappingValue){const requestParamValue=requestParams[requestParamKey];if(requestParamValue!==undefined){// If we pass in empty array, skip setting the query param.
    if(Array.isArray(requestParamValue)&&requestParamValue.length===0){continue;}queryParameterBuilder.set(queryMappingValue,requestParamValue);}}}generatedUri+=queryParameterBuilder.build();}const operationInput={url:generatedUri,referenceId};if(clientOptions&&clientOptions.eTagToCheck){operationInput.httpHeaders={};operationInput.httpHeaders["If-None-Match"]=`"${clientOptions.eTagToCheck}"`;}return operationInput;}const UI_API_INDEX_PREFIX="ADG_";/**
     * @param wire module + name identifying the wire in use
     * @param params config-bad
     * @param referenceId Identifier of the request (used for cross-input references and retrieval from an aggregate response)
     * @returns OperationInputRepresentation
     */function mapDataDependencyToOperationInput(wire,params,referenceId){const resourceReferenceConfig=getResourceReferenceMappings()[wire.name];if(!resourceReferenceConfig){throw new Error("Could not find wire mapping for wire adapter: "+wire.name+" in wire-name-to-reference-resource-map.ts");}return _generateOperationInputRequest(resourceReferenceConfig,params,undefined,UI_API_INDEX_PREFIX+referenceId);}/**
     * What's the valueType for each of these wires?
     * @param wireNames list of wire names
     * @returns list of value-types classifying the wire
     */function mapWireNamesToValueType(wireNames){return wireNames.map(wireName=>{const resourceReferenceConfig=getResourceReferenceMappings()[wireName];if(!resourceReferenceConfig){throw new Error("Could not find wire mapping for wire adapter: "+wireName+" in wire-name-to-reference-resource-map.ts");}return resourceReferenceConfig.valueType;});}/**
     * Provides client-side caching functionality. Consumers read values from the cache via observables that the cache hands out: one observable maps to one cache value.
     * An observable can emit the following:
     * next:
     *      The cache value for the requested value.   If the value changes it will trigger another next.
     * error:
     *      An error was encountered when trying to provide a value. The value given as the error is a regular object, not an Error object. Reasons:
     *      1. it's what you get from the UI API, nothing more or less
     *      2. it's not being thrown, it's emitted
     *      3. stack trace is not required
     *      4. in a sense this is "data" even though it's data about an error so an object is appropriate
     * complete:
     *      Signals the observable has stopped (not because of an error) and will not be emitting any further values. This happens when a cache value is LRU'd out
     *      of the cache or when a value provider returns a 404 from the server.
     */class LdsCache{/**
         * Constructor.
         * @param cacheName The name for this cache. Used to register cache stats by name.
         * @param cacheStore LDS cache store
         * @param timeSource LDS time source
         */constructor(cacheName,cacheStore,timeSource){/**
             * The map of cache key string representations to core observables.
             */this._observablesMap=new Map();/**
             * A map used to track in-flight value providers so they can be debounced.
             */this._valueProviderDebounceMap=new Map();/**
             * Internal cacheStats object to track cache statistics
             */this._serviceRegistry=new Map();this.timeSource=timeSource;this._cacheStore=cacheStore;this._cacheStats=service.registerCacheStats(cacheName.replace(/\s+/g,"_"));}/**
         * @returns A thenable that resolves when the instance is ready to be accessed.
         */access(){const handler=resolve=>{this._cacheStore.access(()=>{resolve();});};return this._cacheStore.isDurable()?new Promise(handler):new Thenable(handler);}/**
         * Bootstraps the LDS cache by bootstraping the cache store.
         */bootstrap(){this._cacheStore.bootstrap();}/**
         * Stage puts the given value using the given cacheAccessor based associated to the given valueType.
         * @param valueType The value type associated to the given value.
         * @param dependencies A list of cache keys that rely on the given value.
         * @param value The value to stage put.
         * @param cacheAccessor The cache accessor to stage put the value into.
         * @param additionalData An optional property bag object that can be consumed by an actual service implimentation of stagePutValue.
         *
         * @throws TransportResponse - Throws when a service is not found for the given valueType. This is a programmer error!
         */stagePutValue(valueType,dependencies,value,cacheAccessor,additionalData){{this._validateIsReady();}const service=this._serviceRegistry.get(valueType);if(!service){throw getLdsInternalError("SERVICE_NOT_FOUND","Could not find service for valueType: "+valueType.toString(),true);}service.stagePutValue(dependencies,value,cacheAccessor,additionalData);}/**
         * Strips eTags from the given value associated with the given valueType.
         * @param valueType The value type associated to the given value.
         * @param value The value from which to strip the eTags.
         * @returns The given value stripped of all eTags.
         *
         * @throws TransportResponse - Throws when a service is not found in the registry for the given valueType. This is a programmer error!
         */stripETagsFromValue(valueType,value){{this._validateIsReady();}const service=this._serviceRegistry.get(valueType);if(!service){throw getLdsInternalError("SERVICE_NOT_FOUND","Could not find service for valueType: "+valueType.toString(),true);}return service.stripETagsFromValue(value);}/**
         * Gets a value using the value provider and then caches it.
         * @param cacheKey The cache key.
         * @param valueProvider The value provider used to retrieve the value if it is not found in cache or needs to be refreshed.
         * @param finishedCallbacks Respective functions will be invoked on outcome of the get.
         * @returns The observable used to get the value and keep watch on it for changes.
         */get(cacheKey,valueProvider,finishedCallbacks){const keyString=serialize(cacheKey);const cacheKeyValueTypeString=cacheKey.type;const cacheValueTtl=this.getService(cacheKey.type).getCacheValueTtl();const observables=this.getOrCreateObservables(cacheKey,cacheValueTtl);const cacheAccessor=new CacheAccessor(this,this.timeSource);if(this._debounceOrTrackValueProvider(cacheKey,valueProvider)){return observables.finalTransformed;}let finishedExecuted=false;const finished=error=>{{this._untrackValueProvider(cacheKey,valueProvider);}// Invoke any applicable callbacks.
    if(finishedCallbacks){if(finishedCallbacks.errorCallback&&error){finishedCallbacks.errorCallback(error);}else if(finishedCallbacks.successCallback){finishedCallbacks.successCallback();}}finishedExecuted=true;};// Before accessing the cache store we need to make sure the cache is ready.
    this.access().then(()=>{const cacheGetPerfMarker=markStart("lds_cache_get",cacheKeyValueTypeString);const valueWrapper=this._cacheStore.get(cacheKey);markEnd(cacheGetPerfMarker);// Cache get performance tracker
    const valueProviderPerfMarker=markStart("lds_cache_value_provider",cacheKeyValueTypeString);const valueProviderPerfMarkerPerfContext=valueProviderPerfMarker.perfContext;valueProvider.provide(cacheAccessor).then(valueProviderResult=>{// return so the Thenable will remain part of the outer Thenable chain.
    let callbackError;try{if(valueProviderResult===2/* CACHE_MISS */){// With LDS now supporting delete record, there are scenarios where we are returning a CACHE_MISS but do not have anything staged for emit
    // as a temporary solution, I'm removing the below assert. I will follow this up in the next design meeting
    // This was not discovered previously because we have an issue with our record-ui-emulator which is now fixed
    // assert(cacheAccessor.isEmitStaged(cacheKey), `If this was a miss we should have an emit staged for the cache key: ${keyString}`);
    if("development"!=="production"){// tslint:disable-next-line:no-console
    console.log(`LDS Cache: Cache miss for '${keyString}'; value is provided.`);}this._cacheStats.logMisses();cacheAccessor.finishCacheAccessor();valueProviderPerfMarkerPerfContext.keyStatus="cache_miss";}else if(valueProviderResult===1/* CACHE_HIT */){if("development"!=="production"){assert$2(cacheAccessor.stagedEmitsCount===0,`There shouldn't be any staged emits on a cacheAccessor for a cache hit, with key ${keyString}`);// tslint:disable-next-line:no-console
    console.log(`LDS Cache: Cache hit for '${keyString}'`);}// We need to denormalize and emit a value if the root observable for this cache key has never emitted.
    if(observables.root.lastValue===undefined){const service=this.getService(cacheKey.type);try{const denormalizedValue=service.denormalizeValue(valueWrapper.value,cacheAccessor);const valueWrapperToEmit=cloneWithValueOverride(valueWrapper,denormalizedValue);observables.root.emitValue(valueWrapperToEmit);}catch(err){if("development"!=="production"){// tslint:disable-next-line:no-console
    console.log("LDS CACHE: Could not denormalize value for emit on cache hit. Err: "+JSON.stringify(err));}}}this._cacheStats.logHits();valueProviderPerfMarkerPerfContext.keyStatus="cache_hit";}else if(valueProviderResult===3/* CACHE_MISS_REFRESH_UNCHANGED */){this._cacheStats.logMisses();// This was a 304 unchanged, so update the ValueWrapper.lastFetchTime and emit. Consumers of LDS don't care about lastFetchTime so
    // emits get squashed by distinctUntilChanged because the actual value inside the ValueWrapper hasn't changed.
    // We also don't invoke affected key handlers for the same reason.
    const newValueWrapper=cacheAccessor.newValueWrapper(valueWrapper.value,valueWrapper.eTag,valueWrapper.extraInfoObject);cacheAccessor.stagePut([],cacheKey,newValueWrapper,newValueWrapper.value);cacheAccessor.commitPuts();cacheAccessor.finishCacheAccessor();valueProviderPerfMarkerPerfContext.keyStatus="cache_miss_refresh_unchanged";}else if(valueProviderResult===4/* CACHE_RECORD_FROM_ADS */){// This is the special value for receiving local records from ADS.
    if("development"!=="production"){// tslint:disable-next-line:no-console
    console.log(`LDS Cache: Cached record from ADS '${keyString}'`);}cacheAccessor.finishCacheAccessor();}else {if("development"!=="production"){assert$2(false,`LDS Cache: Invalid valueProviderResult returned from value provider: ${valueProviderResult}`);}}}catch(error){callbackError=error;valueProviderPerfMarkerPerfContext.keyStatus="cache_error";// Anything bad happening in this try block would be an LDS bug. Rethrow here as opposed to let the onRejected handler
    // handle it because we don't want Observables to get these errors (they can't really handle them). Rethrow here (as
    // opposed to logError()) so that the UI will display an error overlay that will be hard to miss, as well as gack.
    throw error;}finally{finished(callbackError);markEnd(valueProviderPerfMarker);// ValueProvider performance tracker
    }}).catch(error=>{if(!finishedExecuted){finished({error});}this._handleValueProviderError(observables.root,cacheKey,error);});});return observables.finalTransformed;}/**
         * Returns the value, or undefined, from the cacheStore.
         * @param cacheKey The cache key for the value you want to get.
         * @returns See description.
         */getValue(cacheKey){return this._cacheStore.access(cache=>cache.get(cacheKey));}/**
         * Puts the cached object using the provided key.
         * @param cacheKey The cache key for the value you want to put - required.
         * @param value The cache value to put.
         */put(cacheKey,value){this._cacheStore.access(cache=>cache.put(cacheKey,value));}/**
         * Puts all the values stored in the map into the cache.
         * @param cacheKeyToValueMap  Map of cacheKeys to values to store into cache.
         *      Values can be falsy and still be cached with the exception of undefined, which is treated as a removed
         *      or non-existent value.
         */putAll(cacheKeyToValueMap){this._cacheStore.access(cache=>cache.putAll(cacheKeyToValueMap));}/**
         * CAUTION! Evicts a value from the cache. Does not remove dependencies and does not call any affected key handlers.
         * @param cacheKey The cache key of the thing to evict.
         */evict(cacheKey){{this._validateIsReady();}const perfMarker=markStart("lds_cache_evict",serialize(cacheKey));this._cacheStore.evict(cacheKey);markEnd(perfMarker);}/**
         * Evicts a value from the cache, emits a 404, and deletes the observable. This should be invoked in response
         * to the system of record having the item deleted.
         * DO NOT USE THIS FOR GENERALLY EVICTING VALUES OUT OF THE CACHE. USE evict() for that!
         * @param cacheKey The cache key to delete.
         */deleteValueAndDeleteObservable(cacheKey){{this._validateIsReady();}const perfMarker=markStart("lds_cache_evict_complete_observables",cacheKey.type);// Evict!
    const didEvict=this._cacheStore.evict(cacheKey);if(didEvict){// Emit 404 error on observable and delete it.
    const observables=this._getObservables(cacheKey);const rootObservable=observables?observables.root:undefined;if(rootObservable){const error=get404FetchResponse();rootObservable.emitError(error);}this._deleteObservables(cacheKey);// Get the affected keys.
    const cacheAccessor=new CacheAccessor(this,this.timeSource);const affectedCacheKeysArray=this.getAffectedKeys([serialize(cacheKey)],this.getOrCreateDependencyMap().dependencies);// Clear out the dependency tree for this value.
    this._clearDependencies(cacheKey);// Handle the affected keys.
    this.handleAffectedKeys(affectedCacheKeysArray,cacheAccessor);}markEnd(perfMarker);// Perf tracker for cache eviction
    }/**
         * A convenience method for value providers that will iterate over the affected keys, look up the registered affected key
         * handler for each affected key, and invoke each handler.
         * @param affectedKeys An iterable of affected keys.
         * @param cacheAccessor The CacheAccessor in scope.
         */handleAffectedKeys(affectedKeys,cacheAccessor){{this._validateIsReady();}const affectedKeysArray=Array.from(affectedKeys);for(let len=affectedKeysArray.length,n=0;n<len;n++){const affectedKey=affectedKeysArray[n];const affectedKeyValue=serialize(affectedKey);const affectedKeyHandlerFn=this._getAffectedKeyHandler(affectedKey.type);{assert$2(affectedKeyHandlerFn,`Handler function not found for affected key: ${affectedKeyValue}`);}if(affectedKeyHandlerFn){affectedKeyHandlerFn(affectedKey,cacheAccessor);}}}/**
         * Method for getting affected keys from a dependency map.
         * @param keyStringsIterable The cache key string representations for which you want to get dependent keys.
         * @param dependenciesKeyStringMap The keys in the map are string representations of cache
         *      keys and the values are sets of string representations of cache keys. A given entry value (Set<string>) in
         *      the map represents the known cache keys that are affected when the value represented by the entry key in the
         *      map changes.
         * @param keyStringsToOmit Set of strings to omit from the affected keys.
         * @returns An array of affected cache keys.
         */getAffectedKeys(keyStringsIterable,dependenciesKeyStringMap,keyStringsToOmit){return collectionToArray(this._getTransitiveDependencies(keyStringsIterable,dependenciesKeyStringMap)).filter(keyString=>{// At this point the set of affected keys includes all the dependencies, including anything the consumer has just staged. Strip out the
    // stuff they have staged (puts/dependencies) since there is no point in them responding to that.
    if(keyStringsToOmit){return !keyStringsToOmit.has(keyString);}return true;}).map(keyString=>{return deserialize(keyString);}).filter(cacheKey=>{// We make this check because it's possible a dependency came from a prior session's cache (from durable store), but in the current
    // session we don't have a live Observable for this key yet.
    return !!this._getObservables(cacheKey);});}/**
         * Gets the observable for the CacheKey, creating one if necessary.
         * @param cacheKey The cache key for the Observable.
         * @param cacheValueTtl TTL of the value to be cached
         * @returns The core observables for the cache key.
         */getOrCreateObservables(cacheKey,cacheValueTtl){let observables=this._getObservables(cacheKey);if(observables===undefined){const keyString=serialize(cacheKey);const root=new Observable("RootObservable: "+keyString);const changesOnly=root.distinctUntilChanged((oldValueWrapper,newValueWrapper)=>{if(observables&&observables.changesOnly.subscriptions.size>0){// TODO: we may not need this subscriptions check anymore as it's being done in the observable transform functions (I think?).
    // Double check this and remove if possible.
    // If the changesOnly Observable has any subscriptions then do an actual equivalency check, otherwise
    // don't do an equivalency check for performance reasons.
    // TODO: W-4434441 - choose the best equivalency method based on the cache key's value type.
    // Compare the non-proxy, non-read-only values. Do this because traversing the entire value structure
    // of a proxy takes way too long.
    return equivalent(oldValueWrapper,newValueWrapper);}return false;});const finalTransformed=changesOnly.mapWithFilterOnSubscribeBehaviorSubject(value=>{let shouldEmit=false;if(this.timeSource.now()<value.lastFetchTime+cacheValueTtl){shouldEmit=true;}else {// TTL expired, we are refreshing the value, remove it from the set once the new value is back
    lastValueTracker.add(value);}return shouldEmit;},valueWrapper=>{return lwc.readonly(valueWrapper.value);});observables={root,changesOnly,finalTransformed};this._observablesMap.set(keyString,observables);}return observables;}/**
         * Registers a service associated to a specific value type with the cache.
         * @param service The service to register with the cache.
         *
         * @throws TransportResponse - Throws when a service has already been registered for the given valueType. This is a programmer error!
         */registerService(service){const valueTypes=service.getValueTypes();valueTypes.forEach(valueType=>{if(this._serviceRegistry.has(valueType)){throw getLdsInternalError("SERVICE_ALREADY_REGISTERED","A service has already been registered for valueType: "+service.getValueTypes().toString(),true);}this._serviceRegistry.set(valueType,service);});}/**
         * Returns the registered service for the given valueType, or throws an error if it is not found.
         * @param valueType The value type associated to the service to get.
         * @returns See description.
         *
         * @throws FetchResponse - Throws when a service is not found for the given valueType. This is a programmer error!
         */getService(valueType){const service=this._serviceRegistry.get(valueType);if(service===undefined){throw getLdsInternalError("SERVICE_NOT_FOUND","Could not find service for valueType: "+valueType.toString(),true);}return service;}/**
         * Returns the registered service for the given valueType, or undefined if it is not found.
         * @param valueType The value type associated to the service to get.
         * @returns See description.
         */getServiceOrUndefined(valueType){return this._serviceRegistry.get(valueType);}/**
         * @returns The dependency map. If it doesn't exist it will create it first.
         */getOrCreateDependencyMap(){{this._validateIsReady();}const cacheDepsCacheKey=buildCacheKey();let dependencyMapCacheValue=this.getValue(cacheDepsCacheKey);if(!dependencyMapCacheValue){dependencyMapCacheValue={dependencies:Object.create(null),dependenciesReverseLookup:Object.create(null)};this.put(cacheDepsCacheKey,dependencyMapCacheValue);}return dependencyMapCacheValue;}/**
         * Saves the given dependencyMap back into the cache.
         * @param dependencyMap The dependency map to save.
         */saveDependencyMap(dependencyMap){{this._validateIsReady();}const cacheDepsCacheKey=buildCacheKey();this.put(cacheDepsCacheKey,dependencyMap);}/**
         * Gets the observable for the CacheKey if one exists.
         * @param cacheKey The cache key for the Observable's value.
         * @returns The core observables for the cache key or undefined if there aren't any.
         */_getObservables(cacheKey){const keyString=serialize(cacheKey);return this._observablesMap.get(keyString);}/**
         * Deletes the observables identified by the given cacheKey.
         * @param cacheKey The key for the core observables.
         * @returns void
         */_deleteObservables(cacheKey){this._observablesMap.delete(serialize(cacheKey));}/**
         * Handles any value provider errors by doing the appropriate action on the given observable.
         * @param observable The observable to act on.
         * @param cacheKey The cache key associated with the value provider that threw an error.
         * @param readOnlyError The error wrapped in a read-only membrane.
         */_handleValueProviderError(observable,cacheKey,readOnlyError){observable.emitError(readOnlyError);this._deleteObservables(cacheKey);if(readOnlyError.status===404){// Remove object from cache and clear out the dependencies.
    try{this.evict(cacheKey);// this.clearDependencies(cacheKey);
    }catch(err){{// tslint:disable-next-line:no-console
    console.log(`Error evicting or clearing dependencies for cacheKey=${cacheKey}. err=${JSON.stringify(err)}`);}}}else {// log the error in development mode
    {// tslint:disable-next-line:no-console
    console.log("Exception encountered in value provider: ",readOnlyError);}}}/**
         * Returns true if an equal value provider is already in-flight (tracked), otherwise returns false and tracks the value provider
         * and cache key combination for the duration of a get() operation for the purpose of debouncing simultaneous equivalent get() operations.
         * @param cacheKey The cache key.
         * @param valueProvider The provider used to retrieve the value if it is not found in cache or needs to be refreshed.
         * @returns True if an equal value provider is already in flight (tracked), otherwise false.
         */_debounceOrTrackValueProvider(cacheKey,valueProvider){const keyString=serialize(cacheKey);const{_valueProviderDebounceMap}=this;let inFlightValueProviders=_valueProviderDebounceMap.get(keyString);if(inFlightValueProviders===undefined){inFlightValueProviders=new Set();_valueProviderDebounceMap.set(keyString,inFlightValueProviders);}const inFlightValueProvidersArray=Array.from(inFlightValueProviders);for(let len=inFlightValueProvidersArray.length,n=0;n<len;n++){const inFlightValueProvider=inFlightValueProvidersArray[n];if(valueProvider.equals(inFlightValueProvider)&&inFlightValueProvider.equals(valueProvider)){return true;}}inFlightValueProviders.add(valueProvider);return false;}/**
         * Stops tracking this in-flight value provider for the purpose of debouncing simultaneous equivalent get() operations.
         * @param cacheKey The cache key.
         * @param valueProvider The provider used to retrieve the value if it is not found in cache or needs to be refreshed.
         */_untrackValueProvider(cacheKey,valueProvider){const keyString=serialize(cacheKey);const{_valueProviderDebounceMap}=this;const inFlightValueProviders=_valueProviderDebounceMap.get(keyString);{assert$2(inFlightValueProviders!==undefined,`Expected to find tracked value providers for ${keyString}`);}if(inFlightValueProviders){inFlightValueProviders.delete(valueProvider);if(inFlightValueProviders.size===0){_valueProviderDebounceMap.delete(keyString);}}}/**
         * Takes a set of key string representations and a dependency map and builds a set of all the transitive dependencies for
         * this input (as key string representations). Note that the output may need to be further filtered because this doesn't account
         * for keys you might not want to return, because they are already part of a cache transaction for example.
         * @param keyStringsIterable The cache key string representations for which you want to get dependent keys.
         * @param dependencies The keys in the map are string representations of cache
         *      keys and the values are sets of string representations of cache keys. A given entry value (Set<string>) in
         *      the map represents the known cache keys that are affected when the value represented by the entry key in the
         *      map changes.
         * @return A set containing all of the transitive dependent keys as key string representations for the given
         *      cache key strings.
         */_getTransitiveDependencies(keyStringsIterable,dependencies){const transitiveDepsSet=new Set();const dependenciesEntryArrayToProcess=[];const keyStringsArray=Array.from(keyStringsIterable);for(let len=keyStringsArray.length,n=0;n<len;n++){const keyString=keyStringsArray[n];const nextSet=dependencies[keyString];if(nextSet){dependenciesEntryArrayToProcess.push(nextSet);}}while(dependenciesEntryArrayToProcess.length>0){const dependencySetMap=dependenciesEntryArrayToProcess.shift();if(dependencySetMap){const dependencySetMapArray=Array.from(dependencySetMap.entries());for(let len=dependencySetMapArray.length,n=0;n<len;n++){const[keyString]=dependencySetMapArray[n];if(!transitiveDepsSet.has(keyString)){transitiveDepsSet.add(keyString);const nextSet=dependencies[keyString];if(nextSet){dependenciesEntryArrayToProcess.push(nextSet);}}}}}return transitiveDepsSet;}/**
         * Clears dependencies and the reverse lookup for a given cacheKey. NOTE: Affected keys handlers for the given cacheKey MUST have already been
         * handled before calling this function, otherwise dependent values will not know that they are invalid.
         * Algorithm:
         * 1. Get the reverse lookup entry for cache key.
         * 2. For each item in the entry, lookup the corresponding entry in the dependencies and remove it. If it reduces the set to zero, also remove the entry itself.
         * 3. Remove the reverse lookup entry for cache key.
         * 4. Lookup dependency entry for cache key.
         * 5. For each item in the entry, get the corresponding entry in the reverse lookup and remove the cache key. If it reduces the set to zero, also remove the entry itself.
         * 6. Remove the dependency entry for cache key.
         * @param cacheKey The cacheKey for which to clear all dependencies.
         */_clearDependencies(cacheKey){{this._validateIsReady();}const key=serialize(cacheKey);const dependencyMap=this.getOrCreateDependencyMap();// * 1. Get the reverse lookup entry for cache key.
    const reverseLookupEntry=dependencyMap.dependenciesReverseLookup[key];// * 2. For each item in the entry, get the corresponding entry in the dependencies and remove the cache key. If it reduces the set to zero, also remove the entry itself.
    if(reverseLookupEntry){const reverseLookupEntryArray=Array.from(reverseLookupEntry);for(let i=0,len=reverseLookupEntryArray.length;i<len;++i){const lookupKey=reverseLookupEntryArray[i];const dependenciesEntryForLookupKey=dependencyMap.dependencies[lookupKey];if(dependenciesEntryForLookupKey){dependenciesEntryForLookupKey.delete(key);if(dependenciesEntryForLookupKey.size===0){delete dependencyMap.dependencies[lookupKey];}}}}// * 3. Remove the reverse lookup entry for cache key.
    delete dependencyMap.dependenciesReverseLookup[key];// * 4. Lookup dependency entry for cache key.
    const dependencyEntry=dependencyMap.dependencies[key];// * 5. For each item in the entry, get the corresponding entry in the reverse lookup and remove the cache key. If it reduces the set to zero, also remove the entry itself.
    if(dependencyEntry){const dependencyEntryArray=Array.from(dependencyEntry);for(let i=0,len=dependencyEntryArray.length;i<len;++i){const[lookupKey]=dependencyEntryArray[i];const lookupEntry=dependencyMap.dependenciesReverseLookup[lookupKey];if(lookupEntry){lookupEntry.delete(key);if(lookupEntry.size===0){delete dependencyMap.dependenciesReverseLookup[lookupKey];}}}}// * 6. Remove the dependency entry for cache key.
    delete dependencyMap.dependencies[key];this.saveDependencyMap(dependencyMap);}/**
         * Convenience function to retrieve an affected key handler function from the service associated to the given valueType.
         * @param valueType The value type associated with the affected key handler.
         * @returns The function that should handle affected cache keys with the provided value type when they
         *      have been affected by a value provider's cache changes.
         */_getAffectedKeyHandler(valueType){return this.getService(valueType).getAffectedKeyHandler();}/**
         * Throws an error if the underlying cache store is not ready yet.
         */_validateIsReady(){if(!this._cacheStore.isReady()){throw getLdsInternalError("INVALID_LDS_CACHE_ACCESS","Programmer Error: LDS Cache had attempted access before it was ready!",true);}}}/**
     * A base service implimentation of ILdsService. Services should extend this class.
     */class LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         * @param valueTypes The valueTypes which this services is associated.
         */constructor(ldsCache,valueTypes){this._ldsCache=ldsCache;this._valueTypes=valueTypes;}/**
         * By default all services are not persisted to durable storage.
         */isDurable(){return false;}/**
         * @returns The value type with which the service is associated.
         */getValueTypes(){return this._valueTypes;}/**
         * @returns The affected key handler for the service or null if the service doesn't need one (default).
         */getAffectedKeyHandler(){return null;}/**
         * This default implementation just returns the given value as is. If your service normalizes values
         * then you must override this method to properly denormalize it.
         * @param normalizedValue The normalized value to denormalize.
         * @returns The denormalized value.
         */denormalizeValue(normalizedValue,_cacheAccessor){return normalizedValue;}}/**
     * Used to directly access underlying the cache store(s) using during a single cache transaction.
     */class ValueProvider{/**
         * Constructs a new ValueProvider.
         * @param provideFn The function that will provide a new value.
         * @param parameters The parameters for this value provider.
         * @param equalsFn An optional function that will compare one value provider to another
         *      value provider and return true if they are equal. This is used to debounce value provider calls.
         */constructor(provideFn,parameters,equalsFn){this.parameters=parameters;this._provideFn=provideFn;this._equalsFn=equalsFn?equalsFn:otherValueProvider=>{const thisParamsString=JSON.stringify(this.parameters);const thatParamsString=JSON.stringify(otherValueProvider.parameters);return thisParamsString===thatParamsString;};}/**
         * Provides a Thenable that resolves to a ValueProviderResult marker. Along the way this should stage puts and do
         * other necessary cache operations against the CacheAccessor provided as a parameter.
         * @param cacheAccessor The relevant CacheAccessor for this function.
         * @returns The value provider result.
         */provide(cacheAccessor){return this._provideFn(cacheAccessor,this.parameters);}/**
         * An optional function that will compare this value provider to other value providers and return true if they are
         * equal. This is used to debounce value provider calls.
         * @param otherValueProvider Another value provider to compare this one against.
         * @returns True if the value providers are equal.
         */equals(otherValueProvider){return this._equalsFn.call(this,otherValueProvider);}}function toStoreMap(cacheMap){// serialize dependency map
    const depKey=serialize(buildCacheKey());const serializedDepMap=serializeDependencyMap(cacheMap.get(depKey));cacheMap.set(depKey,serializedDepMap);const storedMap={};cacheMap.forEach((value,keyString)=>{storedMap[keyString]=value;});return storedMap;}/**
     * serialize a dependency map using Array.from on Map and Set
     * @param input the dependency map
     */function serializeDependencyMap(input){const depKeys=Object.keys(input.dependencies);const revDepKeys=Object.keys(input.dependenciesReverseLookup);const out={dependencies:{},dependenciesReverseLookup:{}};for(let i=0,length=depKeys.length;i<length;++i){const key=depKeys[i];out.dependencies[key]=Array.from(input.dependencies[key]);}for(let i=0,length=revDepKeys.length;i<length;++i){const key=revDepKeys[i];out.dependenciesReverseLookup[key]=Array.from(input.dependenciesReverseLookup[key]);}return out;}// LDS Durable storage key
    const durableStoreKey="LDS.DURABLE_STORE";// Configure storage parameters here
    const DEFAULT_AURA_STORAGE={persistent:true,secure:true,maxSize:5*1024*1024,expiration:2592000,clearOnInit:false,debugLogging:false};const createDurableStorage=name=>{// See more about AuraStorage here:
    // https://git.soma.salesforce.com/aura/aura/blob/master/aura-impl/src/main/resources/aura/storage/AuraStorage.js
    // W-5920366: Choose a maxSize and expiration.
    const auraParams=Object.assign({},DEFAULT_AURA_STORAGE,{name});const auraStorage$1=auraStorage.initStorage(auraParams);if(auraStorage$1.isPersistent()!==true){auraStorage.deleteStorage(auraParams.name).catch(()=>{/* noop */});instrumentError(new Error("Storage instantiated by Aura is not persistent, disabling durable store"),"LDS_AURA_STORAGE_INIT_FAILURE",InstrumentationErrorType.ERROR);return undefined;}auraStorage$1.suspendSweeping();return auraStorage$1;};/**
     * Abstraction for reading and writing a CacheMap from disk. Uses auraStorage as the persistent store.
     */class DurableStoreAccessor{/*
         * Constructor.
         * @param storage: AuraStorage - uses AuraStorage for now until further requirements
         * @param writeBehindDelayMs: number - The number of milliseconds to wait before executing a write-behind.
         */constructor(auraStorage,writeBehindDelayMs){/**
             * Write behind buffer key string to value map.
             */this._writeBehindBuffer=new Map();this._auraStorage=auraStorage;this._writeBehindBufferFlushDelayMs=writeBehindDelayMs?writeBehindDelayMs:100;}/**
         * Loads the CacheMap from disk and returns it.
         * @returns A Promise resolving to the CacheMap from disk.
         */loadCache(){this._auraStorage.getSize().then(sizeInKb=>{const marker=markStart("LDS_DURABLE_STORE_BOOTSTRAP_CACHED_SIZE_Kb","root");marker.perfContext.count=sizeInKb;markEnd(marker);});return this._auraStorage.get(durableStoreKey);}/**
         * Saves the given cacheMap to disk in a write behind. Will not actually write it until the buffer is flushed.
         * @param cacheMap The CacheMap to save.
         */saveCache(cacheMap){this._writeBehindBuffer=cacheMap;this._scheduleWriteBehindBufferFlush();}/**
         * Sets the given pruning strategy to be used during cache load.
         * @param pruningStrategy The pruning strategy to be used during cache load.
         */setPruningStrategy(pruningStrategy){this._pruningStrategy=pruningStrategy;}/*
         * Causes the cache store's write-behind buffer to be flushed to Aura Storage Service. This includes puts and evicts.
         * Calling this more than once during the flush delay window will cause any already-scheduled flush to be canceled and
         * a new one to be scheduled in its place.
         */_scheduleWriteBehindBufferFlush(){if(this._writeBehindBufferFlushTimeoutId){// Cancel any existing flush if there is one.
    window.clearTimeout(this._writeBehindBufferFlushTimeoutId);}this._writeBehindBufferFlushTimeoutId=window.setTimeout(this.flush.bind(this),this._writeBehindBufferFlushDelayMs);}/**
         * Given a DependencyMap it will create a clone of it.
         * The Maps and Sets are not deeply cloned.
         * @param dependencyMap
         */cloneDependencyMap(input){// returned clone of DependencyMap
    const out={dependencies:{},dependenciesReverseLookup:{}};// clone dependencies first
    Object.keys(input.dependencies).forEach(key=>{out.dependencies[key]=new Map(input.dependencies[key]);});// clone reverse dependencies lookup
    Object.keys(input.dependenciesReverseLookup).forEach(key=>{out.dependenciesReverseLookup[key]=new Set(input.dependenciesReverseLookup[key]);});return out;}/**
         * Flushes whatever is in the buffer to disk.
         */flush(){service.perfStart("LDS");Thenable.resolve().then(()=>{const flushMarker=markStart("LDS_DURABLE_STORE_FLUSH","root");// shallow copy the buffer and prune its keys
    const cacheMap=new Map(this._writeBehindBuffer);// execute pruning strategy
    if(this._pruningStrategy){const markerPrunning=markStart("LDS_DURABLE_STORE_PRUNNING","root");const depMapKeyString=serialize(buildCacheKey());// first clone the dependency map so we do not affect current state
    const dependencyMap=this.cloneDependencyMap(cacheMap.get(depMapKeyString));// execute pruning strategy
    this._pruningStrategy.prune(cacheMap,dependencyMap);markEnd(markerPrunning);// set the new dependency map on the CacheMap
    cacheMap.set(depMapKeyString,dependencyMap);}// serialize and resolve
    const markerSerialize=markStart("LDS_DURABLE_STORE_SERIALIZE","root");const storedMap=toStoreMap(cacheMap);markEnd(markerSerialize);markEnd(flushMarker);if(storedMap){return this._auraStorage.set(durableStoreKey,storedMap);}service.perfEnd("LDS");}).catch(e=>{instrumentError(e,"LDS_DURABLE_STORE_FLUSH_ERROR",InstrumentationErrorType.ERROR);service.perfEnd("LDS");return e;}).then(e=>{this._writeBehindBufferFlushTimeoutId=undefined;if(!(e instanceof Error)){this._auraStorage.getSize().then(sizeInKb=>{const marker=markStart("LDS_DURABLE_STORE_FLUSH_SIZE_Kb","root");marker.perfContext.count=sizeInKb;markEnd(marker);service.perfEnd("LDS");});}});}}/**
     * Deserialize a persisted StoredMap into a CacheMap
     * @param storedMap
     */function toCacheMap(storedMap){// create CacheMap Map
    const cacheMap=new Map();// copy all POJOs
    Object.keys(storedMap).forEach(k=>{cacheMap.set(k,storedMap[k]);});// overwrite dependencyMap POJO with a deserialized version
    const dependencyMapKeyString=serialize(buildCacheKey());const serializedMap=storedMap[dependencyMapKeyString];cacheMap.set(dependencyMapKeyString,deserializeDependencyMap(serializedMap));return cacheMap;}/**
     * deserialize a dependency map object stored in DurableStore
     * @param serialized SerializedDependencyMap
     */function deserializeDependencyMap(input){const out=Object.create(null);out.dependencies=Object.create(null);out.dependenciesReverseLookup=Object.create(null);const keys=input?Object.keys(input.dependencies):[];keys.forEach(k=>{out.dependencies[k]=deserializeDependencyEntry(input.dependencies[k]);});out.dependenciesReverseLookup=deserializeReverseDependencyEntry(input.dependenciesReverseLookup);return out;}/**
     * deserialize a dependency entry for DependencyMap
     * @param entries SerializedDependency
     */function deserializeDependencyEntry(input){const out=new Map();for(let i=0,length=input.length;i<length;++i){const key=input[i][0];const value=input[i][1];out.set(key,value);}return out;}/**
     * deserialize a reverse dependency entry
     * @param entries { [key: string]: SerializedReverseDependency }
     */function deserializeReverseDependencyEntry(entries){const out=Object.create(null);Object.keys(entries).forEach(key=>{out[key]=new Set(entries[key]);});return out;}/**
     * A {@link CacheStore} implementation that is backed by an in memory map. This store's APIs return synchronous Thenables where possible.
     */class InMemoryCacheStore{/**
         * Constructor.
         * @param durableStoreAccessor Optional. If provided, backs the in memory cache with a durable store.
         */constructor(durableStoreAccessor){/**
             * Queued up callbacks
             */this.queuedAccessCallbacks=[];this.privateMap=new Map();this._isBootstrapping=true;this._durableStoreAccessor=durableStoreAccessor;}/**
         * @see {@link CacheStore#isDurable}.
         */isDurable(){return !!this._durableStoreAccessor;}/**
         * @see {@link CacheStore#bootstrap}.
         */bootstrap(){const{_durableStoreAccessor}=this;// Hydrate the in memory cache with durable store.
    if(!_durableStoreAccessor){this._isBootstrapping=false;return;}service.perfStart("LDS");const bootstrapMarker=markStart("LDS_DURABLE_STORE_BOOTSTRAP_TIME","root");_durableStoreAccessor.loadCache().catch(e=>{instrumentError(e,"LDS_DURABLE_STORE_INIT_FAILURE",InstrumentationErrorType.ERROR);return undefined;}).then(storedMap=>{if(storedMap){const marker=markStart("LDS_DURABLE_STORE_BOOTSTRAP_DESERIALIZE","root");// Assign to in memory.
    this.privateMap=toCacheMap(storedMap);markEnd(marker);}this._isBootstrapping=false;// Invoke any queued up callbacks that were waiting on the store to be ready.
    const markerCb=markStart("LDS_DURABLE_STORE_BOOTSTRAP_QUEUED_CALLBACKS","root");this.dequeueCallbacks();markerCb.perfContext.count=this.queuedAccessCallbacks.length;markEnd(markerCb);markEnd(bootstrapMarker);service.perfEnd("LDS");}).catch(e=>{this._isBootstrapping=false;const markerCb=markStart("LDS_DURABLE_STORE_BOOTSTRAP_QUEUED_CALLBACKS","root");this.dequeueCallbacks();markerCb.perfContext.count=this.queuedAccessCallbacks.length;markEnd(markerCb);instrumentError(e,"LDS_DURABLE_STORE_DESERIALIZE_FAILURE",InstrumentationErrorType.ERROR);service.perfEnd("LDS");});}/**
         * @see {@link CacheStore#access}.
         */access(callback){if(this.isReady()){return callback(this);}else {this.queuedAccessCallbacks.push(callback);}}/**
         * @see {@link CacheStore#isReady}.
         */isReady(){return !this._isBootstrapping;}/**
         * @see {@link CacheStore#put}.
         */put(cacheKey,value){this._validateIsReady();this._putInMemoryMap(cacheKey,value);if(this._durableStoreAccessor&&this.isReady()){this._durableStoreAccessor.saveCache(this.privateMap);}}/**
         * @see {@link CacheStore#putAll}.
         */putAll(cacheKeyToValueMap){this._validateIsReady();for(const[cacheKey,value]of cacheKeyToValueMap.entries()){this._putInMemoryMap(cacheKey,value);}if(this._durableStoreAccessor&&this.isReady()){this._durableStoreAccessor.saveCache(this.privateMap);}}/**
         * @see {@link CacheStore#evict}.
         */evict(cacheKey){this._validateIsReady();const keyString=serialize(cacheKey);const found=this.privateMap.has(keyString);if(found){this.privateMap.delete(keyString);}if(this._durableStoreAccessor&&this.isReady()){this._durableStoreAccessor.saveCache(this.privateMap);}return found;}/**
         * @see {@link CacheStore#get}.
         */get(cacheKey){this._validateIsReady();const keyString=serialize(cacheKey);const value=this.privateMap.get(keyString);if(value!==undefined){// Found it.
    // null and other non-undefined falsy values are ok.
    return value;}// Not found.
    return undefined;}/**
         * @see {@link CacheStore#getAll}.
         */getAll(cacheKeysArray){this._validateIsReady();const valuesMap=new Map();cacheKeysArray.forEach(cacheKey=>{const keyString=serialize(cacheKey);const value=this.privateMap.get(keyString);if(value!==undefined){// null and other non-undefined falsy values are ok.
    valuesMap.set(cacheKey,value);}});return valuesMap;}/**
         * @see {@link CacheStore#getNumberOfItems}.
         */getNumberOfItems(){this._validateIsReady();return this.privateMap.size;}dequeueCallbacks(){// Invoke any queued up callbacks that were waiting on the store to be ready.
    this.queuedAccessCallbacks.forEach(cb=>{cb(this);});this.queuedAccessCallbacks=[];}/**
         * Puts a value into the map that backs this in memory cache store.
         * @param cacheKey The key for the value.
         * @param value The value to put.
         */_putInMemoryMap(cacheKey,value){const keyString=serialize(cacheKey);this.privateMap.set(keyString,value);}/**
         * Internal access control enforcement to make sure applicable caching methods are not called before bootstrap is finished.
         */_validateIsReady(){if(!this.isReady()){throw getLdsInternalError("INVALID_CACHE_STORE_ACCESS","Programmer Error: Cache Store had attempted access before it was ready!",true);}}}/**
     * Default time source. Uses Date to measure time.
     */const defaultTimeSource={/**
         * @returns The current time as defined by Date.now().
         */now:()=>{return Date.now();}};/**
     * Pruning strategy which evicts values that are beyond their TTL.
     */class DurableStorePruningStrategy{/**
         * Constructor.
         * @param ldsCache Reference to LdsCache.
         */constructor(ldsCache){this._ldsCache=ldsCache;}/**
         * @see {@link PruningStrategy#prune}.
         */prune(cacheMap,dependencyMap){let updated=false;const markerSizeBefore=markStart("LDS_DURABLE_STORE_PRUNING_STRATEGY_BEFORE","root");markerSizeBefore.perfContext.count=cacheMap.size;markEnd(markerSizeBefore);cacheMap.forEach((_valueWrapper,key)=>{const cacheKey=deserialize(key);const service=this._ldsCache.getServiceOrUndefined(cacheKey.type);const shouldEvict=!service||!service.isDurable();if(shouldEvict){_evictHelper(cacheMap,dependencyMap,key);updated=true;}});const markerSizeAfter=markStart("LDS_DURABLE_STORE_PRUNING_STRATEGY_AFTER","root");markerSizeAfter.perfContext.count=cacheMap.size;markEnd(markerSizeAfter);return updated;}}/**
     * Helper function to evict a value and any ancestors that depend on it for denormalization. Appropriately updates the dependency map.
     *
     * Algorithm:
     * 1. Evict currentCacheKey.
     * 2. Get the reverse lookup entry for currentCacheKey.
     * 3. For each lookupKey, go to corresponding entry in dependencies and remove currentCacheKey from the set. If set is reduced to 0, remove the entry itself.
     * 4. Remove the reverse lookup entry.
     * 5. Lookup dependency entry for currentCacheKey.
     * 6. For each entry, recurse.
     * 7. Remove the dependency entry.
     * @param currentCacheKey The current cache key to be evicted.
     * @param currentCacheKeyString The current cache key to be evicted.
     * @param dependencyMap The dependencyMap to update.
     * @param cacheMap The cacheStore from which to evict values.
     */function _evictHelper(cacheMap,dependencyMap,currentCacheKeyString){// * 1. Evict currKey
    cacheMap.delete(currentCacheKeyString);// * Get the reverse lookup entry for currentCacheKey.
    const reverseLookupEntry=dependencyMap.dependenciesReverseLookup[currentCacheKeyString];// * 3. For each lookupKey, go to corresponding entry in dependencies and remove currKey from the set. If set is reduced to 0, remove the entry itself.
    if(reverseLookupEntry){const reverseLookupEntryArray=Array.from(reverseLookupEntry);for(let i=0,len=reverseLookupEntryArray.length;i<len;++i){const lookupKey=reverseLookupEntryArray[i];const lookupEntry=dependencyMap.dependencies[lookupKey];if(lookupEntry){lookupEntry.delete(currentCacheKeyString);if(lookupEntry.size===0){delete dependencyMap.dependencies[lookupKey];}}}}// * 4. Remove the reverse lookup entry.
    delete dependencyMap.dependenciesReverseLookup[currentCacheKeyString];// * 5. Lookup dependency entry for currKey
    const dependencyEntry=dependencyMap.dependencies[currentCacheKeyString];// * 6. For each entry with an evictable edge, recurse.
    if(dependencyEntry){const dependencyEntryArray=Array.from(dependencyEntry);for(let i=0,len=dependencyEntryArray.length;i<len;++i){const[lookupKey,dependencyInfo]=dependencyEntryArray[i];if(dependencyInfo.type===1/* REQUIRED */){_evictHelper(cacheMap,dependencyMap,lookupKey);}}}// * 7. Remove the dependency entry.
    delete dependencyMap.dependencies[currentCacheKeyString];}/**
     * The valueType to use when building RecordCacheKeys.
     */const RECORD_VALUE_TYPE="uiapi.RecordRepresentation";/**
     * Currently the refresh time in recordLibrary is 30 seconds, so we will keep it the same.
     * This is also the fresh time for actions so having it more consistent would cause the least confusing to our users.
     */const RECORD_TTL=1000*30;/**
     * The master record type id.
     */const MASTER_RECORD_TYPE_ID="012000000000000AAA";/**
     * MAX_DEPTH is the SOQL limit, so we don't denorm past MAX_DEPTH levels.
     */const MAX_DEPTH=5;/**
     * A set of the string names of known view entities. Having this hardcoded list is a hack
     * but there is no metadata yet available to tell us if something is a view, so here we are.
     * See: https://docs.google.com/document/d/17yKaultoME_HxcN-N8g6iaus00023QYI11USYgnODcY/edit.
     */const VIEW_ENTITY_API_NAMES=new Set(["AcceptedEventRelation","AccountPartner","AccountRecordUserAccess","AccountUserTerritory2View","ActivityHistory","AggregateResult","AllOrganization","AllOrganizationValue","AllPackageVersionLm","AllUsersBasic","ApexPackage","ApexPackageIdentifier","AssignmentRule","AttachedContentDocument","AttachedContentNote","AutoResponseRule","CaseStatus","CombinedAttachment","CombinedNote","ContentFolderItem","ContentHubRepository","ContentNote","ContractStatus","CrossOrgLimitUsageHistory","CrossOrgSite","CustomObjectFeed","DeclinedEventRelation","EscalationRule","EventAttendee","EventWhoRelation","FolderedContentDocument","FTestFieldMapping","FTestUnion","FtestViewInheriting","FtestViewNonInheriting","GenericRecordUserAccess","GlobalOrganization","InstalledSubscriberPackage","KnowledgeKeywordSearchHistory","KnowledgeSearchEventHistory","KnowledgeViewEventHistory","KnowledgeVoteEventHistory","LeadStatus","LookedUpFromActivity","MetadataPackage","MetadataPackageVersion","NewsFeed","NoteAndAttachment","OpenActivity","OpportunityPartner","OpportunityStage","OrganizationProperty","OwnedContentDocument","PackagePushError","PackagePushJob","PackagePushRequest","PackageSubscriber","PartnerRole","ProcessInstanceHistory","Project","PublicSolution","QueueMember","RecentlyViewed","RecordVisibility","ServiceAppointmentStatus","SolutionStatus","SubscriberPackage","SubscriberPackageVersion","TaskPriority","TaskStatus","TaskWhoRelation","UndecidedEventRelation","UserListPrefs","UserProfile","UserProfileFeed","UserRecordAccess","WorkOrderLineItemStatus","WorkOrderStatus"]);/**
     * A set of the string names of known ui-api supported entities.
     */const UIAPI_SUPPORTED_ENTITY_API_NAMES=new Set(["Account","AccountTeamMember","Asset","AssetRelationship","AssignedResource","AttachedContentNote","BusinessAccount","Campaign","CampaignMember","﻿CareBarrier","﻿CareBarrierType","Case","Contact","﻿ContactRequest","ContentDocument","ContentNote","ContentVersion","ContentWorkspace","Contract","ContractContactRole","ContractLineItem","Custom Object","Entitlement","EnvironmentHubMember","Lead","LicensingRequest","MaintenanceAsset","MaintenancePlan","MarketingAction","MarketingResource","Note","OperatingHours","Opportunity","OpportunityLineItem","OpportunityTeamMember","Order","OrderItem","PersonAccount","Pricebook2","PricebookEntry","Product2","Quote","QuoteDocument","QuoteLineItem","RecordType","ResourceAbsence","ResourcePreference","ServiceAppointment","ServiceContract","ServiceCrew","ServiceCrewMember","ServiceResource","ServiceResourceCapacity","ServiceResourceSkill","ServiceTerritory","ServiceTerritoryLocation","ServiceTerritoryMember","Shipment","SkillRequirement","SocialPost","Tenant","TimeSheet","TimeSheetEntry","TimeSlot","UsageEntitlement","UsageEntitlementPeriod","User","WorkOrder","WorkOrderLineItem","WorkType"]);/**
     * The valueType to use when building ObjectInfoCacheKey.
     */const OBJECT_INFO_VALUE_TYPE="uiapi.ObjectInfoRepresentation";/**
     * Time to live for the ObjectInfo cache value. 15 minutes.
     */const OBJECT_INFO_TTL=15*60*1000;/**
     * Builds the cache key using objectApiName.
     * @param objectApiName The objectApiName.
     * @returns A new cache key representing the ObjectInfo value type.
     */function buildCacheKey$1(objectApiName){return {type:OBJECT_INFO_VALUE_TYPE,key:`${objectApiName}`};}/**
     * Provides functionality to read object info data from the cache. Can refresh the data from the server.
     */class ObjectInfoService extends LdsServiceBase{constructor(ldsCache){super(ldsCache,[OBJECT_INFO_VALUE_TYPE]);}isDurable(){return true;}getCacheValueTtl(){return OBJECT_INFO_TTL;}/**
         * Gets an object info.
         * @param objectApiName The API name of the object to retrieve.
         * @returns An observable of the object info.
         */getObjectInfo(objectApiName){const objectApiNameString=getObjectApiName(objectApiName);const cacheKey=buildCacheKey$1(objectApiNameString);const valueProviderParameters={cacheKey,objectApiName:objectApiNameString};const valueProvider=this._getValueProvider(valueProviderParameters);return this._ldsCache.get(cacheKey,valueProvider);}/**
         * Stage puts the given object info.
         * @param dependencies List of dependent cache keys.
         * @param objectInfo The object info value to cache.
         * @param cacheAccessor An object to access cache directly.
         * @returns A Thenable which resolves when the stagePut has completed.
         */stagePutValue(dependencies,objectInfo,cacheAccessor){const objectInfoCacheKey=buildCacheKey$1(objectInfo.apiName);const existingValueWrapper=cacheAccessor.get(objectInfoCacheKey);const eTag=objectInfo.eTag;if(existingValueWrapper&&existingValueWrapper.eTag===eTag){cacheAccessor.stageDependencies(dependencies,objectInfoCacheKey);cacheAccessor.stagePutUpdateLastFetchTime(objectInfoCacheKey);return;}// Strip out the eTag from the value. We don't want to emit eTags!
    objectInfo=this.stripETagsFromValue(objectInfo);cacheAccessor.stagePut(dependencies,objectInfoCacheKey,objectInfo,objectInfo,{eTag});}/**
         * Strips all eTag properties from the given objectInfo by directly deleting them.
         * @param objectInfo The objectInfo from which to strip the eTags.
         * @returns The given objectInfo with its eTags stripped.
         */stripETagsFromValue(objectInfo){delete objectInfo.eTag;return objectInfo;}/**
         * Creates the ValueProvider for the ObjectInfo by taking ObjectInfoValueProviderParams as input
         * returns Value Provider instance of the objectInfo
         * @param valueProviderParams Parameters to create Value Provider for ObjectInfo
         */_getValueProvider(valueProviderParams){return new ValueProvider((cacheAccessor,valueProviderParameters)=>{const{cacheKey,objectApiName,localFreshObjectInfo,forceProvide}=valueProviderParameters;if(forceProvide){return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,localFreshObjectInfo);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;const needsRefresh=nowTime>lastFetchTime+OBJECT_INFO_TTL;if(needsRefresh){// Value is stale, get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,localFreshObjectInfo,existingValueWrapper.eTag);}// The value is not stale so it's a cache hit.
    return Thenable.resolve(1/* CACHE_HIT */);}// No existing value, get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,localFreshObjectInfo);},valueProviderParams);}hasValidCachedValue(cacheAccessor,params){const cacheKey=buildCacheKey$1(params.objectApiName);const existingValueWrapper=cacheAccessor.get(cacheKey);return !!existingValueWrapper&&existingValueWrapper.value!==undefined&&cacheAccessor.nowTime<=existingValueWrapper.lastFetchTime+OBJECT_INFO_TTL;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param cacheKey The cache key for the object info.
         * @param objectApiName The object API name for the object info.
         * @param localFreshObjectInfo A ObjectInfo value you want explicitly put into cache instead of getting the value from the server.
         * @param eTagToCheck eTag to send to the server to determine if we already have the latest value. If we do the server will return a 304.
         * @returns Returns a thenable of ValueProviderResult representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,cacheKey,objectApiName,localFreshObjectInfo,eTagToCheck){let transportResponseThenable;// If the objectInfo is provided, we don't go to the server to fetch it.
    if(localFreshObjectInfo){transportResponseThenable=Thenable.resolve(getOkFetchResponse(localFreshObjectInfo));}else {const params={objectApiName};if(eTagToCheck){params.clientOptions={eTagToCheck};}{transportResponseThenable=aggregateUiExecutor.executeSingleRequestOverAggregateUi("getObjectInfo",params,OBJECT_INFO_TTL);}}return transportResponseThenable.then(transportResponse=>{// Cache miss refresh unchanged.
    if(transportResponse.status===304){return 3/* CACHE_MISS_REFRESH_UNCHANGED */;}const freshValue=transportResponse.body;cacheAccessor.stageClearDependencies(cacheKey);this.stagePutValue([],freshValue,cacheAccessor);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}}const{isArray}=Array;/**
     * Map between target values and refresh promise function
     */const wiredTargetValueToConfigMap=new WeakMap();/**
     * Generates a new wire adapter.
     * @param service Function to invoke, with the resolved configuration, to get an observable or undefined.
     * @returns The new wire adapter.
     */function generateWireAdapter(service){return wiredEventTarget=>{let subscription;let config;// initialize the wired property with a properly shaped object so cmps can use <template if:true={wiredProperty.data}>
    wiredEventTarget.dispatchEvent(new wireService.ValueChangedEvent({data:undefined,error:undefined}));function unsubscribe(){if(subscription){subscription.unsubscribe();subscription=undefined;}}const refreshCallback=()=>{return new Promise((resolve,reject)=>{const metaConfig={forceProvide:true,finishedCallbacks:{successCallback:resolve,errorCallback:reject}};service(config,metaConfig);});};const observer={next:data=>{const wiredTargetValue={data,error:undefined};wiredTargetValueToConfigMap.set(wiredTargetValue,refreshCallback);wiredEventTarget.dispatchEvent(new wireService.ValueChangedEvent(wiredTargetValue));},error:error=>{const wiredTargetValue={data:undefined,error};wiredTargetValueToConfigMap.set(wiredTargetValue,refreshCallback);wiredEventTarget.dispatchEvent(new wireService.ValueChangedEvent(wiredTargetValue));unsubscribe();},complete:unsubscribe};wiredEventTarget.addEventListener("connect",()=>{// if already subscribed or no config set then noop
    if(subscription||!config){return;}// no subscription (eg was disconnected so subscription released) so get a new one
    const serviceResult=service(config);if(serviceResult){if(serviceResult.then){const thenable=serviceResult;thenable.then(observable=>{if(observable){subscription=observable.subscribe(observer);}}).catch(err=>{if(observer.error){observer.error(err);}});}else {const observable=serviceResult;subscription=observable.subscribe(observer);}}});wiredEventTarget.addEventListener("disconnect",()=>{unsubscribe();});wiredEventTarget.addEventListener("config",newConfig=>{config=newConfig;unsubscribe();const serviceResult=service(config);if(serviceResult){if(serviceResult.then){const thenable=serviceResult;thenable.then(observable=>{if(observable){subscription=observable.subscribe(observer);}}).catch(err=>{if(observer.error){observer.error(err);}});}else {const observable=serviceResult;subscription=observable.subscribe(observer);}}});};}/**
     * Gets a standard error message for imperative invocation not being supported.
     * @param id The adapter id.
     * @returns Error object to be thrown.
     */function generateError(id){return new Error(`Imperative use is not supported. Use @wire(${id}).`);}/**
     * Checks for the Map containing refreshAdaptor Promise and invokes the promise if exist
     * @param wiredTargetValue {data:..,error:..} Wired value returned by adapter
     * @returns Promise which either resolves in the Promise to fetch the refresh Value or error if adapter does not support refresh
     */function refreshWireAdapter(wiredTargetValue){wiredTargetValue=lwc.unwrap(wiredTargetValue);const refreshPromise=wiredTargetValueToConfigMap.get(wiredTargetValue);if(refreshPromise){return refreshPromise();}{throw new Error("Refresh failed because resolved configuration is not available.");}}/**
     * Validates an @wire config is well-formed.
     * @param id The adapter id.
     * @param config The @wire config to validate.
     * @param required The keys the config must contain.
     * @param supported The keys the config may contain.
     * @param unsupported The keys the config must not contain.
     * @param oneof The keys the config must contain at least one of.
     * @throws An error if config doesn't satisfy the provided key sets.
     */function validateConfig$1(id,config,required,supported,unsupported,oneof){if(required.some(req=>!(req in config))){throw new Error(`@wire(${id}) configuration must specify ${required.join(", ")}`);}if(oneof&&!oneof.some(req=>req in config)){throw new Error(`@wire(${id}) configuration must specify one of ${oneof.join(", ")}`);}if(unsupported&&unsupported.some(req=>req in config)){throw new Error(`@wire(${id}) configuration must not specify ${unsupported.join(", ")}`);}if(Object.keys(config).some(key=>!supported.includes(key))){throw new Error(`@wire(${id}) configuration supports only ${supported.join(", ")}`);}}/**
     * Converts a value to an array. If the value is null/undefined, an empty array is returned.
     * @param value The value to convert to an array.
     * @returns value if it's an array; an empty array if value is null/undefined; otherwise value wrapped in an array.
     */function toArray(value){if(isArray(value)){return value;}if(value!=null){return [value];}return [];}/**
     * @param value The array to inspect.
     * @returns True if the array is non-empty and contains only non-empty strings.
     */function isArrayOfNonEmptyStrings(value){if(value.length===0){return false;}return value.every(v=>typeof v==="string"&&v.trim().length>0);}/**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @return The qualified field API name.
     */function getFieldApiName$1(value){if(typeof value==="string"){return value;}else if(value&&typeof value.objectApiName==="string"&&typeof value.fieldApiName==="string"){return value.objectApiName+"."+value.fieldApiName;}return undefined;}/**
     * Wire adapter id: getObjectInfo.
     * @throws Always throws an error when invoked. Imperative invocation is not supported.
     */function getObjectInfo(){throw generateError("getObjectInfo");}/**
     * Generates the wire adapter for Object Info.
     */class ObjectInfoWireAdapterGenerator{/**
         * Constructor.
         * @param objectInfoService Reference to the ObjectInfoService instance.
         */constructor(objectInfoService){this._objectInfoService=objectInfoService;}/**
         * Generates the wire adapter for @wire getObjectInfo.
         * @returns See description
         */generateGetObjectInfoWireAdapter(){const wireAdapter=generateWireAdapter(this.serviceGetObjectInfo.bind(this));return wireAdapter;}/**
         * @private Made public for testing.
         * Services getObjectInfo @wire.
         * @param config contains objectApiName
         * @returns Observable stream that emits an object info.
         */serviceGetObjectInfo(config){if(!config){return undefined;}{const required=["objectApiName"];const supported=["objectApiName"];validateConfig$1("getObjectInfo",config,required,supported);}if(!config.objectApiName){return undefined;}return this._objectInfoService.getObjectInfo(config.objectApiName);}}/**
     * CacheAccessorWrapper that can track records and object-infos to use to inform recordLibrary where appropriate during commitPuts().
     */class RecordCacheAccessorWrapper{/**
         * Constructor
         * @param cacheAccessor Cache Accessor of LDS Cache.
         * @param adsBridge Ads Bridge ref to inform ADS about records.
         */constructor(cacheAccessor,adsBridge){/**
             * Map of records to inform the ADS cache.
             */this._recordsToInform=new Map();/**
             * Map of object-infos to inform the ADS.
             */this._objectInfos=new Map();this._cacheAccessor=cacheAccessor;this._adsBridge=adsBridge;}/**
         * current time from CacheAccessor.
         * @returns current time from CacheAccessor.
         */get nowTime(){return this._cacheAccessor.nowTime;}/**
         * Returns the Thenable containing ValueWrapper from the cache.
         * @param cacheKey Cachekey for the object in the cache.
         * @returns The value from the cache or undefined if not found.
         */get(cacheKey){return this._cacheAccessor.get(cacheKey);}/**
         * Returns the ValueWrapper for the cachekey.
         * @param cacheKey Cachekey for the object in the cache.
         * @returns ValueWrapper from the cache.
         */getCommitted(cacheKey){return this._cacheAccessor.getCommitted(cacheKey);}/**
         * Stage put the values using cacheAccessor.
         * @param dependencies Dependent keys for which this value to be cached is dependent on.
         * @param cacheKey Cachekey for the object in the cache.
         * @param valueToCache Value to cache in the LDS.
         * @param valueToEmit Value to emit.
         * @param optionalValueWrapperParams Extra Params need to normalize this value in the cache.
         * @param valueWrapperToEmitExtraInfoObject Object with properties to set on the emitted ValueWrapper.extraInfoObject.
         */stagePut(dependencies,cacheKey,valueToCache,valueToEmit,optionalValueWrapperParams,valueWrapperToEmitExtraInfoObject){const type=cacheKey.type;if(type===OBJECT_INFO_VALUE_TYPE&&valueToEmit!==null){this._objectInfos.set(valueToEmit.apiName,valueToEmit);}else if(type===RECORD_VALUE_TYPE){// Note, when a record is staged more than once (multiple nested instances of the same record) the latest record
    // should be the most merged and should be the most complete, and overwriting it in the map lets that one win.
    this._recordsToInform.set(valueToEmit.id,valueToEmit);}this._cacheAccessor.stagePut(dependencies,cacheKey,valueToCache,valueToEmit,optionalValueWrapperParams,valueWrapperToEmitExtraInfoObject);}/**
         * Invokes CacheAccessor's stagePutUpdateLastFetchTime.
         * @param cacheKey Cachekey for the object in the cache.
         */stagePutUpdateLastFetchTime(cacheKey){this._cacheAccessor.stagePutUpdateLastFetchTime(cacheKey);}/**
         * Invokes CacheAccessor's stageDependencies with the values passed, take a look at CacheAccessor for more information.
         * @param dependencies Dependent keys for which this value to be cached is dependent on.
         * @param cacheKey Cachekey for the object in the cache.
         */stageDependencies(dependencies,cacheKey){return this._cacheAccessor.stageDependencies(dependencies,cacheKey);}/**
         * Clear the dependencies for the cacheKey passed.
         * @param cacheKey Cachekey for the object in the cache.
         */stageClearDependencies(cacheKey){return this._cacheAccessor.stageClearDependencies(cacheKey);}/**
         * Invokes the commitPuts of CacheAccessor, inform the ADS using adsbridge and returns the affected Keys.
         * @returns The set of cache keys that are affected by the commit.
         */commitPuts(){const affectedKeys=this._cacheAccessor.commitPuts();const recordsToInformArray=Array.from(this._recordsToInform.values());for(let len=recordsToInformArray.length,n=0;n<len;n++){const record=recordsToInformArray[n];const objectInfoIfAvailable=this._objectInfos.get(record.apiName);this._adsBridge.informRecordLib(record,objectInfoIfAvailable);// If we have an object info then great, otherwise, let this retrieve it if necessary.
    }return affectedKeys;}/**
         * Invokes the CacheAccessor's stageEmit.
         * @param cacheKey Cachekey for the object in the cache.
         * @param valueToEmit ValueWrapper of the value to be emitted.
         */stageEmit(cacheKey,valueToEmit){return this._cacheAccessor.stageEmit(cacheKey,valueToEmit);}/**
         * Invokes the CacheAccessor's isEmitStaged and returns true if the value for the cacheKey is staged for emit.
         * @param cacheKey Cachekey for the object in the cache.
         * @returns True if an emit is staged for the given cacheKey, else false.
         */isEmitStaged(cacheKey){return this._cacheAccessor.isEmitStaged(cacheKey);}/**
         *  method that returns the number of staged emits from staging puts and emits.
         *  @returns the number of staged emits from staging puts and emits.
         */get stagedEmitsCount(){return this._cacheAccessor.stagedEmitsCount;}/**
         * Gets the observables for the CacheKey, creating them if necessary.
         * @param cacheKey The cache key for the Observable.
         * @returns The observables for the cache key.
         */getOrCreateObservables(cacheKey){return this._cacheAccessor.getOrCreateObservables(cacheKey,RECORD_TTL);}/**
         * Makes a new immutable ValueWrapper with a lastFetchTime consistent with the rest of the CacheAccessor transaction. Optionally an
         * eTag may be provided (if available), as can an arbitrary Object containing information the ValueProvider may desire during a
         * future cache transaction.
         * @param valueToCache The value to be cached required (must not be undefined). This should not be an already wrapped
         *      value (instanceof ValueWrapper).
         * @param eTagOverride The eTag to be set on the ValueWrapper.
         * @param extraInfoObject An arbitrary object that ValueProviders may use to store additional information about the value being
         *      cached.
         * @returns The provided params wrapped in an immutable ValueWrapper.
         */newValueWrapper(valueToCache,eTagOverride,extraInfoObject){return this._cacheAccessor.newValueWrapper(valueToCache,eTagOverride,extraInfoObject);}}const SYSTEM_MODSTAMP="SystemModstamp";const DISPLAY_VALUE="displayValue";/**
     * Builds the cache key for type filtered record.
     * @param recordId
     * @param requiredFields  List of required fields.
     * @param optionalFields List of optional fields
     * @returns A new cache key representing the RECORD_VALUE_TYPE value type.
     */function buildFilteredRecordObservableKey(recordId,requiredFields,optionalFields){const fields=collectionToArray(requiredFields).sort().join(",");const optional=collectionToArray(optionalFields).sort().join(",");return {type:RECORD_VALUE_TYPE,key:`${recordId}${KEY_DELIM}${fields}${KEY_DELIM}${optional}`};}/**
     * Builds the cache key for record.
     * @param recordId The record id.
     * @returns  A new CacheKey which represents a RECORD_VALUE_TYPE.
     */function buildRecordCacheKey(recordId){{assert$2(recordId.length===18,"Record Id length should be 18 characters.");}return {type:RECORD_VALUE_TYPE,key:`${recordId}`};}/**
     * Tells you if an objectApiName is that of a known view entity. Note: LDS does not currently support view entities, so this
     * method can be used to make sure they don't end up in the cache. If they are cached without proper support they can "stomp"
     * other records of a primary entity because they often share IDs.
     * @param objectApiName the object API name from a record.
     * @return True if the provided objectApiName is that of a known view entity.
     */function isKnownViewEntity(objectApiName){return VIEW_ENTITY_API_NAMES.has(objectApiName);}/**
     * Tells you if an objectApiName is supported by UI API or not.
     * Note: LDS does not currently support all the entities, the list is limited to UI API supported entities
     * @param objectApiName the object API name from a record.
     * @return True if the provided objectApiName is supported in UI API.
     */function isSupportedEntity(objectApiName){return objectApiName.endsWith("__c")||UIAPI_SUPPORTED_ENTITY_API_NAMES.has(objectApiName);}/**
     * Used to check if SystemModstamps are present and different for the given records.
     * @param firstRecord The first record.
     * @param secondRecord The second record.
     * @returns false if SystemModstamp values exist in both records and are same.
     *          true if SystemModstamp values exist in both records and are different OR one or both record's
     *          systemModstamp do not have a value.
     */function systemModstampsAreDifferent(firstRecord,secondRecord){// treat systemModstamp being null/undefined as being present and different and thereby return true
    // entities like ContentNote(and may be a few more entities) do not have a systemModstamp and thereby the value will be null
    return firstRecord.systemModstamp==null&&secondRecord.systemModstamp==null||firstRecord.systemModstamp!==secondRecord.systemModstamp;}/**
     * Recursively get spanning records within record.
     * @param record The record from which we want to retrieve spanning records.
     * @param records Set of records passed from recursive call
     * @returns Set containing all spanning record Ids.
     */function getSpanningRecords(record,records){function checkSpanning(fieldValue){// this is going to check if the provided value is a spanning field
    // we don't want to count polymorphic Owner as a spanning field so it never gets replaced by wrong user record
    return isRecordRepresentation(fieldValue)&&fieldValue.apiName!=="Name";}if(!records){records=new Set();}if(checkSpanning(record)){const recordFields=record.fields;const recordFieldNamesArray=Object.keys(recordFields);for(let len=recordFieldNamesArray.length,n=0;n<len;n++){// we should add assert here to make sure that every field has a value
    const fieldValue=recordFields[recordFieldNamesArray[n]].value;if(fieldValue&&checkSpanning(fieldValue)){records.add(fieldValue);getSpanningRecords(fieldValue,records);}}}return records;}/**
     * Checks that for all field values in sourceRecord is same as targetRecord except for SystemModstamp and spanned record.
     * @param sourceRecord record to iterate over all fields and check value against target
     * @param targetRecord targetRecord
     * @return true if record is same (as explained in description)
     */function areFieldsEqualForRecords(sourceRecord,targetRecord){return Object.keys(sourceRecord).every(prop=>{if(prop!==SYSTEM_MODSTAMP&&prop!==DISPLAY_VALUE&&!isTypeOfLdsRecord(sourceRecord[prop])&&targetRecord[prop]){if(sourceRecord[prop]===targetRecord[prop]){return true;}if(isRecordRepresentation(sourceRecord[prop])&&isRecordRepresentation(targetRecord[prop])){return areFieldsEqualForRecords(sourceRecord[prop],targetRecord[prop]);}else {return false;}}return true;});}/**
     * Checks that passed object is record or spanned record (in LDS spanned record has marker(true) with id for actual record entry).
     * @param obj Record(normalized or de/normalized object
     * @return true if object is record or spanned record to its parent
     */function isTypeOfLdsRecord(obj){return isRecordRepresentation(obj)||isRecordMarker(obj);}/**
     * Merges two record markers, taking the depth of the shallower marker.
     * Note: this can't be in record-marker-utils, causes a loop.
     * @param sourceMarker The source marker which may have different values.
     * @param targetMarker The marker to change if there are different values in the source marker.
     * @returns True if any changes were made to the target marker, otherwise false.
     */function mergeRecordMarkers(sourceMarker,targetMarker){let changesMade=false;if(targetMarker.id!==sourceMarker.id){targetMarker.id=sourceMarker.id;changesMade=true;}if(targetMarker.recordTypeId!==sourceMarker.recordTypeId){targetMarker.recordTypeId=sourceMarker.recordTypeId;changesMade=true;}if(targetMarker.depth!==sourceMarker.depth){targetMarker.depth=Math.min(sourceMarker.depth,targetMarker.depth);changesMade=true;}const sourceFields=sourceMarker.fields;const targetFields=targetMarker.fields;let fieldsChanged=false;if(changesMade&&targetFields.length!==sourceFields.length){targetMarker.fields=sourceFields;fieldsChanged=true;}else {for(let c=0;c<sourceFields.length;++c){const sourceField=sourceFields[c];if(!targetFields.includes(sourceField)){targetFields.push(sourceField);fieldsChanged=true;}}}changesMade=changesMade||fieldsChanged;return changesMade;}/**
     * Applies any changes in the sourceRecord to the targetRecord if it would result in a change to the targetRecord. This will
     * not copy over new eTag properties (ignores them) and if any other changes are made, it will clear the eTag property in the
     * targetRecord because it has been rendered useless.
     * @param sourceRecord A record that may have different values.
     * @param targetRecord The record to change if there are different values in the source record.
     * @returns true if any changes were made to the targetRecord.
     */function deepRecordCopy(sourceRecord,targetRecord){let changesMade=false;const sourceRecordKeysArray=Object.keys(sourceRecord);for(let len=sourceRecordKeysArray.length,n=0;n<len;n++){const recordProp=sourceRecordKeysArray[n];const targetRecordPropValue=targetRecord[recordProp];// TODO: Remove this hack when W-5775123 is done
    if(recordProp==="recordTypeInfo"){if(!sourceRecord[recordProp]&&targetRecord[recordProp]){continue;}else if(sourceRecord[recordProp]&&!targetRecord[recordProp]){targetRecord[recordProp]=sourceRecord[recordProp];changesMade=true;}}if(targetRecordPropValue&&typeUtils.isPlainObject(targetRecordPropValue)){if(isRecordMarker(targetRecordPropValue)&&isRecordMarker(sourceRecord[recordProp])){const markerChangesMade=mergeRecordMarkers(sourceRecord[recordProp],targetRecordPropValue);changesMade=changesMade||markerChangesMade;}else if(isRecordMarker(targetRecordPropValue)&&!isRecordMarker(sourceRecord[recordProp])){changesMade=true;targetRecord[recordProp]=sourceRecord[recordProp];}else {const deepChangesMade=deepRecordCopy(sourceRecord[recordProp],targetRecord[recordProp]);changesMade=changesMade||deepChangesMade;}}else if(recordProp!=="eTag"&&targetRecord[recordProp]!==sourceRecord[recordProp]){changesMade=true;targetRecord[recordProp]=sourceRecord[recordProp];}}if(changesMade&&isRecordRepresentation(targetRecord)){// If a record has been merged we can no longer use its ETag -- it will no longer be correct.
    delete targetRecord.eTag;}return changesMade;}/**
     * Returns the record type id contained in the given record. If the record doesn't have that info, it will
     * return the MASTER_RECORD_TYPE_ID.
     * @param record The record from which to extract the record type id.
     * @returns recordTypeId of the record.
     */function getRecordTypeIdFromRecord(record){return record.recordTypeInfo&&record.recordTypeInfo.recordTypeId||MASTER_RECORD_TYPE_ID;}/**
     * Returns a new object that has a list of fields that has been filtered by edited fields. Only contains fields that have been
     * edited from their original values (excluding Id which is always copied over.)
     * @param recordInput The uiapi.RecordInput object to filter.
     * @param originalRecord The Record object that contains the original field values.
     * @returns uiapi.RecordInput, see the description
     */function createRecordInputFilteredByEditedFields(recordInput,originalRecord){const filteredRecordInput=getRecordInput();// Always copy over any existing id.
    if(originalRecord.id){filteredRecordInput.fields.Id=originalRecord.id;}const recordInputFields=recordInput.fields;const originalRecordFields=originalRecord.fields;const recordInputFieldPropertyNames=Object.getOwnPropertyNames(recordInputFields);for(let len=recordInputFieldPropertyNames.length,n=0;n<len;n++){const fieldName=recordInputFieldPropertyNames[n];let originalRecordFieldsEntry;if(originalRecordFields){originalRecordFieldsEntry=originalRecordFields[fieldName];}if(!originalRecordFieldsEntry||originalRecordFields&&recordInputFields[fieldName]!==originalRecordFieldsEntry.value){filteredRecordInput.fields[fieldName]=recordInputFields[fieldName];}}return filteredRecordInput;}/**
     * Returns an object with its data populated from the given record. All fields with values that aren't nested records will be assigned.
     * This object can be used to create a record.
     * @param record The record that contains the source data.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record. If provided, only fields that are createable=true
     *        (excluding Id) will be assigned to the object return value.
     * @returns uiapi.RecordInput See description.
     */function generateRecordInputForCreate(record,objectInfo){const recordInput=_generateRecordInput(record,true,objectInfo);recordInput.apiName=record.apiName;// fields.Id is not required for CREATE which might have been copied over, so delete fields.Id
    delete recordInput.fields.Id;return recordInput;}/**
     * Returns an object with its data populated from the given record. All fields with values that aren't nested records will be assigned.
     * This object can be used to update a record.
     * @param record The record that contains the source data.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that are updateable=true (excluding Id) will be assigned to the object return value.
     * @returns uiapi.RecordInput See description.
     */function generateRecordInputForUpdate(record,objectInfo){const recordInput=_generateRecordInput(record,false,objectInfo);if(!record.id){throw new Error("record must have id for update");}// Always copy over any existing id.
    recordInput.fields.Id=record.id;return recordInput;}/**
     * Gets the cache key for the given record.
     * @param record The record for which to get the cache key.
     * @returns The CacheKey for the record.
     */function getRecordCacheKey(record){return buildRecordCacheKey(record.id);}/**
     * Returns an object with its data populated from the given record. All fields with values that aren't nested records will be assigned.
     * @param record The record that contains the source data.
     * @param create used to decide whether to use updateable or createable flag in objectInfo.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that are updateable=true (excluding Id) will be assigned to the object return value.
     * @returns uiapi.RecordInput
     */function _generateRecordInput(record,create,objectInfo){const recordInput=getRecordInput();const recordFields=record.fields;let objectInfoFields;if(objectInfo){objectInfoFields=objectInfo.fields;}// Copy fields. If they provided an objectInfo, only copy over updateable fields.
    const recordFieldPropertyNames=Object.getOwnPropertyNames(recordFields);for(let len=recordFieldPropertyNames.length,n=0;n<len;n++){const fieldName=recordFieldPropertyNames[n];const recordFieldsFieldNameEntry=recordFields[fieldName].value;if(objectInfoFields){const objectInfoFieldsFieldNameValue=objectInfoFields[fieldName];if(objectInfoFieldsFieldNameValue){if(create){if(objectInfoFieldsFieldNameValue.createable===true){recordInput.fields[fieldName]=recordFieldsFieldNameEntry;}}else if(objectInfoFieldsFieldNameValue.updateable===true){recordInput.fields[fieldName]=recordFieldsFieldNameEntry;}}}else {recordInput.fields[fieldName]=recordFieldsFieldNameEntry;}}return recordInput;}/**
     * Gets a new Record Input.
     */function getRecordInput(){return {apiName:undefined,fields:{}};}/**
     * Gets a field's value from a record.
     * @param record The record.
     * @param field The qualified API name of the field to return.
     * @returns The field's value (which may be a record in the case of spanning fields), or undefined if the field isn't found.
     */function getFieldValue(record,field){const unqualifiedField=splitQualifiedFieldApiName(getFieldApiName(field))[1];const fields=unqualifiedField.split(".");let r=record;while(fields.length>0&&r&&r.fields){const f=fields.shift();const fvr=r.fields[f];if(fvr===undefined){return undefined;}else {r=fvr.value;}}return r;}/**
     * Gets a field's display value from a record.
     * @param record The record.
     * @param field The qualified API name of the field to return.
     * @returns The field's display value, or undefined if the field isn't found.
     */function getFieldDisplayValue(record,field){const unqualifiedField=splitQualifiedFieldApiName(getFieldApiName(field))[1];const fields=unqualifiedField.split(".");let r=record;while(r&&r.fields){const f=fields.shift();const fvr=r.fields[f];if(fvr===undefined){return undefined;}else if(fields.length>0){r=fvr.value;}else {return fvr.displayValue;}}return r;}/**
     * Examines an object to see if it appears to be a normalization marker.
     * Note this can't be included in record-marker-utils because that would cause a loop
     * between that class and record-service-utils.
     * @param object An object to inspect to see if it is a record marker.
     * @returns True if the provided object is a marker for a record, otherwise false.
     */function isRecordMarker(object){return object&&object.___marker&&object.id&&object.fields!==undefined;}/**
     * Returns a wrapper for a CacheAccessor that can track records and object infos to use to inform recordLibrary where appropriate during
     * commitPuts().
     * TODO: W-5043986 - Formalize this as a real type.
     * @param cacheAccessor The cache accessor to wrap.
     * @param adsBridgeObj
     * @returns A wrapper for a CacheAccessor that can track records and object infos to use to inform recordLibrary where appropriate during
     *                   commitPuts().
     */function wrapCacheAccessor(cacheAccessor,adsBridgeObj){return new RecordCacheAccessorWrapper(cacheAccessor,adsBridgeObj);}/**
     * Given an array of markers representing normalized record values, this returns a Thenable that resolves to an array of the denormalized records.
     * This is intended to be used during denormalization, and is preferred over simply iterating over fromRecordMarker() because it can do some
     * optimizations like only denormalizing a given record once.
     * @param recordService The recordService instance.
     * @param cacheAccessor The CacheAccessor in scope for this operation.
     * @param recordMarkerArray The record marker representing a normalized record.
     * @returns An array of the denormalized records (or undefined if a particular record could not be denormalized).
     */function fromRecordMarkers(recordService,cacheAccessor,recordMarkerArray){const markersMap=new Map();const denormalizedRecordsArray=[];// Figure out how deep we have to denorm each record, accounting for the fact that it could show up more than
    // once in the list. Store everything in a map so we dedup the records we need to denorm.
    for(let c=0;c<recordMarkerArray.length;++c){const recordMarker=recordMarkerArray[c];const recordId=recordMarker.id;const lastMarker=markersMap.get(recordId);if(lastMarker===undefined){markersMap.set(recordMarker.id,recordMarker);}else if(recordMarker.depth<lastMarker.depth){markersMap.set(recordMarker.id,recordMarker);}}for(const value of markersMap.values()){denormalizedRecordsArray.push(fromRecordMarker(recordService,cacheAccessor,value));}const denormalizedRecordsMap=new Map();const finalDenormalizedRecordsArray=[];// Re-index the denormalized records into a map.
    for(let c=0;c<denormalizedRecordsArray.length;++c){const denormalizedRecord=denormalizedRecordsArray[c];if(denormalizedRecord){denormalizedRecordsMap.set(denormalizedRecord.id,denormalizedRecord);}}// Pluck the records out of the map and put them back in the same order as the original recordMarkerArray.
    for(let c=0;c<recordMarkerArray.length;++c){const recordMarker=recordMarkerArray[c];finalDenormalizedRecordsArray.push(denormalizedRecordsMap.get(recordMarker.id));}return finalDenormalizedRecordsArray;}/**
     * Given a marker representing a normalized record value, this returns a Thenable that resolves to the denormalized record. This is intended
     * to be used during denormalization.
     * @param recordService The recordService instance.
     * @param cacheAccessor The CacheAccessor in scope for this operation.
     * @param recordMarker The record marker representing a normalized record.
     * @returns The denormalized record or undefined if it could not be denormalized.
     */function fromRecordMarker(recordService,cacheAccessor,recordMarker){const cacheKey=buildRecordCacheKey(recordMarker.id);const normalizedRecordValueWrapper=cacheAccessor.get(cacheKey);if(normalizedRecordValueWrapper){const markerFieldNames=getUnqualifiedFieldNamesFromRecordMarker(recordMarker);try{const denormalizedRecord=recordService.denormalizeValue(normalizedRecordValueWrapper.value,cacheAccessor,recordMarker.depth);if(denormalizedRecord){return createFilteredRecordFromRecord(denormalizedRecord,markerFieldNames);}}catch(err){// Catch error and return undefined.
    }}return undefined;}/**
     * Returns an array of unqualified field names taken off the given recordMarker.
     * @param recordMarker The recordMarker instance to extract unqualified field names off of.
     * @returns See description.
     */function getUnqualifiedFieldNamesFromRecordMarker(recordMarker){const apiNameReg=new RegExp(`^${recordMarker.apiName}\\.`);const unqualifiedFieldNames=[];const recordMarkerFields=recordMarker.fields;if(recordMarkerFields){for(let i=0,length=recordMarkerFields.length;i<length;++i){const qualifiedFieldName=recordMarkerFields[i];const unqualifiedFieldName=qualifiedFieldName.replace(apiNameReg,"");unqualifiedFieldNames.push(unqualifiedFieldName);}}return unqualifiedFieldNames;}/**
     * Creates and returns a new filtered record from the given record that only contains the fields specified by allowedFields. Deep clone for now.
     * Will change to shallow copy in future.
     * @param record The record from which to create the filtered record.
     * @param allowedFields An object map keyed by the qualified field names to include in the filtered record.
     * @returns See description.
     */function createFilteredRecordFromRecord(record,allowedFields){const splitField=/^([\w]+)\.(.*)$/;// W-4126359: Proxy and Array.includes are not supported in aura compat mode.
    const filterRecord=(scopedRecord,scopedAllowedFields)=>{const scopedRecordFieldsArray=Object.keys(scopedRecord.fields);for(let len=scopedRecordFieldsArray.length,n=0;n<len;n++){const fieldName=scopedRecordFieldsArray[n];// spanned record case
    if(isRecordRepresentation(scopedRecord.fields[fieldName].value)){const nextAllowedList=scopedAllowedFields.filter(field=>{return field.substring(0,fieldName.length)===fieldName&&splitField.test(field);}).map(field=>{const execVal=splitField.exec(field);if(execVal&&execVal.length>2){return execVal[2];}return "";});const filteredSpannedRecord=filterRecord(scopedRecord.fields[fieldName].value,nextAllowedList.filter(Boolean));if(Object.keys(filteredSpannedRecord.fields).length>0){// only include spanned record if we have access to at least one of its fields.
    scopedRecord.fields[fieldName].value=filteredSpannedRecord;}else {delete scopedRecord.fields[fieldName];}}else if(scopedRecord.fields[fieldName].value===null&&scopedAllowedFields.reduce((accumulator,currentValue)=>{return accumulator||currentValue.split(".")[0]===fieldName;// weird formatting requirement from eslint
    },false));else if(scopedAllowedFields.indexOf(fieldName)===-1){// single field value case
    delete scopedRecord.fields[fieldName];}}// Remove the etag field from the root of the filtered record. Etags don't apply to filtered records because we are changing the number of fields on the record which
    // invalidates the etag. If we didn't remove this field, the equivalence check on the final distinctUntilChanged operator on the filtered observable stream would think
    // the record has changed because the etag has changed, even if all the other data remained the same.
    delete scopedRecord.eTag;return scopedRecord;};const currentRecord=cloneDeepCopy(record);return filterRecord(currentRecord,allowedFields);}/**
     * Checks if the value passed is of shape of RecordRepresentation
     * @param value
     * @returns true if the value passed is of uiapi.RecordRepresentation shape
     */function isRecordRepresentation(value){return value&&value.id!==undefined&&value.fields!==undefined&&value.apiName!==undefined&&value.systemModstamp!==undefined;}/**
     * Creates and returns a marker for the given record that should be used to replace records and nested records during normalization.
     * @param cacheAccessor The CacheAccessor in scope for this operation.
     * @param record The record to use to create the marker.
     * @param depth The depth at which this record exists in a nested record structure. The root record would be depth 0 while
     *        a first level spanning field would be depth 1. Depths greater than 5 are not supported or necessary because SOQL doesn't
     *        support more than 5 levels of record spanning.
     * @param objectInfo Optional. The objectInfo for the record. If specified, this includes the fields from the relationships
     *        this record can have.
     * @returns a marker for the given record that should be used to replace records and nested records during normalization
     */function toRecordMarker(cacheAccessor,record,depth,objectInfo){const id=record.id;const recordTypeId=record.recordTypeInfo&&record.recordTypeInfo.recordTypeId;const recordFields=new Set();recursivelyGatherFieldNames(record.apiName,record,recordFields);if(objectInfo){// Add fields from the lookup relationship record based on objectInfo metadata.
    const fieldsWithRelations=Array.from(Object.values(objectInfo.fields)).filter(field=>field.relationshipName);fieldsWithRelations.forEach(field=>{field.referenceToInfos.forEach(referenceToInfo=>{// Include the Id field. Ex: Opportunity.Account.Id, Opportunity.relation1__r.Id
    recordFields.add(record.apiName+"."+field.relationshipName+".Id");// Include any other fields. Ex: Opportunity.Account.Name, Opportunity.relation1__r.Name
    referenceToInfo.nameFields.forEach(nameField=>recordFields.add(record.apiName+"."+field.relationshipName+"."+nameField));});});}return {id,recordTypeId,depth,___marker:true,timestamp:cacheAccessor.nowTime,fields:collectionToArray(recordFields),apiName:record.apiName,lastModifiedById:record.lastModifiedById,lastModifiedDate:record.lastModifiedDate,systemModstamp:record.systemModstamp};}/**
     * Recursively adds field expressions to the provided set. Field expressions should be in the form of
     * <object-API-name>.<relation-name>*.<field-name>, e.g. "Account.Parent.Name".
     * @param fieldExpressionPrefix Any object API name and spanning field prefix for this record's fields. It should at least be an object API name at the root record level.
     * @param record The relevant record.
     * @param fieldNamesSet The set being used to gather all field names. This is an in/out parameter all fields
     *        will be added to this set.
     */function recursivelyGatherFieldNames(fieldExpressionPrefix,record,fieldNamesSet){const recordFields=record.fields;const fieldNamesArray=Object.keys(recordFields);for(let len=fieldNamesArray.length,n=0;n<len;n++){const fieldName=fieldNamesArray[n];const fieldValue=recordFields[fieldNamesArray[n]].value;const fieldExpression=`${fieldExpressionPrefix}.${fieldName}`;if(isRecordRepresentation(fieldValue)){recursivelyGatherFieldNames(fieldExpression,fieldValue,fieldNamesSet);}else {fieldNamesSet.add(fieldExpression);}}}/**
     * Adds all fields found in the given normalizedRecord into the provided fieldNamesSet. Produces fully qualified field names.
     * Since this is a normalized record there is no recursion because there is no nested spanning records, only markers.
     * @param normalizedRecord The relevant normalized record.
     * @param fieldNamesSet The set being used to gather all field names. This is an in/out parameter - all fields
     *        will be added to this set.
     */function gatherFieldNamesFromNormalizedRecord(normalizedRecord,fieldNamesSet){const fieldNamesArray=Object.keys(normalizedRecord.fields);const apiName=normalizedRecord.apiName;for(let fieldNamesArrayIndex=0,fieldNamesArrayLength=fieldNamesArray.length;fieldNamesArrayIndex<fieldNamesArrayLength;++fieldNamesArrayIndex){const fieldName=fieldNamesArray[fieldNamesArrayIndex];const fieldValue=normalizedRecord.fields[fieldName].value;const fieldExpression=`${apiName}.${fieldName}`;if(isRecordMarker(fieldValue)){const unqualifiedFieldNames=getUnqualifiedFieldNamesFromRecordMarker(fieldValue);// Qualify the field names by adding the api name and field name to each unqualified field name. Example: Opportunity.Owner.Id;
    for(let unqualifiedFieldNamesIndex=0,length=unqualifiedFieldNames.length;unqualifiedFieldNamesIndex<length;++unqualifiedFieldNamesIndex){const unqualifiedFieldName=unqualifiedFieldNames[unqualifiedFieldNamesIndex];const qualifiedFieldName=`${fieldExpression}.${unqualifiedFieldName}`;fieldNamesSet.add(qualifiedFieldName);}}else if(isRecordRepresentation(fieldValue)){// The only reason we should have a RecordRepresentation instead of a marker in a normalizedRecord is if it is a Name object. We need to recurse into
    // the RecordRepresentation to get those field names too. We need a solution to normalize polymorphic spanning fields: W-5188138.
    recursivelyGatherFieldNames(fieldExpression,fieldValue,fieldNamesSet);}else {fieldNamesSet.add(fieldExpression);}}}/**
     * Returns a set of all the fields in a given record.
     * @param record The record.
     * @returns Set of all fields.
     */function getFieldsFromRecord(record){const recordFieldsSet=new Set();gatherFieldNamesFromNormalizedRecord(record,recordFieldsSet);return recordFieldsSet;}/**
     * Returns true if the second record contains all the fields that the first record has.
     * @param firstRecord the first record.
     * @param secondRecord the second record.
     * @returns true if the second record contains all the fields that the first record has, otherwise false.
     */function secondRecordContainsAllFieldsInFirstRecord(firstRecord,secondRecord){return containsAll(getFieldsFromRecord(secondRecord),getFieldsFromRecord(firstRecord));}/**
     * Returns fields of the targetRecord that aren't present in the sourceRecord.
     * @param sourceRecord The source record.
     * @param targetRecord The target record.
     * @returns Set of strings that are present in the target record but not in the sourceRecord.
     */function getDifferentFieldsBetweenRecords(sourceRecord,targetRecord){return difference(getFieldsFromRecord(sourceRecord),getFieldsFromRecord(targetRecord));}/**
     * Produces a list of all the fields to remain in the record. Will throw an error if a required field is missing. Ignores missing optional fields.
     * @param record The record object which has all fields.
     * @param requiredFields The list of required fields to remain in the record.
     * @param optionalFields The list of optional fields to remain in the record.
     * @returns A list of unqualified fields to remain in the record.
     */function getFullFieldsListForFilteredObservable(record,requiredFields,optionalFields){if(record===undefined){throw getLdsInternalError("UNDEFINED_RECORD",`Trying to get fields list for undefined record, requiredFields: ${requiredFields} optionalFields: ${optionalFields}`,true);}const apiNameLength=record.apiName.length+1;// +1 for the '.'
    const unqualifiedRequiredFields=requiredFields.map(field=>{if(getFieldValue(record,field)===undefined){if(field.startsWith(record.apiName+".")){throw getLdsInternalError("INVALID_FIELD",`No such column '${field.substring(apiNameLength)}' on entity '${record.apiName}'. If you are attempting to use a custom field, be sure to append the '__c' after the custom field name. Please reference your WSDL or the describe call for the appropriate names.`,false);}throw getLdsInternalError("INVALID_FIELD",`Entity name for the provided record didn't match required field ${field}`,true);}return field.substring(apiNameLength);});const unqualifiedOptionalFields=optionalFields.filter(field=>field.startsWith(record.apiName)).map(field=>field.substring(apiNameLength));return unqualifiedRequiredFields.concat(unqualifiedOptionalFields);}/**
     * Adds record id to active request list.
     * @param recordIdsToIsRefreshingMap The active request list.
     * @param recordId The record id to track.
     */function addRecordToRefreshList(recordIdsToIsRefreshingMap,recordId){let refreshingCount=recordIdsToIsRefreshingMap.get(recordId);if(refreshingCount===undefined){refreshingCount=1;}else {refreshingCount+=1;}recordIdsToIsRefreshingMap.set(recordId,refreshingCount);}/**
     * Removes record id from active request list.
     * @param recordIdsToIsRefreshingMap The active request list.
     * @param recordId The record id to remove.
     */function removeRecordFromRefreshList(recordIdsToIsRefreshingMap,recordId){let refreshingCount=recordIdsToIsRefreshingMap.get(recordId)||0;if(refreshingCount<=1){recordIdsToIsRefreshingMap.delete(recordId);}else {refreshingCount-=1;recordIdsToIsRefreshingMap.set(recordId,refreshingCount);}}/**
     * The valueType to use when building LayoutCacheKey.
     */const LAYOUT_VALUE_TYPE="uiapi.RecordLayoutRepresentation";/**
     * Time to live for a layout cache value. 15 minutes.
     */const LAYOUT_TTL=15*60*1000;/**
     * The master record type id.
     */const MASTER_RECORD_TYPE_ID$1="012000000000000AAA";/**
     * Constructs a cache key for the Layout value type.
     * @param objectApiName The object api name with which the layout is associated.
     * @param recordTypeId The record type id with which the layout is associated.
     * @param layoutType The layout type with which the layout is associated.
     * @param mode The mode with which the layout is associated.
     * @returns CacheKey A new cache key representing the Layout value type.
     */function buildCacheKey$2(objectApiName,recordTypeId,layoutType,mode){{assert$2(objectApiName,"A non-empty objectApiName must be provided.");assert$2(layoutType,"A non-empty layoutType must be provided.");assert$2(mode,"A non-empty mode must be provided.");assert$2(recordTypeId!==null&&recordTypeId!==undefined,"recordTypeId must be defined.");assert$2(recordTypeId.length===18,"Record Type Id length should be 18 characters.");}return {type:LAYOUT_VALUE_TYPE,key:`${objectApiName.toLowerCase()}${KEY_DELIM}${recordTypeId}${KEY_DELIM}${layoutType.toLowerCase()}${KEY_DELIM}${mode.toLowerCase()}`};}/**
     * Returns an array of qualifiedFieldNames taken from the given layout.
     * @param layout The layout object from which to get the qualified field names.
     * @param objectInfo The object info object associated with the layout.
     * @throws An error if invalid layout or objectInfo is provided.
     * @returns See description.
     */function getQualifiedFieldApiNamesFromLayout(layout,objectInfo){if(!layout){throw new Error("layout must be defined");}if(!objectInfo){throw new Error("objectInfo must be defined");}const qualifiedFieldNames=[];for(let sectionsIndex=0,sectionsLength=layout.sections.length;sectionsIndex<sectionsLength;++sectionsIndex){const section=layout.sections[sectionsIndex];for(let rowsIndex=0,rowsLength=section.layoutRows.length;rowsIndex<rowsLength;++rowsIndex){const row=section.layoutRows[rowsIndex];for(let itemsIndex=0,itemsLength=row.layoutItems.length;itemsIndex<itemsLength;++itemsIndex){const item=row.layoutItems[itemsIndex];for(let componentsIndex=0,componentsLength=item.layoutComponents.length;componentsIndex<componentsLength;++componentsIndex){const component=item.layoutComponents[componentsIndex];if(component.apiName&&component.componentType==="Field"){if(isReferenceFieldNameWithRelationshipName(component.apiName,objectInfo)){const spanningFieldName=getSpanningFieldName(objectInfo,component.apiName);// By default, include the "Id" field on spanning records that are on the layout.
    qualifiedFieldNames.push(`${objectInfo.apiName}.${spanningFieldName}.Id`);// Most entities default to "Name" for nameField. However, there are some exceptions.
    let nameField="Name";const spanningFieldObjectInfo=objectInfo.fields[component.apiName];if(spanningFieldObjectInfo){const referenceToInfos=spanningFieldObjectInfo.referenceToInfos;const firstReferenceToInfos=referenceToInfos&&referenceToInfos[0];const firstNameField=firstReferenceToInfos&&firstReferenceToInfos.nameFields&&firstReferenceToInfos.nameFields[0];if(firstReferenceToInfos&&firstNameField){// If this is an entity with multiple referencesToInfos, or there are multiple nameFields- use the first one if "Name" isn't present.
    if(referenceToInfos.length>1||firstReferenceToInfos.nameFields.length>1){const seenNameField=referenceToInfos.find(ref=>{return ref.nameFields.find(field=>field===nameField)!==undefined;});if(!seenNameField){nameField=firstNameField;}}else {nameField=firstNameField;}}}qualifiedFieldNames.push(`${objectInfo.apiName}.${spanningFieldName}.${nameField}`);}qualifiedFieldNames.push(`${objectInfo.apiName}.${component.apiName}`);}}}}}return qualifiedFieldNames;}/**
     * Returns true if the field specified by the given fieldName is a reference field that also has
     * a relationship name, else false. Also returns false if the objectInfo has no data for that fieldName.
     * @param fieldName The fieldName of the field to check.
     * @param objectInfo The object info that contains the metadata for the field.
     * @returns See description.
     */function isReferenceFieldNameWithRelationshipName(fieldName,objectInfo){if(!objectInfo.fields[fieldName]){return false;}if(objectInfo.fields[fieldName].reference&&objectInfo.fields[fieldName].relationshipName){return true;}return false;}/**
     * Returns the spanning field name for the given referenceFieldName.
     * @param referenceFieldName The field name of the reference field from which to get the spanning field name.
     * @throws An error for unsupported reference field name.
     * @returns See description.
     */function getSpanningFieldName(objectInfo,referenceFieldName){if(objectInfo.fields[referenceFieldName]&&objectInfo.fields[referenceFieldName].relationshipName){return objectInfo.fields[referenceFieldName].relationshipName;}throw new Error(`Unsupported referenceFieldName: ${referenceFieldName}`);}/**
     * Provides functionality to read layout data from the cache. Can refresh the data from the server.
     */class LayoutService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){super(ldsCache,[LAYOUT_VALUE_TYPE]);}getCacheValueTtl(){return LAYOUT_TTL;}isDurable(){return true;}/**
         * Retrieves a layout from the cache. If it doesn't exist in the cache it will retrieve it from the server and put it into the cache.
         * @param objectApiName The object api name of the layout to retrieve.
         * @param layoutType The layout type of the layout to retrieve.
         * @param mode The mode of the layout to retrieve.
         * @param recordTypeId The record type id of the layout to retrieve.
         */getLayout(objectApiName,layoutType,mode,recordTypeId){recordTypeId=to18(recordTypeId);const cacheKey=buildCacheKey$2(objectApiName,recordTypeId,layoutType,mode);const valueProviderParameters={cacheKey,objectApiName,layoutType,mode,recordTypeId,forceProvide:false};const valueProvider=this._createLayoutValueProvider.call(this,valueProviderParameters);return this._ldsCache.get(cacheKey,valueProvider);}/**
         * Stage puts the given layout.
         * @param dependencies List of dependent cache keys.
         * @param layout The layout value to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         * @returns A Thenable that resolves when the stagePut has completed.
         */stagePutValue(dependencies,layout,cacheAccessor,additionalData){const layoutCacheKey=buildCacheKey$2(additionalData.objectApiName,additionalData.recordTypeId,layout.layoutType,layout.mode);const existingValueWrapper=cacheAccessor.get(layoutCacheKey);const eTag=layout.eTag;if(existingValueWrapper&&existingValueWrapper.eTag===eTag){cacheAccessor.stageDependencies(dependencies,layoutCacheKey);cacheAccessor.stagePutUpdateLastFetchTime(layoutCacheKey);return;}// Strip out the eTag from the value. We don't want to emit eTags!
    layout=this.stripETagsFromValue(layout);cacheAccessor.stagePut(dependencies,layoutCacheKey,layout,layout,{eTag});}/**
         * Strips all eTag properties from the given layout by directly deleting them.
         * @param layout The layout from which to strip the eTags.
         * @returns The given layout with its eTags stripped.
         */stripETagsFromValue(layout){delete layout.eTag;return layout;}/**
         * Creates a value provider to retrieve a Layout.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns ValueProvider The value provider to retrieve a Layout.
         */_createLayoutValueProvider(valueProviderParameters){const{cacheKey,objectApiName,layoutType,mode,recordTypeId,forceProvide}=valueProviderParameters;const valueProvider=new ValueProvider(cacheAccessor=>{if(forceProvide){return this._getFreshValue.call(this,cacheAccessor,cacheKey,objectApiName,layoutType,mode,recordTypeId);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;const needsRefresh=nowTime>lastFetchTime+LAYOUT_TTL;if(needsRefresh){// Value is stale; get a fresh value.
    return this._getFreshValue.call(this,cacheAccessor,cacheKey,objectApiName,layoutType,mode,recordTypeId,existingValueWrapper.eTag);}// The value is not stale so it's a cache hit.
    return Thenable.resolve(1/* CACHE_HIT */);}// No existing value; get a fresh value.
    return this._getFreshValue.call(this,cacheAccessor,cacheKey,objectApiName,layoutType,mode,recordTypeId);},valueProviderParameters);return valueProvider;}hasValidCachedValue(cacheAccessor,params){const cacheKey=buildCacheKey$2(params.objectApiName,params.recordTypeId,params.layoutType,params.mode);const existingValueWrapper=cacheAccessor.get(cacheKey);return !!existingValueWrapper&&existingValueWrapper.value!==undefined&&cacheAccessor.nowTime<=existingValueWrapper.lastFetchTime+LAYOUT_TTL;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param cacheKey The cache key for the layout.
         * @param objectApiName The objectApiName of the layout.
         * @param layoutType The layoutType of the layout.
         * @param mode The mode of the layout.
         * @param recordTypeId The recordTypeId of the layout.
         * @param eTagToCheck eTag to send to the server to determine if we already have the latest value. If we do the server will return a 304.
         * @returns Thenable<ValueProviderResult> Returns a thenable representing the outcome of value provider
         */_getFreshValue(cacheAccessor,cacheKey,objectApiName,layoutType,mode,recordTypeId,eTagToCheck){let layoutThenable;const params={objectApiName,layoutType,mode,recordTypeId,clientOptions:undefined};if(eTagToCheck){params.clientOptions={eTagToCheck};}{layoutThenable=aggregateUiExecutor.executeSingleRequestOverAggregateUi("getLayout",params,LAYOUT_TTL);}return layoutThenable.then(transportResponse=>{// Cache miss refresh unchanged.
    if(transportResponse.status===304){return 3/* CACHE_MISS_REFRESH_UNCHANGED */;}// Cache miss.
    cacheAccessor.stageClearDependencies(cacheKey);const freshLayout=transportResponse.body;this.stagePutValue([],freshLayout,cacheAccessor,{objectApiName,recordTypeId});const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}}/**
     * Wire adapter id: getLayout.
     * @throws Error Always throws when invoked. Imperative invocation is not supported.
     * @returns void
     */function getLayout(){throw generateError("getLayout");}/**
     * Generates the wire adapters for:
     *      * @wire getLayout
     */class LayoutWireAdapterGenerator{/**
         * Constructor.
         * @param layoutService Reference to the layoutService instance.
         */constructor(layoutService){this._layoutService=layoutService;}/*
         * Generates the wire adapter for getlayout.
         * @returns WireAdapter - See description.
         */generateGetLayoutWireAdapter(){const wireAdapter=generateWireAdapter(this.serviceGetLayout.bind(this));return wireAdapter;}/**
         * @private
         * Service getlayout @wire.
         * @param config Config params for the service.
         * @return Observable stream that emits a layout object.
         */serviceGetLayout(config){if(!config){return undefined;}{const required=["objectApiName","layoutType","mode"];const supported=["objectApiName","recordTypeId","layoutType","mode"];validateConfig$1("getlayout",config,required,supported);}const{objectApiName,layoutType,mode,recordTypeId}=config;if(!objectApiName||!layoutType||!mode||recordTypeId===undefined){return undefined;}return this._layoutService.getLayout(objectApiName,layoutType,mode,recordTypeId||MASTER_RECORD_TYPE_ID$1);}}/**
     * The type to use when building RecordUiCacheKey.
     */const RECORD_UI_VALUE_TYPE="uiapi.RecordUiRepresentation";/**
     * Time to live for RecordUi object. 15 minutes.
     */const RECORD_UI_TTL=15*60*1000;/**
     * Returns a RecordUiCacheKeyParams based on a keyString. Throws an error if it can't be done because a bad string is provided.
     * @param keyString A cache key string derived from a RecordUi CacheKey.
     * @returns A RecordUiCacheKeyParams based on a keyString.
     */function getRecordUiCacheKeyParams(cacheKey){{assert$2(cacheKey.type===RECORD_UI_VALUE_TYPE,`valueType was expected to be RECORD_UI_VALUE_TYPE but was not: ${cacheKey.type.toString()}`);}const key=cacheKey.key;const localKeyParts=key.split(KEY_DELIM);const recordIds=localKeyParts[0].split(",");let layoutTypes=[];if(localKeyParts.length>1&&localKeyParts[1]!==""){layoutTypes=localKeyParts[1].split(",");}let modes=[];if(localKeyParts.length>2&&localKeyParts[2]!==""){modes=localKeyParts[2].split(",");}let optionalFields=[];if(localKeyParts.length>3&&localKeyParts[3]!==""){optionalFields=localKeyParts[3].split(",");}return {recordIds,layoutTypes,modes,optionalFields};}/**
     * @param recordUi The recordUi from which to create a builder.
     * @returns CacheKey A RecordUi CacheKey based on the given recordUi.
     */function buildCacheKeyFromRecordUi(recordUi){const extracted={layoutTypes:{},modes:{}};Object.keys(recordUi.layouts).forEach(apiName=>{const recordTypeIds=recordUi.layouts[apiName];Object.keys(recordTypeIds).forEach(recordTypeId=>{const layouts=recordTypeIds[recordTypeId];Object.assign(extracted.layoutTypes,layouts);Object.keys(layouts).forEach(layout=>{const modes=layouts[layout];Object.assign(extracted.modes,modes);});});});return buildCacheKey$3(Object.keys(recordUi.records),Object.keys(extracted.layoutTypes),Object.keys(extracted.modes),[]);}/**
     * Builds the cache key.
     * @param recordIds The record ids.
     * @param layoutTypes The layout types.
     * @param modes: The modes.
     * @param optionalFields The list of optional fields.
     * @returns A new cache key representing the RecordUi value type.
     */function buildCacheKey$3(recordIds,layoutTypes,modes,optionalFields){function errorFormatter(_literals,key,valueFound,singleValue){let base=`${key} should be a string list, but received ${valueFound}`;if(singleValue){base+=`, list contains an entry with value ${singleValue}`;}return base;}function constructKeyFromStringList(list,key){{list.forEach(field=>{assert$2(field,errorFormatter`${key}${list}${field}`);});}return list.join(",");}{assert$2(recordIds.length,"Non-empty recordIds must be provided.");assert$2(layoutTypes?layoutTypes.length:false,"Non-empty layoutTypes must be provided.");assert$2(modes?modes.length:false,"Non-empty modes must be provided.");}const recordId=constructKeyFromStringList(recordIds.sort(),"recordIds");const layoutType=constructKeyFromStringList(layoutTypes.map(type=>type.toLowerCase()).sort(),"layoutTypes");const mode=constructKeyFromStringList(modes.map(modeItem=>modeItem.toLowerCase()).sort(),"modes");const optionalField=constructKeyFromStringList(optionalFields.sort(),"optionalFields");return {type:RECORD_UI_VALUE_TYPE,key:`${recordId}${KEY_DELIM}${layoutType}${KEY_DELIM}${mode}${KEY_DELIM}${optionalField}`};}/**
     * The type to use when building LayoutCacheKey.
     */const LAYOUT_USER_STATE_VALUE_TYPE="uiapi.RecordLayoutUserStateRepresentation";/**
     * Time to live for a layout user state cache value. 15 minutes.
     */const LAYOUT_USER_STATE_TTL=15*60*1000;/**
     * The master record type id.
     */const MASTER_RECORD_TYPE_ID$2="012000000000000AAA";/**
     * Constructs a cache key for the Layout value type.
     * Layout cache key is used as cache key for layout data provided by UI API.
     * @param objectApiName The object api name with which the layout is associated.
     * @param recordTypeId The record type id with which the layout is associated.
     * @param layoutType The layout type with which the layout is associated.
     * @param mode The mode with which the layout is associated.
     * @returns A new cache key representing the Layout value type.
     */function buildCacheKey$4(objectApiName,recordTypeId,layoutType,mode){{assert$2(objectApiName,"A non-empty objectApiName must be provided.");assert$2(recordTypeId,"recordTypeId must be defined.");assert$2(layoutType,"A non-empty layoutType must be provided.");assert$2(mode,"A non-empty mode must be provided.");assert$2(recordTypeId.length===18,"Record Type Id length should be 18 characters.");}return {type:LAYOUT_USER_STATE_VALUE_TYPE,key:`${objectApiName.toLowerCase()}${KEY_DELIM}${recordTypeId}${KEY_DELIM}${layoutType.toLowerCase()}${KEY_DELIM}${mode.toLowerCase()}`};}/**
     * Provides functionality to read layout data from the cache. Can refresh the data from the server.
     */class LayoutUserStateService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){super(ldsCache,[LAYOUT_USER_STATE_VALUE_TYPE]);}getCacheValueTtl(){return LAYOUT_USER_STATE_TTL;}isDurable(){return true;}/**
         * Gets a layout user state.
         * @param objectApiName Object API name of the layout to retrieve.
         * @param recordTypeId Record type id of the layout to retrieve.
         * @param layoutType Type of layout to retrieve.
         * @param mode Layout mode to retrieve.
         * @returns An observable of the layout user state.
         */getLayoutUserState(objectApiName,recordTypeId,layoutType,mode){objectApiName=getObjectApiName(objectApiName);recordTypeId=to18(recordTypeId);const cacheKey=buildCacheKey$4(objectApiName,recordTypeId,layoutType,mode);const valueProviderParameters={cacheKey,objectApiName,recordTypeId,layoutType,mode};const valueProvider=this._createLayoutUserStateValueProvider(valueProviderParameters);return this._ldsCache.get(cacheKey,valueProvider);}/**
         * Stage puts the given layoutUserState.
         * @param dependencies List of dependent cache keys.
         * @param layoutUserState The layoutUserState value to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData Property bag that contains additional values needed for generating the cache key.
         */stagePutValue(dependencies,layoutUserState,cacheAccessor,additionalData){const layoutUserStateCacheKey=buildCacheKey$4(additionalData.objectApiName,additionalData.recordTypeId,additionalData.layoutType,additionalData.mode);cacheAccessor.stagePut(dependencies,layoutUserStateCacheKey,layoutUserState,layoutUserState);}/**
         * There are no eTags to strip from layout user state so just return the given value unchanged.
         * @param layoutUserState
         * @returns The given layoutUserState unchanged.
         */stripETagsFromValue(layoutUserState){return layoutUserState;}/**
         * Updates the layout user state associated with the given parameters.
         * NOTE: This is a WRITE-BEHIND style update.
         * @param objectApiName The object api name associated with the layout user state.
         * @param recordTypeId The record type id associated with the layout user state.
         * @param layoutType The layout type associated with the layout user state.
         * @param mode The mode associated with the layout user state.
         * @param layoutUserStateInput Input specifying how to change the layoutUserState. Of the shape:
         *      {
         *          sectionUserStates: {
         *              sectionId1: {
         *                  collapsed: true
         *              }
         *              ...
         *          }
         *      }
         * @return A Promise resolved to the new layoutUserState value.
         */async updateLayoutUserState(objectApiName,recordTypeId,layoutType,mode,layoutUserStateInput){objectApiName=getObjectApiName(objectApiName);// Use the existing cache value and mutate it based on the given layoutUserStateInput. We do this so we can do an optimistic client side update so changes get
    // propagated immediately instead of having to wait on a server call. An optimistic update is only possible if all the sectionUserState ids exist in the cache value.
    let doOptimisticUpdate=true;const cachedLayoutUserState=await observableToPromise(await this.getLayoutUserState(objectApiName,recordTypeId,layoutType,mode),true);const updatedLayoutUserState=cloneDeepCopy(cachedLayoutUserState);Object.keys(layoutUserStateInput.sectionUserStates).forEach(sectionId=>{if(!cachedLayoutUserState.sectionUserStates[sectionId]){// They are trying to update a section that isn't in the cached value so cancel the optimistic update.
    doOptimisticUpdate=false;}else {updatedLayoutUserState.sectionUserStates[sectionId].collapsed=layoutUserStateInput.sectionUserStates[sectionId].collapsed;}});const layoutUserStateCacheKey=buildCacheKey$4(objectApiName,recordTypeId,layoutType,mode);if(doOptimisticUpdate){// Do an optimistic update to the client cache so state will update immediately on the client.
    const valueProviderParameters={cacheKey:layoutUserStateCacheKey,objectApiName,recordTypeId,layoutType,mode,localFreshLayoutUserState:updatedLayoutUserState,forceProvide:true};const valueProvider=this._createLayoutUserStateValueProvider(valueProviderParameters);await observableToPromise(this._ldsCache.get(layoutUserStateCacheKey,valueProvider),true);}// Persist the state to the server.
    const apiParameters={objectApiName,recordTypeId,layoutType,mode,userState:layoutUserStateInput};executeAuraGlobalController("RecordUiController.updateLayoutUserState",apiParameters);return updatedLayoutUserState;}/**
         * Constructs a value provider to retrieve a user's layout state.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns The value provider to retrieve a user's layout state.
         */_createLayoutUserStateValueProvider(valueProviderParameters){const{cacheKey,objectApiName,recordTypeId,layoutType,mode,localFreshLayoutUserState,forceProvide}=valueProviderParameters;const valueProvider=new ValueProvider(cacheAccessor=>{if(forceProvide){return this._getFreshValue(cacheAccessor,objectApiName,recordTypeId,layoutType,mode,localFreshLayoutUserState);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;const needsRefresh=nowTime>lastFetchTime+LAYOUT_USER_STATE_TTL;if(needsRefresh){// Value is stale; get a fresh value.
    return this._getFreshValue(cacheAccessor,objectApiName,recordTypeId,layoutType,mode,localFreshLayoutUserState);}// The value is not stale so it's a cache hit.
    return Thenable.resolve(1/* CACHE_HIT */);}// No existing value; get a fresh value.
    return this._getFreshValue(cacheAccessor,objectApiName,recordTypeId,layoutType,mode,localFreshLayoutUserState);},valueProviderParameters);return valueProvider;}hasValidCachedValue(cacheAccessor,params){const cacheKey=buildCacheKey$4(params.objectApiName,params.recordTypeId,params.layoutType,params.mode);const existingValueWrapper=cacheAccessor.get(cacheKey);return !!existingValueWrapper&&existingValueWrapper.value!==undefined&&cacheAccessor.nowTime<=existingValueWrapper.lastFetchTime+LAYOUT_USER_STATE_TTL;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param objectApiName The objectApiName of the layoutUserState.
         * @param recordTypeId The recordTypeId of the layoutUserState.
         * @param layoutType The layoutType of the layoutUserState.
         * @param mode The mode of the layoutUserState.
         * @param localFreshLayoutUserState Optional. A layoutUserState value you want explicitly put into cache instead of getting the value from the server.
         * @returns Returns a string representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,objectApiName,recordTypeId,layoutType,mode,localFreshLayoutUserState){let layoutUserStateThenable=null;// If the layoutUserState is provided, we don't go to server to fetch it.
    if(localFreshLayoutUserState){layoutUserStateThenable=Thenable.resolve(getOkFetchResponse(localFreshLayoutUserState));}else {const params={objectApiName,recordTypeId,layoutType,mode};{layoutUserStateThenable=aggregateUiExecutor.executeSingleRequestOverAggregateUi("getLayoutUserState",params,LAYOUT_USER_STATE_TTL);}}return layoutUserStateThenable.then(transportResponse=>{// Cache miss.
    const freshLayoutUserState=transportResponse.body;this.stagePutValue([],freshLayoutUserState,cacheAccessor,{objectApiName,recordTypeId,layoutType,mode});const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}}/**
     * Wire adapter id: getLayoutUserState.
     * @throws Error Always throws when invoked. Imperative invocation is not supported.
     * @returns void
     */function getLayoutUserState(){throw generateError("getLayoutUserState");}/**
     * Generates the wire adapters for:
     *      * @wire getLayoutUserState
     */class LayoutUserStateWireAdapterGenerator{/**
         * Constructor.
         * @param layoutUserStateService Reference to the LayoutUserStateService instance.
         */constructor(layoutUserStateService){this._layoutUserStateService=layoutUserStateService;}/*
         * Generates the wire adapter for getLayoutUserState.
         * @returns WireAdapter - See description.
         */generateGetLayoutUserStateWireAdapter(){const wireAdapter=generateWireAdapter(this.serviceGetLayoutUserState.bind(this));return wireAdapter;}/**
         * @private
         * Service getLayoutUserState @wire.
         * @param config Config params for the service.
         * @return Observable stream that emits a layout user state object.
         */serviceGetLayoutUserState(config){if(!config){return undefined;}{const required=["objectApiName","recordTypeId","layoutType","mode"];const supported=["objectApiName","recordTypeId","layoutType","mode"];validateConfig$1("getLayoutUserState",config,required,supported);}const{objectApiName,layoutType,mode,recordTypeId}=config;if(!objectApiName||!layoutType||!mode||recordTypeId===undefined){return undefined;}return this._layoutUserStateService.getLayoutUserState(objectApiName,recordTypeId||MASTER_RECORD_TYPE_ID$2,layoutType,mode);}}/**
     * Provides functionality to read record ui data from the cache. Can refresh the data from the server.
     * We do not utilize caching or sending eTags to the server for this value type because it gets invalidated
     * quickly on the client from having its atoms updated.
     */class RecordUiService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         * @param adsBridge Reference to the AdsBridge instance.
         */constructor(ldsCache,adsBridge){super(ldsCache,[RECORD_UI_VALUE_TYPE]);this._adsBridge=adsBridge;}getCacheValueTtl(){return RECORD_UI_TTL;}/**
         * Gets a record UI.
         * @param recordIds Id of the records to retrieve.
         * @param layoutTypes Layouts defining the fields to retrieve.
         * @param modes Layout modes defining the fields to retrieve.
         * @param optionalFields Qualified field API names to retrieve. If any are inaccessible then they are silently omitted.
         * @returns An observable of record values.
         */getRecordUi(recordIds,layoutTypes,modes,optionalFields){const uniqueOptionalFields=collectionToArray(new Set(optionalFields));const cacheKey=buildCacheKey$3(recordIds,layoutTypes,modes,uniqueOptionalFields);const recordUiValueProviderParams={cacheKey,recordIds,layoutTypes,modes,optionalFields:uniqueOptionalFields,forceProvide:false};const valueProvider=this._createRecordUiValueProvider(recordUiValueProviderParams);return this._ldsCache.get(cacheKey,valueProvider);}/**
         * Helper method to kick off a refresh for a Record UI.
         * @param affectedKey The cache key for the recordUi to refresh.
         */refreshRecordUi(affectedKey){// When a record type changes in a record it can affect the layouts that should be present in the RecordUi. Because of this for now we
    // do a full refresh of the RecordUi.
    const{recordIds,layoutTypes,modes,optionalFields}=getRecordUiCacheKeyParams(affectedKey);// We need to refresh, but we're already in a cache transaction. Kick this to a Promise to get this out of the cache operation we're
    // already in the middle of.
    Promise.resolve().then(()=>{const forceProvide=true;// Use _createRecordUiValueProvider() instead of getRecordUi() so we can force value providing.
    const recordUiValueProviderParams={cacheKey:affectedKey,recordIds,layoutTypes,modes,optionalFields,forceProvide};const valueProvider=this._createRecordUiValueProvider(recordUiValueProviderParams);this._ldsCache.get(affectedKey,valueProvider);});}/**
         * Stage puts the given recordUi.
         * @param dependencies An array of dependent cache keys.
         * @param recordUi The recordUi to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that determine how normalization occurs.
         */stagePutValue(dependencies,recordUi,cacheAccessor,additionalData){// Defaults.
    additionalData=additionalData?additionalData:{rootRecordMerge:true};// fetch parameters from recordUi json and build cache key
    const recordUiCacheKey=buildCacheKeyFromRecordUi(recordUi);this._normalizeAndStagePutRecordUi(dependencies,recordUi,cacheAccessor,recordUiCacheKey,additionalData.rootRecordMerge);}/**
         * Caches a record ui. Use this when you want to put a record ui into the cache that you already have locally.
         * @param recordUiCacheKey The cache key for the record ui to cache.
         * @param recordUi The denormalized record ui object to cache.
         * @param rootRecordMerge True if we should attempt to merge the root record during normalization. This should only happen from ADS bridge
         *      code paths. If this request originated from LDS, then we know the record has all the fields we are interested in and is the freshest version.
         * @returns Returns an observable that emits values for the given cache key.
         */cacheRecordUi(recordUiCacheKey,recordUi,rootRecordMerge){rootRecordMerge=rootRecordMerge===true;const{recordIds,layoutTypes,modes,optionalFields}=getRecordUiCacheKeyParams(recordUiCacheKey);const forceProvide=true;const recordUiValueProviderParams={cacheKey:recordUiCacheKey,recordIds,layoutTypes,modes,optionalFields,forceProvide,localFreshRecordUi:recordUi,rootRecordMerge};const valueProvider=this._createRecordUiValueProvider(recordUiValueProviderParams);return this._ldsCache.get(recordUiCacheKey,valueProvider);}/**
         * Strips all eTag properties from the given recordUi by directly deleting them.
         * @param recordUi The recordUi from which to strip the eTags.
         * @returns The given recordUi with its eTags stripped.
         */stripETagsFromValue(recordUi){delete recordUi.eTag;// Strip eTags from object infos.
    const objectInfos=recordUi.objectInfos;const objectApiNames=Object.keys(objectInfos);for(let len=objectApiNames.length,n=0;n<len;++n){const objectApiName=objectApiNames[n];const objectInfo=objectInfos[objectApiName];objectInfos[objectApiName]=this._ldsCache.stripETagsFromValue(OBJECT_INFO_VALUE_TYPE,objectInfo);}// Strip eTags from layouts.
    const layouts=recordUi.layouts;const layoutObjectApiNames=Object.keys(layouts);for(let len=layoutObjectApiNames.length,layoutObjectApiNameIndex=0;layoutObjectApiNameIndex<len;++layoutObjectApiNameIndex){const objectApiName=layoutObjectApiNames[layoutObjectApiNameIndex];const layoutsUnderObjectApiNames=recordUi.layouts[objectApiName];const recordTypeIds=Object.keys(layoutsUnderObjectApiNames);for(let recordTypeIdsLen=recordTypeIds.length,recordTypeIdIndex=0;recordTypeIdIndex<recordTypeIdsLen;++recordTypeIdIndex){const recordTypeId=recordTypeIds[recordTypeIdIndex];const layoutsUnderRecordTypeIds=layoutsUnderObjectApiNames[recordTypeId];const layoutTypes=Object.keys(layoutsUnderRecordTypeIds);for(let layoutTypesLen=layoutTypes.length,layoutTypeIndex=0;layoutTypeIndex<layoutTypesLen;++layoutTypeIndex){const layoutType=layoutTypes[layoutTypeIndex];const layoutsUnderLayoutTypes=layoutsUnderRecordTypeIds[layoutType];const modes=Object.keys(layoutsUnderLayoutTypes);for(let modeLength=modes.length,modeIndex=0;modeIndex<modeLength;++modeIndex){const mode=modes[modeIndex];const layout=layoutsUnderLayoutTypes[mode];layoutsUnderLayoutTypes[mode]=this._ldsCache.stripETagsFromValue(LAYOUT_VALUE_TYPE,layout);}}}}// Strip eTags from records.
    const records=recordUi.records;const recordIds=Object.keys(records);for(let n=0,len=recordIds.length;n<len;++n){const recordId=recordIds[n];const record=records[recordId];this._ldsCache.stripETagsFromValue(RECORD_VALUE_TYPE,record);}return recordUi;}getAffectedKeyHandler(){return (affectedKey,cacheAccessor)=>{{assert$2(affectedKey.type===RECORD_UI_VALUE_TYPE,`Expected RECORD_UI_VALUE_TYPE value type for RecordUi: ${affectedKey.type.toString()}`);}let refreshRecordUi=false;// We need to detect if any of the records' record types have changed. If they have, we must fully refresh this RecordInfo. If not, we
    // can just denorm and stage an emit for it.
    const recordUiWrapper=cacheAccessor.get(affectedKey);if(recordUiWrapper){const normalizedRecordUi=recordUiWrapper.value;const recordMarkers=normalizedRecordUi.records;const recordIds=Object.keys(recordMarkers);for(let c=0,len=recordIds.length;c<len;++c){const recordId=recordIds[c];const recordMarker=recordMarkers[recordId];{assert$2(recordMarker&&isRecordMarker(recordMarker),`Expected to find a marker for record ${recordId} but instead found ${recordMarker}`);}const recordMarkerRecordTypeId=recordMarker.recordTypeId;const recordCacheKey=buildRecordCacheKey(recordId);const refreshedRecordValueWrapper=cacheAccessor.getCommitted(recordCacheKey);if(refreshedRecordValueWrapper){const refreshedRecord=refreshedRecordValueWrapper.value;// A record matching this marker has been committed as part of this cache transaction. See if its record type changed.
    // If it did we need to do a full refresh of this RecordUi, otherwise we can just denorm/emit it. We don't need to
    // worry about records that weren't committed as part of this cache transaction because they haven't changed.
    // We use null rather than undefined here to be consistent with what we'll find in the API JSON payloads.
    const refreshedRecordTypeId=refreshedRecord.recordTypeInfo?refreshedRecord.recordTypeInfo.recordTypeId:null;if(recordMarkerRecordTypeId!==refreshedRecordTypeId){refreshRecordUi=true;break;}}}// Maybe an ObjectInfo changed, if so determining its effect could be difficult so do a full refresh to be sure we get it right.
    if(!refreshRecordUi){// Don't make further checks if we don't need to.
    const objectInfoMarkers=normalizedRecordUi.objectInfos;const objectApiNames=Object.keys(objectInfoMarkers);for(let c=0,len=objectApiNames.length;c<len;++c){const objectApiName=objectApiNames[c];const objectInfoMarker=objectInfoMarkers[objectApiName];const objectInfoETag=objectInfoMarker.eTag;const objectInfoCacheKey=buildCacheKey$1(objectApiName);const refreshedObjectInfoValueWrapper=cacheAccessor.getCommitted(objectInfoCacheKey);if(refreshedObjectInfoValueWrapper){if(objectInfoETag!==refreshedObjectInfoValueWrapper.eTag){refreshRecordUi=true;break;}}}}}if(refreshRecordUi){this.refreshRecordUi(affectedKey);return;}// A full refresh is unnecessary -- just do denorm and staging of an emit.
    const normalizedRecordUiValueWrapper=cacheAccessor.get(affectedKey);if(normalizedRecordUiValueWrapper){try{const recordUi=this.denormalizeValue(normalizedRecordUiValueWrapper.value,cacheAccessor);// Denorm was successful
    if(recordUi){const recordUiValueWrapperToEmit=cloneWithValueOverride(normalizedRecordUiValueWrapper,recordUi);cacheAccessor.stageEmit(affectedKey,recordUiValueWrapperToEmit);return;}}catch(err){// Denormalization failed for some reason. Could be because there are missing pieces.
    this.refreshRecordUi(affectedKey);return;}}};}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param cacheKey The cache key for the recordUi.
         * @param recordIds The list of record ids for the recordUi.
         * @param layoutTypes The list of layout types for the recordUi.
         * @param modes The list of modes for the recordUi.
         * @param optionalFields The list of optional fields for the recordUi.
         * @param rootRecordMerge True if the cache should attempt to merge the record values instead of replacing them.
         * @param localFreshRecordUi Optional. A recordUi value you want explicitly put into cache instead of getting the value from the server.
         * @returns Returns a ValueProviderResult as the outcome of the operation.
         */_getFreshValue(cacheAccessor,cacheKey,recordIds,layoutTypes,modes,optionalFields,rootRecordMerge,localFreshRecordUi){if(rootRecordMerge===undefined){rootRecordMerge=false;}let transportResponseThenable;if(localFreshRecordUi){// If the recordUi is provided, we don't go to server to fetch it.
    transportResponseThenable=Thenable.resolve(getOkFetchResponse(localFreshRecordUi));}else {if(optionalFields){optionalFields=optionalFields.slice().sort();}const params={recordIds,layoutTypes,modes,optionalFields};{transportResponseThenable=aggregateUiExecutor.executeSingleRequestOverAggregateUi("getRecordUi",params,RECORD_UI_TTL);}}return transportResponseThenable.then(transportResponse=>{// Cache miss.
    // It's a cache miss and we are going normalize the recordUi, mark, and merge the spanning records, then stage and commit puts for the
    // records which are merged successfully. Finally we will denorm and stage emits for affected values that haven't changed
    // but depend on changed values.
    const freshRecordUiValue=transportResponse.body;cacheAccessor.stageClearDependencies(cacheKey);// Nothing should depend on this yet; included for completeness.
    this._normalizeAndStagePutRecordUi([],freshRecordUiValue,cacheAccessor,cacheKey,rootRecordMerge);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}/**
         * Returns true if the existing recordUi cache value is valid, else false.
         * @param cacheAccessor The cacheAccessor.
         * @param normalizedRecordUi The existing recordUi cache value.
         * @returns See description.
         */_validateRecordUiCacheValue(cacheAccessor,normalizedRecordUi){try{const denormalizedRecordUi=this.denormalizeValue(normalizedRecordUi,cacheAccessor);return !!denormalizedRecordUi;}catch(err){return false;}}/**
         * Denormalizes a the given normalizedRecordUi value. Will piece back together all the actual values
         * for object infos, records, layouts, etc.
         * @param normalizedRecordUi The normalizedRecordUi to denormalize.
         * @param cacheAccessor The cache accessor.
         * @returns The denormalized record ui value.
         * @throws FetchReponse Throws an error if the denormalize cannot be completed successfully.
         */denormalizeValue(normalizedRecordUi,cacheAccessor){const objectToClone=normalizedRecordUi;const denormalizedRecordUi=cloneDeepCopy(objectToClone);// Object info denormalization.
    const objectInfos=normalizedRecordUi.objectInfos;const objectApiNames=Object.keys(objectInfos);for(let len=objectApiNames.length,n=0;n<len;n++){const objectApiName=objectApiNames[n];const objectInfoCacheKey=buildCacheKey$1(objectApiName);const cachedObjectInfoValueWrapper=cacheAccessor.get(objectInfoCacheKey);if(cachedObjectInfoValueWrapper){denormalizedRecordUi.objectInfos[objectApiName]=cachedObjectInfoValueWrapper.value;}else {throw getLdsInternalError("DENORMALIZE_FAILED","Did not get an object info back for marker: "+serialize(objectInfoCacheKey),true);}}// Records denormalization.
    const recordMarkersArray=[];const recordIds=Object.keys(normalizedRecordUi.records);for(let len=recordIds.length,n=0;n<len;n++){const recordId=recordIds[n];const recordMarker=normalizedRecordUi.records[recordId];recordMarkersArray.push(recordMarker);// TODO: what we have (and had since 210) is the full version of the record, not filtered to the set of fields that were requested. Revisit.
    }const denormalizedRecordsArray=fromRecordMarkers(this._recordService,cacheAccessor,recordMarkersArray);if(denormalizedRecordsArray.length!==recordMarkersArray.length){throw getLdsInternalError("DENORMALIZE_FAILED",`Expected ${recordMarkersArray.length} records but received ${denormalizedRecordsArray.length}`,true);}for(let c=0,len=denormalizedRecordsArray.length;c<len;++c){const denormalizedRecord=denormalizedRecordsArray[c];if(denormalizedRecord){denormalizedRecordUi.records[denormalizedRecord.id]=denormalizedRecord;}else {throw getLdsInternalError("DENORMALIZE_FAILED",`Did not get a denormalized record back for marker: ${recordMarkersArray[c].id}`,false);}}// Layout denormalization.
    const cachedLayoutInfo=normalizedRecordUi.layouts;const cachedLayoutInfoObjectApiNames=Object.keys(cachedLayoutInfo);for(let len=cachedLayoutInfoObjectApiNames.length,n=0;n<len;n++){const objectApiName=cachedLayoutInfoObjectApiNames[n];const recordTypeIds=Object.keys(cachedLayoutInfo[objectApiName]);for(let recordTypeIdsLength=recordTypeIds.length,n1=0;n1<recordTypeIdsLength;n1++){const recordTypeId=recordTypeIds[n1];const layoutTypes=Object.keys(cachedLayoutInfo[objectApiName][recordTypeId]);for(let layoutTypesLength=layoutTypes.length,n2=0;n2<layoutTypesLength;n2++){const layoutType=layoutTypes[n2];const modes=Object.keys(cachedLayoutInfo[objectApiName][recordTypeId][layoutType]);for(let modesLength=modes.length,n3=0;n3<modesLength;n3++){const mode=modes[n3];const layoutCacheKey=buildCacheKey$2(objectApiName,recordTypeId,layoutType,mode);const cachedLayoutValueWrapper=cacheAccessor.get(layoutCacheKey);if(cachedLayoutValueWrapper){denormalizedRecordUi.layouts[objectApiName][recordTypeId][layoutType][mode]=cachedLayoutValueWrapper.value;}else {throw getLdsInternalError("DENORMALIZE_FAILED","Did not get a denormalized layout back for marker: "+serialize(layoutCacheKey),true);}}}}}// Layout user state denormalization.
    const layoutUserStates=normalizedRecordUi.layoutUserStates;const layoutIds=Object.keys(layoutUserStates);for(let len=layoutIds.length,n=0;n<len;n++){const layoutId=layoutIds[n];// Find the key identifiers for this layout id in the layouts section of the record ui.
    const layoutUserStateMarker=normalizedRecordUi.layoutUserStates[layoutId];const layoutUserStateCacheKey=buildCacheKey$4(layoutUserStateMarker.objectApiName,layoutUserStateMarker.recordTypeId,layoutUserStateMarker.layoutType,layoutUserStateMarker.mode);const cachedLayoutUserStateValueWrapper=cacheAccessor.get(layoutUserStateCacheKey);if(cachedLayoutUserStateValueWrapper){denormalizedRecordUi.layoutUserStates[layoutId]=cachedLayoutUserStateValueWrapper.value;}else {throw getLdsInternalError("DENORMALIZE_FAILED","Did not get a denormalized layout user state for marker: "+serialize(layoutUserStateCacheKey),true);}}// The denormalized RecordUi should now be ready to go.
    return denormalizedRecordUi;}/**
         * Returns a Thenable that resolves once the RecordUi has been normalized and all necessary puts staged.
         * @param dependencies List of dependent cache keys that depend on the given recordUi.
         * @param denormalizedRecordUi Record UI denormalized value
         * @param cacheAccessor An object to access cache directly
         * @param recordUiCacheKey Cache key for Record UI
         * @param rootRecordMerge True if we should attempt to merge the root record during normalization. This should only happen from ADS bridge
         *      code paths. If this request originated from LDS, then we know the record has all the fields we are interested in and is the freshest version.
         */_normalizeAndStagePutRecordUi(dependencies,denormalizedRecordUi,cacheAccessor,recordUiCacheKey,rootRecordMerge){const objectToClone=denormalizedRecordUi;const normalizedRecordUi=cloneDeepCopy(objectToClone);// Object Info normalization
    const objectInfos=denormalizedRecordUi.objectInfos;const objectApiNames=Object.keys(objectInfos);for(let len=objectApiNames.length,n=0;n<len;n++){const objectApiName=objectApiNames[n];const objectInfo=objectInfos[objectApiName];// Construct the marker.
    normalizedRecordUi.objectInfos[objectApiName]={objectApiName:objectInfo.apiName,eTag:objectInfo.eTag};this._ldsCache.stagePutValue(OBJECT_INFO_VALUE_TYPE,[{cacheKey:recordUiCacheKey,type:1/* REQUIRED */}],objectInfo,cacheAccessor);}// Layout normalization
    const layouts=denormalizedRecordUi.layouts;const fieldsOnLayoutByObjectApiName={};const layoutObjectApiNames=Object.keys(layouts);for(let len=layoutObjectApiNames.length,n=0;n<len;n++){const objectApiName=layoutObjectApiNames[n];const recordTypeIdObjects=layouts[objectApiName];const recordTypeIds=Object.keys(recordTypeIdObjects);for(let recordTypeIdsLength=recordTypeIds.length,n1=0;n1<recordTypeIdsLength;n1++){const recordTypeId=recordTypeIds[n1];const layoutTypes=recordTypeIdObjects[recordTypeId];const layoutTypeIds=Object.keys(layoutTypes);for(let layoutTypesLength=layoutTypeIds.length,n2=0;n2<layoutTypesLength;n2++){const layoutType=layoutTypeIds[n2];const modeObjects=layoutTypes[layoutType];const modes=Object.keys(modeObjects);for(let modesLength=modes.length,n3=0;n3<modesLength;n3++){const mode=modes[n3];const layout=modeObjects[mode];// Keep track of the set of fields on the layouts.
    if(fieldsOnLayoutByObjectApiName[objectApiName]===undefined){fieldsOnLayoutByObjectApiName[objectApiName]=new Set();}addAll(fieldsOnLayoutByObjectApiName[objectApiName],getQualifiedFieldApiNamesFromLayout(layout,denormalizedRecordUi.objectInfos[objectApiName]));// Construct the marker for layout.
    normalizedRecordUi.layouts[objectApiName][recordTypeId][layoutType][mode]={objectApiName,recordTypeId,layoutType:layout.layoutType,mode:layout.mode,eTag:layout.eTag};this._ldsCache.stagePutValue(LAYOUT_VALUE_TYPE,[{cacheKey:recordUiCacheKey,type:1/* REQUIRED */}],layout,cacheAccessor,{objectApiName,recordTypeId});}}}}// Layout user state normalization.
    const layoutUserStates=denormalizedRecordUi.layoutUserStates;const layoutIds=Object.keys(layoutUserStates);for(let len=layoutIds.length,n=0;n<len;n++){const layoutId=layoutIds[n];const layoutUserState=layoutUserStates[layoutId];// Find the key identifiers for this layout id in the layouts section of the record ui.
    const layoutUserStateKeyParts=this._getLayoutUserStateKeyPartsFromRecordUiByLayoutId(denormalizedRecordUi,layoutId);{assert$2(layoutUserStateKeyParts,"layoutUserStateKeyParts must not be falsy");}const objectApiName=layoutUserStateKeyParts.objectApiName;const recordTypeId=layoutUserStateKeyParts.recordTypeId;const layoutType=layoutUserStateKeyParts.layoutType;const mode=layoutUserStateKeyParts.mode;// add Marker for the Layout user states
    normalizedRecordUi.layoutUserStates[layoutId]={objectApiName:layoutUserStateKeyParts.objectApiName,recordTypeId:layoutUserStateKeyParts.recordTypeId,layoutType:layoutUserStateKeyParts.layoutType,mode:layoutUserStateKeyParts.mode};this._ldsCache.stagePutValue(LAYOUT_USER_STATE_VALUE_TYPE,[{cacheKey:recordUiCacheKey,type:1/* REQUIRED */}],layoutUserState,cacheAccessor,{objectApiName,recordTypeId,layoutType,mode});}// Record normalization
    const recordService=this._ldsCache.getService(RECORD_VALUE_TYPE);const records=denormalizedRecordUi.records;const recordIds=Object.keys(records);for(let len=recordIds.length,n=0;n<len;n++){const recordId=recordIds[n];const record=records[recordId];// Ensure record service tracks ALL the fields on the layouts. This won't necessarily happen
    // when the record gets merged because the record might not have all the fields that are on the full layout.
    const fieldsOnLayout=fieldsOnLayoutByObjectApiName[record.apiName];if(fieldsOnLayout){recordService.addFieldsToTrack(recordId,fieldsOnLayout);}normalizedRecordUi.records[recordId]=toRecordMarker(cacheAccessor,record,0,denormalizedRecordUi.objectInfos[record.apiName]);this._ldsCache.stagePutValue(RECORD_VALUE_TYPE,[{cacheKey:recordUiCacheKey,type:1/* REQUIRED */}],record,cacheAccessor,{rootRecordMerge});}// Stage put the record ui.
    // Strip out the eTag from the value. We don't want to emit eTags!
    delete normalizedRecordUi.eTag;denormalizedRecordUi=this.stripETagsFromValue(denormalizedRecordUi);// Record ui will not store an eTag because it is an aggregate value.
    cacheAccessor.stagePut(dependencies,recordUiCacheKey,normalizedRecordUi,denormalizedRecordUi);}/**
         * Constructs and returns the layout user state cache key parts by layout id extracted from the given recordUi.
         * @param recordUi The recordUi to search for the given layoutId.
         * @param layoutId The layoutId of the layout with which to associate the userState update.
         * @returns See description.
         */_getLayoutUserStateKeyPartsFromRecordUiByLayoutId(recordUi,layoutId){// Search through the recordUi.layouts tree structure to find the matching layout with the given layoutId.
    const objectApiNames=Object.keys(recordUi.layouts);for(let len=objectApiNames.length,objectApiNameIndex=0;objectApiNameIndex<len;++objectApiNameIndex){const objectApiName=objectApiNames[objectApiNameIndex];const recordTypeIds=Object.keys(recordUi.layouts[objectApiName]);for(let recordTypeIdsLen=recordTypeIds.length,recordTypeIdIndex=0;recordTypeIdIndex<recordTypeIdsLen;++recordTypeIdIndex){const recordTypeId=recordTypeIds[recordTypeIdIndex];const layoutTypes=Object.keys(recordUi.layouts[objectApiName][recordTypeId]);for(let layoutTypesLen=layoutTypes.length,layoutTypeIndex=0;layoutTypeIndex<layoutTypesLen;++layoutTypeIndex){const layoutType=layoutTypes[layoutTypeIndex];const modes=Object.keys(recordUi.layouts[objectApiName][recordTypeId][layoutType]);for(let modeLength=modes.length,modeIndex=0;modeIndex<modeLength;++modeIndex){const mode=modes[modeIndex];const layout=recordUi.layouts[objectApiName][recordTypeId][layoutType][mode];if(layout.id===layoutId){// We found the matching layout, so construct the payload and return.
    return {objectApiName,recordTypeId,layoutType,mode};}}}}}// A matching layout was not found!
    return null;}/**
         * Constructs a value provider to retrieve a RecordUi.
         * @param recordUiValueProviderParameters See RecordUiValueProviderParams for a description of each parameter.
         * @returns The value provider to retrieve a RecordUi.
         */_createRecordUiValueProvider(recordUiValueProviderParameters){const valueProvider=new ValueProvider((cacheAccessor,recordUiValueProviderParams)=>{const{cacheKey,recordIds,layoutTypes,modes,optionalFields,localFreshRecordUi}=recordUiValueProviderParams;let{forceProvide,rootRecordMerge}=recordUiValueProviderParams;// Set defaults.
    forceProvide=forceProvide===true;rootRecordMerge=rootRecordMerge===true;// We need to inform recordLibrary of new records, wrap the cache accessor which will track all new things in this
    // cache operation and let commitPuts() handle the informs.
    cacheAccessor=wrapCacheAccessor(cacheAccessor,this._adsBridge);// W-5043986: Fix this as part of this story.
    // TODO: since we're effectively unioning all the fields for each entity type together, we need to add tracking for this on the return
    // once we know all the records and their entity types. We're not doing that yet.
    if(forceProvide){return this._getFreshValue(cacheAccessor,cacheKey,recordIds,layoutTypes,modes,optionalFields,rootRecordMerge,localFreshRecordUi);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;// check for ttl expiry
    const needsRefresh=nowTime>lastFetchTime+RECORD_UI_TTL;if(needsRefresh){// Value is stale; get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,recordIds,layoutTypes,modes,optionalFields,rootRecordMerge,localFreshRecordUi);}// Value is not stale, but we still need to validate the cached value
    const isValid=this._validateRecordUiCacheValue(cacheAccessor,existingValueWrapper.value);if(isValid){// make a call to recordService.getRecordWithFields which will update the record in case it's expired.
    // once the record gets updated, the record-ui's affected key handler will get invoked and thereby an updated record-ui will be emitted.
    const firstRecordId=recordIds[0];const trackedRecordFields=this._recordService.getFieldsForRecord(firstRecordId);const trackedRecordFieldsArray=collectionToArray(trackedRecordFields);// record service is used to check/refresh the record, if the record is stale, the service will refresh it otherwise will return a cache hit.
    this._recordService.getRecordWithFields(firstRecordId,[],trackedRecordFieldsArray);return Thenable.resolve(1/* CACHE_HIT */);}// Existing value is not valid; get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,recordIds,layoutTypes,modes,optionalFields,rootRecordMerge,localFreshRecordUi);}// No existing value; get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,recordIds,layoutTypes,modes,optionalFields,rootRecordMerge,localFreshRecordUi);},recordUiValueProviderParameters);return valueProvider;}// Quick-access to the logic in _createRecordUiValueProvider, and could be used to refactor that for readability
    hasValidCachedValue(cacheAccessor,params){const{recordIds,layoutTypes,modes,uniqueOptionalFields}=params;const cacheKey=buildCacheKey$3(recordIds,layoutTypes,modes,uniqueOptionalFields);const existingValueWrapper=cacheAccessor.get(cacheKey);return !!existingValueWrapper&&existingValueWrapper.value!==undefined&&cacheAccessor.nowTime<=existingValueWrapper.lastFetchTime+RECORD_UI_TTL&&this._validateRecordUiCacheValue(cacheAccessor,existingValueWrapper.value);}/**
         * @returns Reference to the RecordService instance.
         */get _recordService(){return this._ldsCache.getService(RECORD_VALUE_TYPE);}}/**
     * Wire adapter id: getRecordUi.
     * @throws Error - Always throws when invoked. Imperative invocation is not supported.
     */function getRecordUi(){throw generateError("getRecordUi");}/**
     * Generates the wire adapters for:
     *      * @wire getRecordUi
     */class RecordUiWireAdapterGenerator{/**
         * Constructor.
         * @param recordUiService Reference to the RecordUiService instance.
         */constructor(recordUiService){this._recordUiService=recordUiService;}/**
         * Generates the wire adapter for @wire getRecordUi.
         * @returns See description.
         */generateGetRecordUiWireAdapter(){const wireAdapter=generateWireAdapter(this._serviceGetRecordUi.bind(this));return wireAdapter;}/**
         * @private Made public for testing.
         * Service @wire getRecordUi.
         * @param config Config params for the service. The type is or'd with any so that we can test sending bad configs. Consumers will be able to send us bad configs.
         * @return Observable stream that emits a record ui object.
         */_serviceGetRecordUi(config){if(!config){return undefined;}{// validate schema
    const required=["modes","layoutTypes","recordIds"];const supported=["layoutTypes","modes","optionalFields","recordIds"];const unsupported=["formFactor","childRelationships","pageSize"];// TODO W-6220452 (formFactor), W-4421501 (childRelationships, pageSize)
    validateConfig$1("getRecordUi",config,required,supported,unsupported);}// toArray() + isArrayOfNonEmptyStrings() provides a runtime guarantee that a value is a
    // string[] with length > 0.
    const recordIds=toArray(config.recordIds);const layoutTypes=toArray(config.layoutTypes);const modes=toArray(config.modes);let optionalFields=toArray(config.optionalFields);if(!isArrayOfNonEmptyStrings(recordIds)){return undefined;}if(!isArrayOfNonEmptyStrings(layoutTypes)){return undefined;}if(!isArrayOfNonEmptyStrings(modes)){return undefined;}optionalFields=optionalFields.map(getFieldApiName$1);if(optionalFields.length!==0&&!isArrayOfNonEmptyStrings(optionalFields)){return undefined;}return this._recordUiService.getRecordUi(recordIds.map(to18),layoutTypes,modes,optionalFields);}}/**
     * Provides crud functionality for records in the cache. Can refresh records with data from the server.
     * We do not utilize caching or sending eTags to the server for this value type because it gets invalidated
     * quickly on the client from having its atoms updated.
     */class RecordService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         * @param adsBridge Reference to the AdsBridge instance.
         */constructor(ldsCache,adsBridge){super(ldsCache,[RECORD_VALUE_TYPE]);/**
             * Mapping of record id -> fields requested by ADS. LDS is not currently interested in these but we will add these fields to fetch on CACHE_MISS or refresh.
             */this._recordIdsToFieldsToRefreshMap=new Map();/**
             * Mapping of record id -> readOnly observable.
             */this._recordIdsToReadOnlyObservablesMap=new Map();/**
             * Mapping of filtered observable cache key -> filtered observable.
             */this._filteredObservables=new Map();/**
             * Mapping of record id -> number of current active refreshes. This is used to prevent filtered observables
             * from emitting old values while a refresh(s) is happening.
             */this._recordIdsToIsRefreshingMap=new Map();/**
             * Set of entities that have had server calls to UI API fail.
             */this._unsupportedEntitiesSet=new Set();this._adsBridge=adsBridge;}/**
         * Returns the ttl for records.
         */getCacheValueTtl(){return RECORD_TTL;}/**
         * Gets a record.
         * @param recordId Id of the record to retrieve.
         * @param fields Qualified field API names to retrieve. If any are inaccessible then an error is emitted.
         * @param optionalFields Qualified field API names to retrieve. If any are inaccessible then they are silently omitted.
         * @returns An observable of the record.
         */getRecordWithFields(recordId,fields,optionalFields){return this.getRecordWithFieldsWithMetaConfig(recordId,fields,optionalFields);}/**
         * WARNING: PLEASE DO NOT USE THIS METHOD DIRECTLY FROM RECORD SERVICE, CONTACT LDS TEAM FOR MORE INFORMATION
         * Note: This method is used to refresh the record by skipping the cache, and must not be exported to force-lds-records
         * Gets a record with with additional retrieval configuration.
         * @param recordId Id of the record to retrieve.
         * @param fields Qualified field API names to retrieve. If any are inaccessible then an error is emitted.
         * @param optionalFields Qualified field API names to retrieve. If any are inaccessible then they are silently omitted.
         * @param metaConfig Retrieval configuration.
         *        forceProvide - if true then the cache is skipped
         *        successCallback - callback to be invoked after the refresh is complete
         *        errorCallback - callback to be invoked after the refresh fails
         * @returns An observable of the record.
         */getRecordWithFieldsWithMetaConfig(recordId,fields,optionalFields,metaConfig){const filteredObservable=this._privateGetRecordWithFields(recordId,fields,optionalFields,undefined,false,false,metaConfig);return filteredObservable;}/**
         * Gets a record by layoutType. The given layoutType specifies which fields will be returned on the record as well as any fields additionally specified
         * by fields and optionalFields.
         * @param recordId Id of the record to retrieve.
         * @param layoutTypes List of layoutTypes identifying the layouts from which to grab the field list.
         * @param modes List of modes identifying the layouts from which to grab the field list.
         * @param optionalFields Qualified field API names to retrieve in additional to those on the layout(s). If any are inaccessible then they are silently omitted.
         * @returns A thenable that resolves to an observable of the record.
         */getRecordWithLayouts(recordId,layoutTypes,modes,optionalFields){return this.getRecordWithLayoutsWithMetaConfig(recordId,layoutTypes,modes,optionalFields);}/**
         * WARNING: PLEASE DO NOT USE THIS METHOD DIRECTLY FROM RECORD SERVICE, CONTACT LDS TEAM FOR MORE INFORMATION
         * Note: This method is used to refresh the record by skipping the cache, and must not be exported to force-lds-records
         * Gets a record with layouts with with additional retrieval configuration.
         * @param recordId Id of the record to retrieve.
         * @param layoutTypes List of layoutTypes identifying the layouts from which to grab the field list.
         * @param modes List of modes identifying the layouts from which to grab the field list.
         * @param optionalFields Qualified field API names to retrieve in additional to those on the layout(s). If any are inaccessible then they are silently omitted.
         * @param metaConfig Retrieval configuration.
         *        forceProvide - if true then the cache is skipped
         *        successCallback - callback to be invoked after the refresh is complete
         *        errorCallback - callback to be invoked after the refresh fails
         * @returns An observable of the record.
         * @throws Throws an error when input fails validation.
         */getRecordWithLayoutsWithMetaConfig(recordId,layoutTypes,modes,optionalFields,metaConfig){let objectApiName;let recordTypeId;let record;let layouts=[];let objectInfo;return this._ldsCache.access().then(()=>{// Try to get the record so we can grab the objectApiName and recordTypeId so we can get the metadata
    // necessary to figure out the fields on the layouts.
    const recordCacheKey=buildRecordCacheKey(recordId);const recordValueWrapper=this._ldsCache.getValue(recordCacheKey);if(recordValueWrapper!==undefined&&isWithinTtl(this._ldsCache.timeSource.now(),recordValueWrapper.lastFetchTime,RECORD_TTL)){record=recordValueWrapper.value;}const results=[];if(record!==undefined){// Try to get the object info and layouts so we can get the fields list.
    objectApiName=record.apiName;recordTypeId=record.recordTypeInfo?record.recordTypeInfo.recordTypeId:MASTER_RECORD_TYPE_ID;const objectInfoCacheKey=buildCacheKey$1(record.apiName);results.push(this._ldsCache.getValue(objectInfoCacheKey));for(let layoutTypesLen=layoutTypes.length,layoutTypesIndex=0;layoutTypesIndex<layoutTypesLen;layoutTypesIndex++){for(let modesLen=modes.length,modesIndex=0;modesIndex<modesLen;modesIndex++){const layoutType=layoutTypes[layoutTypesIndex];const mode=modes[modesIndex];const layoutCacheKey=buildCacheKey$2(objectApiName,recordTypeId,layoutType,mode);results.push(this._ldsCache.getValue(layoutCacheKey));}}}// Validate object info and layouts retrieved from cache.
    if(results.length){const objectInfoValueWrapper=results[0];if(objectInfoValueWrapper!==undefined&&isWithinTtl(this._ldsCache.timeSource.now(),objectInfoValueWrapper.lastFetchTime,OBJECT_INFO_TTL)){objectInfo=objectInfoValueWrapper.value;}const layoutValueWrappers=results.slice(1);for(let len=layoutValueWrappers.length,n=0;n<len;n++){const layoutValueWrapper=layoutValueWrappers[n];if(layoutValueWrapper!==undefined&&isWithinTtl(this._ldsCache.timeSource.now(),layoutValueWrapper.lastFetchTime,LAYOUT_TTL)){layouts.push(layoutValueWrapper.value);}else {layouts=[];break;}}}const fieldsOnLayouts=new Set();if(record&&objectInfo&&layouts.length>0){// We have all the necessary metadata to get the fields on the given layouts, so let's get them!
    for(let len=layouts.length,n=0;n<len;n++){const layout=layouts[n];addAll(fieldsOnLayouts,getQualifiedFieldApiNamesFromLayout(layout,objectInfo));}// We finally have the fields on the layout, so now we can make a call to get the record.
    // NOTE: If we had to make the getRecordUi call earlier this will be a cache hit!
    return Thenable.resolve(this._privateGetRecordWithFields(recordId,collectionToArray(fieldsOnLayouts),optionalFields,undefined,false,false,metaConfig));}else {// At this point we are unable to get the fields list for the layout from the cache because we lack the necessary metadata.
    // We need to retrieve this metadata from the server by making a bulk call to record ui (this will also
    // get us the record too so the call later to get the record will just be a cache hit!)
    const recordUiService=this._ldsCache.getService(RECORD_UI_VALUE_TYPE);return observableToPromise(recordUiService.getRecordUi([recordId],layoutTypes,modes,optionalFields),true).then(recordUi=>{const layoutsKeys=Object.keys(recordUi.layouts);for(let layoutsKeysIndex=0,layoutsKeyIndexLength=layoutsKeys.length;layoutsKeysIndex<layoutsKeyIndexLength;++layoutsKeysIndex){const currObjectApiName=layoutsKeys[layoutsKeysIndex];const layoutsForObjectApiName=recordUi.layouts[currObjectApiName];const layoutsForObjectApiNameKeys=Object.keys(layoutsForObjectApiName);for(let layoutsForObjectApiNameKeysIndex=0,layoutsForObjectApiNameKeysLength=layoutsForObjectApiNameKeys.length;layoutsForObjectApiNameKeysIndex<layoutsForObjectApiNameKeysLength;++layoutsForObjectApiNameKeysIndex){const currRecordTypeId=layoutsForObjectApiNameKeys[layoutsForObjectApiNameKeysIndex];const layoutsForRecordTypeId=layoutsForObjectApiName[currRecordTypeId];const layoutsForRecordTypeIdKeys=Object.keys(layoutsForRecordTypeId);for(let layoutsForRecordTypeIdKeysIndex=0,layoutsForRecordTypeIdKeysLength=layoutsForRecordTypeIdKeys.length;layoutsForRecordTypeIdKeysIndex<layoutsForRecordTypeIdKeysLength;++layoutsForRecordTypeIdKeysIndex){const currLayoutType=layoutsForRecordTypeIdKeys[layoutsForRecordTypeIdKeysIndex];const layoutsForLayoutType=layoutsForRecordTypeId[currLayoutType];const layoutsForLayoutTypeKeys=Object.keys(layoutsForLayoutType);for(let layoutsForLayoutTypeKeysIndex=0,layoutsForLayoutTypeKeysLength=layoutsForLayoutTypeKeys.length;layoutsForLayoutTypeKeysIndex<layoutsForLayoutTypeKeysLength;++layoutsForLayoutTypeKeysIndex){const currMode=layoutsForLayoutTypeKeys[layoutsForLayoutTypeKeysIndex];const layout=layoutsForLayoutType[currMode];addAll(fieldsOnLayouts,getQualifiedFieldApiNamesFromLayout(layout,recordUi.objectInfos[recordUi.records[recordId].apiName]));}}}}return this._privateGetRecordWithFields(recordId,collectionToArray(fieldsOnLayouts),optionalFields,undefined,false,false,metaConfig);});}});}/**
         * Creates a new record using the properties defined in the given recordInput.
         * @param recordInput The RecordInput object to use to create the record.
         * @returns A promise that will resolve with the newly created record.
         *          The record will contain data for the list of fields as defined by the applicable layout
         *          for the record
         */async createRecord(recordInput){if(!recordInput){throw new Error("recordInput must be provided");}if(!recordInput.fields){throw new Error("recordInput must have its fields property set");}if(!("allowSaveOnDuplicate"in recordInput)){recordInput.allowSaveOnDuplicate=false;}checkType(recordInput.allowSaveOnDuplicate,Boolean);const transportResponse=await this._makeServerCall(undefined,"RecordUiController.createRecord",{recordInput});const newRecord=transportResponse.body;// Put the value into the cache by doing a get with a value provider that returns our newRecord object locally.
    // This will start the flow of going through all the due diligence of tracking fields, normalizing the record,
    // processing spanning records, etc.
    const newRecordCacheKey=getRecordCacheKey(newRecord);const fieldSet=new Set();recursivelyGatherFieldNames(newRecord.apiName,newRecord,fieldSet);const recordValueProviderParams={cacheKey:newRecordCacheKey,recordId:newRecord.id,optionalFields:collectionToArray(fieldSet),forceProvide:true,localFreshRecord:newRecord,rootRecordMerge:false,informRecordLib:true,resolveRootMerge:false};const localValueProviderForNewRecord=this._createRecordValueProvider(recordValueProviderParams);const observableForNewRecord=this._privateGetRecordWithFields(newRecord.id,[],collectionToArray(fieldSet),localValueProviderForNewRecord,undefined,undefined,undefined,true);// Only resolve when we get an emit for the newRecord. Then we will know it is in the cache. Since we are passing in a local value provider that already has the record,
    // the observable will have emitted by the time the above statement returns. This means when we subscribe the hotness value will be the most recent.
    return observableToPromise(observableForNewRecord,false,1);}/**
         * Updates a given record with updates described in the given recordInput object. Must have the recordInput.fields.Id property set to the record id
         * of the record to update.
         * @param recordInput The record input representation to use to update the record.
         * @param clientOptions Should take ifUnmodifiedSince to check for conflicts for update
         * @returns A promise that will resolve with the patched record. The record will contain data for the list of fields as defined by the
         *          applicable layout for the record as well as any specified additionalFieldsToReturn.
         */async updateRecord(recordInput,clientOptions){if(!recordInput){throw new Error("recordInput must be provided");}if(!recordInput.fields||!recordInput.fields.Id){throw new Error("recordInput must have its fields.Id property set");}if(!("allowSaveOnDuplicate"in recordInput)){recordInput.allowSaveOnDuplicate=false;}checkType(recordInput.allowSaveOnDuplicate,Boolean);// TODO: When W-4302741 gets finished, update this code to request for additional fields for any that we might already be tracking
    // for the record. This will relinquish the need to make a separate GET call for getting a fresh copy of ALL the fields
    // we need.
    const transportResponse=await this._makeServerCall(recordInput.fields.Id,"RecordUiController.updateRecord",{recordId:recordInput.fields.Id,recordInput,clientOptions});const updatedRecord=transportResponse.body;// Request a fresh copy of the record from UIAPI. This will ensure we get a fresh value for all the fields we are tracking. Force an eviction.
    const fieldSet=new Set();recursivelyGatherFieldNames(updatedRecord.apiName,updatedRecord,fieldSet);// Resolve the promise when the refresh has completed.
    const resultPromise=new Promise((resolve,reject)=>{const successCallback=()=>{resolve(this.stripETagsFromValue(updatedRecord));};const metaConfig={forceProvide:true,finishedCallbacks:{successCallback,errorCallback:reject}};// When W-4302741 is finished we will not need to make this call.
    this._privateGetRecordWithFields(updatedRecord.id,[],collectionToArray(fieldSet),undefined,true,true,metaConfig,true);});return resultPromise;}/**
         * Deletes a record given the recordId.
         * @param recordId The 18 char record ID for the record to be retrieved.
         * @returns A promise that resolves when the record is deleted.
         */async deleteRecord(recordId){if(!recordId){throw new Error("recordId must be provided");}await this._makeServerCall(recordId,"RecordUiController.deleteRecord",{recordId});const recordCacheKey=buildRecordCacheKey(recordId);return this._ldsCache.access().then(()=>{this._ldsCache.deleteValueAndDeleteObservable(recordCacheKey);});}/**
         * Stage puts the given record.
         * @param dependencies An array of dependent cache keys.
         * @param record The record to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         * @returns True if the operation succeeded, else false.
         */stagePutValue(dependencies,record,cacheAccessor,additionalData){if(additionalData.optionalFields){this.addFieldsToTrack(record.id,additionalData.optionalFields);}this.mergeRecordAndStagePut(dependencies,record,cacheAccessor,additionalData.rootRecordMerge,additionalData.resolveRootMerge);}/**
         * Strips all eTag properties from the record by directly deleting them (including nested records.)
         * @param record The record from which to strip the eTags.
         * @returns The same record object with its eTags stripped.
         */stripETagsFromValue(record){delete record.eTag;delete record.weakEtag;const fields=record.fields;if(fields){const fieldKeys=Object.keys(fields);for(let n=0,len=fieldKeys.length;n<len;n++){const field=fields[fieldKeys[n]];if(field){const fieldValue=field.value;if(isRecordRepresentation(fieldValue)){// Found a spanning record, so let's recurse!
    this.stripETagsFromValue(fieldValue);}}}}return record;}/**
         * Affected Key handler for record.
         * @returns The affected key handler for this service.
         */getAffectedKeyHandler(){return (affectedKey,cacheAccessor)=>{const normalizedRecordValueWrapper=cacheAccessor.get(affectedKey);if(normalizedRecordValueWrapper&&normalizedRecordValueWrapper.value){try{const record=this.denormalizeValue(normalizedRecordValueWrapper.value,cacheAccessor);if(record){const recordValueWrapperToEmit=cloneWithValueOverride(normalizedRecordValueWrapper,record);cacheAccessor.stageEmit(affectedKey,recordValueWrapperToEmit);}}catch(err){// Denormalization of record failed since record was deleted, proceed to refresh
    const recordId=affectedKey.key;const optionalFields=this.getFieldsForRecord(recordId);this._privateGetRecordWithFields(recordId,[],collectionToArray(optionalFields),undefined,false,true);}}};}/**
         * Takes the normalized record and cacheAccessor and returns the denormalized record.
         * @param normalizedRecord The record to denormalized. This should always be a normalized record that came from the cache.
         * @param cacheAccessor The CacheAccessor in scope for this operation.
         * @param depth This is a recursive call and this parameter is used to indicate what depth we're at so in cyclical cases we don't
         *        continue denormalizing forever. The SOQL limit is 5 levels, so this will denormalize to a depth of 5. Most callers do not need to
         *        provide this since they are denormalizing a top level record, so this param is optional.
         * @returns The denormalized record.
         */denormalizeValue(normalizedRecord,cacheAccessor,depth){if(depth==null){depth=0;}const value=this._denormalizeValueHelper(normalizedRecord,cacheAccessor,depth);if(!value){throw getLdsInternalError("DENORMALIZE_FAILED","Unexpectedly received undefined from denormalizeValueHelper.",true);}return value;}/**
         * Adds the given objectApiName to the list of unsupported entities.
         * @param objectApiName The object api name to add to the list of unsupported entities.
         */addUnsupportedEntity(objectApiName){this._unsupportedEntitiesSet.add(objectApiName);}/**
         * Get tracked fields for the given record from an in-memory Map
         * @param recordId The record id.
         * @returns the tracked fields for the record
         */getFieldsForRecord(recordId){// Check to see if we've ever requested these fields before.
    const _recordIdsToFieldsRequestedMap=this._saveableState._recordIdsToFieldsRequestedMap;let trackedRecordFields=_recordIdsToFieldsRequestedMap.get(recordId);if(!trackedRecordFields){trackedRecordFields=new Set();_recordIdsToFieldsRequestedMap.set(recordId,trackedRecordFields);}return trackedRecordFields;}/**
         * Set fields requested by ADS, that LDS is not interested in for the given record from an in-memory Map
         * @param recordId The record id.
         * @returns the tracked fields for the record
         */setADSFieldsForRecord(recordId){// Check to see if we've ever requested these fields before.
    const _recordIdsToFieldsToRefreshMap=this._recordIdsToFieldsToRefreshMap;let refreshRecordFields=_recordIdsToFieldsToRefreshMap.get(recordId);if(!refreshRecordFields){refreshRecordFields=new Set();_recordIdsToFieldsToRefreshMap.set(recordId,refreshRecordFields);}return refreshRecordFields;}/**
         * Get fields requested by ADS, that LDS is not interested in for the given record from an in-memory Map
         * @param recordId
         * @returns the tracked fields for the record
         */getADSFieldsForRecord(recordId){// Check to see if we've ever requested these fields before.
    const _recordIdsToFieldsToRefreshMap=this._recordIdsToFieldsToRefreshMap;const refreshRecordFields=_recordIdsToFieldsToRefreshMap.get(recordId);return refreshRecordFields;}/**
         * Record UI service (and possibly others?) sometimes need to inform record service to track fields that aren't
         * necessarily in the record they are normalizing. For instance, when record ui gets a record by layout type and mode,
         * all the fields in the layout won't necessarily be returned in the record (spanning id fields might not be set so those
         * fields won't get returned on the record even though they are on the layout!).
         * @param recordId The record id.
         * @param fields A list of fields to add to the tracked fields list for the given recordId.
         */addFieldsToTrack(recordId,fields){if(fields.length===0){return;}const trackedRecordFields=this.getFieldsForRecord(recordId);addAll(trackedRecordFields,fields);this._cacheSaveableState();}/**
         * TODO: Reexamine why record-uis.js needs this function. Should we really be exporting it?!
         * @param rootRecord Root record stored in LDS cache
         * @returns record fields for that root record
         */gatherAndTrackSpanningFields(rootRecord){const recordFieldsSet=new Set();recursivelyGatherFieldNames(rootRecord.apiName,rootRecord,recordFieldsSet);this.addFieldsToTrack(rootRecord.id,collectionToArray(recordFieldsSet));return recordFieldsSet;}/**
         * Takes an array of denormalized root records and does the work of normalizing and merging the root and all nested records.
         * Finally it stages puts for all records.
         * @param dependencies The common cache keys that depend on all of these records - required but may be empty.
         *        This list will be added to any other dependent cache keys already being tracked for these records.
         * @param denormalizedRecordsArray The denormalized root records to be cached.
         * @param cacheAccessor The CacheAccessor in scope for this operation.
         * @param rootRecordMerge RecordService has an addRecord() method which is used by ADS to add records into LDS cache. When this is called from
         *        addRecords() we need to merge the ADS record with what exists in the LDS cache because LDS may be tracking more fields than ADS is giving us.
         *        For scenarios within the LDS Records Module, if we have fetched a fresh value from the server and if it's a root record, there is no need for a
         *        merge because LDS should have retrieved all necessary fields.
         * @returns The array of cache keys for the records to be cached or refreshed as a
         *          result of this operation. The array should not contain duplicate cache keys.
         */mergeRecordsAndStagePuts(dependencies,denormalizedRecordsArray,cacheAccessor,rootRecordMerge){const cacheKeysMap=new Map();const arrayOfArrayOfCacheKeys=[];for(let len=denormalizedRecordsArray.length,c=0;c<len;++c){const denormalizedRecord=denormalizedRecordsArray[c];arrayOfArrayOfCacheKeys.push(this.mergeRecordAndStagePut(dependencies,denormalizedRecord,cacheAccessor,rootRecordMerge,false));}// Merge all returned cache keys into one array, not an array of arrays. Also remove duplicate keys if any.
    for(let len=arrayOfArrayOfCacheKeys.length,c=0;c<len;++c){const arrayOfCacheKeys=arrayOfArrayOfCacheKeys[c];for(let length1=arrayOfCacheKeys.length,i=0;i<length1;++i){const cacheKey=arrayOfCacheKeys[i];cacheKeysMap.set(serialize(cacheKey),cacheKey);}}return Array.from(cacheKeysMap.values());}/**
         * Takes a denormalized root record and does the work of normalizing and merging the root and all nested records.
         * Finally it stages puts for all merged records.
         * @param dependencies The cache keys that depend on this record - required but may be empty. This list
         *        will be added to any other dependent cache keys already being tracked for this record.
         * @param denormalizedRecord The denormalized root record to be cached.
         * @param cacheAccessor The CacheAccessor in scope for this operation.
         * @param rootRecordMerge RecordService has an addRecord() method which is used by ADS to add records into LDS cache. When this is called from
         *        addRecords() we need to merge the ADS record with what exists in the LDS cache because LDS may be tracking more fields than ADS is giving us.
         *        For scenarios within the LDS Records Module, if we have fetched a fresh value from the server and if it's a root record, there is no need for a
         *        merge because LDS should have retrieved all necessary fields.
         * @param resolveRootMerge true if during merge for a root record we should accept the record even if it has fewer fields than the existing record.
         * @param filteredRecordObservableCacheKey Cache Key if this is coming from a filtered record request.
         * @returns A Thenable that resolves to the array of cache keys for the records to be cached or refreshed as a
         *          result of this operation. The array should not contain duplicate cache keys.
         */mergeRecordAndStagePut(dependencies,denormalizedRecord,cacheAccessor,rootRecordMerge,resolveRootMerge,filteredRecordObservableCacheKey){// Check for view entities. LDS does not currently support view entities, so this we check to make sure they don't end up in the cache.
    // If they are cached without proper support they can "stomp" other records of a primary entity because they often share IDs.
    {assert$2(!isKnownViewEntity(denormalizedRecord.apiName),`View entities are not supported: ${denormalizedRecord.apiName}`);if(!denormalizedRecord.lastModifiedById||!denormalizedRecord.lastModifiedDate||!denormalizedRecord.systemModstamp){// tslint:disable-next-line:no-console
    console.log(`target record is missing required properties(lastModifiedDate, systemModstamp, lastModifiedById): ${JSON.stringify(denormalizedRecord)}`);}}if(!rootRecordMerge){// This is a full value replacement, so clear old dependencies and let them be recalculated.
    const recordCacheKey=buildRecordCacheKey(denormalizedRecord.id);cacheAccessor.stageClearDependencies(recordCacheKey);}// The normalized records(including spanning records with dependencies).
    const normalizedRecordsWithDependencies=this._getNormalizedRecordsWithDependencies(denormalizedRecord,cacheAccessor,dependencies,0);// Merge fields across the normalized records.
    const cacheKeyToNormalizedRecordsWithDependenciesMap=new Map();for(let len=normalizedRecordsWithDependencies.length,n=0;n<len;n++){const normalizedRecordWithDependencies=normalizedRecordsWithDependencies[n];if(cacheKeyToNormalizedRecordsWithDependenciesMap.has(serialize(normalizedRecordWithDependencies.sourceCachekey))){const normalizedRecordWithDependenciesFromMap=cacheKeyToNormalizedRecordsWithDependenciesMap.get(serialize(normalizedRecordWithDependencies.sourceCachekey));if(normalizedRecordWithDependenciesFromMap){// Use non-null LastModifiedById, LastModifiedDate, SystemModstamp as these could be null for the same record occuring multiple times.
    normalizedRecordWithDependencies.objectToCache.lastModifiedById=normalizedRecordWithDependencies.objectToCache.lastModifiedById||normalizedRecordWithDependenciesFromMap.objectToCache.lastModifiedById;normalizedRecordWithDependencies.objectToCache.lastModifiedDate=normalizedRecordWithDependencies.objectToCache.lastModifiedDate||normalizedRecordWithDependenciesFromMap.objectToCache.lastModifiedDate;normalizedRecordWithDependencies.objectToCache.systemModstamp=normalizedRecordWithDependencies.objectToCache.systemModstamp||normalizedRecordWithDependenciesFromMap.objectToCache.systemModstamp;Object.assign(normalizedRecordWithDependencies.objectToCache.fields,normalizedRecordWithDependenciesFromMap.objectToCache.fields);Object.assign(normalizedRecordWithDependencies.objectToEmit.fields,normalizedRecordWithDependenciesFromMap.objectToEmit.fields);}}cacheKeyToNormalizedRecordsWithDependenciesMap.set(serialize(normalizedRecordWithDependencies.sourceCachekey),normalizedRecordWithDependencies);}return this._mergeRecordsAndStagePuts(normalizedRecordsWithDependencies,cacheAccessor,rootRecordMerge,resolveRootMerge,filteredRecordObservableCacheKey);}/**
         * For use externally by ADS BRIDGE ONLY. This is exposed because ads-bridge needs special access to import records from ADS into LDS.
         * @param recordId Id of the record to retrieve.
         * @param fields Qualified field API names to retrieve. If any are inaccessible then an error is emitted.
         * @param optionalFields Qualified field API names to retrieve. If any are inaccessible then they are silently omitted.
         * @param overrideValueProvider ValueProvider to fetch, normalize and cache the values.
         * @param returnFinalTransformedObservable True to return a finalTransformed observable, false for an observable whose emitted values are mutable.
         * @param forceProvide True to skip the cache and force a server call.
         * @param metaConfig Retrieval configuration.
         *        forceProvide - if true then the cache is skipped
         *        successCallback - callback to be invoked after the refresh is complete
         *        errorCallback - callback to be invoked after the refresh fails
         * @param emitLastValue True to ignore the stored lastValue emitted during observableConstruction, if there is one.
         *        Generally, you'd want to skip this because the value is stale
         * @param isFromAdsBridge - True if this request is coming from ADS Bridge.
         * @returns An observable of the record.
         */_privateGetRecordWithFields(recordId,fields,optionalFields,overrideValueProvider,returnFinalTransformedObservable,forceProvide,metaConfig,emitLastValue,isFromAdsBridge){recordId=to18(recordId);const cacheKey=buildRecordCacheKey(recordId);const trackedRecordFields=this.getFieldsForRecord(recordId);const refreshRecordFields=this.getADSFieldsForRecord(recordId);const requestedFields=addAll(new Set(fields),optionalFields);const requestOnlyHasTrackedFields=containsAll(trackedRecordFields,requestedFields);// Adjust the optional fields we're requesting to include any other fields we're tracking that aren't already part of the required fields
    // Using Array.push to join the new fields from requestedFields instead of Set.addAll because when sets are converted to arrays
    // via collectionToArray the ordering is determined by insertion order of items. Any additional fields should be appended to preserve ordering.
    const newFields=collectionToArray(difference(requestedFields,trackedRecordFields));const adjustedOptionalFields=collectionToArray(trackedRecordFields);for(let len=newFields.length,n=0;n<len;n++){adjustedOptionalFields.push(newFields[n]);}forceProvide=forceProvide||!containsAll(trackedRecordFields,adjustedOptionalFields)||metaConfig&&metaConfig.forceProvide;// Add in fields that ADS has requested but LDS is not interested in.
    if(refreshRecordFields){const refreshFields=collectionToArray(difference(refreshRecordFields,adjustedOptionalFields));for(let len=refreshFields.length,n=0;n<len;n++){adjustedOptionalFields.push(refreshFields[n]);}}if(forceProvide&&!isFromAdsBridge){addRecordToRefreshList(this._recordIdsToIsRefreshingMap,recordId);}const filteredRecordObservableKey=buildFilteredRecordObservableKey(recordId,fields,optionalFields);const recordValueProviderParams={cacheKey,recordId,optionalFields:adjustedOptionalFields,forceProvide,rootRecordMerge:false,informRecordLib:true,resolveRootMerge:false,filteredRecordObservableCacheKey:filteredRecordObservableKey};const valueProvider=overrideValueProvider?overrideValueProvider:this._createRecordValueProvider(recordValueProviderParams);const finishedCallbacks=metaConfig&&metaConfig.finishedCallbacks;this._ldsCache.get(cacheKey,valueProvider,finishedCallbacks);const observables=this._ldsCache.getOrCreateObservables(cacheKey,this.getCacheValueTtl());this._recordIdsToReadOnlyObservablesMap.set(recordId,observables.finalTransformed);// check if we already have a filtered observable for the fields, and create it if not
    const _filteredObservables=this._filteredObservables;let filteredObservable=_filteredObservables.get(serialize(filteredRecordObservableKey));if(!filteredObservable){// We pass observables.root here so that any new filteredObservable chain gets all emits from the root.
    filteredObservable=this._constructFilteredObservable(filteredRecordObservableKey,observables.root,fields,optionalFields,requestOnlyHasTrackedFields,emitLastValue);_filteredObservables.set(serialize(filteredRecordObservableKey),filteredObservable);}if(returnFinalTransformedObservable){return observables.finalTransformed;}return filteredObservable;}/**
         * What fields does LDS know exist about the given recordId?
         * @param recordId
         * @returns Set<string> of fields that can be fetched for the record during a refresh
         */getAllKnownFields(recordId){if(recordId){recordId=to18(recordId);return new Set([...this.getFieldsForRecord(recordId),...(this.getADSFieldsForRecord(recordId)||[])]);}return new Set();}/**
         * /**
         * For use externally by ADS BRIDGE ONLY. This is exposed because ads-bridge needs special access to import records from ADS into LDS.
         * Constructs a value provider to retrieve a Record.
         * @param valueProviderParameters: { cacheKey, recordId, optionalFields, forceProvide = false, record, rootRecordMerge = false, informRecordLib = true } -
         *        The parameters for the value provider as an object. Each object should contain the following fields:
         *        - cacheKey: CacheKey - The relevant cache key for the Record.
         *        - recordId: Array<string> - The 18 char IDs of the records to retrieve.
         *        - optionalFields: Array<string> - This array should contain every field being tracked for this record as well as any new fields we need to get.
         *        - forceProvide: boolean - True if we need to get fresh value from the server or use the provided value (record param) and skip the cache,
         *          otherwise false. Optional - defaults to false.
         *        - record: object - A Record value you want explicitly put into cache - should be used in conjunction with a true value for forceProvide. When
         *          this is done, no actual API call will be made.
         *        - rootRecordMerge: boolean - RecordService has an addRecord() method which is used by ADS to add records into LDS cache. When this is called from
         *          addRecords() we need to merge the ADS record with what exists in the LDS cache because LDS may be tracking more fields than ADS is giving us.
         *          For scenarios within the LDS Records Module, if we have fetched a fresh value from the server and if it's a root record, there is no need for a
         *          merge because LDS should have retrieved all necessary fields. Optional - defaults to false.
         *        - informRecordLib: boolean - true if this should notify recordLibrary of any records being added due to this operation, otherwise false.
         *        - resolveRootMerge: boolean - true if during merge for a root record we should accept the record even if it has fewer fields than the existing record.
         *          defaults to false.
         * @param vpEqualsFn - a value provider equals function that allows the caller to specify whether to debounce the valueprovider or not
         * @returns ValueProvider: The value provider to retrieve a Record.
         */_createRecordValueProvider(valueProviderParameters,vpEqualsFn){return new ValueProvider((cacheAccessor,{// Do NOT set defaults here. See W-4840393.
    cacheKey,recordId,optionalFields,forceProvide,localFreshRecord,rootRecordMerge,informRecordLib,resolveRootMerge,filteredRecordObservableCacheKey})=>{// Explicitly set defaults. Cannot use deconstruction in function param due to EDGE issue. See W-4840393
    forceProvide=forceProvide||false;informRecordLib=informRecordLib===undefined?true:informRecordLib;resolveRootMerge=resolveRootMerge||false;optionalFields=optionalFields||[];rootRecordMerge=rootRecordMerge||false;if(informRecordLib){// If we need to inform recordLibrary of new records, wrap the cache accessor which will track all new things in this
    // cache operation and let commitPuts() handle the informs.
    cacheAccessor=wrapCacheAccessor(cacheAccessor,this._adsBridge);}if(forceProvide){return this._getFreshValue(cacheAccessor,recordId,optionalFields,rootRecordMerge,localFreshRecord,resolveRootMerge,filteredRecordObservableCacheKey);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;// check for ttl expiry
    const needsRefresh=nowTime>lastFetchTime+RECORD_TTL;if(needsRefresh){// Value is stale; get a fresh value.
    return this._getFreshValue(cacheAccessor,recordId,optionalFields,rootRecordMerge,localFreshRecord,resolveRootMerge,filteredRecordObservableCacheKey);}return Thenable.resolve(1/* CACHE_HIT */);}// No existing value; get a fresh value.
    return this._getFreshValue(cacheAccessor,recordId,optionalFields,rootRecordMerge,localFreshRecord,resolveRootMerge,filteredRecordObservableCacheKey);},valueProviderParameters,vpEqualsFn);}hasValidCachedValue(cacheAccessor,params){const cacheKey=buildRecordCacheKey(params.recordId);const existingValueWrapper=cacheAccessor.get(cacheKey);return !!existingValueWrapper&&existingValueWrapper.value!==undefined&&cacheAccessor.nowTime<=existingValueWrapper.lastFetchTime+RECORD_TTL&&this._validateRecordCacheValue(params,existingValueWrapper.value);}_validateRecordCacheValue(params,normalizedRecord){// If we have all the requested fields in the cache, we don't need to fetch this record (again)
    // TODO: Is it okay to request the (partial) record via Aggregate?
    let requestedFields=params.optionalFields;requestedFields=requestedFields.map(fullyQualifiedFieldName=>{// Turn ObjectApiName.Id -> Id
    const fieldParts=fullyQualifiedFieldName.split(".");if(fieldParts.length===2){return fieldParts[1];}else if(fieldParts.length===1){return fullyQualifiedFieldName;}else {return fullyQualifiedFieldName.substring(fieldParts[0].length+1);}});return normalizedRecord.fields&&requestedFields.every(paramName=>{const storedParamValue=normalizedRecord.fields[paramName];return storedParamValue!==undefined;},true);}/**
         * Takes the normalized record and cacheAccessor and returns the denormalized record.
         * @param normalizedRecord The record to denormalized. This should always be a normalized record that came from the cache.
         * @param cacheAccessor The CacheAccessor in scope for this operation.
         * @param depth This is a recursive call and this parameter is used to indicate what depth we're at so in cyclical cases we don't
         *        continue denormalizing forever. The SOQL limit is 5 levels, so this will denormalize to a depth of 5. Most callers do not need to
         *        provide this since they are denormalizing a top level record, so this param is optional.
         * @param paths. A list of traversed record ids- used to detect if we have reached a cyclical case.
         * @returns A denormalized record or undefined if a nested record can't be found in the cache or MAX_DEPTH has been reached.
         */_denormalizeValueHelper(normalizedRecord,cacheAccessor,depth,paths){// MAX_DEPTH is the SOQL limit, so we don't denorm past MAX_DEPTH levels.
    if(depth>MAX_DEPTH){return;}if(paths===undefined){paths=[];}paths.push(normalizedRecord.id);const denormalizedRecord=cloneDeepCopy(normalizedRecord);const denormalizedRecordFields=denormalizedRecord.fields;{assert$2(denormalizedRecordFields,`Where are the denormalizedRecordFields? ${denormalizedRecordFields}`);}const denormalizedRecordFieldsArray=Object.entries(denormalizedRecordFields);for(let len=denormalizedRecordFieldsArray.length,n=0;n<len;n++){const[fieldName,field]=denormalizedRecordFieldsArray[n];{assert$2(field,`Found malformed field with no field value structure: ${fieldName}, ${field}`);}if(isRecordMarker(field.value)){const fieldValue=field.value;const recordId=fieldValue.id;const cacheKey=buildRecordCacheKey(recordId);const spanningRecordValueWrapper=cacheAccessor.get(cacheKey);if(!spanningRecordValueWrapper){// TODO: W-5450972 maybe the record LRUed out =( -- consider if we should make this impossible (run out of memory instead?).
    throw getLdsInternalError("DENORMALIZE_FAILED",`Did not find record for '${recordId}'`,false);}const normalizedSpanningRecord=spanningRecordValueWrapper.value;// If depth is more than MAX_DEPTH do not try to denormalize further. This can happen in case we have a cycle in denorm records.
    if(Math.max(depth+1,fieldValue.depth)>MAX_DEPTH||paths.indexOf(normalizedSpanningRecord.id)!==-1){// Delete the spanning field as we do not want to gather field names via recursivelyGatherFieldNames for the parent record.
    delete denormalizedRecordFields[fieldName];}else {// Proceed to denormalize spanning record.
    const denormalizedSpanningRecord=this._denormalizeValueHelper(normalizedSpanningRecord,cacheAccessor,Math.max(depth+1,fieldValue.depth),paths.slice(0));if(denormalizedSpanningRecord){const spanningRecordMarkerFieldsArray=fieldValue.fields;const fieldsInSpanningRecordSet=new Set();recursivelyGatherFieldNames(denormalizedSpanningRecord.apiName,denormalizedSpanningRecord,fieldsInSpanningRecordSet);const missingFields=spanningRecordMarkerFieldsArray.filter(fieldApiName=>!fieldsInSpanningRecordSet.has(fieldApiName));if(missingFields.length>0){// We don't have enough fields to satisfy the marker.
    // Check the conflict records map for an entry and if an entry exists, utilize the value from map to denorm the record correctly.
    const recordFromConflictRecordsMap=this._saveableState._mergeConflictRecordsMap.get(normalizedSpanningRecord.id);// the conflict records map also does not have an entry for this record and thereby we cannot denorm the record correctly.
    if(!recordFromConflictRecordsMap){// filter the <fieldName>__r fields before throwing error
    if(missingFields.filter(fieldApiName=>!fieldApiName.endsWith("__r")).length>0){const spanningRecordFieldsArray=collectionToArray(fieldsInSpanningRecordSet);const missingFieldsError=JSON.stringify({expectedFields:spanningRecordMarkerFieldsArray,actualFields:spanningRecordFieldsArray});const missingFieldsErrorMessage=`Did not find all necessary fields for record: '${recordId}': '${missingFieldsError}'`;instrumentError({message:missingFieldsErrorMessage},"LDS.recordService.necessaryFieldsMissing",InstrumentationErrorType.WARN,"DENORMALIZE_FAILED");throw getLdsInternalError("DENORMALIZE_FAILED",missingFieldsErrorMessage,false);}}const spanningRecordMarkerFieldsSet=new Set();addAll(spanningRecordMarkerFieldsSet,spanningRecordMarkerFieldsArray);for(let fieldsLength=missingFields.length,m=0;m<fieldsLength;m++){const apiNameReg=new RegExp(`^${denormalizedSpanningRecord.apiName}\\.`);const fieldApiName=missingFields[m].replace(apiNameReg,"");const missingFieldValue=recordFromConflictRecordsMap&&recordFromConflictRecordsMap.fields[fieldApiName];if(missingFieldValue===undefined){// if we have missing field and it is <fieldName>__r then we add { value: null, displayValue: null };
    // because the <fieldName>__c is undefined at this point otherwise we have a value for <fieldName>__r
    if(fieldApiName.endsWith("__r")){denormalizedSpanningRecord.fields[fieldApiName]={value:null,displayValue:null};}else {const spanningRecordFieldsArray=collectionToArray(fieldsInSpanningRecordSet);// the conflicts records map does not contain a value for a field.
    const missingFieldError=JSON.stringify({expectedFields:spanningRecordMarkerFieldsArray,actualFields:spanningRecordFieldsArray});const missingFieldErrorMessage=`Missing field(s) : '${missingFieldError}' in conflicting record '${recordId}'`;instrumentError({message:missingFieldErrorMessage},"LDS.recordService.necessaryFieldsMissingInConflictMap",InstrumentationErrorType.WARN,"DENORMALIZE_FAILED");throw getLdsInternalError("DENORMALIZE_FAILED",missingFieldErrorMessage,false);}}else {denormalizedSpanningRecord.fields[fieldApiName]=missingFieldValue;}}}// TODO: ideally we'd keep track of the name field (in extra properties?) and use that instead of hardcoding 'Name' which
    // is right most of the time but not all of the time. We need to examine the ObjectInfo to get the correct Name field
    // 100% of the time.
    // Note: the use of null over undefined below is intentional -- since this is a serializable JSON payload we will be using
    // null rather than undefined.
    // Note: we cast from NormalizedFieldValueRepresentation to uiapi.FieldValueRepresentation deliberately: we are denorm'ing
    const nameField=normalizedSpanningRecord.fields.Name;const nameFieldDisplayValue=nameField!==undefined?nameField.displayValue:null;const nameFieldValue=nameField!==undefined?nameField.value:null;// Use the old displayValue we had if we can't find a new one to use.
    const displayValue=nameField&&nameFieldDisplayValue||nameFieldValue||field.displayValue;denormalizedRecordFields[fieldName]={displayValue,value:denormalizedSpanningRecord};}}}}// Returning the final denormalized record.
    return denormalizedRecord;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param recordId The record id for the record.
         * @param optionalFields The list of optional fields for the record.
         * @param rootRecordMerge True if the cache should attempt to merge the record values instead of replacing them.
         * @param localFreshRecord Optional. A record value you want explicitly put into cache instead of getting the value from the server.
         * @param resolveRootMerge true if during merge for a root record we should accept the record even if it has fewer fields than the existing record.
         * @param filteredRecordObservableCacheKey Cache Key if this is coming from a filtered record request.
         * @returns Returns a Thenable that resolves to the string representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,recordId,optionalFields,rootRecordMerge,localFreshRecord,resolveRootMerge,filteredRecordObservableCacheKey){let transportResponseThenable;// If the record is provided, we don't go to server to fetch it.
    if(localFreshRecord){transportResponseThenable=Thenable.resolve(getOkFetchResponse(localFreshRecord));}else {if(optionalFields){optionalFields=optionalFields.slice().sort();}const params={recordId,fields:[],optionalFields};transportResponseThenable=this._makeAggregateServerCall("getRecord",params);}return transportResponseThenable.then(transportResponse=>{// Cache miss.
    // It's a cache miss and we are going normalize, mark, and merge the spanning records, then stage and commit puts for the
    // records which are merged successfully. Finally we will denorm and stage emits for affected records that haven't changed
    // but depend on changed records.
    const freshRecord=transportResponse.body;this.mergeRecordAndStagePut([],freshRecord,cacheAccessor,rootRecordMerge,resolveRootMerge,filteredRecordObservableCacheKey);// we are here, because ADS gave us records or we requested records from within LDS.
    // so if the conflict records map has an entry then delete the entry.
    this._saveableState._mergeConflictRecordsMap.delete(recordId);// Save the record service state.
    this._cacheSaveableState();const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);if(localFreshRecord){return 4/* CACHE_RECORD_FROM_ADS */;}return 2/* CACHE_MISS */;});}/**
         * Persists the saveable state to the cache.
         */_cacheSaveableState(){const recordServiceStateCacheKey=buildRecordServiceStateCacheKey();return this._ldsCache.put(recordServiceStateCacheKey,this._saveableState);}/**
         * Returns an array of objects {dependentCacheKeysArray, recordCacheKey, normalizedRecord, denormalizedRecord, isRoot} that will be
         * used to normalized and merge the record and any nested records into the cache.
         * @param denormalizedRecord A denormalized record or record we get from UI-API.
         * @param cacheAccessor The CacheAccessor in scope for this operation.
         * @param dependencies An array of zero or more cache keys that depend on the key/value being staged. These are used
         *        by the cache to track dependencies for consumers and let them know what they have affected in the return value of commitPuts().
         * @param depth This is a recursive call and this parameter is used to indicate what depth we're at so in cyclical cases we don't
         *        continue denormalizing forever. The SOQL limit is 5 levels, so this will denormalize to a depth of 5. Callers should also provide a
         *        correct value consciously in this case, so this param is required.
         * @returns Returns an array of StagePutObject {dependentCacheKeysArray, recordCacheKey, normalizedRecord, denormalizedRecord, isRoot}
         *          that will be used to normalized and merge the record and any nested records into the cache.
         */_getNormalizedRecordsWithDependencies(denormalizedRecord,cacheAccessor,dependencies,depth){{assert$2(depth>=0&&depth<=5,`Invalid depth: ${depth}`);}const normalizedRecord=cloneDeepCopy(denormalizedRecord);let stagePutObjectArray=[];const recordCacheKey=buildRecordCacheKey(normalizedRecord.id);const normalizedRecordFieldsArray=Object.keys(normalizedRecord.fields);for(let len=normalizedRecordFieldsArray.length,n=0;n<len;n++){const fieldName=normalizedRecordFieldsArray[n];const normalizedRecordFieldValue=normalizedRecord.fields[fieldName].value;// TODO: Do NOT cache spanning records that have apiName === "Name" because we have not figured out yet how to deal with record stomping scenarios in LDS.
    // Optimially the salesforce APIs will be fixed so they don't return inconsistent data.
    if(isRecordRepresentation(normalizedRecordFieldValue)&&normalizedRecordFieldValue.apiName!=="Name"){const spanningRecord=normalizedRecordFieldValue;const spanningRecordDepth=depth+1;const stagePutObject=this._getNormalizedRecordsWithDependencies(spanningRecord,cacheAccessor,[{cacheKey:recordCacheKey,type:1/* REQUIRED */}],spanningRecordDepth);stagePutObjectArray=stagePutObjectArray.concat(stagePutObject);const marker=toRecordMarker(cacheAccessor,spanningRecord,spanningRecordDepth);normalizedRecord.fields[fieldName].value=marker;}}const isRoot=depth===0;const eTag=normalizedRecord.eTag;// Delete the eTag. We don't want to store the eTag as part of the value!
    delete normalizedRecord.eTag;delete normalizedRecord.weakEtag;// Delete the eTags from the denormalizedRecord. We don't want to emit values with eTag properties!
    denormalizedRecord=this.stripETagsFromValue(denormalizedRecord);stagePutObjectArray.push({dependencies,sourceCachekey:recordCacheKey,objectToCache:normalizedRecord,objectToEmit:denormalizedRecord,root:isRoot,eTag});return stagePutObjectArray;}/**
         * Given the provided normalized records (root and spanning), this goes through all the records, merges them, and and stages puts for them.
         * @param stagePutObjects Each object in the array should look like
         *        { dependentRecordKeyArray, recordCacheKey, normalizedRecord, denormalizedRecord, isRoot }.
         * @param cacheAccessor The CacheAccessor in scope for this operation.
         * @param rootRecordMerge RecordService has an addRecord() method which is used by ADS to add records into LDS cache. When this is called from
         *        addRecords() we need to merge the ADS record with what exists in the LDS cache because LDS may be tracking more fields than ADS is giving us.
         *        For scenarios within the LDS Records Module, if we have fetched a fresh value from the server and if it's a root record, there is no need for a
         *        merge because LDS should have retrieved all necessary fields.
         * @param resolveRootMerge true if during merge for a root record we should accept the record even if it has fewer fields than the existing record.
         * @param filteredRecordObservableCacheKey Cache Key if this is coming from a filtered record request.
         * @returns The array of cache keys for the records to be cached or refreshed as a
         *          result of this operation. The array should not contain duplicate cache keys.
         */_mergeRecordsAndStagePuts(stagePutObjects,cacheAccessor,rootRecordMerge,resolveRootMerge,filteredRecordObservableCacheKey){const cacheKeysArray=[];for(let len=stagePutObjects.length,n=0;n<len;n++){const stagePutObject=stagePutObjects[n];const existingValue=cacheAccessor.get(stagePutObject.sourceCachekey);const valueWrapperOptionalProperties={eTag:stagePutObject.eTag};let valueWrapperToEmitExtraInfoObject;if(filteredRecordObservableCacheKey){valueWrapperToEmitExtraInfoObject={filteredRecordObservableCacheKey};}if(existingValue){const mergedNormalizedRecord=this._mergeRecord(existingValue.value,stagePutObject.objectToCache,rootRecordMerge,stagePutObject.root,resolveRootMerge);if(mergedNormalizedRecord){this.gatherAndTrackSpanningFields(stagePutObject.objectToEmit);const denormalizedRecord=this.denormalizeValue(mergedNormalizedRecord,cacheAccessor);if(denormalizedRecord){cacheAccessor.stagePut(stagePutObject.dependencies,stagePutObject.sourceCachekey,mergedNormalizedRecord,denormalizedRecord,valueWrapperOptionalProperties,valueWrapperToEmitExtraInfoObject);cacheKeysArray.push(stagePutObject.sourceCachekey);}}// The merge wasn't successful so a full record refresh should have been queued, however we still need to track that
    // things depend on this record, so track the dependencies.
    if(stagePutObject.dependencies&&stagePutObject.dependencies.length>0){cacheAccessor.stageDependencies(stagePutObject.dependencies,stagePutObject.sourceCachekey);}}else {this.gatherAndTrackSpanningFields(stagePutObject.objectToEmit);cacheAccessor.stagePut(stagePutObject.dependencies,stagePutObject.sourceCachekey,stagePutObject.objectToCache,stagePutObject.objectToEmit,valueWrapperOptionalProperties,valueWrapperToEmitExtraInfoObject);}cacheKeysArray.push(stagePutObject.sourceCachekey);}// Dedeuplicate the cache keys.
    const cacheKeysMap=new Map();for(let len=cacheKeysArray.length,c=0;c<len;c++){const cacheKey=cacheKeysArray[c];cacheKeysMap.set(serialize(cacheKey),cacheKey);}return Array.from(cacheKeysMap.values());}/**
         * Returns a merged and normalized record. If the merge results in a conflict, we request fresh record with all tracked fields for the record.
         * @param existingNormalizedRecord The existing record in the cache.
         * @param newNormalizedRecord The new record we want to merge into the cache.
         * @param rootRecordMerge RecordService has an addRecord() method which is used by ADS to add records into LDS cache. When this is called from
         *        addRecords() we need to merge the ADS record with what exists in the LDS cache because LDS may be tracking more fields than ADS is giving us.
         *        For scenarios within the LDS Records Module, if we have fetched a fresh value from the server and if it's a root record, there is no need for a
         *        merge because LDS should have retrieved all necessary fields.
         * @param isRoot Whether the existingRecord and newNormalizedRecord are root records (true) or nested spanning records (false).
         * @param resolveRootMerge true if during merge for a root record we should accept the record even if it has fewer fields than the existing record.
         * @returns The merged record.
         */_mergeRecord(existingNormalizedRecord,newNormalizedRecord,rootRecordMerge,isRoot,resolveRootMerge){// cannot merge record with different id
    if(existingNormalizedRecord.id!==newNormalizedRecord.id||existingNormalizedRecord.apiName!==newNormalizedRecord.apiName){throw new Error("Id or API Name cannot be different for merging records.");}const newNormalizedRecordContainsAllFieldsOfExistingNormalizedRecord=secondRecordContainsAllFieldsInFirstRecord(existingNormalizedRecord,newNormalizedRecord);// For scenarios within the LDS Records Module, if we fetched a fresh value from the server and if it's a root record:
    // If all existing fields are in newRecord there is no need to merge and so return the newNormalizedRecord
    // If all existing fields are not in newRecord but this was obtained with resolveRootMerge true, then accept the new record.
    if(!rootRecordMerge&&isRoot&&(newNormalizedRecordContainsAllFieldsOfExistingNormalizedRecord||resolveRootMerge)){return newNormalizedRecord;}const sysModstampsAreDifferent=systemModstampsAreDifferent(newNormalizedRecord,existingNormalizedRecord);if(!sysModstampsAreDifferent){// if systemModstamps are same, then we can merge the 2 records
    const mergedRecord=cloneDeepCopy(existingNormalizedRecord);deepRecordCopy(newNormalizedRecord,mergedRecord);return mergedRecord;}// systemModstamps are different
    if(newNormalizedRecordContainsAllFieldsOfExistingNormalizedRecord){// systemModstamps are different and the second record has all fields contained in the first record
    // so no need to merge. return the fresh record
    return newNormalizedRecord;}// systemModstamps are different but the second record does not have all fields contained in the first record
    // so it's a merge conflict and before we queue a fresh request, merge the records and store the mergedRecord in a map
    // which may be(scenario is when we detect that the marker has more fields listed than what we have committed in cache) utilized when we denormalize records
    // See W-5302879 for more details.
    {// tslint:disable-next-line:no-console
    console.log("LDS Cache: Record merge conflict for record: "+existingNormalizedRecord.id+" -- kicking off refresh.");}// We may be able to remove this logic involving conflict record map now that the merge will happen regardless, but leaving it here for now.
    const conflictMergedRecord=cloneDeepCopy(existingNormalizedRecord);deepRecordCopy(newNormalizedRecord,conflictMergedRecord);// @ts-ignore TODO: W-5908928 - remove the ts-ignore when this (and all the other private methods) gets moved into the class as a private method.
    this._saveableState._mergeConflictRecordsMap.set(newNormalizedRecord.id,conflictMergedRecord);// queue a fresh request for the conflicted record as a root record with all the tracked fields.
    const objectApiName=newNormalizedRecord.apiName;// check and log if we are making a server call for unsupported UI API entity
    if(!isSupportedEntity(objectApiName)){instrumentError({message:`Merge conflict for Unsupported entity: ${objectApiName}`},"LDS.recordService.mergeConflict",InstrumentationErrorType.WARN);}// for unsupported UI API entities don't send xhr as it is going to fail
    // @ts-ignore
    if(this._unsupportedEntitiesSet.has(objectApiName)){return newNormalizedRecord;}if(existingNormalizedRecord.systemModstamp==null||newNormalizedRecord.systemModstamp==null){instrumentError({message:`Merge conflict due to null systemModstamp. Existing systemModstamp: ${existingNormalizedRecord.systemModstamp}, New systemModstamp: ${newNormalizedRecord.systemModstamp}, objectApiName: ${objectApiName}, recordId: ${existingNormalizedRecord.id}, differentFieldsInExistingRecord: ${JSON.stringify(Array.from(getDifferentFieldsBetweenRecords(existingNormalizedRecord,newNormalizedRecord)))}, differentFieldsInNewRecord: ${JSON.stringify(Array.from(getDifferentFieldsBetweenRecords(newNormalizedRecord,existingNormalizedRecord)))} `},"LDS.recordService.mergeConflict",InstrumentationErrorType.INFO);}else {instrumentError({message:`Merge conflict due to different systemModstamp. Existing systemModstamp: ${existingNormalizedRecord.systemModstamp}, New systemModstamp: ${newNormalizedRecord.systemModstamp}, objectApiName: ${objectApiName}, recordId: ${existingNormalizedRecord.id}`},"LDS.recordService.mergeConflict",InstrumentationErrorType.INFO);}const allFieldNamesSet=new Set();// if we reached here it means that fields are not same for records and SystemModstamp is different/not present then re-fetch it with all the fields
    const trackedRecordFields=this.getFieldsForRecord(existingNormalizedRecord.id);gatherFieldNamesFromNormalizedRecord(newNormalizedRecord,allFieldNamesSet);gatherFieldNamesFromNormalizedRecord(existingNormalizedRecord,allFieldNamesSet);this.addFieldsToTrack(existingNormalizedRecord.id,collectionToArray(allFieldNamesSet));const trackedRecordFieldsArray=collectionToArray(trackedRecordFields);const refreshRecordFields=this.getADSFieldsForRecord(existingNormalizedRecord.id);// Add in fields that ADS has requested but LDS is not interested in.
    if(refreshRecordFields){const refreshFields=collectionToArray(difference(refreshRecordFields,trackedRecordFieldsArray));for(let len=refreshFields.length,n=0;n<len;n++){trackedRecordFieldsArray.push(refreshFields[n]);}}// evict existing entry and send the request with allFields
    const cacheKey=buildRecordCacheKey(existingNormalizedRecord.id);const recordValueProviderParams={cacheKey,recordId:existingNormalizedRecord.id,optionalFields:trackedRecordFieldsArray,forceProvide:true,rootRecordMerge:false,informRecordLib:true,resolveRootMerge:true};const valueProvider=this._createRecordValueProvider(recordValueProviderParams,()=>{return false;// value provider's equal function specifically returning false so that we make a server call
    });// Make the request to get the fresh record.
    this._privateGetRecordWithFields(existingNormalizedRecord.id,[],trackedRecordFieldsArray,valueProvider,false,true);// If we got a spanning record from ADS that has systemModstamp null, then it should be safe to merge in any fields that are not present in cache.
    // We still want to request the fresh record with full set of fields in the case that the received record from ADS is a newer version.
    if(newNormalizedRecord.systemModstamp==null){const mergedRecord=cloneDeepCopy(newNormalizedRecord);// Merge fields in from cached record into new, which effectively results in a record from cache + any new fields from ADS.
    deepRecordCopy(existingNormalizedRecord,mergedRecord);return mergedRecord;}}/**
         * Constructs an Observable that will emit a record with only those fields given by the requiredFields and optionalFields parameters.
         * If a required field is missing during an emit attempt, an error will be emitted. If an optional field is missing then it will be ignored.
         * @param filteredRecordCacheKey The filtered record key identifying the filtered observable.
         * @param observableToFilter The observable that emits a record object that we want to filter down the fields on.
         * @param requiredFields The list of required fields to remain in the record.
         * @param optionalFields The list of optional fields to remain in the record.
         * @param requestOnlyHasTrackedFields check if the request has tracked fields only
         * @param emitLastValue True to ignore the stored lastValue emitted during observableConstruction, if there is one.
         *        Generally, you'd want to skip this because the value is stale
         * @returns An observable the emits a record with a filtered fields list.
         */_constructFilteredObservable(filteredRecordCacheKey,observableToFilter,requiredFields,optionalFields,requestOnlyHasTrackedFields,emitLastValue){let filteredObservable=observableToFilter;// root observable
    // If this request has previously untracked fields then we need to wait for the refresh to come back before allowing
    // emits through. This is necessary because we don't want the field filter to throw an error until it is
    // acting on the fresh value that contains the new fields.
    if(!requestOnlyHasTrackedFields){// If there's a lastValue, but the request includes untracked fields, we know it won't satisfy our expectations
    if(!emitLastValue&&filteredObservable.lastValue){filteredObservable=filteredObservable.skipOnce();}filteredObservable=filteredObservable.skipIf(valueWrapper=>{const record=valueWrapper.value;const recordId=record.id;let emittedRecordMissingRequiredField=false;for(let len=requiredFields.length,i=0;i<len;i++){if(getFieldValue(record,requiredFields[i])===undefined){emittedRecordMissingRequiredField=true;break;}}const emitCacheKey=valueWrapper.extraInfoObject&&valueWrapper.extraInfoObject.filteredRecordObservableCacheKey;// The emit satisfies, so let it through.
    if(!emittedRecordMissingRequiredField){return false;}else {// The record still has active refreshes, so continue to skip.
    // Note: we may be able to remove this now, but leaving it in to verify initial fix.
    if(this._recordIdsToIsRefreshingMap.has(recordId)){return true;}else {// If the emit is from the actual wire adapter that made the call, let it through to error. This would happen if the
    // requireField requested was invalid, or inaccesible.
    if(emitCacheKey&&emitCacheKey.key===filteredRecordCacheKey.key){return false;}else {// Otherwise, we got an emit from another adapter's request so continue to skip.
    return true;}}}});}filteredObservable=filteredObservable.map(valueWrapper=>{const value=valueWrapper.value;// Transform the record into a record that only contains the fields requested.
    const fullFieldsList=getFullFieldsListForFilteredObservable(value,requiredFields,optionalFields);const newFilteredRecord=createFilteredRecordFromRecord(value,fullFieldsList);return cloneWithValueOverride(valueWrapper,newFilteredRecord);}).distinctUntilChanged((previousValue,newValue)=>{if(previousValue===undefined){return false;}// Only allow new values to be emitted.
    return equivalent(previousValue.value,newValue.value);}).mapWithFilterOnSubscribeBehaviorSubject(value=>{let shouldEmit=false;if(this._ldsCache.timeSource.now()<value.lastFetchTime+this.getCacheValueTtl()){shouldEmit=true;}else {// TTL expired
    lastValueTracker.add(value);}return shouldEmit;},valueWrapper=>{return lwc.readonly(valueWrapper.value);});// Subscribe to the new filtered observable so that when it completes (or errors) we know to remove the filtered observable from the map.
    const errorCompleteSubscription=filteredObservable.subscribe(new Observer(()=>{return;},()=>{this._filteredObservables.delete(serialize(filteredRecordCacheKey));}),()=>{this._filteredObservables.delete(serialize(filteredRecordCacheKey));});// Decorate the subscribe method to return a Subscription instance with a decorated unsubscribe method which will dispose the filtered observable if
    // the subscriptions count drops below 1. (Not 0 because of the above subscription which will always be there but doesn't signify that
    // there is someone interested in this filtered observable externally.
    const recordServiceFilteredObservables=this._filteredObservables;const originalSubscribeFn=filteredObservable.subscribe;filteredObservable.subscribe=(observer,...args)=>{const originalSubscription=originalSubscribeFn.call(filteredObservable,observer,...args);if(originalSubscription){const originalSubscriptionUnsubscribeFn=originalSubscription.unsubscribe;originalSubscription.unsubscribe=()=>{originalSubscriptionUnsubscribeFn.call(originalSubscription);if(filteredObservable.subscriptions.size<=1){if(errorCompleteSubscription&&!errorCompleteSubscription.closed){errorCompleteSubscription.unsubscribe();}recordServiceFilteredObservables.delete(serialize(filteredRecordCacheKey));}};}return originalSubscription;};return filteredObservable;}/**
         * Executes the global aura controller request. Tracks active requests by record id.
         * @param recordId The record id pertaining to the request.
         * @param controllerName The name of the global controller to execute.
         * @param parameters An object map containing the parameters of the request.
         * @returns TransportResponse from the server
         */async _makeServerCall(recordId,controllerName,parameters){if(recordId){addRecordToRefreshList(this._recordIdsToIsRefreshingMap,recordId);}const result=await executeAuraGlobalController(controllerName,parameters);if(recordId){removeRecordFromRefreshList(this._recordIdsToIsRefreshingMap,recordId);}return result;}/**
         * Executes the aggregate-ui server request. Tracks active requests by record id.
         * @param wireName The name of the wire adapter.
         * @param parameters Object containing parameters of the ui-api request.
         * @returns TransportResponse from the server
         */async _makeAggregateServerCall(wireName,parameters){const recordId=parameters.recordId;const result=await aggregateUiExecutor.executeSingleRequestOverAggregateUi(wireName,parameters,RECORD_TTL);// Originally, this call was happening at the beginning of _privateGetRecordWithFields:
    // However, parallel requests can cause the following issue if the getRecord requests/xhrs happen as follows:
    // 1. Wire Adapter 1: getRecord("Id") - trackedFields: [Id]
    // 2. XHR for 1 goes out
    // 3. Wire Adapter 2: getRecord("Id", "Name") - trackedFields: [Id, Name]
    // 4. XHR for 2 goes out
    // 5. Wire Adapter 3: getRecord("Name") - trackedFields: [Id, Name]
    // 6. XHR for 1 comes back with only "Id" field and emits to root observable, which causes error
    // because at Step 5 "Name" was in tracked fields already, the filtered observable was called with requestOnlyHasTrackedFields = true
    // which skipped the previously added skipIf logic (which skips root emits if there are outstanding requests or the emit does not satisfy required fields).
    this.addFieldsToTrack(recordId,parameters.optionalFields);// Make sure we're tracking all requested fields.
    removeRecordFromRefreshList(this._recordIdsToIsRefreshingMap,recordId);return result;}get _saveableState(){if(!this._saveableStateData){// Load it from the cache.
    const valueFromCache=this._ldsCache.getValue(buildRecordServiceStateCacheKey());if(valueFromCache){this._saveableStateData=valueFromCache;}else {// Nothing in the cache, create a new state.
    this._saveableStateData={_recordIdsToFieldsRequestedMap:new Map(),_mergeConflictRecordsMap:new Map()};}}return this._saveableStateData;}}/**
     * The value type for the record service state.
     */const RECORD_SERVICE_STATE_VALUE_TYPE="lds.recordServiceState";/**
     * Builds the cache key for the record service state.
     * @param ldsCacheName The name of the LDS cache used to scope related dependencies.
     * @returns A new cache key representing the LDS_CACHE_DEPENDENCIES_VALUE_TYPE value type.
     */function buildRecordServiceStateCacheKey(){return {type:RECORD_SERVICE_STATE_VALUE_TYPE,key:`record-service-state`};}/**
     * Wire adapter id: getRecord.
     * @throws Error Always throws when invoked. Imperative invocation is not supported.
     * @returns void
     */function getRecord(){throw generateError("getRecord");}/*
     * Singleton class which contains the wire adapter ids and wire adapter functions for servicing
     * @wires in the lds-records module. Handles registering the wire adapters with the wire service.
     */class RecordWireAdapterGenerator{/**
         * Constructor.
         * @param recordService Reference to the RecordService instance.
         */constructor(recordService){this._recordService=recordService;}/*
         * Generates the wire adapter for getRecord.
         * @returns WireAdapter - See description.
         */generateGetRecordWireAdapter(){const wireAdapter=generateWireAdapter(this.serviceGetRecord.bind(this));return wireAdapter;}/**
         * @private
         * Service getRecord @wire.
         * @param config Config params for the service.
         * @param metaConfig WireRefreshMetaConfig to refresh the cache from System of Records (SOR)
         * @return Observable stream that emits a record object.
         */serviceGetRecord(config,metaConfig){if(!config){return undefined;}{// validate schema
    const required=["recordId"];const oneof=["fields","optionalFields","layoutTypes"];const supported=["fields","layoutTypes","modes","optionalFields","recordId"];const unsupported=["childRelationships","pageSize"];// TODO W-4421501, W-4045854
    validateConfig$1("getRecord",config,required,supported,unsupported,oneof);}if(typeof config.recordId!=="string"||config.recordId.trim().length===0){return undefined;}const recordId=to18(config.recordId);// toArray() + isArrayOfNonEmptyStrings() provides a runtime guarantee that a value is a
    // string[] with length > 0.
    const fields=toArray(config.fields).map(getFieldApiName$1);if(fields.length!==0&&!isArrayOfNonEmptyStrings(fields)){return undefined;}const optionalFields=toArray(config.optionalFields).map(getFieldApiName$1);if(optionalFields.length!==0&&!isArrayOfNonEmptyStrings(optionalFields)){return undefined;}const layoutTypes=toArray(config.layoutTypes);if(layoutTypes.length!==0&&!isArrayOfNonEmptyStrings(layoutTypes)){return undefined;}// one of the following must be present
    if(layoutTypes.length===0&&fields.length===0&&optionalFields.length===0){return undefined;}// if a layout-based load
    if(layoutTypes.length>0){const modes=toArray(config.modes);if(modes.length!==0&&!isArrayOfNonEmptyStrings(modes)){return undefined;}// default value is View
    if(modes.length===0){modes.push("View");}if(metaConfig){return this._recordService.getRecordWithLayoutsWithMetaConfig(recordId,layoutTypes,modes,optionalFields,metaConfig);}return this._recordService.getRecordWithLayouts(recordId,layoutTypes,modes,optionalFields);}if(metaConfig){return this._recordService.getRecordWithFieldsWithMetaConfig(recordId,fields,optionalFields,metaConfig);}return this._recordService.getRecordWithFields(recordId,fields,optionalFields);}}/**
     * Do not use this unless calling from force:recordLibrary. This is a special API only for force:recordLibrary.
     */class AdsBridge{/**
         * Getter for receiveFromLdsCallback.
         * This function is a hook back to recordLibrary to let it know when lds-records retrieves records on its own
         * or from the Raptor side of things. When necessary we use this to keep recordLibrary up to date with records
         * we know about and records/fields it may not have.
         */get receiveFromLdsCallback(){return this._receiveFromLdsCallback;}/**
         * Setter for receiveFromLdsCallback.
         * Can be called from non-typed context!
         */set receiveFromLdsCallback(value){if(value!==undefined&&value!==null){checkType(value,Function);}this._receiveFromLdsCallback=value;}/**
         * Getter for retrieving the base record data from the ADS cache only (no XHR).
         * This function is a hook into force:recordLibrary to allow the getRecordLayoutTemplate service to get the base record
         * data of the given recordId.
         */get getBaseRecordDataFromCacheCallback(){return this._getBaseRecordDataFromCacheCallback;}/**
         * Setter for the getBaseRecordDataFromCacheCallback.
         */set getBaseRecordDataFromCacheCallback(value){this._getBaseRecordDataFromCacheCallback=value;}/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){if(Object.getPrototypeOf(this).constructor!==AdsBridge){throw new TypeError("AdsBridge is final and cannot be extended.");}this._ldsCache=ldsCache;}/**
         * Can be called from non-typed context!
         * Do not use this unless calling from force:recordLibrary. This is a special API only for force:recordLibrary.
         * This will:
         * - remove the record from the LdsCache
         * - if eviction is due to a record being unable to be accessed and there is an error message, it should be propagated to observable.error().
         * Questions:
         * - Q: What should we do if there is no existing value or observable? A: Returning null is fine.
         * - Q: Should we be passing next(null) to Observers? What if there are existing Observers out there? Null is a weird contract. A: not doing next(null) is fine.
         * - Q: In order to evict() should you have to provide a non-null replacement value? A: No.
         * - Q: Is the error param a String or an Error? A: it's a string.
         * - Q: Do you need evict() to return anything, like the Observable? A: No.
         * @param recordId The 18 char record ID.
         * @returns A Thenable which will be resolved once the evict is completed.
         */evict(recordId){{assert$2(typeof recordId==="string","recordId must be a string");}// Must ensure ldsCache is ready for access before doing operation.
    return this._ldsCache.access().then(()=>{const cacheKey=buildRecordCacheKey(recordId);return this._ldsCache.deleteValueAndDeleteObservable(cacheKey);});}/**
         * Can be called from non-typed context!
         * Tells you all of the required and optional fields that lds-records is tracking for a given record.
         * @param recordId The 18 char record ID.
         * @returns A Thenable which resolves to an array of qualified field names that lds-records is tracking for a given record.
         *      Will be empty if there are no fields being tracked.
         */getTrackedFieldsForRecord(recordId){{assert$2(typeof recordId==="string","recordId must be a string");}// Must ensure ldsCache is ready for access before doing operation.
    return this._ldsCache.access().then(()=>{const trackedRecordFieldsSet=this._recordService.getFieldsForRecord(recordId);const trackedRecordFields=collectionToArray(trackedRecordFieldsSet);return trackedRecordFields;});}/**
         * Can be called from non-typed context!
         * Do not use this unless calling from force:recordLibrary. This is a special API only for force:recordLibrary.
         * Sticks the value in the TIC and then returns the root (unfiltered) Observable. Adds the fields on the record to the map of required fields in use.
         *
         * This will need to handle merge/replace logic, based on last modified time of the record. (If the times are the same, merge. If the times are different, replace.).
         *
         * TODO: the current merge logic does a straight up merge and does not take SystemModstamp into account yet.
         *
         * Questions:
         * - What should we do we do here if the record we are replacing has more fields than this record? We'd like to to queue a subsequent update, but for view entities
         * will not always have fields that can be easily replaced (they don't exist on the default entity type that the ID will match). Examples are cases where records are
         * allowed to be pushed into RecordGvp and used in conjunction with force:recordCollection. A: If we go with merge, SystemModstamp is preferred, otherwise LastModifiedDate.
         * Other options may include not merging and tracking fields/recordReps by objectApiName. TODO.
         * @param newRecords The records to be added to the LdsCache.
         * @param uiapiEntityWhitelist Whitelist of uiapi entities as key and string value of false to indicate it is unsupported. TODO: Refactor this into a blacklist of boolean!
         * @returns The list of results containing recordId and corresponding the root (unfiltered) Observables.
         */addRecords(newRecords,uiapiEntityWhitelist){{assert$2(newRecords,"newRecords must be provided");assert$2(typeUtils.isArray(newRecords),"newRecords must be an array");}// Process the record if LDS has an observable with something listening to it
    // Otherwise note the fields ADS is tracking for the record.
    const recordsWithObservers=new Map();const recordsWithNoObservers=new Map();for(let newRecordsLen=newRecords.length,n=0;n<newRecordsLen;n++){const newRecord=newRecords[n];const normalizedRecord=this.getRecordValueFromCache(newRecord.id);if(normalizedRecord===undefined){// we dont have a value for root record in the cache.
    // parent record is not subscribed check if the spanning records are subscribed
    recordsWithNoObservers.set(newRecord.id,newRecord);const spanningRecords=getSpanningRecords(newRecord);if(spanningRecords){spanningRecords.forEach(spanningRecord=>{const normalizedSpanningRecord=this.getRecordValueFromCache(spanningRecord.id);if(normalizedSpanningRecord!==undefined){// record existing in the cache
    const exitingSpanningRecord=recordsWithObservers.get(spanningRecord.id);// TODO : Before adding into the Map, check for duplicates and merge the fields
    if(!exitingSpanningRecord||!areFieldsEqualForRecords(exitingSpanningRecord,spanningRecord)){recordsWithObservers.set(spanningRecord.id,spanningRecord);}else {recordsWithNoObservers.set(spanningRecord.id,spanningRecord);}}else {recordsWithNoObservers.set(spanningRecord.id,spanningRecord);}});}}else {// Parent is subscribed, don't look at the spanning records since we update them as part of parent caching
    recordsWithObservers.set(newRecord.id,newRecord);}}const addRecordResults=[];recordsWithObservers.forEach((recordWithObserver,recordId)=>{const objectApiName=recordWithObserver.apiName;const allFieldNamesSet=new Set();recursivelyGatherFieldNames(objectApiName,recordWithObserver,allFieldNamesSet);const trackedRecordFields=this._recordService.getFieldsForRecord(recordId);const combinedFields=addAll(new Set(allFieldNamesSet),trackedRecordFields);// TODO: Why is this a string value for a boolean? Fix it!
    if(uiapiEntityWhitelist&&uiapiEntityWhitelist[objectApiName]==="false"){this._recordService.addUnsupportedEntity(objectApiName);}const cacheKey=buildRecordCacheKey(recordId);const forceProvide=true;const rootRecordMerge=true;// This is coming from ADS so LDS will not necessarily be getting all the fields it needs, therefore merging is the best option.
    const informRecordLib=false;// addRecord() (this method) is only called from recordLibrary, so it doesn't need to inform itself.
    const resolveRootMerge=false;// resolveRootMerge is passed true when we detect a merge conflict, since this record is being provided to us from ADS, resolveRootMerge = false.
    const recordValueProviderParams={cacheKey,recordId,optionalFields:collectionToArray(combinedFields),forceProvide,localFreshRecord:recordWithObserver,rootRecordMerge,informRecordLib,resolveRootMerge};// TODO: Remove the private method usage once we have serviceToValueType working
    const valueProvider=this._recordService._createRecordValueProvider(recordValueProviderParams);addRecordResults.push({recordId,rootObservable:this._recordService._privateGetRecordWithFields(recordId,[],collectionToArray(combinedFields),valueProvider,false,false,undefined,true,true)});});// Although LDS is not interested in these records currently and is discarding this notification,
    // keep track of the fields ADS is tracking for these records so that we include these in the future when LDS load these records.
    recordsWithNoObservers.forEach(recordWithNoObserver=>{const recordId=recordWithNoObserver.id;const objectApiName=recordWithNoObserver.apiName;const allFieldNamesSet=new Set();recursivelyGatherFieldNames(objectApiName,recordWithNoObserver,allFieldNamesSet);addAll(this._recordService.setADSFieldsForRecord(recordId),allFieldNamesSet);});return addRecordResults;}/**
         * Can be called from non-typed context!
         * Do not use this unless calling from raptor wire sevices.
         *
         * Sticks the value in LDS and then returns the root (unfiltered) Observable.
         * @param recordUi The record to add.
         * @returns The root (unfiltered) Observable.
         */addRecordUi(recordUi){{assert$2(recordUi,"recordUi must be provided");}const cacheKey=buildCacheKeyFromRecordUi(recordUi);const rootRecordMerge=true;return this._recordUiService.cacheRecordUi(cacheKey,recordUi,rootRecordMerge);}/**
         * Tells ADS about a record that LDS has retrieved.
         * @param record The record retrieved by LDS and informed to ADS.
         * @param objectInfo The object info associated with the record, if available.
         */informRecordLib(record,objectInfo){const recordId=record.id;const apiName=record.apiName;if(this._receiveFromLdsCallback){if(recordId&&apiName){const nameFields=objectInfo&&Array.isArray(objectInfo.nameFields)?objectInfo.nameFields:[];let nameField="Name";if(nameFields.length>0&&!nameFields.includes("Name")){nameField=nameFields[0];// Default to whatever.
    }const objectMetadata={};objectMetadata[apiName]={_keyPrefix:objectInfo?objectInfo.keyPrefix:recordId.substring(0,3),_nameField:nameField,_entityLabel:objectInfo?objectInfo.label:apiName,_canUseLapi:"true"};// ADS expects records.recordId.apiName.record structure. See W-4147555.
    const records={};records[recordId]={};records[recordId][apiName]={isPrimary:true,record:getValueForAura(record)};// We retrieved a new record from the server. Let recordLib know about it.
    this._receiveFromLdsCallback(records,objectMetadata);}else {{// This doesn't look like a record and it's not a cache hit - why are we getting it?
    assert$2(false,`This object should be a record, but it is not: ${record}`);}}}}/**
         * Returns the normalized record data from the cache using cacheKey
         * @param recordId
         * @returns Thenable containing Normalized record
         */getRecordValueFromCache(recordId){const cacheKey=buildRecordCacheKey(recordId);return this._ldsCache.getValue(cacheKey);}/**
         * Reference to the RecordService instance.
         */get _recordService(){return this._ldsCache.getService(RECORD_VALUE_TYPE);}/**
         * Reference to the RecordUiService instance.
         */get _recordUiService(){return this._ldsCache.getService(RECORD_UI_VALUE_TYPE);}}/**
     * The type to use when building ApexCacheKey.
     */const APEX_VALUE_TYPE="lds.Apex";/**
     * Time to live for the Apex cache value. 5 minutes.
     */const APEX_TTL=5*60*1000;/**
     * Constructs a cache key for the Apex value type.
     * @param namespace The name space.
     * @param classname The class name.
     * @param functionName The function name.
     * @param isContinuation Indicates whether the Apex method returns a continuation.
     * @param params The params.
     * @returns A new cache key representing the Apex value type.
     */function buildCacheKey$5(namespace,classname,functionName,isContinuation,params){return {type:APEX_VALUE_TYPE,key:`${namespace}${KEY_DELIM}${classname}${KEY_DELIM}${functionName}${KEY_DELIM}${isContinuation}${KEY_DELIM}${params?stableJSONStringify(params):""}`};}/**
     * Gets a field value from an Apex sObject.
     * @param sobject The sObject holding the field.
     * @param field The qualified API name of the field to return.
     * @returns The field's value. If it doesn't exist, undefined is returned.
     */function getSObjectValue(sObject,field){const unqualifiedField=splitQualifiedFieldApiName(getFieldApiName(field))[1];const fields=unqualifiedField.split(".");while(fields.length>0){const nextField=fields.shift();// if field or path to field is not found then return undefined
    if(!(nextField in sObject)){return undefined;}sObject=sObject[nextField];}return sObject;}/**
     * Provides functionality to read apex action data from the cache. Can refresh the data from the server.
     */class ApexService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){super(ldsCache,[APEX_VALUE_TYPE]);}getCacheValueTtl(){return APEX_TTL;}/**
         * Checks the cache to see if a value is cached and is within TTL and if so returns the value cached.
         * If the value is not cached or TTL-ed, makes a call to the ApexActionController to fetch the apex controller value.
         *  - If the apex controller value is cacheable, caches the value and returns the value.
         *  - If the apex controller value is not cacheable, then returns the value.
         * @param namespace The namespace of the Apex controller.
         * @param classname The class name of the Apex controller.
         * @param method The method of the Apex controller.
         * @param isContinuation Indicates whether the Apex method returns a continuation.
         * @param params The parameters to pass into the apex action controller.
         * @returns See description.
         */runApex(namespace,classname,method,isContinuation,params){const cacheKey=buildCacheKey$5(namespace,classname,method,isContinuation,params);return this._ldsCache.access().then(()=>{const apexValueWrapper=this._ldsCache.getValue(cacheKey);if(apexValueWrapper!==undefined&&isWithinTtl(this._ldsCache.timeSource.now(),apexValueWrapper.lastFetchTime,APEX_TTL)){// value exists in cache is not TTL-ed, so return the value.
    return apexValueWrapper.value;}// value either does not exist in cache or is TTL-ed
    // fetch fresh value from server
    return executeAuraGlobalController("ApexActionController.execute",{namespace,classname,method,isContinuation,params,cacheable:false},{background:false,hotspot:false,longRunning:isContinuation}).then(transportResponse=>{const localFreshApex=transportResponse.body;// server side apex action response serialization would omit the returnValue property if its value is null
    if(localFreshApex.returnValue===undefined){localFreshApex.returnValue=null;}if(localFreshApex.cacheable){// if apex method is cacheable, then call the value provider which will cache the response and convert the observable to a promise and returns the promise.
    // At this point we know that the value does not exist in cache or is TTL-ed so we can bypass the additional cache get.
    const valueProviderParameters={cacheKey,namespace,classname,method,isContinuation,params,metaConfig:{forceProvide:true},localFreshApex};// create a value provider and call ldsCache.get to cache the local value.
    return observableToPromise(this._ldsCache.get(cacheKey,this._createApexValueProvider(valueProviderParameters)),true);}else {// if the apex method is not cacheable, then return the response without caching it.
    return localFreshApex.returnValue;}});});}/**
         * Retrieves an apex controller value from the cache. If it doesn't exist in the cache it will retrieve it from the server and put it into the cache.
         * @param namespace The namespace of the Apex controller.
         * @param classname The class name of the Apex controller.
         * @param method The method of the Apex controller.
         * @param isContinuation Whether this Apex method returns a continuation object.
         * @param params The parameters to pass into the Apex controller.
         * @param metaConfig Optional configuration object.
         */getApex(namespace,classname,method,isContinuation,params,metaConfig){const cacheKey=buildCacheKey$5(namespace,classname,method,isContinuation,params);const valueProviderParameters={cacheKey,namespace,classname,method,isContinuation,params,metaConfig};const finishedCallbacks=metaConfig&&metaConfig.finishedCallbacks;return this._ldsCache.get(cacheKey,this._createApexValueProvider(valueProviderParameters),finishedCallbacks);}/**
         * Constructs a value provider to retrieve an apex action.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns The value provider to retrieve an Apex controller value.
         */_createApexValueProvider(valueProviderParameters){const{cacheKey,namespace,classname,method,isContinuation,params,metaConfig,localFreshApex}=valueProviderParameters;const valueProvider=new ValueProvider(cacheAccessor=>{if(metaConfig&&metaConfig.forceProvide){return this._getFreshValue(cacheAccessor,cacheKey,namespace,classname,method,isContinuation,params,localFreshApex);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;// check for ttl expiry
    const needsRefresh=nowTime>lastFetchTime+APEX_TTL;if(needsRefresh){// Trigger a refresh. We don't care about the return value of this, we just need to force an API call
    // to keep the Observable's data stream alive.
    return this._getFreshValue(cacheAccessor,cacheKey,namespace,classname,method,isContinuation,params,localFreshApex);}return Thenable.resolve(1/* CACHE_HIT */);}return this._getFreshValue(cacheAccessor,cacheKey,namespace,classname,method,isContinuation,params,localFreshApex);},valueProviderParameters);return valueProvider;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param cacheKey The cache key for the apex action.
         * @param namespace The namespace of the Apex controller.
         * @param classname The class name of the Apex controller.
         * @param method The method of the Apex controller.
         * @param isContinuation Whether the Apex method returns a continuation object.
         * @param params The parameters to pass into the apex action controller.
         * @param localFreshApex An apex value to explicitly put into cache.
         * @returns Returns a ValueProviderResult representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,cacheKey,namespace,classname,method,isContinuation,params,localFreshApex){let transportResponseThenable;// If the apex value is provided, we don't go to server to fetch it.
    if(localFreshApex){transportResponseThenable=Thenable.resolve(getOkFetchResponse(localFreshApex));}else {transportResponseThenable=executeAuraGlobalController("ApexActionController.execute",{namespace,classname,method,isContinuation,params,cacheable:true},{hotspot:false,background:false,longRunning:isContinuation});}return transportResponseThenable.then(transportResponse=>{const apexCacheValue=transportResponse.body;// nothing to normalize
    this.stagePutValue([],apexCacheValue.returnValue,cacheAccessor,cacheKey);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return Thenable.resolve(2/* CACHE_MISS */);});}/**
         * @param dependencies An array of cache keys that depend on the given apex value.
         * @param value The value to stagePut.
         * @param cacheAccessor An object to access cache directly.
         */stagePutValue(dependencies,value,cacheAccessor,additionalData){cacheAccessor.stagePut(dependencies,additionalData,value,value);}/**
         * TODO: Make this actually strip out the eTags!
         * Strips all eTag properties from the given value by directly deleting them.
         * @param value The value from which to strip the eTags.
         * @returns The given value with its eTags stripped.
         */stripETagsFromValue(value){return value;}}/**
     * Generates the wire adapter for Apex.
     */class ApexWireAdapterGenerator{/**
         * Constructor.
         * @param apexService Reference to the ApexService instance.
         */constructor(apexService){this._apexService=apexService;}/**
         * Generates the wire adapter for getApex.
         * @param namespace namespace of the Apex controller.
         * @param classname classname of the Apex controller.
         * @param method method name of the Apex controller.
         * @param isContinuation Indicates whether the Apex method returns a continuation object.
         * @returns See description.
         */generateGetApexWireAdapter(namespace,classname,method,isContinuation){const wireAdapter=generateWireAdapter((config,metaConfig)=>{return this._serviceGetApex(namespace,classname,method,isContinuation,config,metaConfig);});return wireAdapter;}/**
         * Returns the method which invokes the Apex GlobalController with the config passed
         * @param namespace namespace of the Apex controller.
         * @param classname classname of the Apex controller.
         * @param method method name of the Apex controller.
         * @param isContinuation indicates whether the Apex method returns a continuation object.
         */getApexInvoker(namespace,classname,method,isContinuation){return config=>{return this._apexService.runApex(namespace,classname,method,isContinuation,config);};}/**
         * Service getApex @wire.
         * @param namespace namespace of the Apex controller.
         * @param classname classname of the Apex controller.
         * @param method method name of the Apex controller.
         * @param isContinuation Indicates whether the Apex method returns a continuation object.
         * @param config Config params for the service.
         * @param metaConfig Additional configuration to specify cache behavior.
         * @returns Observable stream that emits Apex controller values.
         */_serviceGetApex(namespace,classname,method,isContinuation,config,metaConfig){if(!this._validateApexConfig(config)){return undefined;}return this._apexService.getApex(namespace,classname,method,isContinuation,config,metaConfig);}/**
         *  Validates the apex request configuration passed in from @wire.
         *  @param config The configuration object passed from @wire.
         *  @returns True if config is null/undefined or false if it does not contain undefined values.
         */_validateApexConfig(config){if(config){const values=Object.values(config);if(values&&values.indexOf(undefined)!==-1){return false;}}return true;}}/*
     * The valueType to use when building ListUiCacheKeyBuilder.
     */const LIST_UI_VALUE_TYPE="lds.ListUi";const LIST_INFO_VALUE_TYPE="lds.ListInfo";const LIST_RECORDS_VALUE_TYPE="lds.ListRecords";const LIST_VIEWS_VALUE_TYPE="lds.ListViews";// TTL for list collection related data
    const LIST_COLLECTION_TTL=30*1000;// 30 second ttl
    // TTL for list-ui related data
    const LIST_UI_TTL=15*60*1000;// 15 minute ttl
    // chunk size for caching list-records
    const DEFAULT_LIST_RECORDS_CHUNK_SIZE=25;// chunk size for caching list collections
    const DEFAULT_LIST_COLLECTION_CHUNK_SIZE=50;// listViewApiName to pass to getListUi() to request the MRU list
    const MRU=Symbol.for("MRU");// default page sizes if caller does not specify
    const DEFAULT_LIST_COLLECTION_PAGE_SIZE=20;const DEFAULT_LIST_RECORDS_PAGE_SIZE=50;// default page token if caller does not specify
    const DEFAULT_PAGE_TOKEN="0";// shared utility functions
    /**
     * String template for error messages.
     *
     * @param literals string literals from the template
     * @param key key for which the problem was detected
     * @param valueFound value that was supplied for key (if any)
     * @param singleValue existing value contained in list (?)
     * @return formatted error message
     */function _errorFormatter(_literals,key,valueFound,singleValue){return `${key} should be a string list, but received ${valueFound}`+(singleValue?`, list contains an entry with value ${singleValue}`:"");}/**
     * Converts a list to a string suitable for inclusion in a CacheKey. The
     * list is not permitted to contain any null or undefined values.
     *
     * @param list list
     * @param key key associated with list, only used in case of errors
     * @return list, formatted as a string
     */function _listToString(list=[],key){// TODO - can be removed once all calling code is cleaned up to use undefined rather than null
    list=list||[];list.forEach(field=>{if(!field){throw new TypeError(_errorFormatter`${key}${list}${field}`);}});return list.join(",");}/**
     * Indicates if the supplied value is null or undefined.
     *
     * @param x value to be checked
     * @return true if x is null or undefined; false otherwise
     */function _nullish(x){return x===null||x===undefined;}/**
     * Converts a string from a CacheKey to a listViewApiName.
     *
     * @param s CacheKey string
     * @return listViewApiName associated with s
     */function _stringToListViewApiName(s){return s?s.startsWith("Symbol(")?Symbol.for(s.slice(7,-1)):s:undefined;}/**
     * Converts a string from a CacheKey to a list of strings.
     *
     * @param s CacheKey string
     * @return list of values that were used to generate s
     */function _stringToList(s){return s?s.split(","):undefined;}/**
     * Constructs a cache key for a list-info.
     */class ListInfoCacheKeyBuilder{/**
         * Sets the objectApiName, listViewApiName, and listViewId for the list-info
         * CacheKey.
         *
         * @param objectApiName objectApiName for the list-info cache key
         * @param listViewApiName listViewApiName for the list-info cache key
         * @param listViewId listViewId for the list-info cache key
         * @returns the current object, to allow method chaining
         */setListReference(objectApiName,listViewApiName,listViewId){if(listViewId||objectApiName&&listViewApiName){this._objectApiName=objectApiName;this._listViewApiName=listViewApiName;this._listViewId=listViewId;}else {throw new TypeError(`Either objectApiName (${objectApiName}) AND listViewApiName (${String(listViewApiName)}) or listViewId (${listViewId}) must be set`);}return this;}/**
         * Sets the objectApiName, listViewApiName, and listViewId to match the corresponding
         * fields of a list-ui CacheKey.
         *
         * @param listUiCacheKey list-ui cache key to be copied
         * @returns the current object, to allow method chaining
         */setListUiCacheKey(listUiCacheKey){const pieces=listUiCacheKey.key.split(KEY_DELIM,3);this._objectApiName=pieces[0];this._listViewApiName=_stringToListViewApiName(pieces[1]);this._listViewId=pieces[2];return this;}/**
         * Builds the cache key for a list-info.
         *
         * @returns a new cache key for a list-info
         */build(){return {type:LIST_INFO_VALUE_TYPE,key:`${this._objectApiName||""}${KEY_DELIM}${this._listViewApiName?this._listViewApiName.toString():""}${KEY_DELIM}${this._listViewId||""}`};}}/**
     * Constructs a cache key for a list-records.
     */class ListRecordsCacheKeyBuilder{/**
         * Returns the fields associated with the list-records.
         *
         * @returns fields associated with the list-records
         */get fields(){return this._fields;}/**
         * Sets the fields for the list-records.
         *
         * @param fields fields for the list-records
         */set fields(fields){this.fields=fields;}/**
         * Sets the fields for the list-records.
         *
         * @param fields fields for the list-records
         * @returns the current object, to allow method chaining
         */setFields(fields){this._fields=fields;return this;}/**
         * Returns the listViewApiName associated with the list-records.
         *
         * @returns listViewApiName associated with the list-records
         */get listViewApiName(){return this._listViewApiName;}/**
         * Returns the listViewApiId associated with the list-records.
         *
         * @returns listViewApiId associated with the list-records
         */get listViewId(){return this._listViewId;}/**
         * Returns the objectApiName associated with the list-records.
         *
         * @returns objectApiName associated with the list-records
         */get objectApiName(){return this._objectApiName;}/**
         * Returns the optionalFields associated with the list-records.
         *
         * @returns optionalFields associated with the list-records
         */get optionalFields(){return this._optionalFields;}/**
         * Sets the optionalFields for the list-records.
         *
         * @param optionalFields optionalFields for the list-records
         */set optionalFields(optionalFields){this._optionalFields=optionalFields;}/**
         * Sets the optionalFields for the list-records.
         *
         * @param optionalFields optionalFields for the list-records
         * @returns the current object, to allow method chaining
         */setOptionalFields(optionalFields){this._optionalFields=optionalFields;return this;}/**
         * Returns the pageToken associated with the list-records.
         *
         * @returns pageToken associated with the list-records
         */get pageToken(){return this._pageToken;}/**
         * Sets the pageToken for the list-records.
         *
         * @param pagToken pageToken for the list-records
         */set pageToken(pageToken){this._pageToken=pageToken;}/**
         * Sets the pageToken for the list-records.
         *
         * @param pagToken pageToken for the list-records
         * @returns the current object, to allow method chaining
         */setPageToken(pageToken){this._pageToken=pageToken;return this;}/**
         * Returns the sortBy associated with the list-records.
         *
         * @returns sortBy associated with the list-records
         */get sortBy(){return this._sortBy;}/**
         * Sets the sortBy for the list-records.
         *
         * @param sortBy sortBy for the list-records
         */set sortBy(sortBy){this._sortBy=sortBy;}/**
         * Sets the sortBy for the list-records.
         *
         * @param sortBy sortBy for the list-records
         * @returns the current object, to allow method chaining
         */setSortBy(sortBy){this._sortBy=sortBy;return this;}/**
         * Sets the list reference fields (objectApiName, listViewApiName, and
         * listViewId) for this list-records. Note that either listViewId, or objectApiName
         * and listViewApiName must be supplied.
         *
         * @param objectApiName objectApiName to set
         * @param listViewApiName listViewApiName to set
         * @param listViewId listViewId to set
         * @returns the current object, to allow method chaining
         */setListReference(objectApiName,listViewApiName,listViewId){if(listViewId||objectApiName&&listViewApiName){this._objectApiName=objectApiName;this._listViewApiName=listViewApiName;this._listViewId=listViewId;}else {throw new TypeError(`Either objectApiName (${objectApiName}) AND listViewApiName (${String(listViewApiName)}) or listViewId (${listViewId}) must be set`);}return this;}/**
         * Sets the fields for this list-records cache key based on an existing list-records
         * cache key.
         *
         * @param cacheKey list-records cacheKey
         * @returns the current object, to allow method chaining
         */setListRecordsCacheKey(listRecordsCacheKey){const pieces=listRecordsCacheKey.key.split(KEY_DELIM);this._objectApiName=pieces[0]||undefined;this._listViewApiName=_stringToListViewApiName(pieces[1]);this._listViewId=pieces[2]||undefined;this._pageToken=pieces[3]||undefined;this._sortBy=pieces[4]||undefined;this._fields=_stringToList(pieces[5]);this._optionalFields=_stringToList(pieces[6]);return this;}/**
         * Sets the fields for this list-records cache key based on an existing list-ui
         * cache key.
         *
         * @param cacheKey list-ui cacheKey
         * @returns the current object, to allow method chaining
         */setListUiCacheKey(listUiCacheKey){const pieces=listUiCacheKey.key.split(KEY_DELIM);this._objectApiName=pieces[0]||undefined;this._listViewApiName=_stringToListViewApiName(pieces[1]);this._listViewId=pieces[2]||undefined;this._pageToken=pieces[3]||undefined;this._sortBy=pieces[5]||undefined;this._fields=_stringToList(pieces[6]);this._optionalFields=_stringToList(pieces[7]);return this;}/**
         * Builds the cache key for a list-records.
         *
         * @returns a new cache key for a list-records
         */build(){return {type:LIST_RECORDS_VALUE_TYPE,key:`${this._objectApiName||""}${KEY_DELIM}${this._listViewApiName?this._listViewApiName.toString():""}${KEY_DELIM}${this._listViewId||""}${KEY_DELIM}${_nullish(this._pageToken)?DEFAULT_PAGE_TOKEN:this._pageToken}${KEY_DELIM}${this._sortBy||""}${KEY_DELIM}${_listToString(this._fields,"fields")}${KEY_DELIM}${_listToString(this._optionalFields,"optionalFields")}`};}}/**
     * Constructs a cache key for a list-ui.
     */class ListUiCacheKeyBuilder{/**
         * Returns the fields associated with the list-ui.
         *
         * @returns fields associated with the list-ui
         */get fields(){return this._fields;}/**
         * Sets the fields for the list-ui.
         *
         * @param fields fields for the list-ui
         */set fields(fields){this._fields=fields;}/**
         * Sets the fields for the list-ui.
         *
         * @param fields fields for the list-ui
         * @returns the current object, to allow method chaining
         */setFields(fields){this._fields=fields;return this;}/**
         * Returns the listViewApiName associated with the list-ui.
         *
         * @returns listViewApiName associated with the list-ui
         */get listViewApiName(){return this._listViewApiName;}/**
         * Returns the listViewApiId associated with the list-ui.
         *
         * @returns listViewApiId associated with the list-ui
         */get listViewId(){return this._listViewId;}/**
         * Returns the objectApiName associated with the list-ui.
         *
         * @returns objectApiName associated with the list-ui
         */get objectApiName(){return this._objectApiName;}/**
         * Returns the optionalFields associated with the list-ui.
         *
         * @returns optionalFields associated with the list-ui
         */get optionalFields(){return this._optionalFields;}/**
         * Sets the optionalFields for the list-ui.
         *
         * @param optionalFields optionalFields for the list-ui
         */set optionalFields(optionalFields){this._optionalFields=optionalFields;}/**
         * Sets the optionalFields for the list-ui.
         *
         * @param optionalFields optionalFields for the list-ui
         * @returns the current object, to allow method chaining
         */setOptionalFields(optionalFields){this._optionalFields=optionalFields;return this;}/**
         * Returns the pageSize associated with the list-ui.
         *
         * @returns pageSize associated with the list-ui
         */get pageSize(){return this._pageSize;}/**
         * Sets the pageSize for the list-ui.
         *
         * @param pagSize pageSize for the list-ui
         */set pageSize(pageSize){this._pageSize=pageSize;}/**
         * Sets the pageSize for the list-ui.
         *
         * @param pagSize pageSize for the list-ui
         * @returns the current object, to allow method chaining
         */setPageSize(pageSize){this._pageSize=pageSize;return this;}/**
         * Returns the pageToken associated with the list-ui.
         *
         * @returns pageToken associated with the list-ui
         */get pageToken(){return this._pageToken;}/**
         * Sets the pageToken for the list-ui.
         *
         * @param pagToken pageToken for the list-ui
         */set pageToken(pageToken){this._pageToken=pageToken;}/**
         * Sets the pageToken for the list-ui.
         *
         * @param pagToken pageToken for the list-ui
         * @returns the current object, to allow method chaining
         */setPageToken(pageToken){this._pageToken=pageToken;return this;}/**
         * Returns the sortBy associated with the list-ui.
         *
         * @returns sortBy associated with the list-ui
         */get sortBy(){return this._sortBy;}/**
         * Sets the sortBy for the list-ui.
         *
         * @param sortBy sortBy for the list-ui
         */set sortBy(sortBy){this._sortBy=sortBy;}/**
         * Sets the sortBy for the list-ui.
         *
         * @param sortBy sortBy for the list-ui
         * @returns the current object, to allow method chaining
         */setSortBy(sortBy){this._sortBy=sortBy;return this;}/**
         * Sets the list reference fields (objectApiName, listViewApiName, and
         * listViewId) for this list-ui. Note that either listViewId, or objectApiName
         * and listViewApiName must be supplied.
         *
         * @param objectApiName objectApiName to set
         * @param listViewApiName listViewApiName to set
         * @param listViewId listViewId to set
         * @returns the current object, to allow method chaining
         */setListReference(objectApiName,listViewApiName,listViewId){if(listViewId||objectApiName&&listViewApiName){this._objectApiName=objectApiName;this._listViewApiName=listViewApiName;this._listViewId=listViewId;}else {throw new TypeError(`Either objectApiName (${objectApiName}) AND listViewApiName (${String(listViewApiName)}) or listViewId (${listViewId}) must be set`);}return this;}/**
         * Sets the fields for this list-ui cache key based on an existing list-ui
         * cache key.
         *
         * @param cacheKey list-ui cacheKey
         * @returns the current object, to allow method chaining
         */setListUiCacheKey(listUiCacheKey){const pieces=listUiCacheKey.key.split(KEY_DELIM);this._objectApiName=pieces[0]||undefined;this._listViewApiName=_stringToListViewApiName(pieces[1]);this._listViewId=pieces[2]||undefined;this._pageToken=pieces[3]||undefined;this._pageSize=pieces[4]?parseInt(pieces[4],10):DEFAULT_LIST_RECORDS_PAGE_SIZE;this._sortBy=pieces[5]||undefined;this._fields=_stringToList(pieces[6]);this._optionalFields=_stringToList(pieces[7]);return this;}/**
         * Builds the cache key for a list-ui.
         *
         * @returns a new cache key for a list-ui
         */build(){return {type:LIST_UI_VALUE_TYPE,key:`${this._objectApiName||""}${KEY_DELIM}${this._listViewApiName?this._listViewApiName.toString():""}${KEY_DELIM}${this._listViewId||""}${KEY_DELIM}${_nullish(this._pageToken)?DEFAULT_PAGE_TOKEN:this._pageToken}${KEY_DELIM}${this._pageSize}${KEY_DELIM}${this._sortBy||""}${KEY_DELIM}${_listToString(this._fields,"fields")}${KEY_DELIM}${_listToString(this._optionalFields,"optionalFields")}`};}}/**
     * Constructs a cache key for a list collection.
     */class ListCollectionCacheKeyBuilder{/**
         * Returns the objectApiName associated with the list collection.
         *
         * @returns objectApiName associated with the list collection
         */get objectApiName(){return this._objectApiName;}/**
         * Sets the objectApiName of the list collection.
         *
         * @param objectApiName objectApiName associated with the list collection
         */set objectApiName(objectApiName){this._objectApiName=objectApiName;}/**
         * Sets the objectApiName of the list collection.
         *
         * @param objectApiName objectApiName associated with the list collection
         * @returns the current object, to allow method chaining
         */setObjectApiName(objectApiName){this._objectApiName=objectApiName;return this;}/**
         * Returns the pageSize associated with the list collection.
         *
         * @returns pageSize associated with the list collection
         */get pageSize(){return this._pageSize;}/**
         * Sets the pageSize for the list collection.
         *
         * @param pagSize pageSize for the list collection
         */set pageSize(pageSize){this._pageSize=pageSize;}/**
         * Sets the pageSize for the list collection.
         *
         * @param pagSize pageSize for the list collection
         * @returns the current object, to allow method chaining
         */setPageSize(pageSize){this._pageSize=pageSize;return this;}/**
         * Returns the pageToken associated with the list collection.
         *
         * @returns pageToken associated with the list collection
         */get pageToken(){return this._pageToken;}/**
         * Sets the pageToken for the list collection.
         *
         * @param pagToken pageToken for the list collection
         */set pageToken(pageToken){this._pageToken=pageToken;}/**
         * Sets the pageToken for the list collection.
         *
         * @param pagToken pageToken for the list collection
         * @returns the current object, to allow method chaining
         */setPageToken(pageToken){this._pageToken=pageToken;return this;}/**
         * Returns the query associated with the list collection.
         *
         * @returns query associated with the list collection
         */get q(){return this._q;}/**
         * Sets the query for the list collection.
         *
         * @param q query for the list collection
         */set q(q){this._q=q;}/**
         * Sets the query for the list collection.
         *
         * @param q query for the list collection
         * @returns the current object, to allow method chaining
         */setQ(q){this._q=q;return this;}/**
         * Copies an existing list collection cache key.
         * Note that by default we do NOT copy pageSize as we don't want it when
         * searching for cached list views.
         *
         * @param cacheKey existing list collection cache key
         * @param copyPageSize if truthy, copy pageSize; otherwise set pageSize of this
         *   cache key to undefined
         * @returns the current object, to allow method chaining
         */setListCollectionCacheKey(cacheKey,copyPageSize=false){// TODO - should we assert cacheKey is LIST_VIEWS_VALUE_TYPE?
    const pieces=cacheKey.key.split(KEY_DELIM);this._objectApiName=pieces[0];this._pageToken=pieces[1];this._pageSize=copyPageSize&&pieces[2]?parseInt(pieces[2],10):undefined;this._q=pieces[3]||undefined;return this;}/**
         * Builds the cache key for a list collection.
         *
         * @returns a new cache key for a list collection
         */build(){return {type:LIST_VIEWS_VALUE_TYPE,key:`${this._objectApiName}${KEY_DELIM}${_nullish(this._pageToken)?DEFAULT_PAGE_TOKEN:this._pageToken}${KEY_DELIM}${this._pageSize||""}${KEY_DELIM}${this._q||""}`};}}/**
     * Cache utilities that deal with list-ui, list-info, and list-records
     * data in the LDS cache.
     */ // fetch functions
    /**
     * Fetches a list collection from the server.
     *
     * @param cacheKey cache key for the list collection to be retrieved
     * @param pageSize pageSize for the list collection
     * @return raw list collection data
     */function fetchListCollection(cacheKey,pageSize){const listCollectionCacheKeyBuilder=new ListCollectionCacheKeyBuilder().setListCollectionCacheKey(cacheKey);const params={objectApiName:listCollectionCacheKeyBuilder.objectApiName,pageToken:listCollectionCacheKeyBuilder.pageToken,pageSize,q:listCollectionCacheKeyBuilder.q};if(params.pageToken===DEFAULT_PAGE_TOKEN){delete params.pageToken;}if(!params.q){delete params.q;}return executeAuraGlobalController("ListUiController.getListsByObjectName",params).then(response=>{if(response.status===200){return response.body;}throw response.statusText;});}/**
     * Fetches a list-records from the server.
     *
     * @param cacheKey cache key for the list-records to be retrieved
     * @param pageSize pageSize for the list-records
     * @return raw list-records, as returned by the server
     */function fetchListRecords(cacheKey,pageSize){const listRecordsCacheKeyBuilder=new ListRecordsCacheKeyBuilder().setListRecordsCacheKey(cacheKey);const params={pageToken:listRecordsCacheKeyBuilder.pageToken,pageSize,sortBy:listRecordsCacheKeyBuilder.sortBy,fields:listRecordsCacheKeyBuilder.fields,optionalFields:listRecordsCacheKeyBuilder.optionalFields};let method;if(listRecordsCacheKeyBuilder.listViewId){params.listViewId=listRecordsCacheKeyBuilder.listViewId;method="ListUiController.getListRecordsById";}else if(listRecordsCacheKeyBuilder.listViewApiName===MRU){params.objectApiName=listRecordsCacheKeyBuilder.objectApiName;method="MruListUiController.getMruListRecords";}else {params.objectApiName=listRecordsCacheKeyBuilder.objectApiName;params.listViewApiName=listRecordsCacheKeyBuilder.listViewApiName;method="ListUiController.getListRecordsByName";}if(!params.fields){delete params.fields;}if(!params.optionalFields){delete params.optionalFields;}if(params.pageToken===DEFAULT_PAGE_TOKEN){delete params.pageToken;}if(!params.sortBy){delete params.sortBy;}return executeAuraGlobalController(method,params).then(response=>{if(response.status===200){return response.body;}throw response.statusText;});}/**
     * Fetches a list-ui from the server.
     *
     * @param cacheKey cache key for list-ui to be retrieved
     * @return raw list-ui, as returned by the server
     */function fetchListUi(cacheKey){const listUiCacheKeyBuilder=new ListUiCacheKeyBuilder().setListUiCacheKey(cacheKey);const params={pageToken:listUiCacheKeyBuilder.pageToken,pageSize:listUiCacheKeyBuilder.pageSize,sortBy:listUiCacheKeyBuilder.sortBy,fields:listUiCacheKeyBuilder.fields,optionalFields:listUiCacheKeyBuilder.optionalFields};let method;if(listUiCacheKeyBuilder.listViewId){params.listViewId=listUiCacheKeyBuilder.listViewId;method="ListUiController.getListUiById";}else if(listUiCacheKeyBuilder.listViewApiName===MRU){params.objectApiName=listUiCacheKeyBuilder.objectApiName;method="MruListUiController.getMruListUi";}else {params.objectApiName=listUiCacheKeyBuilder.objectApiName;params.listViewApiName=listUiCacheKeyBuilder.listViewApiName;method="ListUiController.getListUiByName";}if(!params.fields){delete params.fields;}if(!params.optionalFields){delete params.optionalFields;}if(params.pageToken===DEFAULT_PAGE_TOKEN){delete params.pageToken;}if(!params.sortBy){delete params.sortBy;}return executeAuraGlobalController(method,params).then(response=>{if(response.status===200){return response.body;}throw response.statusText;});}// pageToken functions
    /**
     * Converts a record offset to the corresponding pageToken.
     *
     * @param offset offset
     * @returns pageToken
     */function offsetToPageToken(offset){return String(offset);}/**
     * Returns the pageTokens and urls for a given pageToken/pageSize.
     *
     * @param pageToken page token
     * @param pageSize page size
     * @param endOfData true-ish if this is the end of the data
     * @param sampleUrl sample url to use as a pattern for constructing returned urls
     * @return (current|previous|next)Page(Token|Url)
     */function pageTokensAndUrls(pageToken,pageSize,endOfData,sampleUrl){const offset=pageTokenToOffset(pageToken);const previousOffset=offset===0?null:Math.max(offset-pageSize,0);const nextOffset=endOfData?null:offset+pageSize;const urlFor=(_offset,size)=>{return _offset===null?null:sampleUrl.replace(/([&?]pageToken=)[^&+]/,`$1${offsetToPageToken(_offset)}`).replace(/([&?]pageSize=)\d+/,`$1${size}`);};return {currentPageToken:pageToken||offsetToPageToken(offset),currentPageUrl:urlFor(offset,pageSize),previousPageToken:previousOffset===null?null:offsetToPageToken(previousOffset),previousPageUrl:urlFor(previousOffset,pageSize),nextPageToken:nextOffset===null?null:offsetToPageToken(nextOffset),nextPageUrl:urlFor(nextOffset,pageSize)};}/**
     * Parses a pageToken and returns the corresponding record offset.
     *
     * @param pageToken page token
     * @return record offset associated with the pageToken
     */function pageTokenToOffset(pageToken){return parseInt(pageToken||DEFAULT_PAGE_TOKEN,10);}// chunk functions
    /**
     * Returns the pageTokens for the chunks that encompass the specified pageToken
     * and pageSize.
     *
     * @param pageToken page token
     * @param pageSize page size
     * @param chunkSize chunk size
     * @return pageTokens for the chunks, offset of original pageToken within the first chunk
     */function chunkPageTokensFor(pageToken,pageSize,chunkSize){let offset;[pageToken,pageSize,offset]=snapToChunkBoundaries(pageToken,pageSize,chunkSize);const pageTokens=[];while(pageSize>0){pageTokens.push(pageToken);pageSize-=chunkSize;pageToken=offsetToPageToken(pageTokenToOffset(pageToken)+chunkSize);}return [pageTokens,offset];}/**
     * Adjusts a pageToken & pageSize so that both are aligned on cache chunk
     * boundaries.
     *
     * @param pageToken initial pageToken
     * @param pageSize initial pageSize
     * @param chunkSize chunk size
     * @return adjusted pageToken, adjusted pageSize, offset of new pageToken relative to old pageToken
     */function snapToChunkBoundaries(pageToken,pageSize,chunkSize){const offset=pageTokenToOffset(pageToken);// round pageToken down to the nearest chunk boundary
    const offsetAdjustment=offset%chunkSize;// round pageSize up to the nearest chunk boundary
    pageSize=chunkSize*Math.ceil((pageSize+offsetAdjustment)/chunkSize);return [offsetToPageToken(offset-offsetAdjustment),pageSize,offsetAdjustment];}/**
     */class ListUiCacheUtils{constructor(cacheAccessor,{chunkSize,ttl}){this.cacheAccessor=cacheAccessor;this.chunkSize=chunkSize;this.ttl=ttl;}/**
         * Locates as many list collections as possible from the LDS cache for the specified
         * cache key and returns the associated ValueWrappers for them.
         *
         * @param listCollectionCacheKey CacheKey that describes the list views to be retrieved
         * @return ValueWrapper[] for the list views found in the cache, the CacheKeys for those
         *    ValueWrappers, and the offset of the first list view within ValueWrapper[0]. Note
         *    that the ValueWrapper array may contain undefined and/or expired entries.
         */collectCachedLists(listCollectionCacheKey){const listCollectionCacheKeyBuilder=new ListCollectionCacheKeyBuilder().setListCollectionCacheKey(listCollectionCacheKey,true);const[pageTokens,offset]=chunkPageTokensFor(listCollectionCacheKeyBuilder.pageToken,listCollectionCacheKeyBuilder.pageSize,this.chunkSize);// we don't want a pageSize in the constituent keys
    listCollectionCacheKeyBuilder.setPageSize(undefined);const listCollectionCacheKeys=pageTokens.map(pageToken=>listCollectionCacheKeyBuilder.setPageToken(pageToken).build());const valueWrappers=listCollectionCacheKeys.map(cacheKey=>this.cacheAccessor.get(cacheKey));return [valueWrappers,listCollectionCacheKeys,offset];}/**
         * Locates as many list-records as possible from the LDS cache for the specified list-ui
         * and returns the associated ValueWrappers for them.
         *
         * @param listUiCacheKey CacheKey that describes the records to be retrieved
         * @return ValueWrapper[] for the list-records found in the cache, the CacheKeys for those
         *    ValueWrappers, and the offset of the first record within ValueWrapper[0]. Note
         *    that the ValueWrapper array may contain undefined and/or expired entries.
         */collectCachedRecords(listUiCacheKey){const listUiCacheKeyBuilder=new ListUiCacheKeyBuilder().setListUiCacheKey(listUiCacheKey);const[pageTokens,offset]=chunkPageTokensFor(listUiCacheKeyBuilder.pageToken,listUiCacheKeyBuilder.pageSize,this.chunkSize);const listRecordsCacheKeyBuilder=new ListRecordsCacheKeyBuilder().setListUiCacheKey(listUiCacheKey);const listRecordsCacheKeys=pageTokens.map(pageToken=>listRecordsCacheKeyBuilder.setPageToken(pageToken).build());const listRecordsValueWrappers=listRecordsCacheKeys.map(listRecordsCacheKey=>this.cacheAccessor.get(listRecordsCacheKey));return [listRecordsValueWrappers,listRecordsCacheKeys,offset];}/**
         * Fabricates a list collection from its pieces.
         *
         * @param listCollectionValueWrappers ValueWrappers contianing the list data
         * @param offset offset of the first list view within the first list-collection
         * @param listCollectionCacheKey CacheKey for the list-collection
         * @return the assembled list collection
         */constructListCollection(listCollectionValueWrappers,offset,listCollectionCacheKey){const listCollectionCacheKeyBuilder=new ListCollectionCacheKeyBuilder().setListCollectionCacheKey(listCollectionCacheKey,true);// assemble the list data
    let remaining=listCollectionCacheKeyBuilder.pageSize;let endOfData=true;const lists=[].concat(...listCollectionValueWrappers.map(listCollectionValueWrapper=>{const listCollection=listCollectionValueWrapper.value;const count=Math.min(listCollection.lists.length-offset,remaining);const listData=listCollection.lists.slice(offset,offset+count);// we've reached the end of the data if we used all these records and there aren't any more
    endOfData=offset+count>=listCollection.lists.length&&!listCollection.nextPageToken;offset=0;remaining-=count;return listData;}));const samplePageUrl=listCollectionValueWrappers[0].value.currentPageUrl;const{currentPageToken,currentPageUrl,previousPageToken,previousPageUrl,nextPageToken,nextPageUrl}=pageTokensAndUrls(listCollectionCacheKeyBuilder.pageToken,listCollectionCacheKeyBuilder.pageSize,endOfData,samplePageUrl);// put everything together
    return {count:lists.length,lists,currentPageToken,currentPageUrl,previousPageToken,previousPageUrl,nextPageToken,nextPageUrl};}/**
         * Fabricates a list-ui from its pieces
         *
         * @param recordService The recordService instance.
         * @param listInfoValueWrapper the list-info
         * @param listRecordsValueWrappers the list-records
         * @param offset offset of the first record within the first list-records
         * @param listUiCacheKey CacheKey for the list-ui
         * @return the list-ui
         */constructListUi(recordService,listInfoValueWrapper,listRecordsValueWrappers,offset,listUiCacheKey){const listUiCacheKeyBuilder=new ListUiCacheKeyBuilder().setListUiCacheKey(listUiCacheKey);// start with a copy of the list-info
    const info=cloneDeepCopy(listInfoValueWrapper.value);// we're hiding etags from consumers
    delete info.eTag;// expand the markers back into records
    let remaining=listUiCacheKeyBuilder.pageSize;let endOfData=true;const records=listRecordsValueWrappers.map(valueWrapper=>{const listRecords=valueWrapper.value;const count=Math.min(listRecords.records.length-offset,remaining);const markers=listRecords.records.slice(offset,offset+count);// we've reached the end of the data if we used all these records and there aren't any more
    endOfData=offset+count>=listRecords.records.length&&!listRecords.nextPageToken;offset=0;remaining-=count;return fromRecordMarkers(recordService,this.cacheAccessor,markers);});const{currentPageToken,currentPageUrl,previousPageToken,previousPageUrl,nextPageToken,nextPageUrl}=pageTokensAndUrls(listUiCacheKeyBuilder.pageToken,listUiCacheKeyBuilder.pageSize,endOfData,listRecordsValueWrappers[0].value.currentPageUrl);// add the records to the list-ui
    const listUi={info,records:{count:0,currentPageToken,currentPageUrl,previousPageToken,previousPageUrl,nextPageToken,nextPageUrl,records:[].concat(...records)}};listUi.records.count=listUi.records.records.length;return listUi;}/**
         * Indicates if a ValueWrapper from the LDS cache is expired.
         *
         * @param valueWrapper value from the LDS cache to be checked
         * @param ttl maximum age, in millisecondss; if a ttl <= 0 is specified the ttl check is skipped
         * @return truthy if value is expired; falsy if not
         */expired(valueWrapper,ttl=this.ttl){return !valueWrapper||valueWrapper.value===undefined||!valueWrapper.extraInfoObject||ttl>0&&this.cacheAccessor.nowTime>valueWrapper.extraInfoObject.serverFetchTime+ttl;}/**
         * Fetches list views from the server and stagePuts the data. Note that this method
         * adjusts the starting pageToken and pageSize so that complete chunks of list views are
         * retrieved.
         *
         * @param listCollectionCacheKey CacheKey describing the list views to be retrieved
         * @param pageSize number of list views to be retrieved
         * @return list-collection ValueWrappers, CacheKeys, offset of the first list view within the
         *    first ValueWrapper
         */fetchAndStagePutListCollection(listCollectionCacheKey,pageSize){const listCollectionCacheKeyBuilder=new ListCollectionCacheKeyBuilder().setListCollectionCacheKey(listCollectionCacheKey);// adjust pageToken & pageSize so that we ask for full chunks of records
    let offset;[listCollectionCacheKeyBuilder.pageToken,pageSize,offset]=snapToChunkBoundaries(listCollectionCacheKeyBuilder.pageToken,pageSize,this.chunkSize);offset+=0;// eslint is retarded
    listCollectionCacheKey=listCollectionCacheKeyBuilder.build();return fetchListCollection(listCollectionCacheKey,pageSize).then(listCollection=>{return this.stagePutListCollections(listCollectionCacheKey,listCollection);}).then(([listCollectionValueWrappers,listCollectionCacheKeys])=>{// type inference thinks this is any[] - need to be explicit
    return [listCollectionValueWrappers,listCollectionCacheKeys,offset];});}/**
         * Fetches a list-records from the server and stagePuts its data. Note that this method
         * adjusts the starting pageToken and pageSize so that complete chunks of records are
         * retrieved.
         *
         * @param recordService Reference to RecordService for stage putting records
         * @param listRecordsCacheKey CacheKey describing the records to be retrieved
         * @param pageSize number of records to be retrieved
         * @return list-records ValueWrappers, list-records CacheKeys, offset of the first record
         *    within the first ValueWrapper
         */fetchAndStagePutListRecords(recordService,listRecordsCacheKey,pageSize){const listRecordsCacheKeyBuilder=new ListRecordsCacheKeyBuilder().setListRecordsCacheKey(listRecordsCacheKey);// adjust pageToken & pageSize so that we ask for full chunks of records
    let offset;[listRecordsCacheKeyBuilder.pageToken,pageSize,offset]=snapToChunkBoundaries(listRecordsCacheKeyBuilder.pageToken,pageSize,this.chunkSize);listRecordsCacheKey=listRecordsCacheKeyBuilder.build();return fetchListRecords(listRecordsCacheKey,pageSize).then(listRecords=>{// split the records into chunks & add them to the LDS cache
    // note that we make an assumption here that these will not be the only list-records
    // in the cache so we don't need to force a stagePut - this is true most of the time
    // but can break in certain edge-case scenarios, e.g. the list-records from a previous
    // list-ui have expired but the list-info hasn't, or someone previously requested a
    // list-ui with 0 records
    return this.stagePutListRecords(recordService,listRecordsCacheKey,listRecords,false);}).then(([listRecordsValueWrappers,listRecordsCacheKeys])=>{// type inference thinks this is any[] - need to be explicit
    return [listRecordsValueWrappers,listRecordsCacheKeys,offset];});}/**
         * Fetches a list-ui from the server and stagePuts its constituent pieces.
         * Note that the list-ui itself is discarded.
         *
         * @param recordService Reference to RecordService for stage putting records.
         * @param listUiCacheKey CacheKey of the list-ui to be retrieved
         * @return list-info ValueWrapper, list-records ValueWrappers, list-records CacheKeys, offset
         *    of first record within first ValueWrapper
         */fetchAndStagePutListUi(recordService,listUiCacheKey){const listUiCacheKeyBuilder=new ListUiCacheKeyBuilder().setListUiCacheKey(listUiCacheKey);// adjust pageToken & pageSize so that we ask for full chunks of records
    let offset;[listUiCacheKeyBuilder.pageToken,listUiCacheKeyBuilder.pageSize,offset]=snapToChunkBoundaries(listUiCacheKeyBuilder.pageToken,listUiCacheKeyBuilder.pageSize,this.chunkSize);offset+=0;// eslint is retarded
    listUiCacheKey=listUiCacheKeyBuilder.build();return fetchListUi(listUiCacheKey).then(listUi=>{// extract and cache the list-ui
    const listInfoCacheKey=new ListInfoCacheKeyBuilder().setListUiCacheKey(listUiCacheKey).build();const listInfoValueWrapper=this.cacheAccessor.newValueWrapper(listUi.info,listUi.info.eTag,{serverFetchTime:this.cacheAccessor.nowTime});this.cacheAccessor.stagePut([],listInfoCacheKey,listInfoValueWrapper,listUi.info);// split the list-records into chunks and add them to the cache
    const listRecordsCacheKey=new ListRecordsCacheKeyBuilder().setListUiCacheKey(listUiCacheKey).build();// note that if we've fetched a list-ui, this are almost certainly the only records
    // in the cache so we force a stagePut
    // nested then's are gross, but this one is needed for scope
    const[listRecordsValueWrappers,listRecordsCacheKeys]=this.stagePutListRecords(recordService,listRecordsCacheKey,listUi.records,true);// note that we do NOT cache the list-ui itself since it doesn't contain any interesting data;
    // we'll just construct a new list-ui from the cached list-info and list-records when we need it
    // type inference thinks this is any[] - need to be explicit
    return [listInfoValueWrapper,listRecordsValueWrappers,listRecordsCacheKeys,offset];});}/**
         * Computes the effective server fetch time for a constructed list artifact,
         * stagePuts it to the LDS cache, and sets up the LDS cache dependencies for it.
         *
         * @param artifactCacheKey CacheKey for the list artifact
         * @param artifact the data to be stored in the cache
         * @param valueWrappers the ValueWrappers that were used to construct the artifact; used to
         *    compute the effective fetch time
         * @param cacheKeys CacheKeys on which the artifact depends
         */stagePutListArtifact(artifactCacheKey,artifact,valueWrappers,cacheKeys){const oldestFetchTime=valueWrappers.reduce((oldest,valueWrapper)=>{const serverFetchTime=valueWrapper.extraInfoObject?valueWrapper.extraInfoObject.serverFetchTime:oldest;return Math.min(oldest,serverFetchTime);},this.cacheAccessor.nowTime);// Need to save the artifact cache key so that the denormalizeValue method on the service class has enough info to denormalize a list ui from a list ui artifact (normalized).
    const artifactValueWrapper=this.cacheAccessor.newValueWrapper({cacheKey:artifactCacheKey},undefined,{serverFetchTime:oldestFetchTime});this.cacheAccessor.stagePut([],artifactCacheKey,artifactValueWrapper,artifact);cacheKeys.forEach(cacheKey=>this.cacheAccessor.stageDependencies([{cacheKey:artifactCacheKey,type:1/* REQUIRED */}],cacheKey));}/**
         * Breaks a collection of list views into chunks and stagePuts them to the
         * LDS cache.
         *
         * @param listCollectionCacheKey CacheKey for the list collection
         * @param listCollection list collection as returned from the UI API
         * @return ValueWrappers and associated CacheKeys used to stagePut the list views
         */stagePutListCollections(listCollectionCacheKey,listCollection){const offset=pageTokenToOffset(listCollection.currentPageToken);{assert$2(offset%this.chunkSize===0,"list-collection must start on a chunk boundary");}const chunkCacheKeyBuilder=new ListCollectionCacheKeyBuilder().setListCollectionCacheKey(listCollectionCacheKey);const valueWrappers=[];const cacheKeys=[];// always stagePut at least one list collection, even if it is empty; this
    // is necessary to correctly keep track of collections with no lists
    let forceStagePut=true;for(let i=0;i<listCollection.count||forceStagePut;i+=this.chunkSize){// only force one stagePut
    forceStagePut=false;const chunkCacheKey=chunkCacheKeyBuilder.setPageToken(offsetToPageToken(offset+i)).build();const lists=listCollection.lists.slice(i,i+this.chunkSize);const chunkListCollection={// we'll use this url as a template for constructing urls to return to our callers - the
    // pageToken and pageSize values will be replaced so it's not important that they're correct
    currentPageUrl:listCollection.currentPageUrl,// used both to mark the end of the data & when fetching more records
    nextPageToken:i+this.chunkSize>=listCollection.count?listCollection.nextPageToken:offsetToPageToken(offset+i+this.chunkSize),lists,count:lists.length};const chunkValueWrapper=this.cacheAccessor.newValueWrapper(chunkListCollection,undefined,{serverFetchTime:this.cacheAccessor.nowTime});this.cacheAccessor.stagePut([],chunkCacheKey,chunkValueWrapper,chunkListCollection);valueWrappers.push(chunkValueWrapper);cacheKeys.push(chunkCacheKey);}// type inference doesn't do what we want here - need to be explicit
    return Thenable.resolve([valueWrappers,cacheKeys]);}/**
         * stagePuts a list-records
         *
         * @param recordService Reference to RecordService used for stage putting records.
         * @param listRecordsCacheKey CacheKey for the list-records
         * @param listRecords list-records data
         * @param forceStagePut if true always stagePut a list-records, even if it is empty; this is necessary
         *    to correctly keep track of lists with no records
         * @return ValueWrappers and associated CacheKeys used to stagePut the list-records
         */stagePutListRecords(recordService,listRecordsCacheKey,listRecords,forceStagePut){const offset=pageTokenToOffset(listRecords.currentPageToken);{assert$2(offset%this.chunkSize===0,"list-records must start on a chunk boundary");}const chunkCacheKeyBuilder=new ListRecordsCacheKeyBuilder().setListRecordsCacheKey(listRecordsCacheKey);const valueWrappers=[];const cacheKeys=[];for(let i=0;i<listRecords.count||forceStagePut;i+=this.chunkSize){// only force one stagePut
    forceStagePut=false;const records=listRecords.records.slice(i,i+this.chunkSize);const chunkCacheKey=chunkCacheKeyBuilder.setPageToken(offsetToPageToken(offset+i)).build();// clear any dependencies from this chunk to previous records
    this.cacheAccessor.stageClearDependencies(chunkCacheKey);// lds-records owns record data, so let them merge our record data with whatever they already have
    recordService.mergeRecordsAndStagePuts([{cacheKey:chunkCacheKey,type:1/* REQUIRED */}],records,this.cacheAccessor,true);const chunkListRecords={// we need the etag to match up later
    listInfoETag:listRecords.listInfoETag,// we'll use this url as a template for constructing urls to return to our callers - the
    // pageToken and pageSize values will be replaced so it's not important that they're correct
    currentPageUrl:listRecords.currentPageUrl,// used both to mark the end of the data & when fetching more records
    nextPageToken:i+this.chunkSize>=listRecords.count?listRecords.nextPageToken:offsetToPageToken(offset+i+this.chunkSize),// defer to lds-records for record data when this is pulled back out of the cache
    records:records.map(record=>toRecordMarker(this.cacheAccessor,record,0))};const chunkValueWrapper=this.cacheAccessor.newValueWrapper(chunkListRecords,undefined,{serverFetchTime:this.cacheAccessor.nowTime});this.cacheAccessor.stagePut([],chunkCacheKey,chunkValueWrapper,chunkListRecords);valueWrappers.push(chunkValueWrapper);cacheKeys.push(chunkCacheKey);}// type inference doesn't do what we want here - need to be explicit
    return [valueWrappers,cacheKeys];}}/**
     * Provider function for list-uis.
     *
     * @param cacheAccessor accessor to get to the LDS cache
     * @param parameters parameters indicating what value is to be returned;
     * @returns provide result
     */function provide(cacheAccessor,parameters){const cacheUtils=new ListUiCacheUtils(cacheAccessor,{chunkSize:parameters.chunkSize,ttl:parameters.ttl});const listUiValueWrapper=cacheAccessor.get(parameters.listUiCacheKey);// if we already have a value & it's not expired then we're done
    if(!cacheUtils.expired(listUiValueWrapper,parameters.ttl)){return Thenable.resolve(1/* CACHE_HIT */);}// cache value was missing or too old, see which pieces we do have
    let valueWrappers;let cacheKeys;// see if we have the list-info
    const listInfoCacheKey=new ListInfoCacheKeyBuilder().setListUiCacheKey(parameters.listUiCacheKey).build();const listInfoValueWrapper=cacheAccessor.get(listInfoCacheKey);let resultThenable;if(cacheUtils.expired(listInfoValueWrapper)){resultThenable=cacheUtils.fetchAndStagePutListUi(parameters.recordService,parameters.listUiCacheKey);}else {const[listRecordsValueWrappers,listRecordsCacheKeys,offset]=cacheUtils.collectCachedRecords(parameters.listUiCacheKey);// toss out all the list-records at or past the first expired one
    const firstExpired=listRecordsValueWrappers.findIndex(valueWrapper=>cacheUtils.expired(valueWrapper));if(firstExpired>=0){listRecordsValueWrappers.splice(firstExpired);listRecordsCacheKeys.splice(firstExpired);}// If any of the list-records don't match the list-info then just reload everything.
    // In theory it might be possible to save/reuse some of the list-records, but this
    // should be rare & the logic would be complex.
    if(listRecordsValueWrappers.find(valueWrapper=>{return valueWrapper.value.listInfoETag!==listInfoValueWrapper.value.eTag;})){resultThenable=cacheUtils.fetchAndStagePutListUi(parameters.recordService,parameters.listUiCacheKey);}else {const listUiCacheKeyBuilder=new ListUiCacheKeyBuilder().setListUiCacheKey(parameters.listUiCacheKey);// see how many records we found
    let recordsFound=listRecordsValueWrappers.reduce((sum,valueWrapper)=>sum+valueWrapper.value.records.length,0);if(listRecordsValueWrappers.length>0){recordsFound-=offset;}// if we found enough records or hit the end of the data then we're done
    if(recordsFound>=listUiCacheKeyBuilder.pageSize||listRecordsValueWrappers.length>0&&!listRecordsValueWrappers[listRecordsValueWrappers.length-1].value.nextPageToken){// type inference doesn't do what we want here - need to be explicit
    resultThenable=Thenable.resolve([listInfoValueWrapper,listRecordsValueWrappers,listRecordsCacheKeys,offset]);}else {// fetch the missing records
    let pageTokenToFetch;if(listRecordsValueWrappers.length>0){// we want to fetch the nextPageToken from the last chunk of records we got
    pageTokenToFetch=listRecordsValueWrappers[listRecordsValueWrappers.length-1].value.nextPageToken;}else {// if no records were found, use the caller-supplied pageToken
    pageTokenToFetch=listUiCacheKeyBuilder.pageToken;}// TODO - pageTokenToFetch is of type string|null|undefined whereas setPageToken() requires string|undefined
    const listRecordsCacheKey=new ListRecordsCacheKeyBuilder().setListUiCacheKey(parameters.listUiCacheKey).setPageToken(pageTokenToFetch).build();// fetch the remainder of the records from the server
    resultThenable=cacheUtils.fetchAndStagePutListRecords(parameters.recordService,listRecordsCacheKey,listUiCacheKeyBuilder.pageSize-recordsFound).then(([fetchedListRecordsValueWrappers,fetchedListRecordsCacheKeys,fetchedOffset])=>{{// TODO - seems like there might be cases where this could be non-0 if we used the caller's pageToken above?
    assert$2(fetchedOffset===0,"unexpected offset returned from fetching records");}// If any of the list-records don't match the list-info then just reload everything.
    // In theory it might be possible to save/reuse some of the list-records, but this
    // should be rare & the logic would be complex.
    if(fetchedListRecordsValueWrappers.find(valueWrapper=>{return valueWrapper.value.listInfoETag!==listInfoValueWrapper.value.eTag;})){return cacheUtils.fetchAndStagePutListUi(parameters.recordService,parameters.listUiCacheKey);}// type inference doesn't do what we want here - need to be explicit
    return [listInfoValueWrapper,[...listRecordsValueWrappers,...fetchedListRecordsValueWrappers],[...listRecordsCacheKeys,...fetchedListRecordsCacheKeys],offset];});}}}return resultThenable.then(([listInfoValueWrapper2,listRecordsValueWrappers,listRecordsCacheKeys,offset])=>{// save the ValueWrappers and CacheKeys for the next step
    valueWrappers=[listInfoValueWrapper2,...listRecordsValueWrappers];cacheKeys=[listInfoCacheKey,...listRecordsCacheKeys];// assemble the pieces back into a list-ui
    const listUi=cacheUtils.constructListUi(parameters.recordService,listInfoValueWrapper2,listRecordsValueWrappers,offset,parameters.listUiCacheKey);cacheUtils.stagePutListArtifact(parameters.listUiCacheKey,listUi,valueWrappers,cacheKeys);const affectedKeys=cacheAccessor.commitPuts();parameters.ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}/**
     * Indicates if two list-ui ValueProviders are equivalent.
     *
     * @param otherValueProvider ValueProvider
     * @return true if the two ValueProviders are equivalent; false if not
     */function equals(otherValueProvider){// ValueProviders are equivalent if they have the same parameters
    const p1=this.parameters;const p2=otherValueProvider.parameters;// check if same number of keys & all keys equal
    return Object.keys(p1).length===Object.keys(p2).length&&Object.keys(p1).every(key=>p1[key]===p2[key]);}/**
     * Provider function for list-uis collections.
     *
     * @param cacheAccessor accessor to get to the LDS cache
     * @param parameters parameters indicating what value is to be returned;
     * @returns provide result
     */function provide$1(cacheAccessor,parameters){const cacheUtils=new ListUiCacheUtils(cacheAccessor,{chunkSize:parameters.chunkSize,ttl:parameters.ttl});const listCollectionValueWrapper=cacheAccessor.get(parameters.listCollectionCacheKey);// if we already have a value & it's not expired then we're done
    if(!cacheUtils.expired(listCollectionValueWrapper,parameters.ttl)){return Thenable.resolve(1/* CACHE_HIT */);}// cache value was missing or too old, see which pieces we do have
    let valueWrappers;let cacheKeys;let resultThenable;const[listCollectionValueWrappers,listCollectionCacheKeys,offset]=cacheUtils.collectCachedLists(parameters.listCollectionCacheKey);// toss out all the list-collections at or past the first expired one
    const firstExpired=listCollectionValueWrappers.findIndex(valueWrapper=>cacheUtils.expired(valueWrapper));if(firstExpired>=0){listCollectionValueWrappers.splice(firstExpired);listCollectionCacheKeys.splice(firstExpired);}// from here on out, all ValueWrappers exist and have values or, stated more cleverly:
    // assert(listCollectionValueWrappers.every(vw => vw && vw.value))
    const listCollectionCacheKeyBuilder=new ListCollectionCacheKeyBuilder().setListCollectionCacheKey(parameters.listCollectionCacheKey,true);// see how many lists we found
    let listsFound=listCollectionValueWrappers.reduce((sum,valueWrapper)=>sum+valueWrapper.value.count,0);if(listCollectionValueWrappers.length>0){listsFound-=offset;}// if we found enough lists or hit the end of the data then we're done
    if(listCollectionCacheKeyBuilder.pageSize&&listsFound>=listCollectionCacheKeyBuilder.pageSize||listCollectionValueWrappers.length>0&&!listCollectionValueWrappers[listCollectionValueWrappers.length-1].value.nextPageToken){// type inference here doesn't match the type inference for the next then() therefore I need to be explicit
    resultThenable=Thenable.resolve([listCollectionValueWrappers,listCollectionCacheKeys,offset]);}else {// fetch the missing lists
    let pageTokenToFetch;if(listCollectionValueWrappers.length>0){// we want to fetch the nextPageToken from the last chunk of list views we got
    pageTokenToFetch=listCollectionValueWrappers[listCollectionValueWrappers.length-1].value.nextPageToken;}else {// if no list views were found, use the caller-supplied pageToken
    pageTokenToFetch=listCollectionCacheKeyBuilder.pageToken;}// TODO - pageTokenToFetch is of type string|null|undefined whereas setPageToken() requires string|undefined
    const listCollectionCacheKey=new ListCollectionCacheKeyBuilder().setListCollectionCacheKey(parameters.listCollectionCacheKey).setPageToken(pageTokenToFetch).build();const pageSize=listCollectionCacheKeyBuilder.pageSize?listCollectionCacheKeyBuilder.pageSize-listsFound:DEFAULT_LIST_COLLECTION_PAGE_SIZE;// fetch the remainder of the lists from the server
    resultThenable=cacheUtils.fetchAndStagePutListCollection(listCollectionCacheKey,pageSize).then(([fetchedListCollectionValueWrappers,fetchedListCollectionCacheKeys,_fetchedOffset])=>{// type inference here doesn't match the type inference for the next then() therefore I need to be explicit
    const result=[[...listCollectionValueWrappers,...fetchedListCollectionValueWrappers],[...listCollectionCacheKeys,...fetchedListCollectionCacheKeys],offset];return result;});}return resultThenable.then(([listCollectionValueWrappers2,listCollectionCacheKeys2,offset2])=>{// save the ValueWrappers and CacheKeys for the next step
    valueWrappers=listCollectionValueWrappers2;cacheKeys=listCollectionCacheKeys2;// assemble the pieces back into a list-ui
    const listCollection=cacheUtils.constructListCollection(listCollectionValueWrappers2,offset2,parameters.listCollectionCacheKey);cacheUtils.stagePutListArtifact(parameters.listCollectionCacheKey,listCollection,valueWrappers,cacheKeys);const affectedKeys=cacheAccessor.commitPuts();parameters.ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}/**
     * Indicates if two list-ui ValueProviders are equivalent.
     *
     * @param otherValueProvider
     * @return true if the two ValueProviders are equivalent; false if not
     */function equals$1(otherValueProvider){// ValueProviders are equivalent if they have the same parameters
    const p1=this.parameters;const p2=otherValueProvider.parameters;// check if same number of keys & all keys equal
    return Object.keys(p1).length===Object.keys(p2).length&&Object.keys(p1).every(key=>p1[key]===p2[key]);}/*
     * Provides functionality to read list ui data from the cache. Can refresh the data from the server.
     */class ListUiService extends LdsServiceBase{/*
         * Constructor.
         *
         * @param ldsCache the LdsCache instance that backs this service
         */constructor(ldsCache){super(ldsCache,[LIST_UI_VALUE_TYPE,LIST_RECORDS_VALUE_TYPE,LIST_VIEWS_VALUE_TYPE,LIST_INFO_VALUE_TYPE]);/**
             *
             */this.listRecordsChunkSize=DEFAULT_LIST_RECORDS_CHUNK_SIZE;/**
             *
             */this.listCollectionChunkSize=DEFAULT_LIST_COLLECTION_CHUNK_SIZE;/**
             * TTL for cached list-ui data
             */this.listUiTTL=LIST_UI_TTL;}getCacheValueTtl(){return LIST_UI_TTL;}/**
         * Returns an observable for a list-ui constructed from the given inputs.
         *
         * @param objectApiName The API name of the List View's entity (must be specified along with listViewApiName)
         * @param listViewApiName List View API name (must be specified with objectApiName)
         * @param listViewId Id of the List View (may be specified without objectApiName or listViewApiName)
         * @param pageToken Page id of records to retrieve
         * @param pageSize Number of records to retrieve at once
         * @param sortBy A qualified field API name on which to sort
         * @param fields An array of qualified field API names of fields to include.
         * @param optionalFields An array of qualified field API names of optional fields to include.
         * @param q Query string to filter list views (only for list of lists)
         * @returns {Observable} See description.
         */getListUi(params){let cacheKey;let valueProvider;let fieldsAsStrings;let optionalFieldsAsStrings;let pageSize=params.pageSize;// convert importable schema to string
    const objectApiName=params.objectApiName&&getObjectApiName(params.objectApiName);const sortBy=params.sortBy&&getFieldApiName(params.sortBy);const listViewId=params.listViewId&&getObjectApiName(params.listViewId);if(params.fields){fieldsAsStrings=Array.isArray(params.fields)?params.fields.map(field=>getFieldApiName(field)):[];}if(params.optionalFields){optionalFieldsAsStrings=Array.isArray(params.optionalFields)?params.optionalFields.map(field=>getFieldApiName(field)):[];}// If we have a list id or an api and dev name then its a request for list-ui
    if(listViewId||objectApiName&&params.listViewApiName){if(pageSize==null){pageSize=DEFAULT_LIST_RECORDS_PAGE_SIZE;}cacheKey=new ListUiCacheKeyBuilder().setListReference(objectApiName,params.listViewApiName,listViewId).setPageToken(params.pageToken).setPageSize(pageSize).setSortBy(sortBy).setFields(fieldsAsStrings).setOptionalFields(optionalFieldsAsStrings).build();valueProvider=new ValueProvider(provide,{ldsCache:this._ldsCache,recordService:this._recordService,listUiCacheKey:cacheKey,ttl:LIST_UI_TTL,chunkSize:this.listRecordsChunkSize},equals);}else if(objectApiName){if(pageSize==null){pageSize=DEFAULT_LIST_COLLECTION_PAGE_SIZE;}cacheKey=new ListCollectionCacheKeyBuilder().setObjectApiName(objectApiName).setPageToken(params.pageToken).setPageSize(pageSize).setQ(params.q).build();valueProvider=new ValueProvider(provide$1,{ldsCache:this._ldsCache,listCollectionCacheKey:cacheKey,ttl:LIST_COLLECTION_TTL,chunkSize:this.listCollectionChunkSize},equals$1);}if(cacheKey&&valueProvider&&pageSize>0){return this._ldsCache.get(cacheKey,valueProvider);}return undefined;}/* Exposed function to consumers.
         * Allows to save a new sort order
         */async saveSort(objectApiName,listViewApiName,listViewId/* , newSortBy*/){// TODO: Doesn't save for now, only invalidates the right caches
    // TODO: We need to invalidate all caches that are without sortBy (in all variations)
    // newSortBy = newSortBy ? newSortBy : [];
    // newSortBy = Array.isArray(newSortBy) ? newSortBy : [newSortBy];
    const cacheKey=new ListUiCacheKeyBuilder().setListReference(getObjectApiName(objectApiName),listViewApiName,listViewId)// .setFields(fields)
    // .setOptionalFields(optionalFields)
    .build();return this._ldsCache.access().then(()=>{this._ldsCache.evict(cacheKey);});}/* Exposed function to consumers.
         * Allows to save column widths
         */async saveColumnWidths(objectApiName,listViewApiName,listViewId/* , columnWidthMapping*/){// TODO: Doesn't save for now, only invalidates the right caches
    // TODO: We need to invalidate all caches of that list id (in all variations)
    const cacheKey=new ListUiCacheKeyBuilder().setListReference(getObjectApiName(objectApiName),listViewApiName,listViewId)// .setFields(fields)
    // .setOptionalFields(optionalFields)
    .build();return this._ldsCache.access().then(()=>{this._ldsCache.evict(cacheKey);});}/**
         * TODO: When this service class gets refactored into multiple services and updated to typescript, this method needs to be implimented!
         * @param dependencies List of dependent cache keys.
         * @param value The value to cache.
         * @param cacheAccessor An object to access cache directly.
         * @returns A thenable which resolves when the stage put is completed.
         */stagePutValue(_dependencies,_value,_cacheAccessor){// TODO: Implement this!
    throw getLdsInternalError("UNSUPPORTED_OPERATION","Lists service does not implement stagePutValue",true);}/**
         * TODO: When this service class gets refactored into multiple services and updated to typescript, this method needs to be implimented!
         * Strips all eTag properties from the given value by directly deleting them.
         * @returns The given value with its eTags stripped.
         * @param value The value from which to strip the eTags.
         */stripETagsFromValue(value){return value;}/**
         * Affected Key handler. Whenever the list ui cache key is affected we need to denormalize what we have
         * in the cache and re-emit this to the consumer.
         *
         * For example: Since we chain together list-ui -> list-records -> records markers,
         * whenever a record changes from record home we will be notified of that change
         * and we need to denormalize our list-ui which will fetch the latest cached record
         * data using the saved record markers.
         * @returns The affected key handler for this service.
         */getAffectedKeyHandler(){return (affectedKey,cacheAccessor)=>{// TODO: Once this service is split into multiple services, the following check for the secondary types can be removed.
    // We don't want to handle affected keys for these secondary types.
    if(affectedKey.type===LIST_VIEWS_VALUE_TYPE||affectedKey.type===LIST_RECORDS_VALUE_TYPE||affectedKey.type===LIST_INFO_VALUE_TYPE){return;}const listUiValueWrapper=cacheAccessor.get(affectedKey);if(!listUiValueWrapper){return;}const cacheUtils=new ListUiCacheUtils(cacheAccessor,{chunkSize:this.listRecordsChunkSize,ttl:this.listUiTTL});// list-ui missing, ignore key
    if(cacheUtils.expired(listUiValueWrapper,0)){return;}const listUi=this.denormalizeValue(listUiValueWrapper.value,cacheAccessor);const listUiValueWrapperToEmit=cloneWithValueOverride(listUiValueWrapper,listUi);cacheAccessor.stageEmit(affectedKey,listUiValueWrapperToEmit);};}/**
         * Denormalizes the given normalizedListUi artifact and returns the result.
         * @param normalizedListUi The normalizedListUi to denormalize.
         * @param cacheAccessor Used to access the cache.
         * @returns The denormalized list ui.
         */denormalizeValue(normalizedListUi,cacheAccessor){const listUiCacheKey=normalizedListUi.cacheKey;const cacheUtils=new ListUiCacheUtils(cacheAccessor,{chunkSize:this.listRecordsChunkSize,ttl:this.listUiTTL});const listInfoCacheKey=new ListInfoCacheKeyBuilder().setListUiCacheKey(listUiCacheKey).build();const listInfoValueWrapper=cacheAccessor.get(listInfoCacheKey);if(!listInfoValueWrapper){throw getLdsInternalError("DENORMALIZE_FAILED","Could not find a listInfo for the corresponding key: "+listInfoCacheKey,true);}const[listRecordsValueWrappers/* listRecordsCacheKeys */,,offset]=cacheUtils.collectCachedRecords(listUiCacheKey);// toss out all the list-records at or past the first missing one (we can still use
    // expired values for this scenario)
    const firstMissing=listRecordsValueWrappers.findIndex(valueWrapper=>cacheUtils.expired(valueWrapper,0));if(firstMissing>=0){listRecordsValueWrappers.splice(firstMissing);}// from here on out, all ValueWrappers exist and have values or, stated more cleverly:
    // if ("development" !== 'production') {
    //     assert(listRecordsValueWrappers.every(lrvw => lrvw && lrvw.value))
    // }
    const listUiCacheKeyBuilder=new ListUiCacheKeyBuilder().setListUiCacheKey(listUiCacheKey);// we must either have all the records or have hit the end of the list to continue
    const recordsFound=listRecordsValueWrappers.reduce((sum,valueWrapper)=>sum+valueWrapper.value.records.length,0)-offset;if(recordsFound<listUiCacheKeyBuilder.pageSize&&listRecordsValueWrappers.length>0&&listRecordsValueWrappers[listRecordsValueWrappers.length-1].value.nextPageToken);// make sure we're not mixing data from different versions of the
    const mismatchedEtags=listRecordsValueWrappers.find(valueWrapper=>{const recordEtag=valueWrapper.value.listInfoETag;const metadataEtag=listInfoValueWrapper.value.eTag;return recordEtag!==metadataEtag;});if(mismatchedEtags){// TODO - fork this off for background processing - we need to refetch the data
    throw getLdsInternalError("DENORMALIZED_FAILED","Found mismatched etags for list",true);}// assemble the pieces back into a list-ui
    const listUi=cacheUtils.constructListUi(this._recordService,listInfoValueWrapper,listRecordsValueWrappers,offset,listUiCacheKey);return listUi;}/**
         * Reference to the RecordService instance.
         */get _recordService(){return this._ldsCache.getService(RECORD_VALUE_TYPE);}}/*
     * Generates the wire adapter for List Ui
     */class ListUiWireAdapterGenerator{/*
         * Constructor.
         * @param listUiService Reference to the ListUiService instance.
         */constructor(listUiService){this._listUiService=listUiService;}/*
         * Generates the wire adapter for getObjectInfo.
         * @returns WireAdapter - See description.
         */generateGetListUiWireAdapter(){const wireAdapter=generateWireAdapter(this._serviceGetListUi.bind(this));return wireAdapter;}/*
         * Service getListUi @wire.
         * @private
         * @param config: Config params for the service.
         * @return Observable stream that emits a list ui.
         */_serviceGetListUi(config){if(!config.listViewId&&!config.objectApiName){return undefined;}return this._listUiService.getListUi(config);}}/*
     * Wire adapter id: getListUi.
     * @throws Error - Always throws when invoked. Imperative invocation is not supported.
     * @returns void
     */function getListUi(){throw generateError("getListUi");}const RELATED_LIST_TEMPLATE_VALUE_TYPE="lds.RelatedListTemplate";const RELATED_LIST_TEMPLATE_TTL=60*1000;/**
     * The valueType to use when building RecordAvatarsCacheKey.
     */const RECORD_AVATAR_BULK_VALUE_TYPE="uiapi.RecordAvatarBulk";/**
     * Time to live for the RecordAvatars cache value. 5 minutes.
     */const RECORD_AVATAR_BULK_TTL=5*60*1000;/**
     * Constructs a cache key for the RecordAvatars value type.
     * @param recordIds An array of recordIds.
     * @returns A new cache key representing the RecordAvatars value type.
     */function buildCacheKey$6(recordIds){{assert$2(recordIds.length,"A non-empty recordIds must be provided.");}return {type:RECORD_AVATAR_BULK_VALUE_TYPE,key:`${JSON.stringify(recordIds)}`};}/**
     * Transforms and returns the given RecordAvatarBulk into RecordAvatarRepresentations.
     * This is a shallow copy of RecordAvatarRepresentation entries contained in the provided RecordAvatarBulk
     * @param recordAvatarBulk The instance of RecordAvatarBulk to transform into a RecordAvatarRepresentations.
     * @returns RecordAvatarRepresentations transformed from the provided RecordAvatarBulk
     */function createRecordAvatarRepresentationsFromRecordAvatarBulk(recordAvatarBulk){const results=[];let hasErrors=false;const recordAvatarIds=Object.keys(recordAvatarBulk);for(let len=recordAvatarIds.length,n=0;n<len;n++){results.push(recordAvatarBulk[recordAvatarIds[n]]);if(recordAvatarBulk[recordAvatarIds[n]].statusCode!==200){hasErrors=true;}}return {hasErrors,results};}/**
     * Transforms the given RecordAvatarRepresentations into a RecordAvatarBulk using the provided recordAvatarIds
     * This is a shallow copy of RecordAvatarRepresentation entries contained in the provided RecordAvatarRepresentations
     * @param freshRecordAvatarsValue Instance of RecordAvatarRepresentations to index based on recordAvatarIds
     * @param recordAvatarIds Ids to index new RecordAvatarBulk with
     * @returns RecordAvatarBulk instance transformed from the args
     */function createRecordAvatarBulkFromRecordAvatarRepresentations(freshRecordAvatarsValue,recordAvatarIds){const recordAvatarBulk={};for(let len=freshRecordAvatarsValue.results.length,n=0;n<len;n++){const recordAvatarId=recordAvatarIds[n];const recordAvatarRepresentation=freshRecordAvatarsValue.results[n];recordAvatarBulk[recordAvatarId]=recordAvatarRepresentation;}return recordAvatarBulk;}/**
     * The valueType to use when building RecordAvatarCacheKey.
     */const RECORD_AVATAR_VALUE_TYPE="uiapi.RecordAvatarRepresentation";/**
     * Time to live for the RecordAvatar cache value. 5 minutes.
     */const RECORD_AVATAR_TTL=5*60*1000;/**
     * Constructs a cache key for the RecordAvatar value type.
     * @param recordId The recordId.
     * @returns CacheKey - A new cache key representing the RecordAvatar value type.
     */function buildCacheKey$7(recordId){{assert$2(recordId,"A non-empty recordId must be provided.");}return {type:RECORD_AVATAR_VALUE_TYPE,key:`${recordId}`};}/**
     * Provides functionality to read record avatar data from the cache. Can refresh the data from the server.
     * We do not utilize caching or sending eTags to the server for this value type because it gets invalidated
     * quickly on the client from having its atoms updated.
     */class RecordAvatarService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){super(ldsCache,[RECORD_AVATAR_VALUE_TYPE]);}getCacheValueTtl(){return RECORD_AVATAR_TTL;}/**
         * Stage puts the given recordAvatar.
         * @param dependencies An array of dependent cache keys.
         * @param recordAvatar The recordAvatar to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         * @returns A Thenable that resolves when the stagePut has completed.
         */stagePutValue(dependencies,recordAvatar,cacheAccessor,additionalData){const recordAvatarCacheKey=buildCacheKey$7(additionalData.recordAvatarId);const existingRecordAvatarValueWrapper=cacheAccessor.get(recordAvatarCacheKey);let eTag;if(recordAvatar.result.eTag){eTag=recordAvatar.result.eTag;}if(existingRecordAvatarValueWrapper&&existingRecordAvatarValueWrapper.eTag===eTag){cacheAccessor.stageDependencies(dependencies,recordAvatarCacheKey);cacheAccessor.stagePutUpdateLastFetchTime(recordAvatarCacheKey);return;}// Strip out the eTag from the value. We don't want to emit eTags!
    recordAvatar=this.stripETagsFromValue(recordAvatar);cacheAccessor.stagePut(dependencies,recordAvatarCacheKey,recordAvatar,recordAvatar,{eTag});}/**
         * Strips all eTag properties from the given recordAvatar by directly deleting them.
         * @param recordAvatar The recordAvatar from which to strip the eTags.
         * @returns The given recordAvatar with its eTags stripped.
         */stripETagsFromValue(recordAvatar){delete recordAvatar.result.eTag;return recordAvatar;}}/**
     * Provides functionality to read record avatar data from the cache. Can refresh the data from the server.
     * We do not utilize caching or sending eTags to the server for this value type because it gets invalidated
     * quickly on the client from having its atoms updated.
     */class RecordAvatarBulkService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){super(ldsCache,[RECORD_AVATAR_BULK_VALUE_TYPE]);}getCacheValueTtl(){return RECORD_AVATAR_BULK_TTL;}/**
         * Retrieves avatars specified for the specified record Ids.
         * @param recordIds The array of record ids.
         * @returns An observable for the avatar values specified by the given parameters.
         */getRecordAvatars(recordIds,metaConfig){// We sort so that same set of recordIds specified in any order results in the same avatar group key.
    let uniqueRecordIds=collectionToArray(new Set(recordIds)).sort();uniqueRecordIds=uniqueRecordIds.map(to18);const recordAvatarBulkCacheKey=buildCacheKey$6(uniqueRecordIds);const vpArgs={recordIds:uniqueRecordIds,cacheKey:recordAvatarBulkCacheKey,forceProvide:metaConfig&&metaConfig.forceProvide||false};const finishedCallbacks=metaConfig&&metaConfig.finishedCallbacks;return this._ldsCache.get(recordAvatarBulkCacheKey,this._createRecordAvatarBulkValueProvider(vpArgs),finishedCallbacks);}async updateRecordAvatar(updateAvatarParams){if(!updateAvatarParams){throw new Error("avatarAssociationInput must be provided");}if(!updateAvatarParams.recordId){throw new Error("recordId must be provided");}const input=this.constructAvatarAssociationInput(updateAvatarParams);const transportResponse=await executeAuraGlobalController("RecordUiController.postRecordAvatarAssociation",{recordId:updateAvatarParams.recordId,input});const updatedRecordAvatar=transportResponse.body;// Resolve the promise when the refresh has completed.
    const resultPromise=new Promise((resolve,reject)=>{const successCallback=()=>{resolve(this.stripETagsFromRecordAvatarValue(updatedRecordAvatar));};const finishedCallbacks={successCallback,errorCallback:reject};let uniqueRecordIds=[updateAvatarParams.recordId];uniqueRecordIds=uniqueRecordIds.map(to18);const metaConfig={forceProvide:true,finishedCallbacks};this.getRecordAvatars(uniqueRecordIds,metaConfig);});return resultPromise;}/**
         * Stage put the recordAvatars.
         * Usage Example: This is used by record-layouts module to store the avatars it fetches into the cache.
         * @param dependencies An array of dependent cache keys which depend on this stage put.
         * @param recordAvatars Object with a results array of objects representing avatars
         *      results[0].result = result_avatar_for_001xx12345
         *      results[1].result = result_avatar_for_005xx56789
         *      results[2].result = result_404
         * @param cacheAccessor Cache Accessor used in the scope of this operation.
         * @param additionalData bag of required data for stagePut. Expects the following:
         *      {
         *          recordIds: string[]
         *      }
         */stagePutValue(dependencies,recordAvatars,cacheAccessor,additionalData){if(recordAvatars&&recordAvatars.results&&recordAvatars.results.length){// Avenues exist that do not send this along. That's *okay*, we can deal with it by inspecting the inbound information.
    // The natural format of recordAvatarBulk is RecordAvatarRepresentations. As of 218 some paths do not return this from the server.
    // ones that DO return this format, in case of error, do not include the recordId of the RecordAvatarInvalidResult
    if(!additionalData||!additionalData.recordAvatarIds||!additionalData.recordAvatarIds.length){const recordIds=[];for(let idx=0,len=recordAvatars.results.length;idx<len;idx++){const anAvatar=recordAvatars.results[idx];if(anAvatar.statusCode===200){const validResult=anAvatar.result;recordIds.push(validResult.recordId);}else {// If the status code is !== 200, there was a problem, which means there's NO associated recordId with this data
    // we presently have no choice but to skip putting this entry unless RecordAvatarInvalidResult entries begin to include recordId data from the services
    recordAvatars.results.splice(idx,1);idx--;len--;}}additionalData={recordAvatarIds:recordIds};}if(additionalData.recordAvatarIds.length){const recordAvatarBulk=createRecordAvatarBulkFromRecordAvatarRepresentations(recordAvatars,additionalData.recordAvatarIds);const recordAvatarBulkCacheKey=buildCacheKey$6(additionalData.recordAvatarIds);this._normalizeAndStagePutRecordAvatarBulk(dependencies,recordAvatarBulk,cacheAccessor,recordAvatarBulkCacheKey);}}}/**
         * Strips all eTag properties from the given recordAvatarBulk by directly deleting them.
         * @param recordAvatarBulk The recordAvatarBulk from which to strip the eTags.
         * @returns The given recordAvatarBulk with its eTags stripped.
         */stripETagsFromValue(recordAvatarBulk){const recordIds=Object.keys(recordAvatarBulk);for(let len=recordIds.length,n=0;n<len;n++){const recordId=recordIds[n];const recordAvatar=recordAvatarBulk[recordId];recordAvatarBulk[recordId]=this._ldsCache.stripETagsFromValue(RECORD_AVATAR_VALUE_TYPE,recordAvatar);}return recordAvatarBulk;}/**
         * Strips all eTag properties from the given recordAvatarBulk by directly deleting them.
         * @param recordAvatarBulk The recordAvatarBulk from which to strip the eTags.
         * @returns The given recordAvatarBulk with its eTags stripped.
         */stripETagsFromRecordAvatarValue(recordAvatarRepresentation){delete recordAvatarRepresentation.eTag;return recordAvatarRepresentation;}/**
         * Denormalize the normalizedAvatars.
         * @param normalizedAvatars The normalized group avatar.
         * @param affectedKey The key that we are denormalizing.
         * @param cacheAccessor The cacheAccessor used in scope for this operation.
         * @returns The Thenable that will resolve to the denormalized avatars or undefined if a nested avatar cannot be found in the cache.
         */denormalizeValue(normalizedAvatars,cacheAccessor){const denormedAvatars={};const avatarRecordIds=Object.keys(normalizedAvatars);for(let len=avatarRecordIds.length,n=0;n<len;n++){const avatarRecordId=avatarRecordIds[n];const avatarMarker=normalizedAvatars[avatarRecordId];const avatarCacheKey=buildCacheKey$7(avatarMarker.id);const avatar=cacheAccessor.get(avatarCacheKey);if(!avatar){throw getLdsInternalError("DENORMALIZE_FAILED",`Did not find avatar for '${serialize(avatarCacheKey)}''}`,true);}const avatarValue=avatar.value;{assert$2(avatarValue,"avatar.value was falsy");}// Individual avatar values are frozen in cache, so clone will optimize and return same value here.
    denormedAvatars[avatarRecordId]=cloneDeepCopy(avatarValue);}return denormedAvatars;}/**
         * @returns The affected key handler for this service.
         */getAffectedKeyHandler(){return (avatarsAffectedKey,cacheAccessor)=>{{assert$2(avatarsAffectedKey.type===RECORD_AVATAR_BULK_VALUE_TYPE,`Unexpected value type: ${avatarsAffectedKey.type.toString()}`);}// Get avatars group normed value. This will have markers for each avatar.
    const avatarsValueWrapper=cacheAccessor.get(avatarsAffectedKey);if(avatarsValueWrapper){const avatarsValue=avatarsValueWrapper.value;{assert$2(avatarsValueWrapper,`avatarsWrapper is falsy`);assert$2(avatarsValue,`avatarsWrapperValue is falsy ${avatarsValue}`);}if(avatarsValueWrapper&&avatarsValue){// Denorm value (replace marker for each avatar with actual value) and stageemit.
    const denormedAvatars=this.denormalizeValue(avatarsValue,cacheAccessor);const recordAvatarsValueWrapperToEmit=cloneWithValueOverride(avatarsValueWrapper,denormedAvatars);cacheAccessor.stageEmit(avatarsAffectedKey,recordAvatarsValueWrapperToEmit);}}};}/**
         * Constructs a valueProvider to retrieve Avatars for a group of recordIds and cache them if there is a CACHE_MISS.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns Value Provider to retrieve Avatars.
         */_createRecordAvatarBulkValueProvider(valueProviderParameters){const{cacheKey,recordIds,forceProvide}=valueProviderParameters;const recordAvatarBulkValueProvider=new ValueProvider(cacheAccessor=>{if(forceProvide){// Here we refresh all individual avatars.
    const cachedRecordAvatarBulk={};return this._getFreshValue(cacheAccessor,cacheKey,recordIds,cachedRecordAvatarBulk);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){// We have the record avatar bulk value already in the cache.
    const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;// check for ttl expiry.
    const needsRefresh=nowTime>lastFetchTime+RECORD_AVATAR_BULK_TTL;if(needsRefresh){// TTL for avatars group value has expired. Refresh individual avatars within group whose TTL has expired.
    // Pass false for useCacheIndividualAvatarsWithoutCheckingTtl so that we only use individual avatars that have not expired.
    const recordAvatarIdsToFetchAndRecordAvatarBulkInCache=this._getRecordAvatarIdsToFetchFromServer(recordIds,cacheAccessor,false);return this._getFreshValue(cacheAccessor,cacheKey,recordAvatarIdsToFetchAndRecordAvatarBulkInCache.recordIdsToFetch,recordAvatarIdsToFetchAndRecordAvatarBulkInCache.cachedRecordAvatarBulk);}return Thenable.resolve(1/* CACHE_HIT */);}// We do not have this avatars value in cache. Determine which individual avatar values we already have.
    // Pass true for useCacheIndividualAvatarsWithoutCheckingTtl. In this case, we use individual avatar values from cache as long without checking ttl.
    const recordIdsToFetchAndRecordAvatarsInCache=this._getRecordAvatarIdsToFetchFromServer(recordIds,cacheAccessor,true);return this._getFreshValue(cacheAccessor,cacheKey,recordIdsToFetchAndRecordAvatarsInCache.recordIdsToFetch,recordIdsToFetchAndRecordAvatarsInCache.cachedRecordAvatarBulk);},valueProviderParameters);return recordAvatarBulkValueProvider;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param cacheKey The cache key for the recordAvatars.
         * @param recordIds The list of record ids for the recordAvatars.
         * @param recordIdsToFetch The list of record ids identifying which record avatars to fetch from the server.
         * @param cachedRecordAvatarBulk The list of record ids identifying which record avatars are already in cache and should be COMBINED with the response from the server.
         * @returns Returns a thenable representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,cacheKey,recordIdsToFetch,cachedRecordAvatarBulk){let transportResponseThenable;const params={recordIds:recordIdsToFetch};if(recordIdsToFetch.length>0){// If we need to fetch any from the server.
    {transportResponseThenable=aggregateUiExecutor.executeSingleRequestOverAggregateUi("getRecordAvatars",params,RECORD_AVATAR_BULK_TTL);}}else {// We did not need to fetch any from server. Set to empty.
    const results=[];transportResponseThenable=Thenable.resolve(getOkFetchResponse({results}));}return transportResponseThenable.then(transportResponse=>{// Cache miss.
    const freshRecordAvatarsValue=transportResponse.body;// Transform the response into the shape cached by LDS and normalize it.
    let recordAvatarBulk=createRecordAvatarBulkFromRecordAvatarRepresentations(freshRecordAvatarsValue,recordIdsToFetch);recordAvatarBulk=Object.assign(recordAvatarBulk,cachedRecordAvatarBulk);this._normalizeAndStagePutRecordAvatarBulk([],recordAvatarBulk,cacheAccessor,cacheKey);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}/**
         * Takes the denormalized avatars and normalizes it.
         * Then stagePuts the normalized group avatar and the individual avatars.
         * @param dependentCacheKeys An array of dependent cache keys.
         * @param recordAvatarBulk The denormalized avatars to be cached.
         * @param cacheAccessor Cache Accessor reference.
         * @param recordAvatarBulkCacheKey The cache key for the group avatar.
         */_normalizeAndStagePutRecordAvatarBulk(dependentCacheKeys,recordAvatarBulk,cacheAccessor,recordAvatarBulkCacheKey){const objectToClone=recordAvatarBulk;const normalizedRecordAvatarBulk=cloneDeepCopy(objectToClone);// Stage put the individual avatar entries.
    const recordAvatarIds=Object.keys(normalizedRecordAvatarBulk);for(let len=recordAvatarIds.length,n=0;n<len;n++){const recordAvatarRecordId=recordAvatarIds[n];const recordAvatar=recordAvatarBulk[recordAvatarRecordId];// Replace avatar value with marker. Include id and eTag in the marker.
    normalizedRecordAvatarBulk[recordAvatarRecordId]={id:recordAvatarRecordId,eTag:recordAvatar.result.eTag};const recordAvatarStagePutAdditionalData={recordAvatarId:recordAvatarRecordId};this._ldsCache.stagePutValue(RECORD_AVATAR_VALUE_TYPE,[{cacheKey:recordAvatarBulkCacheKey,type:1/* REQUIRED */}],recordAvatar,cacheAccessor,recordAvatarStagePutAdditionalData);}// Stage put the normalized bulk object.
    recordAvatarBulk=this.stripETagsFromValue(recordAvatarBulk);cacheAccessor.stagePut(dependentCacheKeys,recordAvatarBulkCacheKey,normalizedRecordAvatarBulk,recordAvatarBulk);}/**
         * From the parameter specifying a list of all recordIds that we need avatars for,
         * this function returns
         *  1) A list of recordIds that need their avatars fetched from the server.
         *  2) For values that already exist in the cache, it returns recordIdAvatarsInCache as below
         *       recordIdAvatarsInCache["001xx12345"] = avatar_for_001xx12345
         *       recordIdAvatarsInCache["005xx55667"] = avatar_for_005xx55667
         * Values in cache as checked for ttl based on th ignoreTtl flag.
         * @param recordIds An array of recordIds we need avatars for.
         * @param cacheAccessor Cache Accessor used in the scope of this operation.
         * @param useCacheIndividualAvatarsWithoutCheckingTtl True if we need to use values from cache ignoring their ttl.
         * @returns Thenable resolves to an object {recordIdsToFetch, recordIdAvatarsInCache} - See description.
         */_getRecordAvatarIdsToFetchFromServer(recordIds,cacheAccessor,useCacheIndividualAvatarsWithoutCheckingTtl){const recordIdsToFetch=[];const recordAvatarBulkFromCache={};for(let len=recordIds.length,n=0;n<len;n++){const recordId=recordIds[n];const avatarCacheKey=buildCacheKey$7(recordId);const recordAvatarValueWrapper=cacheAccessor.get(avatarCacheKey);let fetch=true;const avatarValue=recordAvatarValueWrapper!==undefined?recordAvatarValueWrapper.value:undefined;if(recordAvatarValueWrapper!=null&&avatarValue!=null){// We have a avatar value in cache.
    if(useCacheIndividualAvatarsWithoutCheckingTtl){// We do not care about ttl. Since value in cache is available, set fetch to false.
    fetch=false;}else {// We care about ttl expired.
    const nowTime=cacheAccessor.nowTime;const lastFetchTime=recordAvatarValueWrapper.lastFetchTime;// check for ttl expiry. If expiree, refresh individual avatars whose TTL has expired.
    const needsRefresh=nowTime>lastFetchTime+RECORD_AVATAR_BULK_TTL;if(!needsRefresh){fetch=false;// We have avatar and ttl has not expired.
    }}}if(fetch){recordIdsToFetch.push(recordId);}else {recordAvatarBulkFromCache[recordId]=avatarValue;}}// Need to clone the cached values because they are going to be renormalized.
    const recordIdsToFetchAndRecordAvatarsInCache={recordIdsToFetch,cachedRecordAvatarBulk:cloneDeepCopy(recordAvatarBulkFromCache)};return recordIdsToFetchAndRecordAvatarsInCache;}constructAvatarAssociationInput(untrustedConfig){const config={};const untrustedConfig_externalId=untrustedConfig.externalId;if(typeof untrustedConfig_externalId==="string"){config.externalId=untrustedConfig_externalId;}const untrustedConfig_blueMasterId=untrustedConfig.blueMasterId;if(typeof untrustedConfig_blueMasterId==="string"){config.blueMasterId=untrustedConfig_blueMasterId;}const untrustedConfig_profileName=untrustedConfig.profileName;if(typeof untrustedConfig_profileName==="string"){config.profileName=untrustedConfig_profileName;}const untrustedConfig_photoUrl=untrustedConfig.photoUrl;if(typeof untrustedConfig_photoUrl==="string"){config.photoUrl=untrustedConfig_photoUrl;}const untrustedConfig_actionType=untrustedConfig.actionType;if(typeof untrustedConfig_actionType==="string"){config.actionType=untrustedConfig_actionType;}return config;}}/**
     * Wire adapter id: getRecordAvatars.
     * @throws Always throws when invoked. Imperative invocation is not supported.
     */function getRecordAvatars(){throw generateError("getRecordAvatars");}/**
     * Generates the wire adapters for:
     *      * @wire getRecordAvatars
     */class RecordAvatarBulkWireAdapterGenerator{/**
         * Constructor.
         * @param recordAvatarBulkService Reference to the RecordAvatarBulkService instance.
         */constructor(recordAvatarBulkService){this._recordAvatarBulkService=recordAvatarBulkService;}/**
         * Generates the wire adapter for @wire getRecordAvatars.
         * @returns See description.
         */generateGetRecordAvatarsWireAdapter(){const wireAdapter=generateWireAdapter(this.serviceGetRecordAvatars.bind(this));return wireAdapter;}/**
         * @private Made public for testing.
         * Service getRecordAvatars @wire.
         * @param config Config params for the service.
         * @return Observable stream that emits a record avatars object.
         */serviceGetRecordAvatars(config,metaConfig){if(!config||!config.recordIds){return undefined;}return this._recordAvatarBulkService.getRecordAvatars(config.recordIds,metaConfig);}}function hasModule(module){return aura.hasModule(module);}function getModule(descriptor){return aura.getModule(descriptor);}/**
     * The valueType to use when building PicklistCacheKey.
     */const PICKLIST_VALUES_VALUE_TYPE="uiapi.PicklistValuesRepresentation";/**
     * Time to live for the Picklist cache value. 5 minutes.
     */const PICKLIST_VALUES_TTL=5*60*1000;/**
     * Builds the cache key for the single picklist field api
     * @param objectApiName The objectApiName used to build the picklist cache key.
     * @param recordTypeId The recordTypeId used to build the picklist cache key.
     * @param fieldApiName The fieldApiName used to build the picklist cache key.
     * @returns A new cache key representing the Picklist value type.
     */function buildCacheKey$8(objectApiName,recordTypeId,fieldApiName){{assert$2(objectApiName,"A non-empty objectApiName must be provided.");assert$2(recordTypeId,"A non-empty recordTypeId must be provided.");assert$2(fieldApiName,"A non-empty fieldApiName must be provided.");assert$2(recordTypeId.length===18,"Record Type Id length should be 18 characters.");}return {type:PICKLIST_VALUES_VALUE_TYPE,key:`${objectApiName.toLowerCase()}${KEY_DELIM}${recordTypeId}${KEY_DELIM}${fieldApiName}`};}/**
     * Provides functionality to read picklist data from the cache. Can refresh the data from the server.
     * We do not utilize caching or sending eTags to the server for the PicklistsByRecordType value type because it gets invalidated
     * quickly on the client from having its atoms updated.
     */class PicklistValuesService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){super(ldsCache,[PICKLIST_VALUES_VALUE_TYPE]);}getCacheValueTtl(){return PICKLIST_VALUES_TTL;}/**
         * Gets picklist values for a picklist field.
         * @param fieldApiName The picklist field's qualified API name.
         * @param recordTypeId The record type id. Pass '012000000000000AAA' for the master record type.
         * @returns An observable for the picklist values.
         */getPicklistValues(fieldApiName,recordTypeId){fieldApiName=getFieldApiName(fieldApiName);const[objectApiName,unqualifiedFieldApiName]=splitQualifiedFieldApiName(fieldApiName);recordTypeId=to18(recordTypeId);const cacheKey=buildCacheKey$8(objectApiName,recordTypeId,unqualifiedFieldApiName);const vpArgs={cacheKey,objectApiName,recordTypeId,fieldApiName:unqualifiedFieldApiName,forceProvide:false};return this._ldsCache.get(cacheKey,this._createPicklistValueProvider(vpArgs));}/**
         * Stage puts the given picklist values object.
         * @param dependencies An array of dependent cache keys.
         * @param picklistValues The picklist to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         * @returns A Thenable that resolves when the stagePut has completed.
         */stagePutValue(dependencies,picklistValues,cacheAccessor,additionalData){const picklistCacheKey=buildCacheKey$8(additionalData.objectApiName,additionalData.recordTypeId,additionalData.fieldApiName);const eTag=picklistValues.eTag;const existingValueWrapper=cacheAccessor.get(picklistCacheKey);if(existingValueWrapper&&existingValueWrapper.eTag===eTag){cacheAccessor.stageDependencies(dependencies,picklistCacheKey);cacheAccessor.stagePutUpdateLastFetchTime(picklistCacheKey);return;}// Strip out the eTag from the value. We don't want to emit eTags!
    picklistValues=this.stripETagsFromValue(picklistValues);cacheAccessor.stagePut(dependencies,picklistCacheKey,picklistValues,picklistValues,{eTag});}/**
         * Strips all eTag properties from the given picklist by directly deleting them.
         * @param picklistValues The picklist from which to strip the eTags.
         * @returns The given picklist with its eTags stripped.
         */stripETagsFromValue(picklistValues){delete picklistValues.eTag;return picklistValues;}/**
         * Constructs a value provider to retrieve picklist values.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns The value provider to retrieve picklist values.
         */_createPicklistValueProvider(valueProviderParameters){const{// Do NOT set defaults here. See W-4840393.
    cacheKey,objectApiName,recordTypeId,fieldApiName,forceProvide}=valueProviderParameters;const picklistValueProvider=new ValueProvider(cacheAccessor=>{if(forceProvide){return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,recordTypeId,fieldApiName);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;// check for ttl expiry
    const needsRefresh=nowTime>lastFetchTime+PICKLIST_VALUES_TTL;if(needsRefresh){// Value is stale; get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,recordTypeId,fieldApiName,existingValueWrapper.eTag);}// The value is not stale so it's a cache hit.
    return Thenable.resolve(1/* CACHE_HIT */);}// No existing value; get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,recordTypeId,fieldApiName);},valueProviderParameters);return picklistValueProvider;}hasValidCachedValue(cacheAccessor,params){const cacheKey=buildCacheKey$8(params.objectApiName,params.recordTypeId,params.fieldApiName);const existingValueWrapper=cacheAccessor.get(cacheKey);return !!existingValueWrapper&&existingValueWrapper.value!==undefined&&cacheAccessor.nowTime<=existingValueWrapper.lastFetchTime+PICKLIST_VALUES_TTL;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param cacheKey The cache key for the picklistValues.
         * @param objectApiName The objectApiName of the picklistValues.
         * @param recordTypeId The recordTypeId of the picklistValues.
         * @param fieldApiName The fieldApiName of the picklistValues.
         * @param eTagToCheck eTag to send to the server to determine if we already have the latest value. If we do the server will return a 304.
         * @returns Returns a ValueProviderResult representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,cacheKey,objectApiName,recordTypeId,fieldApiName,eTagToCheck){let picklistValuesThenable;const params={objectApiName,recordTypeId,fieldApiName};if(eTagToCheck){params.clientOptions={eTagToCheck};}{picklistValuesThenable=aggregateUiExecutor.executeSingleRequestOverAggregateUi("getPicklistValues",params,PICKLIST_VALUES_TTL);}return picklistValuesThenable.then(transportResponse=>{// Cache miss refresh unchanged.
    if(transportResponse.status===304){return 3/* CACHE_MISS_REFRESH_UNCHANGED */;}// Cache miss.
    const freshPicklist=transportResponse.body;// nothing to normalize
    {assert$2(freshPicklist.eTag!==undefined,`eTag was undefined for: ${cacheKey}`);}this.stagePutValue([],freshPicklist,cacheAccessor,{objectApiName,recordTypeId,fieldApiName});const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}}/**
     * Wire adapter id: getPicklistValues.
     * @throws Always throws an error when invoked. Imperative invocation is not supported.
     */function getPicklistValues(){throw generateError("getPicklistValues");}/**
     * Generates the wire adapters for:
     * @wire getPicklistValues
     * @wire getPicklistValuesByRecordType
     */class PicklistValuesWireAdapterGenerator{/**
         * Constructor.
         * @param picklistValuesService Reference to the PicklistValuesService instance.
         */constructor(picklistValuesService){this._picklistValuesService=picklistValuesService;}/**
         * Generates the wire adapter for getPicklistValues.
         * @returns Returns the generated wire adapter for getPicklistValues
         */generateGetPicklistValuesWireAdapter(){const wireAdapter=generateWireAdapter(this.serviceGetPicklistValues.bind(this));return wireAdapter;}/**
         * @private Made public for testing.
         * Services getPicklistValues @wire.
         * @param config Config params for the service.
         * @return Observable stream that emits a picklist values object.
         */serviceGetPicklistValues(config){if(!config){return undefined;}{const required=["fieldApiName","recordTypeId"];const supported=["fieldApiName","recordTypeId"];validateConfig$1("getPicklistValues",config,required,supported);}if(!config.recordTypeId||!config.fieldApiName){return undefined;}return this._picklistValuesService.getPicklistValues(config.fieldApiName,config.recordTypeId);}}/**
     * The valueType to use when building PicklistRecordTypeCacheKey.
     */const PICKLIST_VALUES_BY_RT_VALUE_TYPE="uiapi.PicklistValuesCollectionRepresentation";/**
     * Time to live for the Picklist cache value. 5 minutes.
     */const PICKLIST_VALUES_BY_RECORD_TYPE_TTL=5*60*1000;/**
     * Returns a PickListValuesByRecordTypeCacheKeyParams based on a cacheKey. Throws an error if it can't be done because a bad string is provided.
     * @param cacheKey PicklistValuesByRecordType cache key.
     * @returns See description
     */function getPicklistValuesByRecordTypeCacheKeyParams(cacheKey){const key=cacheKey.key;const localKeyParts=key.split(KEY_DELIM);{assert$2(localKeyParts.length===2,`localKeyParts did not have the required parts(objectApiName and recordTypeId): ${localKeyParts}`);assert$2(cacheKey.type===PICKLIST_VALUES_BY_RT_VALUE_TYPE,`valueType was expected to be PICKLIST_VALUES_BY_RT_VALUE_TYPE but was not: ${cacheKey.type.toString()}`);}return {objectApiName:localKeyParts[0],recordTypeId:localKeyParts[1]};}/**
     * Builds the cache key for the picklist record type api.
     * @param objectApiName The objectApiName used to build the picklist cache key.
     * @param recordTypeId The recordTypeId used to build the picklist cache key.
     * @returns A new cache key representing the Picklist record type value type.
     */function buildCacheKey$9(objectApiName,recordTypeId){{assert$2(objectApiName,"A non-empty objectApiName must be provided.");assert$2(recordTypeId,"A non-empty recordTypeId must be provided.");assert$2(recordTypeId.length===18,"Record Type Id length should be 18 characters.");}return {type:PICKLIST_VALUES_BY_RT_VALUE_TYPE,key:`${objectApiName.toLowerCase()}${KEY_DELIM}${recordTypeId}`};}/**
     * Provides functionality to read picklist data from the cache. Can refresh the data from the server.
     * We do not utilize caching or sending eTags to the server for the PicklistsByRecordType value type because it gets invalidated
     * quickly on the client from having its atoms updated.
     */class PicklistValuesByRecordTypeService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){super(ldsCache,[PICKLIST_VALUES_BY_RT_VALUE_TYPE]);}getCacheValueTtl(){return PICKLIST_VALUES_BY_RECORD_TYPE_TTL;}/**
         * Gets picklist values for all picklist fields of an object and record type.
         * @param objectApiName API name of the object.
         * @param recordTypeId Record type id. Pass '012000000000000AAA' for the master record type.
         * @returns An observable of the picklist values.
         */getPicklistValuesByRecordType(objectApiName,recordTypeId){objectApiName=getObjectApiName(objectApiName);recordTypeId=to18(recordTypeId);const cacheKey=buildCacheKey$9(objectApiName,recordTypeId);const vpArgs={cacheKey,objectApiName,recordTypeId,forceProvide:false};return this._ldsCache.get(cacheKey,this._createPicklistValuesByRecordTypeValueProvider(vpArgs));}/**
         * Stage puts the given picklistsByRecordType and all its normalized values.
         * @param dependencies An array of dependent cache keys.
         * @param picklistsByRecordType The picklistsByRecordType to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         */stagePutValue(dependencies,picklistsByRecordType,cacheAccessor,additionalData){const picklistsByRecordTypeCacheKey=buildCacheKey$9(additionalData.objectApiName,additionalData.recordTypeId);// This is an any so we can transform the cloned object into the normalized form.
    const normalizedPicklistsByRecordType=cloneDeepCopy(picklistsByRecordType);// Picklist normalization
    const picklistFieldValues=normalizedPicklistsByRecordType.picklistFieldValues;const picklistFieldValuesKeys=Object.keys(picklistFieldValues);for(let n=0,len=picklistFieldValuesKeys.length;n<len;++n){const picklistFieldName=picklistFieldValuesKeys[n];const picklist=picklistsByRecordType.picklistFieldValues[picklistFieldName];// add marker for the pick list value
    picklistFieldValues[picklistFieldName]={eTag:picklist.eTag,objectApiName:additionalData.objectApiName,recordTypeId:additionalData.recordTypeId};const picklistValuesStagePutAdditionalData={objectApiName:additionalData.objectApiName,recordTypeId:additionalData.recordTypeId,fieldApiName:picklistFieldName};this._ldsCache.stagePutValue(PICKLIST_VALUES_VALUE_TYPE,[{cacheKey:picklistsByRecordTypeCacheKey,type:1/* REQUIRED */}],picklist,cacheAccessor,picklistValuesStagePutAdditionalData);}// Stage put the picklistsByRecordType
    // Strip out the eTag from the value. We don't want to emit eTags!
    delete normalizedPicklistsByRecordType.eTag;picklistsByRecordType=this.stripETagsFromValue(picklistsByRecordType);// PicklistsByRecordType will not store an eTag because it is an aggregate value.
    cacheAccessor.stagePut(dependencies,picklistsByRecordTypeCacheKey,normalizedPicklistsByRecordType,picklistsByRecordType);}/**
         * Strips all eTag properties from the given picklistsByRecordType by directly deleting them.
         * @param picklistsByRecordType The picklists for a recordtype.
         * @returns The given picklistsByRecordType with its eTags stripped.
         */stripETagsFromValue(picklistsByRecordType){// Delete the eTag off the root object.
    delete picklistsByRecordType.eTag;// Delete the eTags for each picklist.
    const picklistFieldValues=picklistsByRecordType.picklistFieldValues;const picklistFieldValuesKeys=Object.keys(picklistFieldValues);for(let n=0,len=picklistFieldValuesKeys.length;n<len;++n){const picklistFieldValueKey=picklistFieldValuesKeys[n];const picklist=picklistFieldValues[picklistFieldValueKey];picklistFieldValues[picklistFieldValueKey]=this._ldsCache.stripETagsFromValue(PICKLIST_VALUES_VALUE_TYPE,picklist);}return picklistsByRecordType;}/**
         * Denormalizes the given noramlizedPicklistValuesByRecordType and returns it.
         * @param normalizedPicklistValuesByRecordType The normalized picklist values by record type to denormalize.
         * @param cacheAccessor Used to access the cache.
         * @returns The denormalized picklist values by record type.
         */denormalizeValue(normalizedPicklistValuesByRecordType,cacheAccessor){// Any used so we can morph types.
    const denormalizedPicklistValuesByRecordType=cloneDeepCopy(normalizedPicklistValuesByRecordType);// Picklist values denormalization.
    const picklistFieldValues=normalizedPicklistValuesByRecordType.picklistFieldValues;const picklistFieldValuesKeys=Object.keys(picklistFieldValues);for(let n=0,len=picklistFieldValuesKeys.length;n<len;++n){const picklistFieldValuesKey=picklistFieldValuesKeys[n];const picklistFieldValuesMarker=picklistFieldValues[picklistFieldValuesKey];const picklistValuesCacheKey=buildCacheKey$8(picklistFieldValuesMarker.objectApiName,picklistFieldValuesMarker.recordTypeId,picklistFieldValuesKey);const cachedPicklistValuesValueWrapper=cacheAccessor.get(picklistValuesCacheKey);if(cachedPicklistValuesValueWrapper){denormalizedPicklistValuesByRecordType.picklistFieldValues[picklistFieldValuesKey]=cachedPicklistValuesValueWrapper.value;}else {throw getLdsInternalError("DENORMALIZE_FAILED","Did not get a picklist values back for marker: "+serialize(picklistValuesCacheKey),true);}}return denormalizedPicklistValuesByRecordType;}/**
         * @returns The affected key handler for this service.
         */getAffectedKeyHandler(){return (affectedKey,_cacheAccessor)=>{const affectedKeyValueType=affectedKey.type;{assert$2(affectedKeyValueType===PICKLIST_VALUES_BY_RT_VALUE_TYPE,`Unexpected value type for Record: ${affectedKeyValueType===undefined?"undefined":affectedKeyValueType.toString()}`);}const keyBuilder=getPicklistValuesByRecordTypeCacheKeyParams(affectedKey);const objectApiName=keyBuilder.objectApiName;const recordTypeId=keyBuilder.recordTypeId;// When one of the picklists fields have changed, need to do a full refresh of the picklistsByRecordType. This
    // handler will only ever be invoked if a picklist field value has actually changed so we don't need to
    // check anything, just kick off a refresh.
    // Kick this to a Promise to get this out of the cache operation we're already in the middle of.
    Promise.resolve().then(()=>{const forceProvide=true;const vpArgs={cacheKey:affectedKey,objectApiName,recordTypeId,forceProvide};// Use the ValueProvider's provider instead of getPicklistValuesByRecordType() so we can force value providing.
    this._ldsCache.get(affectedKey,this._createPicklistValuesByRecordTypeValueProvider(vpArgs));});};}/**
         * Constructs a value provider to retrieve all picklist values for a record type.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns The value provider to retrieve picklist by record type values.
         */_createPicklistValuesByRecordTypeValueProvider(valueProviderParameters){const{// Do NOT set defaults here. See W-4840393.
    cacheKey,objectApiName,recordTypeId,forceProvide}=valueProviderParameters;const picklistsByRecordTypeValueProvider=new ValueProvider(cacheAccessor=>{if(forceProvide){return this._getFreshValue(cacheAccessor,objectApiName,recordTypeId);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;// check for ttl expiry
    const needsRefresh=nowTime>lastFetchTime+PICKLIST_VALUES_BY_RECORD_TYPE_TTL;if(needsRefresh){// Value is stale, get a fresh value.
    // return this._getFreshPicklistsByRecordTypeValue(cacheAccessor, cacheKey, objectApiName, recordTypeId, existingValueWrapper.eTag);
    return this._getFreshValue(cacheAccessor,objectApiName,recordTypeId);}// The value is not stale so it's a cache hit.
    return Thenable.resolve(1/* CACHE_HIT */);}// No existing value, get a fresh value.
    return this._getFreshValue(cacheAccessor,objectApiName,recordTypeId);},valueProviderParameters);return picklistsByRecordTypeValueProvider;}hasValidCachedValue(cacheAccessor,params){const cacheKey=buildCacheKey$9(params.objectApiName,params.recordTypeId);const existingValueWrapper=cacheAccessor.get(cacheKey);return !!existingValueWrapper&&existingValueWrapper.value!==undefined&&cacheAccessor.nowTime<=existingValueWrapper.lastFetchTime+PICKLIST_VALUES_BY_RECORD_TYPE_TTL;}/**
         * Gets a fresh value for picklists by record type and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param objectApiName The objectApiName of the picklistsByRecordTypeValue.
         * @param recordTypeId The recordTypeId of the picklistsByRecordTypeValue.
         * @returns Returns a ValueProviderResult representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,objectApiName,recordTypeId){let picklistValuesByRecordTypeThenable;const params={objectApiName,recordTypeId};{picklistValuesByRecordTypeThenable=aggregateUiExecutor.executeSingleRequestOverAggregateUi("getPicklistValuesByRecordType",params,PICKLIST_VALUES_BY_RECORD_TYPE_TTL);}return picklistValuesByRecordTypeThenable.then(transportResponse=>{// Cache miss.
    const freshPicklistsByRecordType=transportResponse.body;this.stagePutValue([],freshPicklistsByRecordType,cacheAccessor,{objectApiName,recordTypeId});const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}}/**
     * Wire adapter id: getPicklistValuesByRecordType.
     * @throws Always throws an error when invoked. Imperative invocation is not supported.
     */function getPicklistValuesByRecordType(){throw generateError("getPicklistValuesByRecordType");}/**
     * Generates the wire adapters for:
     * @wire getPicklistValuesByRecordType
     */class PicklistValuesByRecordTypeWireAdapterGenerator{/**
         * Constructor.
         * @param picklistValuesByRecordTypeService Reference to the PicklistValuesByRecordTypeService instance.
         */constructor(picklistValuesByRecordTypeService){this._picklistValuesByRecordTypeService=picklistValuesByRecordTypeService;}/**
         * Generates the wire adapter for @wire getPicklistValuesByRecordType.
         * @returns Returns the generated wire adapter for getPicklistValuesByRecordType
         */generateGetPicklistValuesByRecordTypeWireAdapter(){const wireAdapter=generateWireAdapter(this.serviceGetPicklistValuesByRecordType.bind(this));return wireAdapter;}/**
         * @private Made public for testing.
         * Services getPicklistValuesByRecordType @wire.
         * @param config Config params for the service.
         * @return Observable stream that emits a picklist values by record type object.
         */serviceGetPicklistValuesByRecordType(config){if(!config){return undefined;}{const required=["objectApiName","recordTypeId"];const supported=["objectApiName","recordTypeId"];validateConfig$1("getPicklistValuesByRecordType",config,required,supported);}if(!config.objectApiName||!config.recordTypeId){return undefined;}return this._picklistValuesByRecordTypeService.getPicklistValuesByRecordType(config.objectApiName,config.recordTypeId);}}/**
     * The valueType to use when building RecordCreateDefaultsCacheKey.
     */const RECORD_CREATE_DEFAULTS_VALUE_TYPE="uiapi.RecordDefaultsRepresentation";/**
     * Time to live for RecordCreateDefaults object. 15 minutes.
     */const RECORD_CREATE_DEFAULTS_TTL=15*60*1000;/**
     * Constructs a cache key for the RecordCreateDefaults value type.
     * @param objectApiName The object api name.
     * @param formFactor The form factor.
     * @param recordTypeId The record type id.
     * @param optionalFields The list of optional fields.
     * @returns A new cache key representing the RecordCreateDefaults value type.
     */function buildCacheKey$a(objectApiName,formFactor,recordTypeId,optionalFields){function errorFormatter(_literals,key,valueFound,singleValue){let base=`${key} should be a string list, but received ${valueFound}`;if(singleValue){base+=`, list contains an entry with value ${singleValue}`;}return base;}function constructKeyFromStringList(key,list){if(list===undefined){return "";}{list.forEach(field=>{assert$2(field,errorFormatter`${key}${list}${field}`);});}return list.join(",");}{if(recordTypeId){assert$2(recordTypeId.length===18,"Record Type Id length should be 18 characters.");}}const cacheKeyPartFormFactor2=formFactor?formFactor.toLowerCase():"Large";const cacheKeyPartRecordTypeId2=recordTypeId?recordTypeId:MASTER_RECORD_TYPE_ID;const cacheKeyPartOptionalFields2=constructKeyFromStringList("optionalFields",optionalFields?optionalFields.sort():undefined);return {type:RECORD_CREATE_DEFAULTS_VALUE_TYPE,key:`${objectApiName.toLowerCase()}${KEY_DELIM}${cacheKeyPartFormFactor2}${KEY_DELIM}${cacheKeyPartRecordTypeId2}${KEY_DELIM}${cacheKeyPartOptionalFields2}`};}/**
     * Returns a RecordCreateDefaultsCacheKeyParams based on a CacheKey.
     * @param cacheKey A cache key string derived from a RecordCreateDefaults CacheKey.
     * @returns See description.
     */function getRecordCreateDefaultsCacheKeyParams(cacheKey){{assert$2(cacheKey.type===RECORD_CREATE_DEFAULTS_VALUE_TYPE,`valueType was expected to be RECORD_CREATE_DEFAULTS_VALUE_TYPE but was not: ${cacheKey.type.toString()}`);}const key=cacheKey.key;const localKeyParts=key.split(KEY_DELIM);const optionalFields=localKeyParts[3]===""?[]:localKeyParts[3].split(",");return {objectApiName:localKeyParts[0],recordTypeId:localKeyParts[2],formFactor:localKeyParts[1],optionalFields};}/**
     * Provides functionality to read record create defaults data from the cache. Can refresh the data from the server.
     */class RecordDefaultsService extends LdsServiceBase{/*
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache){super(ldsCache,[RECORD_CREATE_DEFAULTS_VALUE_TYPE]);}getCacheValueTtl(){return RECORD_CREATE_DEFAULTS_TTL;}/**
         * Gets record create default values.
         * @param objectApiName API name of the object.
         * @param formFactor Form factor. Possible values are 'Small', 'Medium', 'Large'. Large is default.
         * @param recordTypeId Record type id.
         * @param optionalFields Qualified field API names. If any are inaccessible then they are silently omitted.
         * @returns An observable of record create default values.
         */getRecordCreateDefaults(objectApiName,formFactor,recordTypeId,optionalFields){// Process arguments and check for validity.
    objectApiName=getObjectApiName(objectApiName);if(formFactor!==undefined&&typeof formFactor!=="string"){throw new TypeError(`Expected to get a string for formFactor but instead got ${formFactor}`);}formFactor=formFactor||"Large";if(recordTypeId!==undefined&&typeof recordTypeId!=="string"){throw new TypeError(`Expected to get a string for recordTypeId but instead got ${recordTypeId}`);}recordTypeId=recordTypeId?to18(recordTypeId):MASTER_RECORD_TYPE_ID;if(optionalFields&&!Array.isArray(optionalFields)){throw new TypeError(`Expected to get an array for optionalFields but instead got ${optionalFields}`);}const processedOptionalFields=(optionalFields||[]).map(getFieldApiName);const cacheKey=buildCacheKey$a(objectApiName,formFactor,recordTypeId,processedOptionalFields);const valueProviderParameters={cacheKey,objectApiName,formFactor,recordTypeId,optionalFields:processedOptionalFields,forceProvide:false};const valueProvider=this._createRecordDefaultsValueProvider(valueProviderParameters);return this._ldsCache.get(cacheKey,valueProvider);}/*
         * Stage puts the given recordAvatar.
         * @param dependentCacheKeys An array of dependent cache keys.
         * @param recordAvatar The recordAvatar to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         */stagePutValue(dependencies,recordCreateDefaults,cacheAccessor,additionalData){const recordCreateDefaultsCacheKey=buildCacheKey$a(additionalData.objectApiName,additionalData.formFactor,additionalData.recordTypeId,additionalData.optionalFields);this._normalizeAndStagePutRecordCreateDefaults(recordCreateDefaults,cacheAccessor,recordCreateDefaultsCacheKey,dependencies);}/**
         * Strips all eTag properties from the given recordCreateDefaults by directly deleting them.
         * @param recordCreateDefaults The recordCreateDefaults from which to strip the eTags.
         * @returns recordCreateDefaults with its eTags stripped.
         */stripETagsFromValue(recordCreateDefaults){delete recordCreateDefaults.eTag;// Strip eTags from object infos.
    const objectInfos=recordCreateDefaults.objectInfos;const objectApiNames=Object.keys(objectInfos);for(let len=objectApiNames.length,n=0;n<len;++n){const objectApiName=objectApiNames[n];const objectInfo=objectInfos[objectApiName];objectInfos[objectApiName]=this._ldsCache.stripETagsFromValue(OBJECT_INFO_VALUE_TYPE,objectInfo);}// Strip eTags from layout.
    const layout=recordCreateDefaults.layout;recordCreateDefaults.layout=this._ldsCache.stripETagsFromValue(LAYOUT_VALUE_TYPE,layout);// Strip eTags from record.
    const record=recordCreateDefaults.record;recordCreateDefaults.record=this._ldsCache.stripETagsFromValue(RECORD_VALUE_TYPE,record);return recordCreateDefaults;}/**
         * Denormalize record create defaults value.
         * @param normalizedRecordCreateDefaults RecordCreateDefaults normalized value.
         * @param cacheAccessor An object to access the cache directly.
         * @returns Denormalized RecordCreateDefaults.
         * @throws FetchResponse Throws an error if denormalization fails for some reason.
         */denormalizeValue(normalizedRecordCreateDefaults,cacheAccessor){const objectToClone=normalizedRecordCreateDefaults;const denormalizedRecordCreateDefaults=cloneDeepCopy(objectToClone);// Denormalize object infos.
    Object.keys(normalizedRecordCreateDefaults.objectInfos).forEach(objectApiName=>{const objectInfoCacheKey=buildCacheKey$1(objectApiName);const cachedObjectInfoValueWrapper=cacheAccessor.get(objectInfoCacheKey);if(cachedObjectInfoValueWrapper){denormalizedRecordCreateDefaults.objectInfos[objectApiName]=cachedObjectInfoValueWrapper.value;}else {throw getLdsInternalError("DENORMALIZE_FAILED","Did not get an object info back for marker: "+serialize(objectInfoCacheKey),true);}});// Denormalize layout.
    const layoutCacheKey=buildCacheKey$2(normalizedRecordCreateDefaults.layout.objectApiName,normalizedRecordCreateDefaults.layout.recordTypeId,normalizedRecordCreateDefaults.layout.layoutType,normalizedRecordCreateDefaults.layout.mode);const cachedLayoutValueWrapper=cacheAccessor.get(layoutCacheKey);if(cachedLayoutValueWrapper){denormalizedRecordCreateDefaults.layout=cachedLayoutValueWrapper.value;}else {throw getLdsInternalError("DENORMALIZE_FAILED","Did not get a layout back for marker: "+serialize(layoutCacheKey),true);}// The denormalized recordCreateDefaults should now be ready to go.
    return denormalizedRecordCreateDefaults;}/**
         * @returns The affected key handler for this service.
         */getAffectedKeyHandler(){return (affectedKey,_cacheAccessor)=>{{assert$2(affectedKey.type===RECORD_CREATE_DEFAULTS_VALUE_TYPE,`Expected RECORD_CREATE_DEFAULTS_VALUE_TYPE value type for RecordCreateDefaults: ${affectedKey.type.toString()}`);}const recordCreateDefaultsCacheKeyParams=getRecordCreateDefaultsCacheKeyParams(affectedKey);const objectApiName=recordCreateDefaultsCacheKeyParams.objectApiName;const formFactor=recordCreateDefaultsCacheKeyParams.formFactor;const recordTypeId=recordCreateDefaultsCacheKeyParams.recordTypeId;const optionalFields=recordCreateDefaultsCacheKeyParams.optionalFields;// We need to refresh, but we're already in a cache transaction. Kick this to a Promise to get this out of the cache operation we're
    // already in the middle of.
    Promise.resolve().then(()=>{const valueProviderParameters={cacheKey:affectedKey,objectApiName,formFactor,recordTypeId,optionalFields,forceProvide:true};const valueProvider=this._createRecordDefaultsValueProvider(valueProviderParameters);this._ldsCache.get(affectedKey,valueProvider);});};}/**
         * Constructs a value provider to retrieve record default values.
         * @param valueProviderParameters: Parameters for the record create defaults value provider.
         * @returns The value provider to retrieve record defaults.
         */_createRecordDefaultsValueProvider(valueProviderParameters){const valueProvider=new ValueProvider((cacheAccessor,valueProviderParams)=>{const{cacheKey,objectApiName,formFactor,recordTypeId,optionalFields,forceProvide}=valueProviderParams;if(forceProvide){return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,formFactor,recordTypeId,optionalFields);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){// Determine if the value in the cache needs a refresh.
    const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;// check for ttl expiry
    const needsRefresh=nowTime>lastFetchTime+RECORD_CREATE_DEFAULTS_TTL;if(needsRefresh){// Value is stale, get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,formFactor,recordTypeId,optionalFields);}// Value is not stale, but we still need to validate it.
    const isValid=this._validateRecordCreateDefaultsCacheValue(cacheAccessor,existingValueWrapper.value);if(isValid){// Value contained in the cache is determined to be valid so return a cache hit!
    return Thenable.resolve(1/* CACHE_HIT */);}// Existing value is not valid; get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,formFactor,recordTypeId,optionalFields);}// No existing value; get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,objectApiName,formFactor,recordTypeId,optionalFields);},valueProviderParameters);return valueProvider;}hasValidCachedValue(cacheAccessor,params){const cacheKey=buildCacheKey$a(params.objectApiName,params.formfactor,params.recordTypeId,params.optionalFields);const existingValueWrapper=cacheAccessor.get(cacheKey);return !!existingValueWrapper&&existingValueWrapper.value!==undefined&&cacheAccessor.nowTime<=existingValueWrapper.lastFetchTime+RECORD_CREATE_DEFAULTS_TTL&&this._validateRecordCreateDefaultsCacheValue(cacheAccessor,existingValueWrapper.value);}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param cacheKey The cache key for the recordCreateDefaults.
         * @param objectApiName The objectApiName of the recordCreateDefaults.
         * @param formFactor The formFactor of the recordCreateDefaults.
         * @param recordTypeId The recordTypeId of the recordCreateDefaults.
         * @param optionalFields The list of optional fields for the recordCreateDefaults.
         * @returns ValueProvider result representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,cacheKey,objectApiName,formFactor,recordTypeId,optionalFields){const params={objectApiName,formFactor,recordTypeId,optionalFields};let transportResponseThenable;{transportResponseThenable=aggregateUiExecutor.executeSingleRequestOverAggregateUi("getRecordCreateDefaults",params,RECORD_CREATE_DEFAULTS_TTL);}return transportResponseThenable.then(transportResponse=>{// Cache miss.
    const freshRecordCreateDefaults=transportResponse.body;cacheAccessor.stageClearDependencies(cacheKey);// Nothing should depend on this yet; included for completeness.
    this.stagePutValue([],freshRecordCreateDefaults,cacheAccessor,{objectApiName,formFactor,recordTypeId,optionalFields});const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}/**
         * Returns true if the existing formUi cache value is valid, else false.
         * @param cacheAccessor The cacheAccessor.
         * @param normalizedRecordCreateDefaults The existing recordCreateDefaults cache value.
         * @returns See description.
         */_validateRecordCreateDefaultsCacheValue(cacheAccessor,normalizedRecordCreateDefaults){const denormalizedRecordCreateDefaults=this.denormalizeValue(normalizedRecordCreateDefaults,cacheAccessor);return !!denormalizedRecordCreateDefaults;}/**
         * Normalize record create defaults value.
         * @param denormalizedRecordCreateDefaults RecordCreateDefaults denormalized value
         * @param cacheAccessor An object to access cache directly.
         * @param recordCreateDefaultsCacheKey The cache key for RecordCreateDefaults.
         */_normalizeAndStagePutRecordCreateDefaults(denormalizedRecordCreateDefaults,cacheAccessor,recordCreateDefaultsCacheKey,dependencies){const objectToClone=denormalizedRecordCreateDefaults;const normalizedRecordCreateDefaults=cloneDeepCopy(objectToClone);// Object Info normalization
    const objectInfos=denormalizedRecordCreateDefaults.objectInfos;Object.keys(objectInfos).forEach(apiName=>{const objectInfo=objectInfos[apiName];// Construct the marker.
    normalizedRecordCreateDefaults.objectInfos[apiName]={objectApiName:objectInfo.apiName,eTag:objectInfo.eTag};this._ldsCache.stagePutValue(OBJECT_INFO_VALUE_TYPE,[{cacheKey:recordCreateDefaultsCacheKey,type:1/* REQUIRED */}],objectInfo,cacheAccessor);});// Layout normalization
    const layout=denormalizedRecordCreateDefaults.layout;const objectApiName=denormalizedRecordCreateDefaults.record.apiName;// Construct the marker for layout. We need to keep the following data on the marker so that we have the necessary data
    // to recreate the layout cache key during denormalization and for checking for refresh during the affected key handler.
    const recordTypeId=getRecordTypeIdFromRecord(denormalizedRecordCreateDefaults.record);// Add Layout Marker
    normalizedRecordCreateDefaults.layout={recordTypeId,objectApiName,layoutType:layout.layoutType,mode:layout.mode,eTag:layout.eTag};this._ldsCache.stagePutValue(LAYOUT_VALUE_TYPE,[{cacheKey:recordCreateDefaultsCacheKey,type:1/* REQUIRED */}],layout,cacheAccessor,{objectApiName,recordTypeId});// Stage put the record create defaults.
    // Strip out the eTag from the value. We don't want to emit eTags!
    const eTag=normalizedRecordCreateDefaults.eTag;delete normalizedRecordCreateDefaults.eTag;denormalizedRecordCreateDefaults=this.stripETagsFromValue(denormalizedRecordCreateDefaults);cacheAccessor.stagePut(dependencies,recordCreateDefaultsCacheKey,normalizedRecordCreateDefaults,denormalizedRecordCreateDefaults,{eTag});}}/**
     * Wire adapter id: getRecordCreateDefaults.
     * @throws Error - Always throws when invoked. Imperative invocation is not supported.
     * @returns void
     */function getRecordCreateDefaults(){throw generateError("getRecordCreateDefaults");}/**
     * Generates the wire adapters for:
     * @wire getRecordCreateDefaults
     */class RecordDefaultsWireAdapterGenerator{/*
         * Constructor.
         * @param recordDefaultsService Reference to the RecordDefaultsService instance.
         */constructor(recordDefaultsService){this._recordDefaultsService=recordDefaultsService;}/**
         * Generates the wire adapter for @wire getRecordCreateDefaults
         * @returns See description.
         */generateGetRecordCreateDefaultsWireAdapter(){const wireAdapter=generateWireAdapter(this._serviceGetRecordCreateDefaults.bind(this));return wireAdapter;}/**
         * Service getRecordCreateDefaults @wire.
         * @private Made public for testing.
         * @param config Config params for the service. The type is or'd with any so that we can test sending bad configs. Consumers will be able to send us bad configs.
         * @return Observable stream that emits a recordCreateDefaults object.
         */_serviceGetRecordCreateDefaults(config){if(!config){return undefined;}{const required=["objectApiName"];const supported=["formFactor","objectApiName","optionalFields","recordTypeId"];validateConfig$1("getRecordCreateDefaults",config,required,supported);}if(!config.objectApiName){return undefined;}return this._recordDefaultsService.getRecordCreateDefaults(config.objectApiName,config.formFactor,config.recordTypeId,config.optionalFields);}}// HACK - early out of ADG data fetching if lds224 is enabled. superseded by W-6448498
    const IS_LDS_224_ENABLED=window.location.search.includes("lds224")||typeof $A!=="undefined"&&$A.get("$Browser.S1Features.isLds224Enabled");const TEMPLATE_REQUEST_URL="DynamicComponentController.getTemplateDescriptorWithExpansionBundle";const USE_ADG_KEY="isTemplateAdgEnabled";const USE_ADG_CONFIGURATION_KEY="DescriptorRollup."+USE_ADG_KEY;function executeTemplateBundleController(requestParams,cacheAccessor,ldsCache,requestingServiceValueType,getServiceConfiguration,forceRefresh){const params={type:"Bundle",templateReferences:requestParams.map(requestParam=>{const genericRequestParams=requestParam;return {type:genericRequestParams.type,attributes:Object.assign({},genericRequestParams.params,genericRequestParams.expansionHints)};})};if(getServiceConfiguration(USE_ADG_CONFIGURATION_KEY)){return resolveTemplatesViaADG(params,cacheAccessor,ldsCache,forceRefresh);}return fetchTemplatesWithData(params,cacheAccessor,ldsCache,requestingServiceValueType);}/**
     * Requests a template with expansion hints which may return more data that is needed as part of the template. The additional data
     * that is returned from the server is injected into the LDS caches. This method returns just the template to the caller.
     *
     * @param requestParams The parameters to pass to the server side
     * @param cacheAccessor Used to inject data into the lds caches
     * @param ldsCache Reference to the LdsCache instance
     * @param requestingServiceValueType the value type of the service requesting the template
     * @returns A promise of the template layout descriptor
     */function executeTemplateController(requestParams,cacheAccessor,ldsCache,requestingServiceValueType,getServiceConfiguration,forceRefresh){return executeTemplateBundleController([requestParams],cacheAccessor,ldsCache,requestingServiceValueType,getServiceConfiguration,forceRefresh).then(promiseSet=>{return promiseSet[0];});}function resolveTemplatesViaADG(params,cacheAccessor,ldsCache,forceRefresh){// While this is yet another location that builds module names, doing so here will avoid an XHR (if the server logic was used).
    const targetModuleNames=buildTargetModuleNames(params);return getRollupModules(targetModuleNames,forceRefresh).then(rollupModules=>{let concreteRequests=[];rollupModules.forEach((rollupModule,index)=>{const rawRollupModule=rollupModule;const ADG=getAdgFromRollupModule(rawRollupModule);// TODO: Immutable ADG -> List requests
    // Seed $recordId with literals / actual values out of attributes and expansion hints
    concreteRequests=concreteRequests.concat(initializeADG(params.templateReferences[index].attributes,ADG));});// new type: intermediate? concrete? DG
    const preparedRequests=getResolvableDependencies(concreteRequests,ldsCache,cacheAccessor).map(injectRefreshInfo.bind(null,ldsCache));// TODO: Break up into sub-groups separated by transformWire
    const preparedUiRequests=convertDataDepsToAggregateUi(preparedRequests);// How can we abstract this process such that we don't explicitly depend on AggregateUi?
    // TODO: Break-off Template calls & their children to the adapter
    if(IS_LDS_224_ENABLED||preparedUiRequests.input.compositeRequest.length===0){return packageTemplateDescriptors(rollupModules,params);}const asyncCacheAccessor=new CacheAccessor(ldsCache,ldsCache.timeSource);// queue up aggregateUi for everything the ADG specified, and start rendering the template ASAP by returning before the data has returned
    callAggregateUi(preparedUiRequests).then(function(data){const requestedValueTypes=mapWireNamesToValueType(preparedRequests.map(req=>req.type.name));// Use input DataDependencies to do hacky transformations for certain wires (layout user states, I'm looking at you)
    stagePutAggregateResponse(requestedValueTypes,preparedRequests,data,asyncCacheAccessor,ldsCache);asyncCacheAccessor.commitPuts();asyncCacheAccessor.finishCacheAccessor();});return packageTemplateDescriptors(rollupModules,params);});}function buildTargetModuleNames(allParams){return allParams.templateReferences.map(params=>{const lowerCaseType=params.type.substring(0,1).toLowerCase()+params.type.substring(1);if(params.type==="DetailPanel"||params.type==="HighlightsPanel"){assert$2(params.attributes.objectApiName,"ADG Flow requires objectApiName be passed into the wire");assert$2(params.attributes.recordTypeId,"ADG Flow requires recordTypeId");return "forceGenerated__"+lowerCaseType+"_"+params.attributes.objectApiName+"___"+params.attributes.recordTypeId+"___"+params.attributes.layoutType+"___"+params.attributes.mode;}else if(params.type==="Action"){assert$2(params.attributes.actionApiName,"Action Flow requires actionApiName be passed into the wire");assert$2(params.attributes.recordId,"Action Flow requires recordId");assert$2(params.attributes.timestamp,"Action Flow requires timestamp");return "forceGenerated__"+lowerCaseType+"_"+params.attributes.actionApiName+"___"+params.attributes.recordId+"___"+params.attributes.timestamp;}else {return "forceGenerated__"+lowerCaseType+"_"+"RecordPage___"+params.attributes.pageDeveloperName+"___"+params.attributes.objectApiName+"___VIEW";}});}function packageTemplateDescriptors(rollupModules,params){return rollupModules.map((rollupModule,index)=>{const rawRollupModule=rollupModule;const descriptor=rawRollupModule.targetModule;const templateReference=params.templateReferences[index];if(templateReference.type==="DetailPanel"||templateReference.type==="HighlightsPanel"){return {descriptor,additionalParams:{objectApiName:templateReference.attributes.objectApiName,recordTypeId:templateReference.attributes.recordTypeId}};}else if(templateReference.type==="Flexipage"){return {descriptor,additionalParams:{}};}else {return {descriptor,additionalParams:{}};}});}// TODO: Why does getModule say it returns a string? Modules are most certainly not strings
    function getRollupModules(moduleNames,forceRefresh){const rollupParams={type:"Bundle",templateReferences:moduleNames.map(moduleName=>{return {type:"Rollup",attributes:{targetModule:moduleName}};})};return getFreshRollupDescriptor(rollupParams,forceRefresh).then(getRollupModuleByDescriptor);}/**
     * Given rollup params, construct the module name of the rollup module
     * @param rollupParams
     */function getRollupDescriptor(rollupParams){return "forceGenerated/rollup_"+rollupParams.attributes.targetModule;}// ADG Template TTL: long enough to get re-use, but not so long that users wait forever to get layout updates from admin changes
    const ADG_MODULE_TTL=15*60*1000;// 15 minutes
    function getFreshRollupDescriptor(rollupParams,forceRefresh){// Aura Actions defer writes to IndexDB, so if (all) the modules being requested have already been loaded in memory, don't make a Global Controller call
    let allTemplatesLoaded=true;const rollupDescriptors=[];for(let i=0;i<rollupParams.templateReferences.length;i++){const params=rollupParams.templateReferences[i];const rollupDescriptor=getRollupDescriptor(params);rollupDescriptors.push(rollupDescriptor);// If we're missing any modules being requested, break & make an auraGlobalController call to fetch the templates
    if(!hasModule(rollupDescriptor)||!hasModule(params.attributes.targetModule.replace("__","/"))){allTemplatesLoaded=false;break;}}if(allTemplatesLoaded){return Thenable.resolve(rollupDescriptors);}// note: rollupDescriptors may be incomplete
    const needsRefresh=!!forceRefresh;const transportConfig={hotspot:true,background:false,longRunning:false,storable:{ignoreExisting:needsRefresh,refresh:ADG_MODULE_TTL,/*
                 * TODO: test if setting this to true is safe & useful. What would refresh the action (for us)
                 * We wouldn't have the calling wire in that case, but we should be able to stage-put the new
                 * ADG, which should re-call any active wires (which have dependencies on the cacheKey), and
                 * we'd re-evaluate the ADG & get any expired or missing data.
                 * The page could be currently visible, or in the background. The biggest risk seems to come from
                 * some critical change, like if the RecordType changes, and we get a refresh; will we refresh correctly?
                 */executeCallbackIfUpdated:false}};return executeAuraGlobalController(TEMPLATE_REQUEST_URL,rollupParams,transportConfig).then(transportResponse=>{// Full clone takes mem/cpu, but guarantees we won't accidentally screw with a cached value accidentally
    const valueMap=transformResponse(cloneDeepCopy(transportResponse.body));return valueMap["lds.DescriptorRollup"].map(value=>value.representation);});}function getRollupModuleByDescriptor(moduleNames){return moduleNames.map(moduleName=>{if(hasModule(moduleName)){return getModule(moduleName);}throw new Error("Failed to get rollup module for: "+moduleName);});}function getAdgFromRollupModule(rollupModule){return rollupModule.ADG;}function initializeADG(expansionHints,ADG){return ADG.dependencies.map(dep=>{const concreteConfig={};Object.keys(dep.config).forEach(k=>{const inputValue=dep.config[k];if(inputValue&&inputValue.indexOf("$")===0){const paramKey=inputValue.substring(1);// Inter-dependencies will be handeled elsewhere
    if(paramKey.indexOf("@")!==0){const seedValue=expansionHints[paramKey];if(seedValue){// Push the expansion hint into the wire config
    concreteConfig[k]=seedValue;return;}}}concreteConfig[k]=dep.config[k];});return {id:dep.id,type:{module:dep.type.module,name:dep.type.name},config:concreteConfig};});}const UNBATCHABLE_WIRES=["getRecordAvatars","getActionTemplate","getRecordLayoutTemplate"];const UNBATCHABLE_MODULES=["force/ldsTransform","@salesforce"];// TODO: Test without export?
    function getResolvableDependencies(dataDependencies,ldsCache,cacheAccessor){const resolvableDependencies=[];const indexMap={};dataDependencies.forEach((dep,depIdx)=>{if(!isDependencyResolvable(dep)||isDependencyCached(dep,ldsCache,cacheAccessor)){indexMap[depIdx]=null;return;}indexMap[depIdx]=resolvableDependencies.length;resolvableDependencies.push({id:indexMap[dep.id],type:dep.type,config:dep.config});});// Because unresolvable deps weren't copied over, we need to re-index the ones that were
    reindexDependencies(resolvableDependencies,indexMap);// TODO: It's possible that we have a chain of dependencies off unresolvable deps
    // Recurse until all are resolvable?
    const hasUnresolvableChain=!!resolvableDependencies.find(dep=>{return !isConfigResolvable(dep.config);});if(hasUnresolvableChain){return getResolvableDependencies(resolvableDependencies,ldsCache,cacheAccessor);}return resolvableDependencies;}function isDependencyResolvable(dependency){return UNBATCHABLE_WIRES.indexOf(dependency.type.name)===-1&&UNBATCHABLE_MODULES.indexOf(dependency.type.module)===-1&&isConfigResolvable(dependency.config);}function isConfigResolvable(config){const configKeys=Object.keys(config);for(let i=0;i<configKeys.length;i++){const configVal=config[configKeys[i]];if(configVal===undefined){return false;}// $foo returns false
    // $@foo_0@ is allowed
    if(configVal.indexOf("$")===0&&configVal.indexOf("$@")!==0){return false;}}return true;}function isDependencyCached(dependency,ldsCache,cacheAccessor){// If there's a dependency on the output of another wire, we don't know this input and therefore don't know the cacheKey or know if it's cached, so we should make this request
    if(configHasReference(dependency.config)){return false;}// const valueType = getValueTypeFromWireIdentity(dependency.type);
    // const service = ldsCache.getService(valueType);
    // Originally, I was hoping to dynamically get the service & check "are you cached? {params}" but ILdsService/BaseService doesn't have anything
    // like that, nor is there any consistency among Services on dealing with config-bags in any way beyond trying to fetch a value
    const adsBridge=new AdsBridge(ldsCache);const rawConfigBag=dependency.config;switch(dependency.type.name){// Scoped cases because of duplicate variables per case
    // Sync'd to list in wire-name-to-reference-resource-map.ts
    case"getRecordUi":{// const recordUiService: any = ldsCache.getService("uiapi.RecordUiRepresentation");
    const recordUiService=new RecordUiService(ldsCache,adsBridge);return recordUiService.hasValidCachedValue(cacheAccessor,{recordIds:listize(rawConfigBag.recordIds),layoutTypes:listize(rawConfigBag.layoutTypes),modes:listize(rawConfigBag.modes),uniqueOptionalFields:listize(rawConfigBag.uniqueOptionalFields)});}case"getRecord":{const recordService=new RecordService(ldsCache,adsBridge);return recordService.hasValidCachedValue(cacheAccessor,{recordId:rawConfigBag.recordId,// we need to check both .fields and .optionalFields, but hasValidCachedValue only
    // checks optionalFields
    optionalFields:[...listize(rawConfigBag.fields),...listize(rawConfigBag.optionalFields)]});}case"getLayout":{const layoutService=new LayoutService(ldsCache);return layoutService.hasValidCachedValue(cacheAccessor,rawConfigBag);}case"getLayoutUserState":{const layoutUserStateService=new LayoutUserStateService(ldsCache);return layoutUserStateService.hasValidCachedValue(cacheAccessor,rawConfigBag);}case"getObjectInfo":{const objectInfoService=new ObjectInfoService(ldsCache);return objectInfoService.hasValidCachedValue(cacheAccessor,rawConfigBag);}case"getPicklistValues":{const picklistValuesService=new PicklistValuesService(ldsCache);return picklistValuesService.hasValidCachedValue(cacheAccessor,rawConfigBag);}case"getPicklistValuesByRecordType":{const picklistValuesByRecordTypeSerivce=new PicklistValuesByRecordTypeService(ldsCache);return picklistValuesByRecordTypeSerivce.hasValidCachedValue(cacheAccessor,rawConfigBag);/* TODO: needs Id-checking similar to records
            } case "getRecordAvatars": {
                const recordAvatarService = new RecordAvatarBulkService(ldsCache);
                return recordAvatarService.hasValidCachedValue(cacheAccessor, rawConfigBag);
                */}case"getCreateDefaults":{const recordDefaultsService=new RecordDefaultsService(ldsCache);return recordDefaultsService.hasValidCachedValue(cacheAccessor,rawConfigBag);}// TODO: Presumably we'll need the rest of the Services
    default:return false;}}/**
     * When the ADG is fetching a dependency, it should do so like the wire Service would, which in many cases,
     * involves fetching everything the system knows about the particular resource.
     * e.g. During getRecord(fields: [A, B]), if the system has previously fetched [C, D], then the request should be
     * for [A, B, C, D], to ensure that both consumers have up-to-date information. Likewise, the ADG should do the same,
     * and get this extra request-set injected into the dependency.
     * Note that this function is exported for testing purposes *only*.
     * @param ldsCache
     * @param dependency Single dependency being requseted
     * @returns New Dependency for the same resource, but potentially more info/data about the Resource
     */function injectRefreshInfo(ldsCache,dependency){const configChanges={};// Hack edging on the side of feature: If the wireService knows about more fields than the ADG does (e.g. warm when coming from a List page), do a record refresh along with our "new" (ish?) request
    if(dependency.type.name==="getRecord"){const recordId=dependency.config.recordId;if(!recordId.startsWith("$")){const{fields:fieldsString,optionalFields:optionalFieldsString}=dependency.config;const fields=fieldsString?fieldsString.split(","):[];const optionalFields=optionalFieldsString?optionalFieldsString.split(","):[];const recordService=ldsCache.getService("uiapi.RecordRepresentation");const knownFields=recordService.getAllKnownFields(recordId);// de-dupe add using a Set
    const requestedFields=new Set([...optionalFields]);knownFields.forEach(f=>requestedFields.add(f));// No need to duplicate fields in optionalFields
    fields.forEach(f=>requestedFields.delete(f));// Turn it back into the UI API expected form: comma-separated list
    if(requestedFields.size>0){configChanges.optionalFields=Array.from(requestedFields).sort().join(",");}}}if(Object.keys(configChanges).length===0){// Avoid an unnecessary copy if there weren't any changes
    return dependency;}else {return {id:dependency.id,type:dependency.type,// clone config to be cautious
    config:Object.assign({},dependency.config,configChanges)};}}function configHasReference(config){return Object.keys(config).reduce((accum,key)=>{return accum||config[key]&&config[key].indexOf("$@")===0;},false);}// Convert from comma-separated string list to real list, with null guards
    function listize(val){if(!val){return [];}return val.split(",");}function extractReferenceIndex(configValue){if(!configValue||configValue.indexOf("@")!==1){return null;}const indexDelim=configValue.indexOf("@",2);return Number(configValue.substring(2,indexDelim));}function reindexDependencies(resolvableDependencies,indexMap){for(let ri=0;ri<resolvableDependencies.length;ri++){const rDep=resolvableDependencies[ri];Object.keys(rDep.config).forEach(rConfigKey=>{const rConfigVal=rDep.config[rConfigKey];const referencesIndex=extractReferenceIndex(rConfigVal);if(referencesIndex!==null){const indexDelim=rConfigVal.indexOf("@",2);// Pass the index to depend on through the indexMap to get the new
    // index inside resolvableDependencies
    const newIndex=indexMap[referencesIndex];if(newIndex===null){// This depends on a wire that's not resolvable
    // use `$` as a bit of a hack to mark this input as unresolvable
    rDep.config[rConfigKey]="$";}else {rDep.config[rConfigKey]="$@"+newIndex+"@"+rConfigVal.substring(indexDelim+1);}}});}}function convertDataDepsToAggregateUi(dependencies){const aggregateInputs=dependencies.map(dataDependency=>{reconfigureReferences(dataDependency.config);// TODO: Pass through the wire services to build up our requests
    // FYI: This is a destructive operation; the logic will/may delete attributes from the config
    // Clone config to prevent destruction to our input DataDependencies
    return mapDataDependencyToOperationInput(dataDependency.type,Object.assign({},dataDependency.config),dataDependency.id);});return {input:{compositeRequest:aggregateInputs}};}function reconfigureReferences(config){const keys=Object.keys(config);for(let i=0;i<keys.length;i++){let val=config[keys[i]];if(val.indexOf("$@")===0){// ADG uses $@n@.foo while aggregateUi uses @{n.foo}
    val="{"+val.substring(2);val="@"+val.replace("@","")+"}";config[keys[i]]=val;}}}function callAggregateUi(uiRequests){return aggregateUiExecutor.executeAggregateUi(uiRequests);}// TODO: Not important for templates, but lets say we're returning many templates; we'd need to match for the exact one we requested
    /**
     * Remove the requested valueType out of the valueMap, and return it
     */function extractCurrentRequestFromValueMap(valueMap,requestingServiceValueType){const serviceRequestedValues=valueMap[requestingServiceValueType];delete valueMap[requestingServiceValueType];return serviceRequestedValues;}function stagePutValueMap(valueMap,cacheAccessor,ldsCache){// normalize and stage put the various pieces of information
    const entries=Object.entries(valueMap);for(const[valueType,values]of entries){const _values=values;for(let i=0,l=_values.length;i<l;i++){const value=_values[i];// Timing of stagePut vs wires getting called -- does each wire get called after _all_ stage puts, or intermingled between puts?
    ldsCache.stagePutValue(valueType,[],value.representation,cacheAccessor,value.additionalParams);}}}function stagePutAggregateResponse(requestedValueTypes,inputDependencies,aggregateResponse,cacheAccessor,ldsCache){for(let i=0;i<aggregateResponse.compositeResponse.length;i++){const{body,httpStatusCode,additionalParams}=preStagePutTransform(aggregateResponse.compositeResponse[i],inputDependencies[i]);const valueType=requestedValueTypes[i];if(httpStatusCode===200){// W-6688763 - Add all the fields that we requested to LDS' list of tracked fields. The stagePut logic
    // below is sufficient to cause LDS to track all the fields that are present in response, but we *also*
    // need to track fields that were requested but *not* returned (e.g. spanning fields where the lookup
    // field contains a null value, or fields omitted due to FLS). Note that we do *not* need to consider
    // inputDependencies[i].config.fields here - the 200 response guarantees that those fields are in the
    // returned data and stagePutValue will add them to the list of tracked fields.
    if(valueType==="uiapi.RecordRepresentation"){const{recordId,optionalFields}=inputDependencies[i].config;if(recordId&&optionalFields){const recordService=ldsCache.getService("uiapi.RecordRepresentation");recordService.addFieldsToTrack(recordId,optionalFields.split(","));}}ldsCache.stagePutValue(valueType,[],body,cacheAccessor,additionalParams);}}}function preStagePutTransform(response,inputDependency){switch(inputDependency.type.name){case"getLayout":case"getLayoutUserState":case"getPicklistValues":case"getPicklistValuesByRecordType":case"getRecordActions":case"getRecordCreateDefaults":return {body:response.body,httpStatusCode:response.httpStatusCode,// getLayout* look at additional params -- I'm assuming this was because in the server-fetched world, the input params were not known,
    // but they're necessary to do a stagePut. Ideally, I'd say the URI should be reversed to build the cacheKey instead of relying on
    // additionalParams. But... at least for now, this is an easier hack
    additionalParams:inputDependency.config};}return {body:response.body,httpStatusCode:response.httpStatusCode,additionalParams:{}};}function fetchTemplatesWithData(params,cacheAccessor,ldsCache,requestingServiceValueType){return executeAuraGlobalController(TEMPLATE_REQUEST_URL,params).then(transportResponse=>{// Full clone takes mem/cpu, but guarantees we won't accidentally screw with a cached value
    const payloadList=cloneDeepCopy(transportResponse.body);const valueMap=transformResponse(payloadList);stagePutValueMap(valueMap,cacheAccessor,ldsCache);// This currently presumes that the template requests are all one type.
    // We could be more intelligent: get rid of requestingServiceValueType and use the type present in each of the params. However, this code is going away very soon so this is Good Enough.
    const templates=extractCurrentRequestFromValueMap(valueMap,requestingServiceValueType);return templates.map((referenceMappedRepresentation,index)=>{const templateReference=params.templateReferences[index];// TODO: API is return getModule ?
    if(templateReference.type==="DetailPanel"||templateReference.type==="HighlightsPanel"){const newResult={descriptor:referenceMappedRepresentation.representation,additionalParams:referenceMappedRepresentation.additionalParams};return newResult;}else if(templateReference.type==="Flexipage"){const newResult={descriptor:referenceMappedRepresentation.representation,additionalParams:referenceMappedRepresentation.additionalParams};return newResult;}else if(templateReference.type==="Action"){const newResult={descriptor:referenceMappedRepresentation.representation,additionalParams:referenceMappedRepresentation.additionalParams};return newResult;}else {const newResult={descriptor:referenceMappedRepresentation.representation,additionalParams:referenceMappedRepresentation.additionalParams};return newResult;}});});}/**
     * This function transforms the old controllers data shape into the new one
     *
     * @param valueMap the new data shape
     * @return the emulated new data shape
     */function transformResponse(valueMap){// Mutate to save mem/cpu from copying
    if(valueMap.recordAvatars){const recordAvatars=valueMap.recordAvatars[0].representation;const avatarAdditionalData={recordAvatarIds:Object.keys(recordAvatars)};valueMap["uiapi.RecordAvatarBulk"]=[{representation:createRecordAvatarRepresentationsFromRecordAvatarBulk(recordAvatars),additionalParams:avatarAdditionalData}];delete valueMap.recordAvatars;}return valueMap;}/*
     * Copyright 2019 salesforce.com, inc.
     * All Rights Reserved
     * Company Confidential
     */ /**
     * Provides functionality to fetch the related list template from the cache. Can refresh the data from the server.
     */class RelatedListTemplateService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache,getServiceConfiguration){super(ldsCache,[RELATED_LIST_TEMPLATE_VALUE_TYPE]);this._getServiceConfiguration=getServiceConfiguration;}getCacheValueTtl(){return RELATED_LIST_TEMPLATE_TTL;}/**
         * Gets a related list template
         * @param objectApiName the parent's object api name
         * @param parentRecordId The parent record id.
         * @param relatedListId The related list id or name.
         * @returns An observable that emits the layout descriptor.
         */getRelatedListTemplate(objectApiName,parentRecordId,relatedListId){const cacheKey=this.buildCacheKey(parentRecordId,relatedListId);const observable=this._ldsCache.get(cacheKey,new ValueProvider(cacheAccessor=>{// TODO: Add caching with W-6011078
    return this._getFreshValue(cacheAccessor,objectApiName,parentRecordId,relatedListId,cacheKey);},{objectApiName,parentRecordId,relatedListId}));return observable.filter(hasModule).map(getModule);}/**
         * Stage puts the given dynamicComponentDescriptor.
         * @param dependencies An array of dependent cache keys.
         * @param generatedComponentDescriptor The generatedComponentDescriptor to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param cacheKey A property bag with additional values that are needed to generate the cache key.
         */stagePutValue(dependencies,generatedComponentDescriptor,cacheAccessor,additionalData){const cacheKey=this.buildCacheKey(additionalData.parentRecordId,additionalData.relatedListId);this.normalizeAndStagePut(dependencies,cacheKey,generatedComponentDescriptor,cacheAccessor);}/**
         * Normalizes and stage puts given generatedComponentDescriptor
         * @param dependencies An array of dependent cache keys.
         * @param cacheKey utilized by the value provider to fetch the value.
         * @param generatedComponentDescriptor The generatedComponentDescriptor to cache.
         * @param cacheAccessor An object to access cache directly.
         */normalizeAndStagePut(dependencies,cacheKey,generatedComponentDescriptor,cacheAccessor){cacheAccessor.stagePut(dependencies,cacheKey,generatedComponentDescriptor,generatedComponentDescriptor);}/**
         * Strips all eTag properties from the given dynamicComponentDescriptor by directly deleting them.
         * @param dynamicComponentDescriptor The dynamicComponentDescriptor from which to strip the eTags.
         * @returns The given dynamicComponentDescriptor with its eTags stripped.
         */stripETagsFromValue(dynamicComponentDescriptor){return dynamicComponentDescriptor;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to access cache directly.
         * @param objectApiName the parent's object api name
         * @param parentRecordId The parent record id.
         * @param relatedListId The related list id or name.
         * @param cacheKey the precomputed cache key
         */_getFreshValue(cacheAccessor,objectApiName,parentRecordId,relatedListId,cacheKey){let layoutTemplateDescriptorThenable;const params={type:"RelatedList",params:{objectApiName,parentRecordId,relatedListId}};layoutTemplateDescriptorThenable=executeTemplateController(params,cacheAccessor,this._ldsCache,RELATED_LIST_TEMPLATE_VALUE_TYPE,this._getServiceConfiguration);return layoutTemplateDescriptorThenable.then(freshValue=>{// nothing to normalize
    this.normalizeAndStagePut([],cacheKey,freshValue.descriptor,cacheAccessor);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;}).catch(rejectionReason=>{{// tslint:disable-next-line:no-console
    console.log(rejectionReason);// Do not go gentle into that good night.
    }throw rejectionReason;});}/**
         * Builds the cache key.
         * @param parentRecordId The parent record id.
         * @param relatedListId The related list id or name.
         * @returns  A new CacheKey which represents a RELATED_LIST_TEMPLATE_VALUE_TYPE.
         */buildCacheKey(parentRecordId,relatedListId){return {type:RELATED_LIST_TEMPLATE_VALUE_TYPE,key:`${parentRecordId||""}${KEY_DELIM}${KEY_DELIM}${relatedListId||""}`};}}/*
     * Copyright 2019 salesforce.com, inc.
     * All Rights Reserved
     * Company Confidential
     */ /*
     * Generates the wire adapter for List Template
     */class RelatedListTemplateWireAdapterGenerator{/*
         * Constructor.
         * @param listUiService Reference to the ListUiService instance.
         */constructor(relatedListTemplateService){this._relatedListTemplateService=relatedListTemplateService;}/*
         * Generates the wire adapter for getRelatedListTemplate.
         * @returns WireAdapter - See description.
         */generateGetRelatedListTemplateWireAdapter(){const wireAdapter=generateWireAdapter(this._serviceGetRelatedListTemplate.bind(this));return wireAdapter;}/*
         * Service getRelatedListTemplate @wire.
         * @private
         * @param config: Config params for the service.
         * @return Observable stream that emits a related list template.
         */_serviceGetRelatedListTemplate(config){if(!config||!config.parentObjectApiName||!config.parentRecordId||!config.relatedListId){return undefined;}return this._relatedListTemplateService.getRelatedListTemplate(config.parentObjectApiName,config.parentRecordId,config.relatedListId);}}/*
     * Copyright 2019 salesforce.com, inc.
     * All Rights Reserved
     * Company Confidential
     */ /*
     * Wire adapter id: getRelatedListTemplate.
     * @throws Error - Always throws when invoked. Imperative invocation is not supported.
     * @returns void
     */function getRelatedListTemplate(){throw generateError("getRelatedListTemplate");}/**
     * Lookup actions value type
     */const LOOKUP_ACTIONS_VALUE_TYPE="lds.LookupActions";/**
     * Lookup actions value expires in 5 minutes in cache
     */const LOOKUP_ACTIONS_TTL=5*60*1000;/**
     * Returns a comma delimited string insensitive to letter cases and order of the input strings
     * @param array An array of strings
     * @return see description
     */function stableCommaDelimitedString(array){return array&&array.length?[...array].sort().join(","):"";}/**
     * Returns an array of lower cased strings
     * @param array An array of strings
     * @return see description
     */function toLowerCase(array){return array&&array.length?array.map(elem=>elem.toLowerCase()):array;}/**
     * Builds a cache key for lookup actions
     * @param objectApiNames The list of object api names
     * @param formFactor The form factor
     * @param sections The sections
     * @param actionTypes The action types
     * @return See description
     */function buildCacheKey$b(objectApiNames,formFactor,sections,actionTypes){{assert$2(objectApiNames.length,"A non-empty objectApiNames must be provided.");}const objectApiName=stableCommaDelimitedString(toLowerCase(objectApiNames));formFactor=(formFactor||"").toLowerCase();const section=stableCommaDelimitedString(toLowerCase(sections));const actionType=stableCommaDelimitedString(toLowerCase(actionTypes));return {type:LOOKUP_ACTIONS_VALUE_TYPE,key:[objectApiName,formFactor,section,actionType].join(KEY_DELIM)};}/**
     * Value type for action definition
     */const ACTION_DEFINITION_VALUE_TYPE="lds.ActionDefinition";/**
     * Function builds a marker from a cache key
     * @param actionDefinitionCacheKey
     * @return A marker of an action definition
     */function buildActionDefinitionMarker(actionDefinitionCacheKey){return {key:serialize(actionDefinitionCacheKey)};}/**
     * Builder builds a cache key from a marker
     * @param marker The marker of an action definition
     * @return A cache key for an action definition
     */function buildCacheKeyFromMarker(marker){return {type:ACTION_DEFINITION_VALUE_TYPE,key:marker.key.split(KEY_DELIM).slice(1).join(KEY_DELIM)};}/**
     * @param externalId The external id
     * @return A cache key for action definition
     */function buildCacheKey$c(externalId){return {type:ACTION_DEFINITION_VALUE_TYPE,key:externalId.split(KEY_DELIM).slice(5).join(KEY_DELIM)};}/**
     * Normalize an action payload. The call doesn't mutate the input payload.
     * @param cacheAccessor The cache accessor
     * @param fnForCacheKeyDependenciesOfKey A function provided by endpoint to specify the cache key and its non-action-hierarchical dependencies given a key
     * @param cacheKey The cache key of the payload, usually available from within the caller (the endpoint) before this call
     * @param payload The de-normalized action payload returned from Ui Api
     */function normalizePayload(cacheAccessor,fnForCacheKeyDependenciesOfKey,cacheKey,payload){// a function to normalize one key value pair of an action payload
    const normalizeAndStageSingleKeyedPayload=(key,multipleKeyedPayloadCacheKeys,valueWrapperProperties)=>{// for a provided key,
    // cache key is the cache key of the single keyed payload,
    // dependencies are non-action-hierarchical ones each end point has the best knowledge what they are
    const{cacheKey:singleKeyedPayloadCacheKey,dependencies:interModuleDependencies,getSingleActionByApiNameCacheKey}=fnForCacheKeyDependenciesOfKey(key);const singleKeyedPayloadDependency={cacheKey:singleKeyedPayloadCacheKey,type:1/* REQUIRED */};const multipleKeyedPayloadDependencyArray=multipleKeyedPayloadCacheKeys.map(currCacheKey=>{return {cacheKey:currCacheKey,type:1/* REQUIRED */};});// a function to extract action definition from the action payload and replace it with a marker
    const extractActionDefinition=platformActionRepresentation=>{// a set of hard coded fields extracted as the action definition
    const{actionTarget,actionTargetType,apiName,iconUrl,label,primaryColor,subtype,type}=platformActionRepresentation,rest=_objectWithoutProperties(platformActionRepresentation,["actionTarget","actionTargetType","apiName","iconUrl","label","primaryColor","subtype","type"]);const actionDefinition={actionTarget,actionTargetType,apiName,iconUrl,label,primaryColor,subtype,type};const actionDefinitionCacheKey=buildCacheKey$c(rest.externalId);// stage action definition payload and their dependencies
    const dependencies=[singleKeyedPayloadDependency,...multipleKeyedPayloadDependencyArray];if(getSingleActionByApiNameCacheKey){dependencies.push({cacheKey:getSingleActionByApiNameCacheKey(apiName),type:1/* REQUIRED */});}cacheAccessor.stagePut(dependencies,actionDefinitionCacheKey,actionDefinition,actionDefinition);const marker=buildActionDefinitionMarker(actionDefinitionCacheKey);return _objectSpread$3({},rest,{actionDefinition:marker});};// prepare single key payload by extracting action definition, value could be either a single action or a list of actions
    const value=payload.actions[key];const singleKeyedPayload={actions:{}};singleKeyedPayload.actions[key]={actions:value.actions.map(extractActionDefinition)};// prepare de-normalized payload to emit, making sure it has the necessary action payload envelop so that no payload transformation on a cache hit
    const valueToEmit={actions:{}};valueToEmit.actions[key]={actions:value.actions};// stage single keyed payload
    cacheAccessor.stagePut(multipleKeyedPayloadDependencyArray,singleKeyedPayloadCacheKey,singleKeyedPayload,valueToEmit,valueWrapperProperties);// when non-action-hierarchical dependencies are provided by endpoint, stage them up
    if(interModuleDependencies){interModuleDependencies.forEach(dependency=>{cacheAccessor.stageDependencies([singleKeyedPayloadDependency],dependency);});}// normalize for requests of retrievalMode "All" with a single action api name
    if(getSingleActionByApiNameCacheKey){singleKeyedPayload.actions[key].actions.forEach((normalizedAction,index)=>{const singleActionPayload={actions:{}};singleActionPayload.actions[key]={actions:[normalizedAction]};const singleActionValueToEmit={actions:{}};singleActionValueToEmit.actions[key]={actions:[value.actions[index]]};const singleActionByApiNameCacheKey=getSingleActionByApiNameCacheKey(value.actions[index].apiName);cacheAccessor.stagePut([],singleActionByApiNameCacheKey,singleActionPayload,singleActionValueToEmit);});}return [singleKeyedPayloadCacheKey,valueToEmit];};const keys=Object.keys(payload.actions);if(keys.length===0){// no normalization at all
    cacheAccessor.stagePut([],cacheKey,payload,{actions:payload.actions});}else if(keys.length===1){// normalize the only key, there is no multiple keyed payload cache keys specified
    normalizeAndStageSingleKeyedPayload(keys[0],[],{eTag:payload.eTag});}else {const{normalized,denormalized}=keys.reduce((result,key)=>{// the following call fully stages up single keyed payload and their dependencies
    const[singleKeyedPayloadCacheKey,singleKeyedPayloadToEmit]=normalizeAndStageSingleKeyedPayload(key,[cacheKey]);// replaces single keyed payload with a marker
    result.normalized.actions[key]={key:serialize(singleKeyedPayloadCacheKey)};result.denormalized.actions[key]=singleKeyedPayloadToEmit.actions[key];return result;},{normalized:{actions:{}},denormalized:{actions:{}}});// stages up multiple keyed payload
    cacheAccessor.stagePut([],cacheKey,normalized,denormalized,{eTag:payload.eTag});}}/**
     * A utility function to get cache value from the cache accessor.
     * The use of this function is private to de-normalization process since lds-cache currently never evicts
     * thus the function assumes the value always exists in the cache during de-normalization.
     *
     * @param cacheAccessor The cache accessor
     * @param cacheKey The cache key
     * @return The value of the value wrapper if exists
     */function getValue(cacheAccessor,cacheKey){const valueWrapper=cacheAccessor.get(cacheKey);if(valueWrapper&&valueWrapper.value){return valueWrapper.value;}throw new Error(`Value not found for cache key: ${serialize(cacheKey)}`);}/**
     * De-normalize an action payload. The call doesn't mutate the normalized payload in the cache. It doesn't emit payload with eTag.
     *
     * @param cacheAccessor The cache accessor
     * @param affectedKey The affected cache key of the payload to be de-normalized
     * @param fnForCacheKeyDependenciesOfKey A function provided by end point to specify the cache key given a key
     * @return A de-normalized action payload
     */function denormalizeValue(cacheAccessor,normalizedPayload){// a function to replace a marker with an action definition retrieved from the cache
    const restoreActionDefinition=normalizedAction=>{const{actionDefinition:actionDefinitionMarker}=normalizedAction,rest=_objectWithoutProperties(normalizedAction,["actionDefinition"]);// reconstruct the cache key by the marker
    const cacheKey=buildCacheKeyFromMarker(actionDefinitionMarker);const myValue=getValue(cacheAccessor,cacheKey);return Object.assign({},myValue,rest);};// a function to de-normalize single keyed payload, the value could either be a single action or a list of actions
    const denormalizeSingleKeyedPayload=payload=>{const actions=payload.actions.map(restoreActionDefinition);return {actions};};const keys=Object.keys(normalizedPayload.actions);if(keys.length===0){return {actions:{}};}else if(keys.length===1){// de-normalize the only key/value pair
    const key=keys[0];const actions=denormalizeSingleKeyedPayload(normalizedPayload.actions[key]);const singleKeyedPayload={actions:{}};singleKeyedPayload.actions[key]=actions;return singleKeyedPayload;}else {// de-normalize each key, replace each normalized value with de-normalized payload
    const multipleKeyedPayload={actions:_objectSpread$3({},normalizedPayload.actions)};Object.keys(multipleKeyedPayload.actions).map(key=>{const cacheKey=deserialize(multipleKeyedPayload.actions[key].key);const normalizedSingleKeyedPayload=getValue(cacheAccessor,cacheKey);// de-normalize single keyed payload
    const singleOrMultipleRawActions=denormalizeSingleKeyedPayload(normalizedSingleKeyedPayload.actions[key]);multipleKeyedPayload.actions[key]=singleOrMultipleRawActions;});return multipleKeyedPayload;}}// eslint-disable-next-line lwc/no-compat-execute
    /**
     * The ui api end point of lookup actions
     */const ACTIONS_GLOBAL_CONTROLLER="ActionsController.getLookupActions";/**
     * Service to retrieve lookup actions via UI API
     */class LookupActionsService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         * @param affectedKeyHandlerInspector Used by tests to inspect the affectedKeyHandler.
         * @param valueProviderFunctionInspector Used by tests to inspect the valueProviderFunction.
         */constructor(ldsCache,functionProvidesValueProviderFunction){super(ldsCache,[LOOKUP_ACTIONS_VALUE_TYPE]);/**
             * Implementation of affected key handler for this service
             */this.affectedKeyHandler=(affectedKey,cacheAccessor)=>{const oldValueWrapper=cacheAccessor.get(affectedKey);if(oldValueWrapper){const updatedActionPayloadToEmit=denormalizeValue(cacheAccessor,oldValueWrapper.value);const valueWrapper=cloneWithValueOverride(oldValueWrapper,updatedActionPayloadToEmit);cacheAccessor.stageEmit(affectedKey,valueWrapper);}};this._functionProvidesValueProviderFunction=functionProvidesValueProviderFunction;}getCacheValueTtl(){return LOOKUP_ACTIONS_TTL;}/**
         * @return A higher order of function that returns an affected key handler
         */getAffectedKeyHandler(){return this.affectedKeyHandler;}/**
         * Retrieves lookup actions
         *
         * @param objectApiNameArray Object API names of lookup actions to retrieve.
         * @param requestParams Options to filter the resulting actions by formFactor, sections, or actionTypes
         * @returns A collections of actions categorized by their associated object api name
         *
         */getLookupActions(objectApiNameArray,requestParams){const objectApiNames=objectApiNameArray.map(getObjectApiName);const parameters=Object.assign({},{objectApiNames},requestParams);const cacheKey=buildCacheKey$b(parameters.objectApiNames,parameters.formFactor,parameters.sections,parameters.actionTypes);const valueProviderFunction=this._functionProvidesValueProviderFunction?this._functionProvidesValueProviderFunction(cacheKey,parameters,false):this.getValueProviderFn(cacheKey,parameters,false);return this._ldsCache.get(cacheKey,new ValueProvider(valueProviderFunction,{}));}/**
         * Stage puts the given action.
         * @param dependencies List of dependent cache keys.
         * @param action The action to stagePut.
         * @param cacheAccessor An object to access cache directly.
         * @param lookupActionsParameters Data to build cache key with
         */stagePutValue(dependencies,action,cacheAccessor,lookupActionsParameters){const recordActionCacheKey=buildCacheKey$b(lookupActionsParameters.objectApiNames,lookupActionsParameters.formFactor,lookupActionsParameters.sections,lookupActionsParameters.actionTypes);return cacheAccessor.stagePut(dependencies,recordActionCacheKey,action,action);}/**
         * Strips all eTag properties from the given action by directly deleting them.
         * @param action The action from which to strip the eTags.
         * @returns The given action with its eTags stripped.
         */stripETagsFromValue(action){delete action.eTag;return action;}/**
         * Denormalizes the given normalizedValue and returns it.
         * @param normalizedValue The normalizedValue to denormalize.
         * @param cacheAccessor Used to access the cache.
         * @returns The denormalized lookup actions value.
         */denormalizeValue(normalizedValue,cacheAccessor){const denormalizedValue=denormalizeValue(cacheAccessor,normalizedValue);return denormalizedValue;}/**
         * A higher order function to provide a value provider function
         * @param cacheKey The cache key
         * @param params The lookup action parameters for the transaction
         * @param forceFetch Indicates whether a server round trip is forced
         * @return A value provider function
         */getValueProviderFn(cacheKey,params,forceFetch){return cacheAccessor=>{const cacheEntry=cacheAccessor.get(cacheKey);if(!forceFetch&&this.doesCacheEntryHasValue(cacheEntry)&&this.hasNotExpired(cacheAccessor.nowTime,cacheEntry)){return Thenable.resolve(1/* CACHE_HIT */);}return this.primeCacheEntries(params,cacheAccessor,cacheKey).then(result=>{if(cacheEntry&&cacheEntry.eTag&&result.eTag&&cacheEntry.eTag===result.eTag){return 3/* CACHE_MISS_REFRESH_UNCHANGED */;}else {return 2/* CACHE_MISS */;}});};}/**
         * Makes a server round trip and normalizes the response
         * @param parameters The lookup action parameters for the round trip
         * @param cacheAccessor The cache accessor for the transaction
         * @param cacheKey The cache key for the payload
         * @return The action representation
         */primeCacheEntries(parameters,cacheAccessor,cacheKey){return executeAuraGlobalController(ACTIONS_GLOBAL_CONTROLLER,parameters).then(response=>{const result=response.body;normalizePayload(cacheAccessor,this.getCacheKeyDependencyOfKey.bind(this,parameters),cacheKey,result);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return result;});}/**
         * Calculates the cache key and dependencies provided the parameters for the request
         * @param formFactor The form factor
         * @param sections The sections
         * @param actionTypes The action types
         * @param objectApiName The object api name
         * @return The cache key of the request along with their dependencies
         */getCacheKeyDependencyOfKey({formFactor,sections,actionTypes},objectApiName){const cacheKey=buildCacheKey$b([objectApiName],formFactor,sections,actionTypes);return {cacheKey,dependencies:[]};}/**
         * A function to check whether cache entry has expired
         * @param now Current timestamp
         * @param entry Cache entry
         * @returns Whether cache entry has expired
         */hasNotExpired(now,entry){return !isNaN(now)&&!isNaN(entry.lastFetchTime)&&now-entry.lastFetchTime<LOOKUP_ACTIONS_TTL;}/**
         * A function to check whether cache entry has a value
         * @param entry Cache entry
         * @return Whether the cache entry has a value
         */doesCacheEntryHasValue(entry){return entry?entry.value!==undefined:false;}}/**
     * Wire adapter id: getLookupActions.
     * @throws Always throws when invoked. Imperative invocation is not supported.
     */function getLookupActions(){throw generateError("getLookupActions");}/**
     * Generates the wire adapter for Lookup Actions.
     */class LookupActionsWireAdapterGenerator{/**
         * Constructor.
         * @param lookupActionsService Reference to the LookupActionsService instance.
         */constructor(lookupActionsService){this._lookupActionsService=lookupActionsService;}/**
         * Generates the wire adapter for getLookupActions.
         * @returns See description.
         */generateGetLookupActionsWireAdapter(){return generateWireAdapter(this.serviceGetLookupActions.bind(this));}/**
         * Service getLookupActions @wire.
         * @param config Config params for the service.
         * @return Observable stream that emits lookup actions.
         */serviceGetLookupActions(config){return this._lookupActionsService.getLookupActions(config.objectApiNames,config.requestParams);}}const LOOKUP_RECORDS_VALUE_TYPE="lds.LookupRecords";/**
     * Time to live for the LookupRecords cache value is 2 minutes.
     */const LOOKUP_RECORDS_TTL=2*60*1000;/**
     * Computes a key for lookup records caching.
     * @param fieldApiName - The qualified field api name.
     * @param targetApiName - The target entity api name.
     * @param requestParams - The request params to filter data.
     * @returns - A key for caching.
     */function computeKey(fieldApiName="",targetApiName="",requestParams={}){const requestParamKeys=Object.keys(requestParams).sort();const paramKeys=[];requestParamKeys.forEach(key=>{paramKeys.push(key);paramKeys.push(String(requestParams[key]));});// TODO - W-5590585 - Make lookups UI API and wire adapter case insensitive.
    // Currently, lookups UI API supports case insensitive targetApiName hence lowercase it while building key.
    return `${fieldApiName}${KEY_DELIM}${targetApiName.toLowerCase()}${KEY_DELIM}${paramKeys.join(KEY_DELIM)}`;}/**
     * Builds a cache key.
     * @param fieldApiName - The fieldApiName used to build the cache key.
     * @param targetApiName - The targetApiName used to build the cache key.
     * @param requestParams - The requestParams used to build the cache key.
     */function buildCacheKey$d(fieldApiName,targetApiName,requestParams){{assert$2(fieldApiName,"A non-empty fieldApiName must be provided.");assert$2(targetApiName,"A non-empty targetApiName must be provided.");assert$2(requestParams,"A non-empty requestParams must be provided.");}return {type:LOOKUP_RECORDS_VALUE_TYPE,key:computeKey(fieldApiName,targetApiName,requestParams)};}/**
     * Provides functionality to fetch lookup results for records.
     */class LookupRecordsService extends LdsServiceBase{constructor(ldsCache){super(ldsCache,[LOOKUP_RECORDS_VALUE_TYPE]);}getCacheValueTtl(){return LOOKUP_RECORDS_TTL;}/**
         * Gets lookup records.
         * @param fieldApiName - The qualified field API name.
         * @param targetApiName - The target object API name.
         * @param requestParams - Request params to filter data.
         * @returns - The observable used to get the value and keep watch on it for changes.
         */getLookupRecords(fieldApiName,targetApiName,requestParams={}){fieldApiName=getFieldApiName(fieldApiName);targetApiName=getObjectApiName(targetApiName);const cacheKey=buildCacheKey$d(fieldApiName,targetApiName,requestParams);const valueProviderParameters={cacheKey,fieldApiName,targetApiName,requestParams};const valueProvider=this._getValueProvider(valueProviderParameters);return this._ldsCache.get(cacheKey,valueProvider);}/**
         * Creates a ValueProvider for the LookupRecords.
         * @param valueProviderParams - Parameters to create ValueProvider for LookupRecords.
         * @returns - A value Provider instance.
         */_getValueProvider(valueProviderParams){const valueProvider=new ValueProvider((cacheAccessor,valueProviderParameters)=>{const{cacheKey,fieldApiName,targetApiName,requestParams,localFreshLookupRecords,forceProvide}=valueProviderParameters;if(forceProvide){return this._getFreshValue(cacheAccessor,cacheKey,fieldApiName,targetApiName,requestParams,localFreshLookupRecords);}const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;const needsRefresh=nowTime>lastFetchTime+LOOKUP_RECORDS_TTL;if(needsRefresh){// The value is stale, get a fresh one.
    return this._getFreshValue(cacheAccessor,cacheKey,fieldApiName,targetApiName,requestParams,localFreshLookupRecords,existingValueWrapper.eTag);}// The value is not stale so it's a cache hit.
    return Thenable.resolve(1/* CACHE_HIT */);}// No existing value, get a fresh value.
    return this._getFreshValue(cacheAccessor,cacheKey,fieldApiName,targetApiName,requestParams,localFreshLookupRecords);},valueProviderParams);return valueProvider;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor - An object to transactionally access the cache.
         * @param cacheKey - The cache key for the object info.
         * @param fieldApiName - The qualified field api name.
         * @param targetApiName - The target entity api name.
         * @param requestParams - Request params to filter data.
         * @param localFreshLookupRecords - Lookup records value you want explicitly put into cache instead of getting the value from the server.
         * @param eTagToCheck - eTag to send to the server to determine if we already have the latest value. If we do the server will return a 304.
         * @returns - A thenable of ValueProviderResult representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,cacheKey,fieldApiName,targetApiName,requestParams,localFreshLookupRecords,eTagToCheck){let transportResponseThenable;const params={fieldApiName,targetApiName,requestParams};// If the lookup records are provided, we don't go to the server to fetch it.
    if(localFreshLookupRecords){transportResponseThenable=Thenable.resolve(getOkFetchResponse(localFreshLookupRecords));}else {if(eTagToCheck){params.clientOptions={eTagToCheck};}// TODO - W-5528819 @wire(getLookupRecords) and LookupController.getLookupRecords params are inconsistent.
    const[objectApiName,unqualifiedFieldApiName]=splitQualifiedFieldApiName(fieldApiName);const auraControllerParams=_objectSpread$3({objectApiName,fieldApiName:unqualifiedFieldApiName,targetApiName},requestParams);transportResponseThenable=executeAuraGlobalController("LookupController.getLookupRecords",auraControllerParams);}return transportResponseThenable.then(transportResponse=>{// Cache miss refresh unchanged.
    if(transportResponse.status===304){return 3/* CACHE_MISS_REFRESH_UNCHANGED */;}const freshValue=transportResponse.body;cacheAccessor.stageClearDependencies(cacheKey);this.stagePutValue([],freshValue,cacheAccessor,params);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}/**
         * Stage puts the given lookup records.
         * @param dependencies - A list of dependent cache keys.
         * @param lookupRecords - The lookup records value to cache.
         * @param cacheAccessor - An object to access cache directly.
         * @returns - A thenable on completing the stagePut operation.
         */stagePutValue(dependencies,lookupRecords,cacheAccessor,params){const cacheKey=buildCacheKey$d(params.fieldApiName,params.targetApiName,params.requestParams);const existingValueWrapper=cacheAccessor.get(cacheKey);const eTag=lookupRecords.eTag;if(existingValueWrapper&&existingValueWrapper.eTag===eTag){cacheAccessor.stageDependencies(dependencies,cacheKey);cacheAccessor.stagePutUpdateLastFetchTime(cacheKey);return;}// Strip out the eTag from the value.
    lookupRecords=this.stripETagsFromValue(lookupRecords);cacheAccessor.stagePut(dependencies,cacheKey,lookupRecords,lookupRecords,{eTag});}/**
         * Strips eTag from the given LookupRecords.
         * @param LookupRecords - The LookupRecords from which to strip the eTag.
         * @returns - LookupRecords without eTag.
         */stripETagsFromValue(lookupRecords){delete lookupRecords.eTag;return lookupRecords;}}/**
     * Generates the wire adapter for Lookup Records.
     */class LookupRecordsWireAdapterGenerator{/**
         * Constructor.
         * @param lookupRecordsService - Reference to the LookupRecordsService instance.
         */constructor(lookupRecordsService){this._lookupRecordsService=lookupRecordsService;}/**
         * Generates the wire adapter for @wire getLookupRecords.
         */generateGetLookupRecordsWireAdapter(){const wireAdapter=generateWireAdapter(this.serviceGetLookupRecords.bind(this));return wireAdapter;}/**
         * Service @wire getLookupRecords.
         * @private Made public for testing.
         * @param config - Config params for the service.
         * @returns - An observable stream that emits lookup records.
         */serviceGetLookupRecords(config){if(!config||!config.fieldApiName||!config.targetApiName){return undefined;}return this._lookupRecordsService.getLookupRecords(config.fieldApiName,config.targetApiName,config.requestParams);}}/**
     * Return the wire adapter id.
     */function getLookupRecords(){throw generateError("getLookupRecords");}/**
     * The valueType to use when building RecordLayoutCacheKeys.
     */const RECORD_LAYOUT_VALUE_TYPE="lds.ModuleRecordLayout";/**
     * The valueType to use when building DescriptorRecordLayout.
     */const DESCRIPTOR_RECORD_LAYOUT_VALUE_TYPE="lds.DescriptorRecordLayout";/**
     * Time to live for the RecordLayout cache value. 30 days.
     */const RECORD_LAYOUT_VALUES_TTL=2592000000;/**
     * The master record type id.
     */const MASTER_RECORD_TYPE_ID$3="012000000000000AAA";/**
     * Constructs a cache key for the layout descriptor value type.
     * @param objectApiName The object api name with which the layout descriptor is associated.
     * @param recordTypeId The record type id with which the layout descriptor is associated.
     * @param layoutType The layout type with which the layout descriptor is associated.
     * @param mode The mode with which the layout descriptor is associated.
     * @param dynamicComponentType The dynamicComponentType with which the layout descriptor is associated.
     * @returns A new cache key representing the descriptor record layout value type.
     */function buildDescriptorLayoutCacheKey(objectApiName,recordTypeId,layoutType,mode,dynamicComponentType){{assert$2(objectApiName,"A non-empty objectApiName must be provided.");assert$2(recordTypeId!==null&&recordTypeId!==undefined,"recordTypeId must be defined.");assert$2(layoutType,"A non-empty layoutType must be provided.");assert$2(mode,"A non-empty mode must be provided.");assert$2(dynamicComponentType,"A non-empty dynamic component type must be provided.");}return {type:DESCRIPTOR_RECORD_LAYOUT_VALUE_TYPE,key:`${objectApiName.toLowerCase()}${KEY_DELIM}${recordTypeId}${KEY_DELIM}${layoutType.toLowerCase()}${KEY_DELIM}${mode}${KEY_DELIM}${dynamicComponentType}`};}/**
     * Returns a DescriptorLayoutCacheKeyParams based on a cacheKey.
     * @param cacheKey The cacheKey object for layout
     * @returns A DescriptorLayoutCacheKeyParams based on a cacheKey.
     */function getDescriptorLayoutCacheKeyParams(cacheKey){const key=cacheKey.key;const localKeyParts=key.split(KEY_DELIM);{assert$2(cacheKey.type===DESCRIPTOR_RECORD_LAYOUT_VALUE_TYPE,`valueType was expected to be DESCRIPTOR_RECORD_LAYOUT_VALUE_TYPE but was not: ${cacheKey.type.toString()}`);assert$2(localKeyParts.length===5,`localKeyParts did not have the required parts(objectApiName, recordTypeId, layoutType, mode and dynamicComponentType): ${localKeyParts}`);}return {objectApiName:localKeyParts[0],recordTypeId:localKeyParts[1],layoutType:localKeyParts[2],mode:localKeyParts[3],dynamicComponentType:localKeyParts[4]};}/**
     * Constructs a cache key for the record layout value type.
     * @param recordId The record id with which the record layout is associated.
     * @param mode The mode with which the record layout is associated.
     * @param layoutType The layout type with which the record layout is associated.
     * @param dynamicComponentType The dynamic component type with which the record layout is associated.
     * @param objectApiName The API name of the record identified by recordId.
     * @returns A new cache key representing the record layout value type.
     */function buildRecordLayoutCacheKey(recordId,mode,layoutType,dynamicComponentType,objectApiName){{assert$2(recordId,"A recordId must be provided to build a RecordLayoutCacheKey");assert$2(layoutType,"A non-empty layoutType must be provided.");assert$2(mode,"A non-empty mode must be provided.");assert$2(dynamicComponentType,"A non-empty dynamic component type must be provided.");assert$2(objectApiName,"A non-empty objectApiName must be provided.");assert$2(recordId.length===18,"Record Id length should be 18 characters.");}return {type:RECORD_LAYOUT_VALUE_TYPE,key:`${recordId}${KEY_DELIM}${layoutType.toLowerCase()}${KEY_DELIM}${mode.toLowerCase()}${KEY_DELIM}${dynamicComponentType}${KEY_DELIM}${objectApiName.toLowerCase()}`};}/**
     * Returns a RecordLayoutCacheKeyParams based on a cacheKey. Throws an error if it can't be done because a bad string is provided.
     * @param cacheKey The cacheKey object for layout
     * @returns A RecordLayoutCacheKeyParams based on a cacheKey.
     */function getRecordLayoutCacheKeyParams(cacheKey){const key=cacheKey.key;const localKeyParts=key.split(KEY_DELIM);{assert$2(localKeyParts.length===5,`localKeyParts did not have the required parts(recordId, layoutType, mode and dynamicComponentType): ${localKeyParts}`);assert$2(cacheKey.type===RECORD_LAYOUT_VALUE_TYPE,`valueType was expected to be RECORD_LAYOUT_VALUE_TYPE but was not: ${cacheKey.type.toString()}`);}return {recordId:localKeyParts[0],layoutType:localKeyParts[1],mode:localKeyParts[2],dynamicComponentType:localKeyParts[3],objectApiName:localKeyParts[4]};}/**../../shared/utils/template/template-utils
     * TODO: Split out this service into two (one for each value provider).
     * Provides functionality to fetch layout descriptor from the cache. Can refresh the data from the server.
     */class RecordLayoutService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         * @param adsBridge Reference to the AdsBridge instance.
         */constructor(ldsCache,adsBridge,getServiceConfiguration){super(ldsCache,[DESCRIPTOR_RECORD_LAYOUT_VALUE_TYPE,RECORD_LAYOUT_VALUE_TYPE]);/**
             * Mapping of module observable cache key -> module observable.
             */this._moduleObservables=new Map();this._adsBridge=adsBridge;this._getServiceConfiguration=getServiceConfiguration;}getCacheValueTtl(){return RECORD_LAYOUT_VALUES_TTL;}/**
         * Gets a layout template's descriptor.
         * @param recordId The record id for which the layout descriptor is being requested.
         * @param layoutType The layout type for which the layout descriptor is being requested.
         * @param mode The mode for which the layout descriptor is being requested.
         * @param dynamicComponentType The component for which this layout is loaded.
         * @param objectApiName The apiName for the entity of the record of the given recordId.
         * @returns An observable that emits the layout descriptor.
         */getLayoutTemplateDescriptor(recordId,layoutType,mode,dynamicComponentType,objectApiName){checkType(recordId,String);checkType(layoutType,String);checkType(mode,String);checkType(dynamicComponentType,String);checkType(objectApiName,String);recordId=to18(recordId);const recordLayoutCacheKey=buildRecordLayoutCacheKey(recordId,mode,layoutType,dynamicComponentType,objectApiName);const valueProviderParameters={recordLayoutCacheKey,recordId,layoutType,mode,dynamicComponentType,objectApiName,forceProvide:false,recordTypeChanged:false};return this._ldsCache.get(recordLayoutCacheKey,this._createLayoutTemplateDescriptorValueProvider(valueProviderParameters));}/**
         * Stage puts the given dynamicComponentDescriptor.
         * @param dependencies An array of dependent cache keys.
         * @param dynamicComponentDescriptor The dynamicComponentDescriptor to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         */stagePutValue(dependencies,dynamicComponentDescriptor,cacheAccessor,additionalData){const layoutDescriptorCacheKey=buildDescriptorLayoutCacheKey(additionalData.objectApiName,additionalData.recordTypeId,additionalData.layoutType,additionalData.mode,additionalData.dynamicComponentType);const recordLayoutCacheKey=buildRecordLayoutCacheKey(additionalData.recordId,additionalData.mode,additionalData.layoutType,additionalData.dynamicComponentType,additionalData.objectApiName);this._normalizeAndStagePutComponentDescriptor(dependencies,cacheAccessor,additionalData.recordId,layoutDescriptorCacheKey,recordLayoutCacheKey,dynamicComponentDescriptor);}/**
         * Strips all eTag properties from the given dynamicComponentDescriptor by directly deleting them.
         * @param dynamicComponentDescriptor The dynamicComponentDescriptor from which to strip the eTags.
         * @returns The given dynamicComponentDescriptor with its eTags stripped.
         */stripETagsFromValue(dynamicComponentDescriptor){return dynamicComponentDescriptor;}/**
         * Returns the recordTypeId if it's present on the record. Otherwise, returns null.
         * @param record The record to get the recordTypeId from
         */_getRecordTypeIdFromRecord(record){// TODO W-6281152 - if the recordTypeInfo is undefined, the record has been loaded without it.
    // this is possible if this record was loaded as a nested record.
    if(!("recordTypeInfo"in record)){return undefined;}// a falsy recordTypeInfo or recordTypeId is equivalent to the master record type
    if(!record.recordTypeInfo||!record.recordTypeInfo.recordTypeId){return MASTER_RECORD_TYPE_ID$3;}return record.recordTypeInfo.recordTypeId;}/**
         * Get the record from the LDS cache, ADS cache, or fetch it from the server. Only return the record from
         * the cache if it contains a recordTypeId.
         *
         * @param recordId the recordID for the record being requested.
         * @param layoutType the layoutType used to populate the record request when fetching from the server.
         * @param objectApiName the API name of the entity for the record with the provided recordId.
         */_getOrFetchRecord(cacheAccessor,recordId,objectApiName){const recordCacheKey=buildRecordCacheKey(recordId);// get the record from the LDS cache only. if the record exists, return the record only if the rtId is present.
    const cachedRecordWrapper=cacheAccessor.get(recordCacheKey);const recordFromLds=cachedRecordWrapper&&cachedRecordWrapper.value&&cachedRecordWrapper.value;if(recordFromLds&&this._getRecordTypeIdFromRecord(recordFromLds)){return Thenable.resolve(recordFromLds);}// if not present in the LDS cache, then check the ADS cache.
    let getRecordFromAdsPromise;if(this._adsBridge&&this._adsBridge.getBaseRecordDataFromCacheCallback){getRecordFromAdsPromise=this._adsBridge.getBaseRecordDataFromCacheCallback(recordId);}else {getRecordFromAdsPromise=Thenable.resolve(null);}// only return the record from ADS if the rtId is present.
    return getRecordFromAdsPromise.then(recordFromAds=>{if(recordFromAds&&this._getRecordTypeIdFromRecord(recordFromAds)){return recordFromAds;}// nothing in either the LDS or ADS cache. fetch a fresh record from the server.
    // we really want the recordTypeId here, but rtId won't be present on objects without record types, so supply the Id
    // to satisfy the field list requirement
    const qualifiedIdFieldName=objectApiName+".Id";return observableToPromise(this._recordService.getRecordWithFieldsWithMetaConfig(recordId,[qualifiedIdFieldName],[],{forceProvide:true}),true).catch(()=>{// if we can't get the record from checking the cache, then allow the flow to continue to get a fresh layout
    return null;});});}/**
         * Gets a layout template as module.
         * @param recordId The record id for which the layout descriptor is being requested.
         * @param layoutType The layout type for which the layout descriptor is being requested.
         * @param mode The mode for which the layout descriptor is being requested.
         * @param dynamicComponentType The component for which this layout is loaded.
         * @param objectApiName the API name of the entity for the record with the provided recordId.
         * @returns An observable that emits the layout template module.
         */getLayoutTemplateModule(recordId,layoutType,mode,dynamicComponentType,objectApiName){checkType(recordId,String);checkType(layoutType,String);checkType(mode,String);checkType(dynamicComponentType,String);checkType(objectApiName,String);const recordLayoutCacheKey=buildRecordLayoutCacheKey(recordId,mode,layoutType,dynamicComponentType,objectApiName);this.getLayoutTemplateDescriptor(recordId,layoutType,mode,dynamicComponentType,objectApiName);// check if we already have a module observable for the layout template, and create it if not
    const _moduleObservables=this._moduleObservables;const moduleObservable=_moduleObservables.get(serialize(recordLayoutCacheKey));if(!moduleObservable){// We pass observables.unwrapped here
    const observables=this._ldsCache.getOrCreateObservables(recordLayoutCacheKey,this.getCacheValueTtl());const newObservable=this._constructModuleObservable(recordLayoutCacheKey,observables.finalTransformed);_moduleObservables.set(serialize(recordLayoutCacheKey),newObservable);return newObservable;}return moduleObservable;}/**
         * Affected key handler for RecordLayoutDynamicComponent values. The cache will call this handler when a RecordLayoutDynamicComponent cache value
         * could have been affected by a change in another related cache key value.
         * @returns The affected key handler for this service.
         */getAffectedKeyHandler(){return (affectedKey,cacheAccessor)=>{// TODO: Once this service is split into multiple services, the following check for the secondary types can be removed.
    // We don't want to handle affected keys for any secondary types.
    if(affectedKey.type===DESCRIPTOR_RECORD_LAYOUT_VALUE_TYPE){return;}const normalizedRecordLayoutValueWrapper=cacheAccessor.get(affectedKey);if(normalizedRecordLayoutValueWrapper){// Fetch params from affected key
    const recordLayoutCacheKeyParams=getRecordLayoutCacheKeyParams(affectedKey);const recordId=recordLayoutCacheKeyParams.recordId;const layoutType=recordLayoutCacheKeyParams.layoutType;const mode=recordLayoutCacheKeyParams.mode;const dynamicComponentType=recordLayoutCacheKeyParams.dynamicComponentType;const objectApiName=recordLayoutCacheKeyParams.objectApiName;// Figure out if the recordTypeId of the record has changed
    const recordCacheKey=buildRecordCacheKey(recordId);const refreshedRecordValueWrapper=cacheAccessor.getCommitted(recordCacheKey);const existingRecord=normalizedRecordLayoutValueWrapper.value;const existingRecordTypeId=existingRecord.recordTypeId;let recordTypeChanged=false;if(refreshedRecordValueWrapper){const refreshedRecord=refreshedRecordValueWrapper.value;{assert$2(refreshedRecord,`unexpected falsy value for refreshedRecord: ${refreshedRecord}`);}const newRecordTypeId=refreshedRecord.recordTypeInfo?refreshedRecord.recordTypeInfo.recordTypeId:MASTER_RECORD_TYPE_ID$3;if(newRecordTypeId!==existingRecordTypeId){recordTypeChanged=true;}}if(!recordTypeChanged){// if recordTypeId has not changed, there is no need to force refresh, denorm the value of component descriptor and emit
    const denormedComponentDescriptor=this._denormalizeRecordLayout(existingRecord,cacheAccessor,affectedKey);if(denormedComponentDescriptor&&hasModule(denormedComponentDescriptor)){const componentDescriptorValueWrapperToEmit=cloneWithValueOverride(normalizedRecordLayoutValueWrapper,denormedComponentDescriptor);cacheAccessor.stageEmit(affectedKey,componentDescriptorValueWrapperToEmit);return;}}// When recordTypeId has changed, we need to do figure out whether we need a full refresh of the recordLayoutCache.
    // or the layout descriptor with updated recordType already exists in cache.
    // However we're already in a cache transaction.
    // Kick this to a Promise to get this out of the cache operation we're already in the middle of.
    // and then figure out if we have everything required in cache or we need to queue a fresh request
    Promise.resolve().then(()=>{const forceProvide=false;// For now set it to false, if we cannot find the updated layout descriptor in cache, we will make it forceProvide
    recordTypeChanged=true;// we know that record type has changed, so ignore the force provide until we cannot find the updated layout descriptor in cache
    const vpArgs={recordLayoutCacheKey:affectedKey,recordId,layoutType,mode,dynamicComponentType,objectApiName,forceProvide,recordTypeChanged};this._ldsCache.get(affectedKey,this._createLayoutTemplateDescriptorValueProvider(vpArgs));return undefined;});}};}/**
         * Constructs an Observable that will emit a record with only those fields given by the requiredFields and optionalFields parameters.
         * If a required field is missing during an emit attempt, an error will be emitted. If an optional field is missing then it will be ignored.
         * @param recordLayoutCacheKey The record layout templatekey identifying the module observable.
         * @param observableToFilter The observable that emits an aura module
         * @returns Observable An observable the emits an aura module
         */_constructModuleObservable(recordLayoutCacheKey,observableToFilter){let moduleObservable=observableToFilter;moduleObservable=moduleObservable.filter(hasModule).map(getModule);// Subscribe to the new filtered observable so that when it completes (or errors) we know to remove the filtered observable from the map.
    const errorCompleteSubscription=moduleObservable.subscribe({next:()=>{/* do nothing */},error:()=>{this._moduleObservables.delete(serialize(recordLayoutCacheKey));},complete:()=>{this._moduleObservables.delete(serialize(recordLayoutCacheKey));}});// Decorate the subscribe method to return a Subscription instance with a decorated unsubscribe method which will dispose the module observable if
    // the subscriptions count drops below 1. (Not 0 because of the above subscription which will always be there but doesn't signify that
    // there is someone interested in this module observable externally.
    const _moduleObservables=this._moduleObservables;const originalSubscribeFn=moduleObservable.subscribe;moduleObservable.subscribe=(observer,...args)=>{const originalSubscription=originalSubscribeFn.call(moduleObservable,observer,...args);if(originalSubscription){const originalSubscriptionUnsubscribeFn=originalSubscription.unsubscribe;originalSubscription.unsubscribe=()=>{originalSubscriptionUnsubscribeFn.call(originalSubscription);if(moduleObservable.subscriptions.size<=1){if(errorCompleteSubscription&&!errorCompleteSubscription.closed){errorCompleteSubscription.unsubscribe();}_moduleObservables.delete(serialize(recordLayoutCacheKey));}};}return originalSubscription;};return moduleObservable;}/**
         * Constructs a value provider to retrieve a layout descriptor.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns The value provider to retrieve a layout descriptor.
         */_createLayoutTemplateDescriptorValueProvider(valueProviderParameters){const{recordLayoutCacheKey,recordId,layoutType,mode,dynamicComponentType,objectApiName,forceProvide,recordTypeChanged}=valueProviderParameters;const layoutTemplateDescriptorValueProvider=new ValueProvider(cacheAccessor=>{cacheAccessor=wrapCacheAccessor(cacheAccessor,this._adsBridge);// W-5043986: Fix this as part of this story.
    // if recordType has changed, then look for layout descriptor with new recordType in cache, and if the layout descriptor with new recordType is not present in cache,
    // we fetch everything from DynamicComponentController
    if(recordTypeChanged){return this._lookForLayoutDescriptorInCache(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,objectApiName);}if(forceProvide||this._getServiceConfiguration(USE_ADG_CONFIGURATION_KEY)){return this._getRecordAndGetFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,objectApiName);}const existingValueWrapper=cacheAccessor.get(recordLayoutCacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;// check for ttl expiry
    const needsRefresh=nowTime>lastFetchTime+RECORD_LAYOUT_VALUES_TTL;if(needsRefresh){// Trigger a refresh. We don't care about the return value of this, we just need to force an API call
    // to keep the Observable's data stream alive.
    return this._getRecordAndGetFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,objectApiName);}return Thenable.resolve(1/* CACHE_HIT */);}// look for layout descriptor in cache, and it the layout descriptor is not present in cache,
    // we fetch everything from DynamicComponentController
    return this._lookForLayoutDescriptorInCache(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,objectApiName);},valueProviderParameters);return layoutTemplateDescriptorValueProvider;}/**
         * Normalize the layout descriptor and create dependency for record layout on the layout descriptor and the record.
         * @param dependencies Dependencies on the record layout.
         * @param cacheAccessor An object to access cache directly.
         * @param recordId The id of the record on which the record layout depends.
         * @param layoutDescriptorCacheKey Cache key for layout descriptor.
         * @param recordLayoutCacheKey Cache key for record layout.
         * @param dynamicComponentDescriptor The layout descriptor that needs to be normalized.
         * @returns True if the operation succeeded, else false.
         */_normalizeAndStagePutComponentDescriptor(dependencies,cacheAccessor,recordId,layoutDescriptorCacheKey,recordLayoutCacheKey,dynamicComponentDescriptor){// stage the dependency for record layout cache key on the record cache key so that if recordTypeId changes, then we get notified and we can handle the changes appropriately
    const recordCacheKey=buildRecordCacheKey(recordId);cacheAccessor.stageDependencies([{cacheKey:recordLayoutCacheKey,type:2/* NOTIFICATION */}],recordCacheKey);const normalizedObjectComponentDescriptor=this._getNormalizedComponentDescriptor(layoutDescriptorCacheKey);cacheAccessor.stagePut([{cacheKey:recordLayoutCacheKey,type:2/* NOTIFICATION */}],layoutDescriptorCacheKey,dynamicComponentDescriptor,dynamicComponentDescriptor);cacheAccessor.stagePut(dependencies,recordLayoutCacheKey,normalizedObjectComponentDescriptor,dynamicComponentDescriptor);}/**
         * Stage put record layout and stage dependencies on the already existing layout descriptor and record that exists in cache.
         * @param cacheAccessor An object to access cache directly.
         * @param recordId The id of the record on which the record layout depends.
         * @param layoutDescriptorCacheKey Cache key for layout descriptor.
         * @param recordLayoutCacheKey Cache key for record layout.
         * @param dynamicComponentDescriptor The layout descriptor that needs to be normalized.
         * @returns True if the operation succeeded, else false.
         */_stageDependencyNormalizeAndStagePutRecordLayout(cacheAccessor,recordId,layoutDescriptorCacheKey,recordLayoutCacheKey,dynamicComponentDescriptor){// Stage the dependency for record layout cache key on the record cache key so that if recordTypeId changes, then we get notified and we can handle the changes appropriately
    const recordCacheKey=buildRecordCacheKey(recordId);cacheAccessor.stageDependencies([{cacheKey:recordLayoutCacheKey,type:2/* NOTIFICATION */}],recordCacheKey);// Stage dependency for record layout cache key on the layout descriptor
    cacheAccessor.stageDependencies([{cacheKey:recordLayoutCacheKey,type:1/* REQUIRED */}],layoutDescriptorCacheKey);// Normalize and stage put the layout component descriptor
    const normalizedObjectComponentDescriptor=this._getNormalizedComponentDescriptor(layoutDescriptorCacheKey);cacheAccessor.stagePut([],recordLayoutCacheKey,normalizedObjectComponentDescriptor,dynamicComponentDescriptor);}/**
         * Helper function to normalize and create marker for layout component descriptor.
         * @param layoutDescriptorCacheKey Cache key for the layout descriptor.
         * @returns Record layout marker.
         */_getNormalizedComponentDescriptor(layoutDescriptorCacheKey){const descriptorLayoutCacheKeyParams=getDescriptorLayoutCacheKeyParams(layoutDescriptorCacheKey);const normalizedObjectComponentDescriptor={objectApiName:descriptorLayoutCacheKeyParams.objectApiName,recordTypeId:descriptorLayoutCacheKeyParams.recordTypeId,layoutType:descriptorLayoutCacheKeyParams.layoutType,mode:descriptorLayoutCacheKeyParams.mode,dynamicComponentType:descriptorLayoutCacheKeyParams.dynamicComponentType};return normalizedObjectComponentDescriptor;}/**
         * Takes the normalized record layout and cacheAccessor and returns the denormalized record layout.
         * @param normalizedRecordLayout The record layout to be denormalized. This should always be a normalized record layout that came from the cache.
         * @param cacheAccessor The CacheAccessor in scope for this operation.
         * @param recordLayoutCacheKey Cache key for the record layout.
         * @returns The denormalized record layout.
         */_denormalizeRecordLayout(normalizedRecordLayout,cacheAccessor,recordLayoutCacheKey){{assert$2(recordLayoutCacheKey.type===RECORD_LAYOUT_VALUE_TYPE,`Expected RECORD_LAYOUT_VALUE_TYPE value type for RecordLayout: ${recordLayoutCacheKey.type.toString()}`);}const objToClone=normalizedRecordLayout;let denormalizedRecordLayout=objToClone;// build the layout descriptor cache key object
    const layoutDescriptorCacheKey=buildDescriptorLayoutCacheKey(normalizedRecordLayout.objectApiName,normalizedRecordLayout.recordTypeId,normalizedRecordLayout.layoutType,normalizedRecordLayout.mode,normalizedRecordLayout.dynamicComponentType);const layoutDescriptorValueWrapper=cacheAccessor.get(layoutDescriptorCacheKey);if(layoutDescriptorValueWrapper){denormalizedRecordLayout=layoutDescriptorValueWrapper.value;}return denormalizedRecordLayout;}/**
         * Helper method to build the layout descriptor cache key.
         * @param record The record used to fetch the recordTypeId to construct the layout descriptor cache key.
         * @param layoutType The layout type used to construct the layout descriptor cache key.
         * @param mode The mode used to construct the layout descriptor cache key.
         * @param dynamicComponentType The component for which this layout is loaded.
         * @returns The layout descriptor cache key.
         */_buildLayoutDescriptorCacheKeyWithRecord(record,layoutType,mode,dynamicComponentType){const recordTypeId=record.recordTypeInfo?record.recordTypeInfo.recordTypeId:MASTER_RECORD_TYPE_ID$3;return this._buildLayoutDescriptorCacheKey(record.apiName,recordTypeId,layoutType,mode,dynamicComponentType);}/**
         * Helper method to build the layout descriptor cache key.
         * @param apiName The api name used to construct the layout descriptor cache key.
         * @param recordTypeId The recordTypeId used to construct the layout descriptor cache key.
         * @param layoutType The layout type used to construct the layout descriptor cache key.
         * @param mode The mode used to construct the layout descriptor cache key.
         * @param dynamicComponentType The component for which this layout is loaded.
         * @returns The layout descriptor cache key.
         */_buildLayoutDescriptorCacheKey(apiName,recordTypeId,layoutType,mode,dynamicComponentType){return buildDescriptorLayoutCacheKey(apiName,recordTypeId,layoutType,mode,dynamicComponentType);}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to access cache directly.
         * @param recordId The id of the record on which the record layout depends.
         * @param layoutType The layout type for which the layout descriptor is being requested.
         * @param mode The mode for which the layout descriptor is being requested.
         * @param dynamicComponentType The component for which this layout is loaded.
         * @param recordLayoutCacheKey Cache key for record layout.
         * @param dynamicComponentDescriptor The layout descriptor that needs to be normalized. Optional.
         * @param layoutDescriptorCacheKey layoutDescriptorCacheKey Cache key for layout descriptor. Optional.
         * @param recordTypeId the recordTypeId of the record of the record layout. Optional
         * @param apiName the object API name of the record for the record layout. Optional
         */_getFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,dynamicComponentDescriptor,layoutDescriptorCacheKey,recordTypeId,objectApiName){recordTypeId=recordTypeId||"";objectApiName=objectApiName||"";let layoutTemplateDescriptorThenable;// If the dynamicComponentDescriptor is provided, we don't go to server to fetch it.
    if(dynamicComponentDescriptor){layoutTemplateDescriptorThenable=Thenable.resolve(undefined);}else {const params={type:dynamicComponentType,params:{layoutType,mode,objectApiName,recordTypeId},expansionHints:{recordId}};layoutTemplateDescriptorThenable=executeTemplateController(params,cacheAccessor,this._ldsCache,DESCRIPTOR_RECORD_LAYOUT_VALUE_TYPE,this._getServiceConfiguration);}return layoutTemplateDescriptorThenable.then(freshValue=>{if(!dynamicComponentDescriptor){{assert$2(freshValue.additionalParams.objectApiName,`objectApiName is required for record layout template`);assert$2(freshValue.additionalParams.recordTypeId,`objectApiName is required for record layout template`);}// build the layout descriptor cache key
    layoutDescriptorCacheKey=this._buildLayoutDescriptorCacheKey(freshValue.additionalParams.objectApiName,freshValue.additionalParams.recordTypeId,layoutType,mode,dynamicComponentType);dynamicComponentDescriptor=freshValue.descriptor;// normalize and stage put the component descriptor
    this._normalizeAndStagePutComponentDescriptor([],cacheAccessor,recordId,layoutDescriptorCacheKey,recordLayoutCacheKey,dynamicComponentDescriptor);}else {{assert$2(layoutDescriptorCacheKey,`layoutDescriptorCacheKey should be provided: $layoutDescriptorCacheKey`);}if(layoutDescriptorCacheKey){{assert$2(layoutDescriptorCacheKey.type!==undefined,`Value type for layout descriptor was undefined.`);assert$2(layoutDescriptorCacheKey.type===DESCRIPTOR_RECORD_LAYOUT_VALUE_TYPE,`Unexpected value type for layout: ${layoutDescriptorCacheKey.type.toString()}`);}// update dependency and stage put only the record layout
    this._stageDependencyNormalizeAndStagePutRecordLayout(cacheAccessor,recordId,layoutDescriptorCacheKey,recordLayoutCacheKey,dynamicComponentDescriptor);}}const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}/**
         * Gets the record to gather the recordTypeId and apiName. Then gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to access cache directly.
         * @param recordId The id of the record on which the record layout depends.
         * @param layoutType The layout type for which the layout descriptor is being requested.
         * @param mode The mode for which the layout descriptor is being requested.
         * @param dynamicComponentType The component for which this layout is loaded.
         * @param recordLayoutCacheKey Cache key for record layout.
         * @param objectApiName the API name of the entity for the record with the provided recordId.
         */_getRecordAndGetFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,objectApiName){return this._getOrFetchRecord(cacheAccessor,recordId,objectApiName).then(fetchedRecord=>{const recordTypeId=fetchedRecord?this._getRecordTypeIdFromRecord(fetchedRecord):undefined;// if we can't supply the rtId, then getFreshValue will fetch the layout using the recordId
    return this._getFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,undefined,undefined,recordTypeId,objectApiName);});}/**
         * Helper function to check the cache for a layout descriptor.
         * @param cacheAccessor An object to access cache directly.
         * @param recordId The id of the record on which the record layout depends.
         * @param layoutType The layout type for which the layout descriptor is being requested.
         * @param mode The mode for which the layout descriptor is being requested.
         * @param dynamicComponentType The component for which this layout is loaded.
         * @param objectApiName The API name of the entity for the record with the provided recordId.
         */_lookForLayoutDescriptorInCache(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,objectApiName){// get the record in the cache or fetch the record from the server so we can use the recordTypeId
    // to build a cache key and retrieve the template from the cache
    return this._getOrFetchRecord(cacheAccessor,recordId,objectApiName).then(fetchedRecord=>{const recordTypeId=fetchedRecord?this._getRecordTypeIdFromRecord(fetchedRecord):undefined;if(!fetchedRecord||!recordTypeId){// failed to retrieve the record or the recordTypeId. get a fresh value for the layout using the recordId
    return this._getFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey);}// build the layout descriptor cache key
    const layoutDescriptorCacheKey=this._buildLayoutDescriptorCacheKeyWithRecord(fetchedRecord,layoutType,mode,dynamicComponentType);// check if the layout descriptor exists in the cache
    const existingLayoutDescriptor=cacheAccessor.get(layoutDescriptorCacheKey);if(existingLayoutDescriptor&&existingLayoutDescriptor.value!==undefined){const existingLayoutDescriptorValue=existingLayoutDescriptor.value;const layoutNowTime=cacheAccessor.nowTime;const layoutLastFetchTime=existingLayoutDescriptor.lastFetchTime;// check for ttl expiry of the layout descriptor
    const layoutDescriptorNeedsRefresh=layoutNowTime>layoutLastFetchTime+RECORD_LAYOUT_VALUES_TTL||!hasModule(existingLayoutDescriptorValue);if(layoutDescriptorNeedsRefresh){// if layout descriptor is present in cache and ttl of layout descriptor has expired, then fetch everything from DynamicComponentController
    return this._getFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,undefined,undefined,recordTypeId,objectApiName);}// if layout descriptor is present in cache and ttl has not expired, then stagePut the descriptor and return CACHE_MISS
    return this._getFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,existingLayoutDescriptorValue,layoutDescriptorCacheKey,recordTypeId,objectApiName);}// if layout descriptor is not present in cache then fetch everything from DynamicComponentController
    return this._getFreshValue(cacheAccessor,recordId,layoutType,mode,dynamicComponentType,recordLayoutCacheKey,undefined,undefined,recordTypeId,objectApiName);});}/**
         * Reference to the RecordService instance.
         */get _recordService(){return this._ldsCache.getService(RECORD_VALUE_TYPE);}}/**
     * Wire adapter id: getRecordLayoutTemplate.
     * @throws Error - Always throws when invoked. Imperative invocation is not supported.
     */function getRecordLayoutTemplate(){throw generateError("getRecordLayoutTemplate");}/**
     * Generates the wire adapters for:
     *      * @wire getRecordLayoutTemplate
     */class RecordLayoutWireAdapterGenerator{/**
         * Constructor.
         * @param recordLayoutService Reference to the RecordLayoutService instance.
         */constructor(recordLayoutService){this._recordLayoutService=recordLayoutService;}/**
         * Generates the wire adapter for @wire getLayoutTemplate.
         * @returns See description.
         */generateGetRecordLayoutTemplateWireAdapter(){const wireAdapter=generateWireAdapter(this._serviceGetRecordLayoutTemplate.bind(this));return wireAdapter;}/**
         * @private Made public for testing.
         * Service @wire getRecordUi.
         * @param config Config params for the service. The type is or'd with any so that we can test sending bad configs. Consumers will be able to send us bad configs.
         * @return Observable stream that emits a record layout template object.
         */_serviceGetRecordLayoutTemplate(config){if(!config){return undefined;}if(!config.recordId||!config.layoutType||!config.mode||!config.dynamicComponentType||!config.objectApiName){return undefined;}const recordId=to18(config.recordId);return this._recordLayoutService.getLayoutTemplateModule(recordId,config.layoutType,config.mode,config.dynamicComponentType,config.objectApiName);}}/**
     * The valueType to use when building DescriptorFlexipage.
     */const FLEXIPAGE_DESCRIPTOR_VALUE_TYPE="lds.DescriptorFlexipage";/**
     * Time to live for a flexipage descriptor cache value. 30 days.
     */const FLEXIPAGE_DESCRIPTOR_TTL=2592000000;// 30 days.
    /**
     * Constructs a cache key for the Flexipage Template.
     * @param pageDeveloperName Developer Name of the Flexipage
     * @param objectApiName The object api name with which the Flexipage is associated.
     * @returns CacheKey A new cache key representing the Layout value type.
     */function buildCacheKey$e(pageDeveloperName,objectApiName){return {type:FLEXIPAGE_DESCRIPTOR_VALUE_TYPE,key:`${pageDeveloperName}${KEY_DELIM}${objectApiName}`};}/**
     * Generated Component Type for Flexipages
     */const FLEXIPAGE_GENERATED_COMPONENT_TYPE="Flexipage";/**
     * Flexipage save cookie
     */const FLEXIPAGE_SAVE_COOKIE="flexipagesSaved";/**
     * Provides functionality to read flexipage descriptor from the cache. Can refresh the data from the server.
     */class FlexipageService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache,getServiceConfiguration){super(ldsCache,[FLEXIPAGE_DESCRIPTOR_VALUE_TYPE]);this._ttl=FLEXIPAGE_DESCRIPTOR_TTL;this._getServiceConfiguration=getServiceConfiguration;}getCacheValueTtl(){return this._ttl;}setTtl(value){const ttl=parseInt(value,10);this._ttl=isNaN(ttl)?FLEXIPAGE_DESCRIPTOR_TTL:ttl;}/**
         * Strips all eTag properties from the given dynamicComponentDescriptor by directly deleting them.
         * @param dynamicComponentDescriptor The dynamicComponentDescriptor from which to strip the eTags.
         * @returns The given dynamicComponentDescriptor with its eTags stripped.
         */stripETagsFromValue(dynamicComponentDescriptor){return dynamicComponentDescriptor;}/**
         * Stage puts the given dynamicComponentDescriptor.
         * @param dependencies An array of dependent cache keys.
         * @param generatedComponentDescriptor The generatedComponentDescriptor to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         */stagePutValue(dependencies,generatedComponentDescriptor,cacheAccessor,additionalData){const cacheKey=buildCacheKey$e(additionalData.pageDeveloperName,additionalData.objectApiName);this.normalizeAndStagePut(dependencies,cacheKey,generatedComponentDescriptor,cacheAccessor);}/**
         * Normalizes and stage puts given generatedComponentDescriptor
         * @param dependencies An array of dependent cache keys.
         * @param cacheKey utilized by the value provider to fetch the value.
         * @param generatedComponentDescriptor The generatedComponentDescriptor to cache.
         * @param cacheAccessor An object to access cache directly.
         */normalizeAndStagePut(dependencies,cacheKey,generatedComponentDescriptor,cacheAccessor){cacheAccessor.stagePut(dependencies,cacheKey,generatedComponentDescriptor,generatedComponentDescriptor);}/**
         * Gets a Flexipage as a Module
         * @param pageDeveloperName The developer name of the page for which descriptor is being fetched.
         * @param objectApiName For Record Home/Object Home, Api Name of the Object flexipage belongs to.
         * @param expansionHints Expansion hints to be used for fetching dependent data
         * @returns The observable used to get the value and keep watch on it for changes.
         */getFlexipageTemplateModule(pageDeveloperName,objectApiName,expansionHints){const cacheKey=buildCacheKey$e(pageDeveloperName,objectApiName);this.getFlexipageDescriptor(pageDeveloperName,objectApiName,expansionHints);const observables=this._ldsCache.getOrCreateObservables(cacheKey,this.getCacheValueTtl());return this._constructModuleObservable(observables.finalTransformed);}/**
         * Retrieves flexipage descriptor from the cache. If it doesn't exist in the cache it will retrieve it from the server and put it into the cache.
         * @param pageDeveloperName The developer name of the page for which descriptor is being fetched.
         * @param objectApiName For Record Home/Object Home, Api Name of the Object flexipage belongs to.
         * @param expansionHints Expansion hints to be used for fetching dependent data
         * @returns The observable used to get the value and keep watch on it for changes.
         */getFlexipageDescriptor(pageDeveloperName,objectApiName,expansionHints){const cacheKey=buildCacheKey$e(pageDeveloperName,objectApiName);const valueProviderParameters={cacheKey,pageDeveloperName,objectApiName,expansionHints};const valueProvider=this._createFlexipageValueProvider(valueProviderParameters);return this._ldsCache.get(cacheKey,valueProvider);}/**
         * Constructs a value provider to retrieve a Flexipage.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns The value provider to retrieve a flexipage.
         */_createFlexipageValueProvider(valueProviderParameters){const{cacheKey,pageDeveloperName,objectApiName,expansionHints}=valueProviderParameters;const flexipageValueProvider=new ValueProvider(cacheAccessor=>{const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;const needsRefresh=nowTime>lastFetchTime+this._ttl||!hasModule(existingValueWrapper.value)||this._isPageInCookie(pageDeveloperName);if(needsRefresh||this._getServiceConfiguration(USE_ADG_CONFIGURATION_KEY)){// Value is stale; get a fresh value.
    return this._getFreshValue(cacheAccessor,pageDeveloperName,objectApiName,expansionHints,needsRefresh);}// The value is not stale so it's a cache hit.
    return Thenable.resolve(1/* CACHE_HIT */);}// No existing value; get a fresh value.
    return this._getFreshValue(cacheAccessor,pageDeveloperName,objectApiName,expansionHints,this._isPageInCookie(pageDeveloperName));},valueProviderParameters);return flexipageValueProvider;}/**
         * Updates the cookie and removes pageDevName
         * @param pageDevName
         */_updatedPageLoaded(pageDevName){const cookieValue=this._getCookie(FLEXIPAGE_SAVE_COOKIE);if(cookieValue!=null){const values=cookieValue.split(",");const index=values.indexOf(pageDevName);if(index>-1){values.splice(index,1);this._setCookie(FLEXIPAGE_SAVE_COOKIE,values.join());}}}/**
         * finds if pageDevName in cookie
         * @param pageDevName
         * @returns true if the pageDevname is in cookie
         */_isPageInCookie(pageDevName){const cookieValue=this._getCookie(FLEXIPAGE_SAVE_COOKIE);if(cookieValue!=null){const values=cookieValue.split(",");const index=values.indexOf(pageDevName);if(index>-1){return true;}else {return false;}}return false;}/**
         * Gets cookie with name
         * @param name cookie name
         * @returns String cookie value
         */_getCookie(name){const unescapeCookieVal=decodeURIComponent;const dc=document.cookie;// dc is set in setCookie so if getCookie is called before setCookie, dc could be null which would result in NPE.
    if(!dc){return null;}const prefix=name+"=";let begin=dc.indexOf("; "+prefix);if(begin===-1){begin=dc.indexOf(prefix);if(begin!==0){return null;}}else {begin+=2;}let end=document.cookie.indexOf(";",begin);if(end===-1){end=dc.length;}return unescapeCookieVal(dc.substring(begin+prefix.length,end));}/**
         * Updates cookie with new value
         * @param name cookie name
         * @param value cookie value
         */_setCookie(name,value){const escapeCookieVal=encodeURIComponent;document.cookie=name+"="+escapeCookieVal(value)+"; path=/";}/**
         * Constructs an Observable with Module defintion for a given Observable with descriptor
         * @param observableToFilter The observable that emits an aura module
         * @returns Observable An observable the emits an aura module
         */_constructModuleObservable(observableToFilter){let moduleObservable=observableToFilter;moduleObservable=moduleObservable.filter(hasModule).map(getModule);return moduleObservable;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param apiName The form api name of the form to retrieve.
         * @param eTagToCheck eTag to send to the server to determine if we already have the latest value. If we do the server will return a 304.
         * @returns Returns a ValueProviderResult representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,pageDeveloperName,objectApiName,expansionHints,needsRefresh){const params={type:FLEXIPAGE_GENERATED_COMPONENT_TYPE,params:{pageDeveloperName,objectApiName},expansionHints};return executeTemplateController(params,cacheAccessor,this._ldsCache,FLEXIPAGE_DESCRIPTOR_VALUE_TYPE,this._getServiceConfiguration,needsRefresh).then(freshValue=>{const descriptor=freshValue.descriptor;if(freshValue.additionalParams){this.setTtl(freshValue.additionalParams.flexipageTtl);}const descriptorCacheKey=buildCacheKey$e(pageDeveloperName,objectApiName);cacheAccessor.stageClearDependencies(descriptorCacheKey);// Nothing should depend on this yet; included for completeness.
    this._updatedPageLoaded(pageDeveloperName);this.normalizeAndStagePut([],descriptorCacheKey,descriptor,cacheAccessor);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}}/**
     * Wire adapter id: getFlexipageTemplate.
     * @throws Error - Always throws when invoked. Imperative invocation is not supported.
     * @returns void
     */function getFlexipageTemplate(){throw generateError("getFlexipageTemplate");}/**
     * Generates Wire adapters for
     *   @wireAdapter getFlexipageTemplate
     */class FlexipageWireAdapterGenerator{/**
         * Constructor.
         * @param flexipageService Reference to the FlexipageService instance.
         */constructor(flexipageService){this._flexipageService=flexipageService;}/**
         * Generates the wire adapter for getRecord.
         * @returns WireAdapter - See description.
         */generateGetFlexipageTemplateWireAdapter(){const wireAdapter=generateWireAdapter(this._serviceGetFlexipageTemplate.bind(this));return wireAdapter;}/**
         * @private Made public for testing.
         * Service getFlexipageTemplate @wire.
         * @param config: object - Config params for the service.
         * @return Observable<object> - Observable stream that emits a Flexipage Module.
         */_serviceGetFlexipageTemplate(config){if(!config){return undefined;}if(!config.pageDeveloperName){return undefined;}return this._flexipageService.getFlexipageTemplateModule(config.pageDeveloperName,config.objectApiName,{recordId:config.recordId});}}/**
     * The valueType to use when building DescriptorActionTemplate.
     */const ACTION_DESCRIPTOR_VALUE_TYPE="lds.DescriptorActionModule";/**
     * Time to live for a action descriptor cache value. 30 days.
     */const ACTION_DESCRIPTOR_TTL=2592000000;// 30 days.
    /**
     * Constructs a cache key for the ActionTemplate Template.
     * @param actionApiName Api Name of the Action.
     * @param recordId Id of the associated record.
     * @returns CacheKey A new cache key representing the Layout value type.
     */function buildCacheKey$f(actionApiName,recordId,timestamp){return {type:ACTION_DESCRIPTOR_VALUE_TYPE,key:`${actionApiName}${KEY_DELIM}${recordId}${KEY_DELIM}${timestamp}`};}/**
     * Constructs a cache key for a bundle of the ActionTemplate Templates.
     * @param params The set of action template params
     * @returns CacheKey A new cache key representing the Layout value type.
     */function buildBundleCacheKey(paramList){return {type:ACTION_DESCRIPTOR_VALUE_TYPE,key:paramList.map(p=>`${p.actionApiName}${KEY_DELIM}${p.recordId}${KEY_DELIM}${p.timestamp}`).join(KEY_DELIM)};}/**
     * Generated Component Type for ActionTemplate
     */const ACTION_GENERATED_COMPONENT_TYPE="Action";const ACTION_DELIMITER=",";/**
     * Provides functionality to read action template descriptor from the cache. Can refresh the data from the server.
     */class ActionTemplateService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         */constructor(ldsCache,getServiceConfiguration){super(ldsCache,[ACTION_DESCRIPTOR_VALUE_TYPE]);this._getServiceConfiguration=getServiceConfiguration;}getCacheValueTtl(){return ACTION_DESCRIPTOR_TTL;}/**
         * There are no eTags to strip from dynamicComponentDescriptor so just return the given value unchanged.
         * @param dynamicComponentDescriptor
         * @returns The given dynamicComponentDescriptor unchanged.
         */stripETagsFromValue(dynamicComponentDescriptor){return dynamicComponentDescriptor;}/**
         * Stage puts the given dynamicComponentDescriptor.
         * @param dependencies An array of dependent cache keys.
         * @param generatedComponentDescriptor The generatedComponentDescriptor to cache.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData A property bag with additional values that are needed to generate the cache key.
         */stagePutValue(dependencies,generatedComponentDescriptor,cacheAccessor,additionalData){const cacheKey=buildCacheKey$f(additionalData.actionApiName,additionalData.recordId,additionalData.timestamp);this.normalizeAndStagePut(dependencies,cacheKey,generatedComponentDescriptor,cacheAccessor);}/**
         * Normalizes and stage puts given generatedComponentDescriptor
         * @param dependencies An array of dependent cache keys.
         * @param cacheKey utilized by the value provider to fetch the value.
         * @param generatedComponentDescriptor The generatedComponentDescriptor to cache.
         * @param cacheAccessor An object to access cache directly.
         */normalizeAndStagePut(dependencies,cacheKey,generatedComponentDescriptor,cacheAccessor){cacheAccessor.stagePut(dependencies,cacheKey,generatedComponentDescriptor,generatedComponentDescriptor);}/**
         * Gets an ActionTemplate as a Module
         * @param paramList An array of Action Template request parameters
         * @param expansionHints Expansion hints to be used for fetching dependent data
         * @returns The observable used to get the value and keep watch on it for changes.
         */getActionTemplateModule(paramList,expansionHints){this.getActionDescriptor(paramList,expansionHints);const cacheKey=buildBundleCacheKey(paramList);const observables=this._ldsCache.getOrCreateObservables(cacheKey,this.getCacheValueTtl());return this._constructModuleObservable(observables.finalTransformed);}/**
         * Retrieves action descriptor from the cache. If it doesn't exist in the cache it will retrieve it from the server and put it into the cache.
         * @param paramList An array of Action Template request parameters
         * @param expansionHints Expansion hints to be used for fetching dependent data
         * @returns The observable used to get the value and keep watch on it for changes.
         */getActionDescriptor(paramList,expansionHints){const cacheKey=buildBundleCacheKey(paramList);const valueProviderParameters={cacheKey,paramList,expansionHints};const valueProvider=this._createActionValueProvider(valueProviderParameters);return this._ldsCache.get(cacheKey,valueProvider);}/**
         * Constructs a value provider to retrieve an ActionTemplate.
         * @param valueProviderParameters The parameters for the value provider as an object.
         * @returns The value provider to retrieve a ActionTemplate.
         */_createActionValueProvider(valueProviderParameters){const{cacheKey,paramList,expansionHints}=valueProviderParameters;const actionValueProvider=new ValueProvider(cacheAccessor=>{const existingValueWrapper=cacheAccessor.get(cacheKey);if(existingValueWrapper&&existingValueWrapper.value!==undefined){const nowTime=cacheAccessor.nowTime;const lastFetchTime=existingValueWrapper.lastFetchTime;const needsRefresh=nowTime>lastFetchTime+ACTION_DESCRIPTOR_TTL||!hasModule(existingValueWrapper.value);if(needsRefresh){// Value is stale; get a fresh value.
    return this._getFreshValue(cacheAccessor,paramList,expansionHints);}// The value is not stale so it's a cache hit.
    return Thenable.resolve(1/* CACHE_HIT */);}// No existing value; get a fresh value.
    return this._getFreshValue(cacheAccessor,paramList,expansionHints);},valueProviderParameters);return actionValueProvider;}/**
         * Constructs an Observable with Module definition for a given Observable with descriptor
         * @param observableToFilter The observable that emits an aura module
         * @returns Observable An observable the emits an aura module
         */_constructModuleObservable(observableToFilter){const allHaveModule=module=>{const modules=module.split(ACTION_DELIMITER);return modules.every(p=>{return hasModule(p);});};const getModuleArray=module=>{const modules=module.split(ACTION_DELIMITER);const ans=modules.map(m=>{return {descriptor:m,def:getModule(m)};});return ans;// can't convert a module to string, I think aura-module.d.ts has a wrong type signature.
    };let moduleObservable=observableToFilter;moduleObservable=moduleObservable.filter(allHaveModule).map(getModuleArray);return moduleObservable;}/**
         * Gets a fresh value and processes it into the cache with the cacheAccessor.
         * @param cacheAccessor An object to transactionally access the cache.
         * @param paramList An array of Action Template request parameters
         * @param expansionHints Expansion hints to be used for fetching dependent data
         * @returns Returns a ValueProviderResult representing the outcome of the value provider.
         */_getFreshValue(cacheAccessor,paramList,expansionHints){const controllerParams=paramList.map(action=>{return {type:ACTION_GENERATED_COMPONENT_TYPE,params:{actionApiName:action.actionApiName,recordId:action.recordId,timestamp:action.timestamp},expansionHints};});return executeTemplateBundleController(controllerParams,cacheAccessor,this._ldsCache,ACTION_DESCRIPTOR_VALUE_TYPE,this._getServiceConfiguration).then(freshValue=>{const descriptors=freshValue.map(p=>p.descriptor).join(ACTION_DELIMITER);const descriptorCacheKey=buildBundleCacheKey(paramList);cacheAccessor.stageClearDependencies(descriptorCacheKey);// Nothing should depend on this yet; included for completeness.
    this.normalizeAndStagePut([],descriptorCacheKey,descriptors,cacheAccessor);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return 2/* CACHE_MISS */;});}}/**
     * Wire adapter id: getActionTemplate.
     * @throws Error - Always throws when invoked. Imperative invocation is not supported.
     * @returns void
     */function getActionTemplate(){throw generateError("getActionTemplate");}/**
     * Generates Wire adapters for
     *   @wireAdapter getActionTemplate
     */class ActionTemplateWireAdapterGenerator{/**
         * Constructor.
         * @param ActionTemplateService Reference to the ActionTemplateService instance.
         */constructor(actionTemplateService){this._actionTemplateService=actionTemplateService;}/**
         * Generates the wire adapter for getActionTemplate.
         * @returns WireAdapter - See description.
         */generateGetActionTemplateWireAdapter(){const wireAdapter=generateWireAdapter(this._serviceGetActionTemplate.bind(this));return wireAdapter;}/**
         * @private Made public for testing.
         * Service getActionTemplate @wire.
         * @param config: object - Config params for the service.
         * @return Observable<object> - Observable stream that emits an ActionTemplate.
         */_serviceGetActionTemplate(config){if(!config||!config.actions){return undefined;}// Check each param to make sure it is valid
    const actions=config.actions.filter(action=>action.actionApiName&&action.recordId&&action.timestamp);// Once we've filtered out invalid requests, check that we have at least one item
    if(!actions.length){return undefined;}return this._actionTemplateService.getActionTemplateModule(actions,{});}}/**
     * Value type for record actions
     */const RECORD_ACTIONS_VALUE_TYPE="lds.RecordActions";/**
     * Record actions expires in 5 minutes in the cache
     */const RECORD_ACTIONS_TTL=5*60*1000;/**
     * Cache key builder for record actions
     * @param recordIds The list of record ids
     * @param formFactor The form factor
     * @param sections The list of sections
     * @param actionTypes The list of action types
     * @param retrievalMode Sets the retrieval mode
     * @param apiNames Sets the Api Names
     * @return A cache key for record actions
     */function buildCacheKey$g(recordIds,formFactor,sections,actionTypes,retrievalMode,apiNames){{assert$2(recordIds.length,"A non-empty recordIds must be provided");}const recordId=stableCommaDelimitedString(recordIds.map(to18));const formFactorStr=formFactor?formFactor.toLowerCase():"";const section=stableCommaDelimitedString(toLowerCase(sections));const actionType=stableCommaDelimitedString(toLowerCase(actionTypes));retrievalMode=(retrievalMode||"").toLowerCase();const apiName=stableCommaDelimitedString(apiNames);const key=[recordId,formFactorStr,section,actionType,retrievalMode,apiName].join(KEY_DELIM);return {type:RECORD_ACTIONS_VALUE_TYPE,key};}/**
     * Quick and dirty function to reconstruct record actions parameters from a cache key
     * @param affectedKey A cache key
     * @return Record actions parameters
     */function reconstructRecordActionsParameters(affectedKey){const reverseJoin=str=>str?str.split(","):[];const[,recordIds,formFactor,sections,actionTypes,retrievalMode,apiNames]=serialize(affectedKey).split(KEY_DELIM);return {recordId:reverseJoin(recordIds),formFactor:formFactor,sections:reverseJoin(sections),actionTypes:reverseJoin(actionTypes),retrievalMode,apiNames:reverseJoin(apiNames)};}/**
     * The ui api end point of record actions
     */const ACTIONS_GLOBAL_CONTROLLER$1="ActionsController.getRecordActions";/**
     * Record actions service
     */class RecordActionsService extends LdsServiceBase{/**
         * Constructor.
         * @param ldsCache Reference to the LdsCache instance.
         * @param affectedKeyHandlerInspector Used by tests to inspect the affectedKeyHandler.
         * @param valueProviderFunctionInspector Used by tests to inspect the valueProviderFunction.
         */constructor(ldsCache,functionProvidesValueProviderFunction){super(ldsCache,[RECORD_ACTIONS_VALUE_TYPE,ACTION_DEFINITION_VALUE_TYPE]);/**
             * Affected key handler instance for the service
             */this.affectedKeyHandler=(affectedKey,cacheAccessor)=>{const parameters=reconstructRecordActionsParameters(affectedKey);const hasDependencyUpdated=parameters.recordId.some(recordId=>{const{dependencies}=this.getCacheKeyDependencyOfKey(parameters,recordId);return dependencies.some(dependency=>!!cacheAccessor.getCommitted(dependency));});if(hasDependencyUpdated){this._ldsCache.get(affectedKey,new ValueProvider(this.getValueProviderFn(affectedKey,parameters,true),{}));return;}const oldValueWrapper=cacheAccessor.get(affectedKey);if(oldValueWrapper){const updatedActionPayloadToEmit=denormalizeValue(cacheAccessor,oldValueWrapper.value);const valueWrapper=cloneWithValueOverride(oldValueWrapper,updatedActionPayloadToEmit);cacheAccessor.stageEmit(affectedKey,valueWrapper);}};this._functionProvidesValueProviderFunction=functionProvidesValueProviderFunction;}getCacheValueTtl(){return RECORD_ACTIONS_TTL;}/**
         * A function to check whether cache entry has expired
         * @param now Current timestamp
         * @param entry Cache entry
         * @returns Whether cache entry has expired
         */hasNotExpired(now,entry){return !isNaN(now)&&!isNaN(entry.lastFetchTime)&&now-entry.lastFetchTime<RECORD_ACTIONS_TTL;}/**
         * A function to check whether cache entry has a value
         * @param entry Cache entry
         * @return Whether the cache entry has a value
         */doesCacheEntryHasValue(entry){return entry?entry.value!==undefined:false;}/**
         * @return A higher order of function that returns an affected key handler
         */getAffectedKeyHandler(){return this.affectedKeyHandler;}/**
         * Wire service to provide record actions
         * @param The list of recordIds for their record detail actions
         * @param optionalParameters The optional parameters to further filter the resultant actions
         * @return Observable of the list of record actions
         */getRecordActions(recordId,actionTypes,apiNames,formFactor,retrievalMode,sections,metaConfig){if(!Array.isArray(recordId)){recordId=[recordId];}let apiNamesArr;if(apiNames){apiNamesArr=Array.isArray(apiNames)?apiNames:[apiNames];}let sectionsArr;if(sections){sectionsArr=Array.isArray(sections)?sections:[sections];}const parameters={recordId,actionTypes,apiNames:apiNamesArr,formFactor,retrievalMode,sections:sectionsArr};const forceFetch=!!(metaConfig&&metaConfig.forceProvide);const cacheKey=this.buildCacheKey(parameters);const valueProviderFunction=this._functionProvidesValueProviderFunction?this._functionProvidesValueProviderFunction(cacheKey,parameters,forceFetch):this.getValueProviderFn(cacheKey,parameters,forceFetch);return this._ldsCache.get(cacheKey,new ValueProvider(valueProviderFunction,{}));}/**
         * Stage puts the given action.
         * @param dependencies List of dependent cache keys.
         * @param action The action to stagePut.
         * @param cacheAccessor An object to access cache directly.
         * @param additionalData Data to build cache key with
         */stagePutValue(dependencies,action,cacheAccessor,additionalData){const recordActionCacheKey=this.buildCacheKey(additionalData);cacheAccessor.stagePut(dependencies,recordActionCacheKey,action,action);}/**
         * Strips all eTag properties from the given action by directly deleting them.
         * @param action The action from which to strip the eTags.
         * @returns The given action with its eTags stripped.
         */stripETagsFromValue(action){delete action.eTag;return action;}/**
         * Denormalizes the given normalizedValue and returns it.
         * @param normalizedValue The normalizedValue to denormalize.
         * @param cacheAccessor Used to access the cache.
         * @returns The denormalized record actions value.
         */denormalizeValue(normalizedValue,cacheAccessor){const denormalizedValue=denormalizeValue(cacheAccessor,normalizedValue);return denormalizedValue;}/**
         * A higher order function to provide a value provider function
         * @param cacheKey The cache key
         * @param params The record action parameters for the transaction
         * @param forceFetch Indicates whether a server round trip is forced
         * @return A value provider function
         */getValueProviderFn(cacheKey,params,forceFetch){return cacheAccessor=>{const cacheEntry=cacheAccessor.get(cacheKey);if(!forceFetch&&this.doesCacheEntryHasValue(cacheEntry)&&this.hasNotExpired(cacheAccessor.nowTime,cacheEntry)){return Thenable.resolve(1/* CACHE_HIT */);}return this.primeCacheEntries(params,cacheAccessor,cacheKey).then(result=>{if(cacheEntry&&cacheEntry.eTag&&result.eTag&&cacheEntry.eTag===result.eTag){return 3/* CACHE_MISS_REFRESH_UNCHANGED */;}else {return 2/* CACHE_MISS */;}});};}/**
         * Makes a server round trip and normalizes the response
         * @param parameters The record action parameters for the round trip
         * @param cacheAccessor The cache accessor for the transaction
         * @param cacheKey The cache key for the payload
         * @return The action representation
         */primeCacheEntries(parameters,cacheAccessor,cacheKey){return executeAuraGlobalController(ACTIONS_GLOBAL_CONTROLLER$1,parameters).then(response=>{const result=response.body;normalizePayload(cacheAccessor,this.getCacheKeyDependencyOfKey.bind(this,parameters),cacheKey,result);const affectedKeys=cacheAccessor.commitPuts();this._ldsCache.handleAffectedKeys(affectedKeys,cacheAccessor);return result;});}/**
         * Builds a record action cache key from parameters
         * @param parameters The record actions parameters
         * @return A cache key for record actions
         */buildCacheKey(parameters){const{formFactor,actionTypes,retrievalMode}=parameters;let{recordId:recordIds,sections,apiNames}=parameters;if(recordIds&&!Array.isArray(recordIds)){recordIds=[recordIds];}if(sections&&!Array.isArray(sections)){sections=[sections];}if(apiNames&&!Array.isArray(apiNames)){apiNames=[apiNames];}return buildCacheKey$g(recordIds,formFactor,sections,actionTypes,retrievalMode,apiNames);}/**
         * Calculates the cache key and dependencies provided the parameters for the request
         * @param formFactor The form factor
         * @param sections The sections
         * @param actionTypes The action types
         * @param recordId The record id
         * @return The cache key of the request along with their dependencies
         */getCacheKeyDependencyOfKey({formFactor,sections,actionTypes,retrievalMode,apiNames},recordId){const cacheKey=buildCacheKey$g([recordId],formFactor,sections,actionTypes,retrievalMode,apiNames);const recordCacheKey=buildRecordCacheKey(recordId);return {cacheKey,dependencies:[recordCacheKey],getSingleActionByApiNameCacheKey:apiName=>{return buildCacheKey$g([recordId],formFactor,sections,actionTypes,"All",[apiName]);}};}}/**
     * Wire adapter id: getRecordActions.
     * @throws Always throws when invoked. Imperative invocation is not supported.
     */function getRecordActions(){throw generateError("getRecordActions");}/**
     * Generates the wire adapter for Record Actions.
     */class RecordActionsWireAdapterGenerator{/**
         * Constructor.
         * @param recordActionsService Reference to the RecordActionsService instance.
         */constructor(recordActionsService){this._recordActionsService=recordActionsService;}/**
         * Generates the wire adapter for getRecordActions.
         * @returns See description.
         */generateGetRecordActionsWireAdapter(){return generateWireAdapter(this.serviceGetRecordActions.bind(this));}/**
         * Service getRecordActions @wire
         * @param config Parameters for the service
         * @returns Observable stream that emits record actions.
         */serviceGetRecordActions(config,metaConfig){return this._recordActionsService.getRecordActions(config.recordId,config.actionTypes,config.apiNames,config.formFactor,config.retrievalMode,config.sections,metaConfig);}}/*
     * This is the container for LDS in lwc core.
     */const isLDSDurableStoreEnabled=typeof $A!=="undefined"&&$A.get("$Browser.S1Features.isLDSDurableStoreEnabled");let ldsCache;let storeAccessor;// create durable store accessor if required
    if(isLDSDurableStoreEnabled){const storage=createDurableStorage("LDS");storeAccessor=typeof storage!=="undefined"?new DurableStoreAccessor(storage,5000):undefined;}// Create the cache layer
    const cacheStore=new InMemoryCacheStore(storeAccessor);ldsCache=new LdsCache("LDS Production Cache",cacheStore,defaultTimeSource);// set pruning strategy for durable store accessor
    if(storeAccessor){const pruningStrategy=new DurableStorePruningStrategy(ldsCache);storeAccessor.setPruningStrategy(pruningStrategy);}// Create ads bridge.
    const adsBridge=new AdsBridge(ldsCache);function checkS1Features(key){return typeof $A!=="undefined"&&$A.get("$Browser.S1Features."+key);}// TODO: This would be better served as a class
    function getServiceConfiguration$1(key){switch(key){case USE_ADG_CONFIGURATION_KEY:return checkS1Features(USE_ADG_KEY);case USE_DEDUPE_CONFIGURATION_KEY:return checkS1Features(USE_DEDUPE_KEY);default:return false;}}provideConfiguration(getServiceConfiguration$1);// Create services.
    const apexService=new ApexService(ldsCache);const layoutService=new LayoutService(ldsCache);const layoutUserStateService=new LayoutUserStateService(ldsCache);const listUiService=new ListUiService(ldsCache);const relatedListTemplateService=new RelatedListTemplateService(ldsCache,getServiceConfiguration$1);const lookupActionsService=new LookupActionsService(ldsCache);const lookupRecordsService=new LookupRecordsService(ldsCache);const objectInfoService=new ObjectInfoService(ldsCache);const picklistValuesService=new PicklistValuesService(ldsCache);const picklistValuesByRecordTypeService=new PicklistValuesByRecordTypeService(ldsCache);const recordActionsService=new RecordActionsService(ldsCache);const recordAvatarService=new RecordAvatarService(ldsCache);const recordAvatarBulkService=new RecordAvatarBulkService(ldsCache);const recordDefaultsService=new RecordDefaultsService(ldsCache);const recordLayoutService=new RecordLayoutService(ldsCache,adsBridge,getServiceConfiguration$1);const recordService=new RecordService(ldsCache,adsBridge);const recordUiService=new RecordUiService(ldsCache,adsBridge);const flexipageService=new FlexipageService(ldsCache,getServiceConfiguration$1);const actionTemplateService=new ActionTemplateService(ldsCache,getServiceConfiguration$1);// Register services.
    ldsCache.registerService(apexService);ldsCache.registerService(layoutService);ldsCache.registerService(layoutUserStateService);ldsCache.registerService(listUiService);ldsCache.registerService(relatedListTemplateService);ldsCache.registerService(lookupActionsService);ldsCache.registerService(lookupRecordsService);ldsCache.registerService(objectInfoService);ldsCache.registerService(picklistValuesService);ldsCache.registerService(picklistValuesByRecordTypeService);ldsCache.registerService(recordActionsService);ldsCache.registerService(recordAvatarService);ldsCache.registerService(recordAvatarBulkService);ldsCache.registerService(recordService);ldsCache.registerService(recordDefaultsService);ldsCache.registerService(recordLayoutService);ldsCache.registerService(recordUiService);ldsCache.registerService(flexipageService);ldsCache.registerService(actionTemplateService);// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Apex
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Exports.
    const apexWireAdapterGenerator=new ApexWireAdapterGenerator(apexService);const generateGetApexWireAdapter=apexWireAdapterGenerator.generateGetApexWireAdapter.bind(apexWireAdapterGenerator);const generateGetApexInvoker=apexWireAdapterGenerator.getApexInvoker.bind(apexWireAdapterGenerator);const getApexInvoker=(namespace,classname,method,isContinuation)=>{const invokerIdentifier=generateGetApexInvoker(namespace,classname,method,isContinuation);wireService.register(invokerIdentifier,generateGetApexWireAdapter(namespace,classname,method,isContinuation));return invokerIdentifier;};// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Layout
    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire Adapter
    const layoutWireAdapterGenerator=new LayoutWireAdapterGenerator(layoutService);wireService.register(getLayout,layoutWireAdapterGenerator.generateGetLayoutWireAdapter());/* TODO W-6568533 - replace this temporary imperative invocation with wire reform */const _getLayout=config=>{layoutWireAdapterGenerator.serviceGetLayout(config);};// TODO W-4846954 - do not export Observable methods.
    const getLayoutObservable=layoutService.getLayout.bind(layoutService);// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Layout User State
    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire Adapter
    const layoutUserStateWireAdapterGenerator=new LayoutUserStateWireAdapterGenerator(layoutUserStateService);wireService.register(getLayoutUserState,layoutUserStateWireAdapterGenerator.generateGetLayoutUserStateWireAdapter());/* TODO W-6568533 - replace this temporary imperative invocation with wire reform */const _getLayoutUserState=config=>{layoutUserStateWireAdapterGenerator.serviceGetLayoutUserState(config);};const updateLayoutUserState=layoutUserStateService.updateLayoutUserState.bind(layoutUserStateService);// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // List Ui
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const listUiWireAdapterGenerator=new ListUiWireAdapterGenerator(listUiService);wireService.register(getListUi,listUiWireAdapterGenerator.generateGetListUiWireAdapter());const saveSort=listUiService.saveSort.bind(listUiService);const saveColumnWidths=listUiService.saveColumnWidths.bind(listUiService);// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Related List Template
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const relatedListColumnsWireAdapterGenerator=new RelatedListTemplateWireAdapterGenerator(relatedListTemplateService);wireService.register(getRelatedListTemplate,relatedListColumnsWireAdapterGenerator.generateGetRelatedListTemplateWireAdapter());// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lookup Actions
    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const lookupActionsWireAdapterGenerator=new LookupActionsWireAdapterGenerator(lookupActionsService);wireService.register(getLookupActions,lookupActionsWireAdapterGenerator.generateGetLookupActionsWireAdapter());// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Record Actions
    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const recordActionsWireAdapterGenerator=new RecordActionsWireAdapterGenerator(recordActionsService);wireService.register(getRecordActions,recordActionsWireAdapterGenerator.generateGetRecordActionsWireAdapter());/* TODO W-6568533 - replace this temporary imperative invocation with wire reform */const _getRecordActions=config=>{recordActionsWireAdapterGenerator.serviceGetRecordActions(config);};// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lookup Records
    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const lookupRecordsWireAdapterGenerator=new LookupRecordsWireAdapterGenerator(lookupRecordsService);wireService.register(getLookupRecords,lookupRecordsWireAdapterGenerator.generateGetLookupRecordsWireAdapter());// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Object Info
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const objectInfoWireAdapterGenerator=new ObjectInfoWireAdapterGenerator(objectInfoService);wireService.register(getObjectInfo,objectInfoWireAdapterGenerator.generateGetObjectInfoWireAdapter());/* TODO W-6568533 - replace this temporary imperative invocation with wire reform */const _getObjectInfo=config=>{objectInfoWireAdapterGenerator.serviceGetObjectInfo(config);};// TODO W-4846954 - do not export *Observable methods.
    const getObjectInfoObservable=objectInfoService.getObjectInfo.bind(objectInfoService);// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Picklist values
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const picklistValuesWireAdapterGenerator=new PicklistValuesWireAdapterGenerator(picklistValuesService);wireService.register(getPicklistValues,picklistValuesWireAdapterGenerator.generateGetPicklistValuesWireAdapter());// TODO W-4846954 - do not export *Observable methods.
    const getPicklistValuesObservable=picklistValuesService.getPicklistValues.bind(picklistValuesService);// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Picklist values by record type
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const picklistValuesByRecordTypeWireAdapterGenerator=new PicklistValuesByRecordTypeWireAdapterGenerator(picklistValuesByRecordTypeService);wireService.register(getPicklistValuesByRecordType,picklistValuesByRecordTypeWireAdapterGenerator.generateGetPicklistValuesByRecordTypeWireAdapter());// TODO W-4846954 - do not export *Observable methods.
    const getPicklistValuesByRecordTypeObservable=picklistValuesByRecordTypeService.getPicklistValuesByRecordType.bind(picklistValuesByRecordTypeService);// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Record
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const recordWireAdapterGenerator=new RecordWireAdapterGenerator(recordService);wireService.register(getRecord,recordWireAdapterGenerator.generateGetRecordWireAdapter());/* TODO W-6568533 - replace this temporary imperative invocation with wire reform */const _getRecord=config=>{let result=recordWireAdapterGenerator.serviceGetRecord(config);if(result===undefined){return Promise.reject(new Error("Insufficient config"));}else if(!("then"in result)){result=Thenable.resolve(result);}return result.then(observable=>{return new Promise((resolve,reject)=>{let subscription;let emitted=false;const observer={next:data=>{resolve(data);emitted=true;if(subscription){subscription.unsubscribe();}},error:error=>{reject(error);emitted=true;if(subscription){subscription.unsubscribe();}}};subscription=observable.subscribe(observer);// handle synchronous emit
    if(emitted&&subscription){subscription.unsubscribe();}});});};// TODO W-4846954 - do not export getRecordWithFieldsObservable that returns an observable
    const getRecordWithFieldsObservable=recordService.getRecordWithFields.bind(recordService);const createRecord=recordService.createRecord.bind(recordService);const updateRecord=recordService.updateRecord.bind(recordService);const deleteRecord=recordService.deleteRecord.bind(recordService);const updateRecordAvatar=recordAvatarBulkService.updateRecordAvatar.bind(recordAvatarBulkService);// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Record Avatar
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const recordAvatarBulkWireAdapterGenerator=new RecordAvatarBulkWireAdapterGenerator(recordAvatarBulkService);wireService.register(getRecordAvatars,recordAvatarBulkWireAdapterGenerator.generateGetRecordAvatarsWireAdapter());/* TODO W-6568533 - replace this temporary imperative invocation with wire reform */const _getRecordAvatars=config=>{recordAvatarBulkWireAdapterGenerator.serviceGetRecordAvatars(config);};// TODO W-4846954 - do not export getRecordAvatarsObservable that returns an observable
    const getRecordAvatarsObservable=recordAvatarBulkService.getRecordAvatars.bind(recordAvatarBulkService);// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Record Create Defaults
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const recordDefaultsWireAdapterGenerator=new RecordDefaultsWireAdapterGenerator(recordDefaultsService);wireService.register(getRecordCreateDefaults,recordDefaultsWireAdapterGenerator.generateGetRecordCreateDefaultsWireAdapter());// TODO W-4846954 - do not export getRecordCreateDefaultsObservable that returns an observable
    const getRecordCreateDefaultsObservable=recordDefaultsService.getRecordCreateDefaults.bind(recordDefaultsService);// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Record Layout
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const recordLayoutWireAdapterGenerator=new RecordLayoutWireAdapterGenerator(recordLayoutService);wireService.register(getRecordLayoutTemplate,recordLayoutWireAdapterGenerator.generateGetRecordLayoutTemplateWireAdapter());// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Record Ui
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const recordUiWireAdapterGenerator=new RecordUiWireAdapterGenerator(recordUiService);wireService.register(getRecordUi,recordUiWireAdapterGenerator.generateGetRecordUiWireAdapter());/* TODO W-6568533 - replace this temporary imperative invocation with wire reform */const _getRecordUi=config=>{recordUiWireAdapterGenerator._serviceGetRecordUi(config);};// TODO W-4846954 - do not export getRecordUiObservable that returns an observable
    const getRecordUiObservable=recordUiService.getRecordUi.bind(recordUiService);// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Flexipages
    // /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const flexipageWireAdapterGenerator=new FlexipageWireAdapterGenerator(flexipageService);wireService.register(getFlexipageTemplate,flexipageWireAdapterGenerator.generateGetFlexipageTemplateWireAdapter());// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Actions
    // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Wire adapter.
    const actionTemplateWireAdapterGenerator=new ActionTemplateWireAdapterGenerator(actionTemplateService);wireService.register(getActionTemplate,actionTemplateWireAdapterGenerator.generateGetActionTemplateWireAdapter());// ////////////////////////
    // Trigger bootstrap to ready the cache. If a durableStoreAccessor is configured this will load durable store from disk and into memory.
    ldsCache.bootstrap();

    var lds222 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        MRU: MRU,
        Observable: Observable,
        _getLayout: _getLayout,
        _getLayoutUserState: _getLayoutUserState,
        _getObjectInfo: _getObjectInfo,
        _getRecord: _getRecord,
        _getRecordActions: _getRecordActions,
        _getRecordAvatars: _getRecordAvatars,
        _getRecordUi: _getRecordUi,
        adsBridge: adsBridge,
        createRecord: createRecord,
        createRecordInputFilteredByEditedFields: createRecordInputFilteredByEditedFields,
        deleteRecord: deleteRecord,
        generateError: generateError,
        generateRecordInputForCreate: generateRecordInputForCreate,
        generateRecordInputForUpdate: generateRecordInputForUpdate,
        generateWireAdapter: generateWireAdapter,
        getActionTemplate: getActionTemplate,
        getApexInvoker: getApexInvoker,
        getFieldDisplayValue: getFieldDisplayValue,
        getFieldValue: getFieldValue,
        getFlexipageTemplate: getFlexipageTemplate,
        getLayout: getLayout,
        getLayoutObservable: getLayoutObservable,
        getLayoutUserState: getLayoutUserState,
        getListUi: getListUi,
        getLookupActions: getLookupActions,
        getLookupRecords: getLookupRecords,
        getObjectInfo: getObjectInfo,
        getObjectInfoObservable: getObjectInfoObservable,
        getPicklistValues: getPicklistValues,
        getPicklistValuesByRecordType: getPicklistValuesByRecordType,
        getPicklistValuesByRecordTypeObservable: getPicklistValuesByRecordTypeObservable,
        getPicklistValuesObservable: getPicklistValuesObservable,
        getRecord: getRecord,
        getRecordActions: getRecordActions,
        getRecordAvatars: getRecordAvatars,
        getRecordAvatarsObservable: getRecordAvatarsObservable,
        getRecordCreateDefaults: getRecordCreateDefaults,
        getRecordCreateDefaultsObservable: getRecordCreateDefaultsObservable,
        getRecordInput: getRecordInput,
        getRecordLayoutTemplate: getRecordLayoutTemplate,
        getRecordUi: getRecordUi,
        getRecordUiObservable: getRecordUiObservable,
        getRecordWithFieldsObservable: getRecordWithFieldsObservable,
        getRelatedListTemplate: getRelatedListTemplate,
        getSObjectValue: getSObjectValue,
        getValueForAura: getValueForAura,
        get ldsCacheReferenceForTestingOnly () { return ldsCache; },
        recursivelyGatherFieldNames: recursivelyGatherFieldNames,
        refresh: refreshWireAdapter,
        saveColumnWidths: saveColumnWidths,
        saveSort: saveSort,
        updateLayoutUserState: updateLayoutUserState,
        updateRecord: updateRecord,
        updateRecordAvatar: updateRecordAvatar
    });

    function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$4(target, key, source[key]); }); } return target; }

    function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    /*  *******************************************************************************************
     *  ATTENTION!
     *  THIS IS A GENERATED FILE FROM https://github.com/salesforce/lds
     *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
     *  Any changes made to this file in p4 will be automatically overwritten.
     *  *******************************************************************************************
     */
    const {
      assign,
      create,
      freeze,
      keys
    } = Object;

    function isFieldId(value) {
      return value && typeof value.objectApiName === 'string' && typeof value.fieldApiName === 'string';
    }
    /**
     * Split the object API name and field API name from a qualified field name.
     * Eg: Opportunity.Title returns ['Opportunity', 'Title']
     * Eg: Opportunity.Account.Name returns ['Opportunity', 'Account.Name']
     * @param fieldApiName The qualified field name.
     * @return The object and field API names.
     */


    function splitQualifiedFieldApiName$1(fieldApiName) {
      const idx = fieldApiName.indexOf('.');

      if (idx < 1) {
        // object api name must non-empty
        throw new TypeError('Value does not include an object API name.');
      }

      return [fieldApiName.substring(0, idx), fieldApiName.substring(idx + 1)];
    }

    function isString(value) {
      return typeof value === 'string';
    }
    /**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @return The qualified field API name.
     */


    function getFieldApiName$2(value) {
      // Note: tightening validation logic changes behavior from userland getting
      // a server-provided error to the adapter noop'ing. In 224 we decided to not
      // change the behavior.
      if (isString(value)) {
        const trimmed = value.trim();

        if (trimmed.length > 0) {
          return trimmed;
        }
      } else if (isFieldId(value)) {
        return value.objectApiName + '.' + value.fieldApiName;
      }

      return undefined;
    }
    /**
     * Returns a new object that has a list of fields that has been filtered by
     * edited fields. Only contains fields that have been edited from their original
     * values (excluding Id which is always copied over).
     * @param input The RecordInputRepresentation object to filter.
     * @param original The Record object that contains the original field values.
     * @returns RecordInputRepresentation, see the description
     */


    function createRecordInputFilteredByEditedFields$1(input, original) {
      const filteredRecordInput = getRecordInput$1(); // Always copy over any existing id.

      if (original.id) {
        filteredRecordInput.fields.Id = original.id;
      }

      const recordInputFields = input.fields;
      const originalRecordFields = original.fields;
      const recordInputFieldPropertyNames = keys(recordInputFields);

      for (let i = 0, len = recordInputFieldPropertyNames.length; i < len; i++) {
        const fieldName = recordInputFieldPropertyNames[i];
        let originalRecordFieldsEntry;

        if (originalRecordFields) {
          originalRecordFieldsEntry = originalRecordFields[fieldName];
        }

        if (!originalRecordFieldsEntry || originalRecordFields && recordInputFields[fieldName] !== originalRecordFieldsEntry.value) {
          filteredRecordInput.fields[fieldName] = recordInputFields[fieldName];
        }
      }

      return filteredRecordInput;
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned. This object can be
     * used to create a record.
     * @param record The record that contains the source data.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that are createable=true (excluding Id) will
     *        be assigned to the object return value.
     * @returns RecordInputRepresentation See description.
     */


    function generateRecordInputForCreate$1(record, objectInfo) {
      const recordInput = _generateRecordInput$1(record, field => field.createable === true, objectInfo);

      recordInput.apiName = record.apiName; // fields.Id is not required for CREATE which might have been copied over,
      // so delete fields.Id

      delete recordInput.fields.Id;
      return recordInput;
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned. This object can be
     * used to update a record.
     * @param record The record that contains the source data.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that are updateable=true (excluding Id) will
     *        be assigned to the object return value.
     * @returns RecordInputRepresentation See description.
     */


    function generateRecordInputForUpdate$1(record, objectInfo) {
      const recordInput = _generateRecordInput$1(record, field => field.updateable === true, objectInfo);

      if (!record.id) {
        throw new Error('record must have id for update');
      } // Always copy over any existing id.


      recordInput.fields.Id = record.id;
      return recordInput;
    }

    function isRecordInputFieldValue(unknown) {
      const type = typeof unknown;
      return unknown === null || type === 'string' || type === 'number' || type === 'boolean';
    }
    /**
     * Returns an object with its data populated from the given record. All fields
     * with values that aren't nested records will be assigned.
     * @param record The record that contains the source data.
     * @param copyFieldPredicate predicate to determine if a field should be copied.
     *        Required if "objectInfo" parameter is passed.
     * @param objectInfo The ObjectInfo corresponding to the apiName on the record.
     *        If provided, only fields that match the copyFieldPredicate (excluding
     *        Id) will be assigned to the object return value.
     * @returns RecordInputRepresentation
     */


    function _generateRecordInput$1(record, copyFieldPredicate, objectInfo) {
      const recordInput = getRecordInput$1();
      const recordFields = record.fields;
      let objectInfoFields;

      if (objectInfo) {
        objectInfoFields = objectInfo.fields;
      }

      const recordFieldPropertyNames = keys(recordFields);

      for (let i = 0, len = recordFieldPropertyNames.length; i < len; i++) {
        const fieldName = recordFieldPropertyNames[i];
        const recordFieldsFieldNameEntry = recordFields[fieldName].value;

        if (isRecordInputFieldValue(recordFieldsFieldNameEntry)) {
          if (objectInfoFields && copyFieldPredicate) {
            const objectInfoFieldsFieldNameValue = objectInfoFields[fieldName];

            if (objectInfoFieldsFieldNameValue && copyFieldPredicate(objectInfoFieldsFieldNameValue)) {
              recordInput.fields[fieldName] = recordFieldsFieldNameEntry;
            }
          } else {
            recordInput.fields[fieldName] = recordFieldsFieldNameEntry;
          }
        }
      }

      return recordInput;
    }
    /**
     * Gets a new Record Input.
     */


    function getRecordInput$1() {
      return {
        apiName: undefined,
        fields: {}
      };
    }
    /**
     * Gets a field's value from a record.
     * @param record The record.
     * @param field The qualified API name of the field to return.
     * @returns The field's value (which may be a record in the case of spanning
     *          fields), or undefined if the field isn't found.
     */


    function getFieldValue$1(record, field) {
      const fieldValueRepresentation = getField(record, field);

      if (fieldValueRepresentation === undefined) {
        return undefined;
      }

      if (isFieldValueRepresentation(fieldValueRepresentation)) {
        return fieldValueRepresentation.value;
      }

      return fieldValueRepresentation;
    }
    /**
     * Gets a field's display value from a record.
     * @param record The record.
     * @param field The qualified API name of the field to return.
     * @returns The field's display value, or undefined if the field isn't found.
     */


    function getFieldDisplayValue$1(record, field) {
      const fieldValueRepresentation = getField(record, field);

      if (fieldValueRepresentation === undefined) {
        return undefined;
      }

      if (isFieldValueRepresentation(fieldValueRepresentation)) {
        return fieldValueRepresentation.displayValue;
      }

      return fieldValueRepresentation;
    }

    function isFieldValueRepresentation(unknown) {
      if (typeof unknown !== 'object' || unknown === null) {
        return false;
      }

      return 'value' in unknown && 'displayValue' in unknown;
    }

    function getField(record, field) {
      const fieldApiName = getFieldApiName$2(field);

      if (fieldApiName === undefined) {
        return undefined;
      }

      const unqualifiedField = splitQualifiedFieldApiName$1(fieldApiName)[1];
      const fields = unqualifiedField.split('.');
      let r = record;

      while (r && r.fields) {
        const f = fields.shift();
        const fvr = r.fields[f];

        if (fvr === undefined) {
          return undefined;
        } else if (fields.length > 0) {
          r = fvr.value;
        } else {
          return fvr;
        }
      }

      return r;
    }

    var LayoutType;

    (function (LayoutType) {
      LayoutType["Full"] = "Full";
      LayoutType["Compact"] = "Compact";
    })(LayoutType || (LayoutType = {}));

    var LayoutMode;

    (function (LayoutMode) {
      LayoutMode["View"] = "View";
      LayoutMode["Edit"] = "Edit";
      LayoutMode["Create"] = "Create";
    })(LayoutMode || (LayoutMode = {}));

    const getListUiByApiName_ConfigPropertyNames = {
      displayName: 'getListUiByApiName',
      parameters: {
        required: ['objectApiName', 'listViewApiName'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
      }
    };
    const getListUiByListViewId_ConfigPropertyNames = {
      displayName: 'getListUiByListViewId',
      parameters: {
        required: ['listViewId'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
      }
    };
    const getMruListUi_ConfigPropertyNames = {
      displayName: 'getMruListUi',
      parameters: {
        required: ['objectApiName'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
      }
    }; // make local copies of the adapter configs so we can ignore other getListUi config parameters to match
    // lds222 behavior

    const getMruListUi_ConfigPropertyNames_augmented = _objectSpread$4({}, getMruListUi_ConfigPropertyNames, {
      parameters: _objectSpread$4({}, getMruListUi_ConfigPropertyNames.parameters, {
        optional: [...getMruListUi_ConfigPropertyNames.parameters.optional, 'listViewApiName', 'listViewId']
      })
    }); // make local copies of the adapter configs so we can have them ignore each other's config parameters
    // to match lds222 behavior


    const getListUiByApiName_ConfigPropertyNames_augmented = _objectSpread$4({}, getListUiByApiName_ConfigPropertyNames, {
      parameters: _objectSpread$4({}, getListUiByApiName_ConfigPropertyNames.parameters, {
        optional: [...getListUiByApiName_ConfigPropertyNames.parameters.optional, 'listViewId']
      })
    });

    const getListUiByListViewId_ConfigPropertyNames_augmented = _objectSpread$4({}, getListUiByListViewId_ConfigPropertyNames, {
      parameters: _objectSpread$4({}, getListUiByListViewId_ConfigPropertyNames.parameters, {
        optional: [...getListUiByListViewId_ConfigPropertyNames.parameters.optional, 'listViewApiName', 'objectApiName']
      })
    });

    const DEFAULT_MODE = LayoutMode.View;
    var FormFactor;

    (function (FormFactor) {
      FormFactor["Large"] = "Large";
      FormFactor["Medium"] = "Medium";
      FormFactor["Small"] = "Small";
    })(FormFactor || (FormFactor = {}));

    const select$e = function LeadStatusPicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$h();
      return {
        kind: 'Fragment',
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'converted',
          kind: 'Scalar'
        }]
      };
    };

    const select$f = function CaseStatusPicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$h();
      return {
        kind: 'Fragment',
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'closed',
          kind: 'Scalar'
        }]
      };
    };

    const select$g = function OpportunityStagePicklistValueAttributesRepresentationSelect() {
      const {
        selections: AbstractPicklistValueAttributesRepresentationSelections
      } = select$h();
      return {
        kind: 'Fragment',
        selections: [...AbstractPicklistValueAttributesRepresentationSelections, {
          name: 'closed',
          kind: 'Scalar'
        }, {
          name: 'defaultProbability',
          kind: 'Scalar'
        }, {
          name: 'forecastCategoryName',
          kind: 'Scalar'
        }, {
          name: 'won',
          kind: 'Scalar'
        }]
      };
    };

    const selectChildren = function AbstractPicklistValueAttributesRepresentationSelectChildren(params) {
      const {
        selections: LeadStatusPicklistValueAttributesRepresentationSelections
      } = select$e();
      const {
        selections: CaseStatusPicklistValueAttributesRepresentationSelections
      } = select$f();
      const {
        selections: OpportunityStagePicklistValueAttributesRepresentationSelections
      } = select$g();
      return {
        kind: 'Object',
        name: params.propertyName,
        nullable: params.nullable,
        union: true,
        discriminator: 'picklistAtrributesValueType',
        unionSelections: {
          LeadStatus: LeadStatusPicklistValueAttributesRepresentationSelections,
          CaseStatus: CaseStatusPicklistValueAttributesRepresentationSelections,
          OpportunityStage: OpportunityStagePicklistValueAttributesRepresentationSelections
        }
      };
    };

    const select$h = function AbstractPicklistValueAttributesRepresentationSelect() {
      return {
        kind: 'Fragment',
        selections: [{
          name: 'picklistAtrributesValueType',
          kind: 'Scalar'
        }]
      };
    };

    const select$i = function PicklistValueRepresentationSelect() {
      const AbstractPicklistValueAttributesRepresentation__unionSelections = selectChildren({
        propertyName: 'attributes',
        nullable: true
      });
      return {
        kind: 'Fragment',
        selections: [AbstractPicklistValueAttributesRepresentation__unionSelections, {
          name: 'label',
          kind: 'Scalar'
        }, {
          name: 'validFor',
          kind: 'Scalar',
          plural: true
        }, {
          name: 'value',
          kind: 'Scalar'
        }]
      };
    };

    const select$j = function PicklistValuesRepresentationSelect() {
      const {
        selections: PicklistValueRepresentation__selections,
        opaque: PicklistValueRepresentation__opaque
      } = select$i();
      return {
        kind: 'Fragment',
        selections: [{
          name: 'controllerValues',
          kind: 'Scalar',
          map: true
        }, {
          name: 'defaultValue',
          kind: 'Object',
          nullable: true,
          selections: PicklistValueRepresentation__selections
        }, {
          name: 'url',
          kind: 'Scalar'
        }, {
          name: 'values',
          kind: 'Object',
          plural: true,
          selections: PicklistValueRepresentation__selections
        }]
      };
    };

    const path = select$j().selections;
    const {
      hasOwnProperty
    } = Object.prototype;
    /**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @return The qualified field API name.
     */

    function getFieldApiName$1$1(value) {
      if (typeof value === 'string') {
        return value;
      } else if (value && typeof value.objectApiName === 'string' && typeof value.fieldApiName === 'string') {
        return value.objectApiName + '.' + value.fieldApiName;
      }

      throw new TypeError('Value is not a string or FieldId.');
    }
    /**
     * Split the object API name and field API name from a qualified field name.
     * Eg: Opportunity.Title returns ['Opportunity', 'Title']
     * Eg: Opportunity.Account.Name returns ['Opportunity', 'Account.Name']
     * @param fieldApiName The qualified field name.
     * @return The object and field API names.
     */


    function splitQualifiedFieldApiName$1$1(fieldApiName) {
      const idx = fieldApiName.indexOf('.');

      if (idx < 1) {
        // object api name must non-empty
        throw new TypeError('Value does not include an object API name.');
      }

      return [fieldApiName.substring(0, idx), fieldApiName.substring(idx + 1)];
    }

    const {
      isArray: ArrayIsArray
    } = Array;

    function untrustedIsObject(untrusted) {
      return typeof untrusted === 'object' && untrusted !== null && ArrayIsArray(untrusted) === false;
    }
    /**
     * Gets a field value from an Apex sObject.
     * @param sobject The sObject holding the field.
     * @param field The qualified API name of the field to return.
     * @returns The field's value. If it doesn't exist, undefined is returned.
     */


    function getSObjectValue$1(sObject, field) {
      if (untrustedIsObject(sObject) === false) {
        return;
      }

      const unqualifiedField = splitQualifiedFieldApiName$1$1(getFieldApiName$1$1(field))[1];
      const fields = unqualifiedField.split('.');
      let ret = sObject;

      for (let i = 0, fieldsLength = fields.length; i < fieldsLength; i++) {
        const nextField = fields[i];

        if (!hasOwnProperty.call(ret, nextField)) {
          return undefined;
        }

        ret = ret[nextField];
      }

      return ret;
    }

    function _objectSpread$5(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?Object(arguments[i]):{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==='function'){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable;}));}ownKeys.forEach(function(key){_defineProperty$5(target,key,source[key]);});}return target;}function _defineProperty$5(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}// really should just be whatever the server sends back for currentPageToken
    // when the request did not specify a pageToken parameter.
    const DEFAULT_TOKEN='0';const END_TOKEN='__END__';// TODO: re-evaluate passing save function vs something like getPaginationData
    function pagination(pd,save){const pd_=pd||{[DEFAULT_TOKEN]:0};return {defaultToken:()=>DEFAULT_TOKEN,endOffset:()=>pd_[END_TOKEN],isPastEnd:offset=>{return END_TOKEN in pd_&&offset>=pd_[END_TOKEN];},limitToEnd:offset=>{return END_TOKEN in pd_&&offset>=pd_[END_TOKEN]?pd_[END_TOKEN]:offset;},offsetFor:token=>{return pd_[token||DEFAULT_TOKEN];},save:()=>{if(!save){{throw new Error('pagination.save() invoked but no save function supplied');}}else {save(pd_);}},setEnd:offset=>{if(offset===undefined){delete pd_[END_TOKEN];}else {pd_[END_TOKEN]=offset;}},setToken:(token,offset)=>{if(offset===undefined){delete pd_[token];}else {pd_[token]=offset;}},tokenFor:offset=>{const tokens=Object.keys(pd_);for(let i=0;i<tokens.length;++i){if(pd_[tokens[i]]===offset){return tokens[i];}}},tokenForAtMost:offset=>{let result=[DEFAULT_TOKEN,0];const tokens=Object.keys(pd_);for(let i=0;i<tokens.length;++i){let offsetI=pd_[tokens[i]];if(offsetI<=offset&&offsetI>result[1]){result=[tokens[i],offsetI];}}return result;}};}function isUnionLinkSelection(sel){return sel.union===true&&sel.kind==='Link';}function isUnionObjectSelection(sel){return sel.union===true&&sel.kind==='Object';}const{keys: keys$1,create: create$1,freeze: freeze$1}=Object;const{hasOwnProperty: hasOwnProperty$1}=Object.prototype;const{isArray: isArray$1}=Array;const{push,indexOf,slice}=Array.prototype;const{stringify}=JSON;function formatStorageKey(name,argValues){if(!argValues){return name;}var values=[];for(var _argName in argValues){if(hasOwnProperty$1.call(argValues,_argName)){var value=argValues[_argName];if(value!==null||value!==undefined){values.push(_argName+':'+stringify(value));}}}return values.length===0?name:name+'('.concat(values.join(','),')');}function getArgumentValues(args,variables){const values={};args.forEach(arg=>{if(arg.kind==='Variable'){// Variables are provided at runtime and are not guaranteed to be stable.
    values[arg.name]=variables[arg.variableName];}else {values[arg.name]=arg.value;}});return values;}function getStorageKey(field,variables){const{args,name}=field;if(args&&args.length!==0){return formatStorageKey(name,getArgumentValues(args,variables));}return name;}const READER_PATH_ROOT='ROOT';const EMPTY_STRING='';class Reader{constructor(records,expirationMap,variables,refresh,baseSnapshot){this.missingPaths={};this.hasPendingData=false;this.variables=variables;this.records=records;this.seenIds={};this.isMissingData=false;this.refresh=refresh;// When we aren't passed a base snapshot, we don't have to worry about
    // marking the snapshot as changed because there is nothing to compare against.
    // Therefore, our initial state is that the snapshot has changed.
    let snapshotChanged=true;// When we aren't passed a base snapshot, we do not have any previous data
    // So we can just assign this to undefined
    let baseSnapshotValue=undefined;// When we are passed a base snapshot, we want to keep track of the previous data
    // We also will need to compare all of our data against the snapshot's previous data
    // Our initial state is that the snapshot has not changed. The reason for this is because
    // Once we detect a change, we can just flip this boolean on the first change and then
    // not have to worry about it for additional changes.
    if(baseSnapshot!==undefined&&baseSnapshot.state===SnapshotState.Fulfilled){baseSnapshotValue=baseSnapshot.data;snapshotChanged=false;}this.snapshotChanged=snapshotChanged;this.currentPath={fullPath:EMPTY_STRING,key:READER_PATH_ROOT,parent:null,baseSnapshotValue};this.baseSnapshot=baseSnapshot;this.expirationMap=expirationMap;this.timestamp=Date.now();}pagination(key){return pagination(this.records[key]);}read(selector){const{recordId}=selector;const record=this.storeLookup(recordId);const{node:selectorNode}=selector;// Record does not exist or is expired
    if(record===undefined){if(this.isMissingData===false){this.isMissingData=true;this.snapshotChanged=true;}return this.createSnapshot(undefined,selector);}// top level record could be null when opaque
    if(record===null&&selectorNode.opaque===true){return this.createSnapshot(null,selector);}if(isStoreRecordError(record)){return this.createErrorSnapshot(record.error);}if(selectorNode.opaque===true){this.checkIfChanged(record);return this.createSnapshot(record,selector);}let data=isArray$1(record)?[]:{};this.traverseSelections(selectorNode,record,data);freeze$1(data);return this.createSnapshot(data,selector);}getSnapshotState(){if(this.isMissingData===true){return SnapshotState.Unfulfilled;}if(this.hasPendingData===true){return SnapshotState.Pending;}return SnapshotState.Fulfilled;}createErrorSnapshot(data){return {data:undefined,error:data,state:SnapshotState.Error,refresh:this.refresh};}createSnapshot(data,selector){if(this.snapshotChanged===false){return this.baseSnapshot;}return {recordId:selector.recordId,select:selector,variables:this.variables,seenRecords:this.seenIds,data,state:this.getSnapshotState(),missingPaths:this.missingPaths,refresh:this.refresh};// Typescript complains about unfulfilled vs fulfilled snapshot if we don't cast
    }deepCopy(record,data,key,visitedKeys){const value=record[key];this.enterPath(key);if(isArray$1(value)){// Array
    const items=[];this.selectAll(value,items,visitedKeys);data[key]=items;}else if(typeof value==='object'&&value!==null){// Object
    if(value.__ref!==undefined){// Link
    const nextRecordId=value.__ref;if(isArray$1(nextRecordId)){const items=[];this.selectAll(nextRecordId,items,visitedKeys);data[key]=items;}else {if(hasOwnProperty$1.call(visitedKeys,nextRecordId)===true){throw new Error(`Invalid eager selection on records with circular references.`);}this.seenIds[nextRecordId]=true;const nextRecord=this.storeLookup(nextRecordId);if(nextRecord===undefined){this.markMissing();data[key]=undefined;}else {const nested={};this.selectAll(nextRecord,nested,_objectSpread$5({},visitedKeys,{[nextRecordId]:true}));data[key]=nested;}}}else {// Inlined object
    const items={};this.selectAll(value,items,visitedKeys);data[key]=items;}}else {// Scalar
    this.checkIfChanged(value);data[key]=value;}this.exitPath();}selectAllArray(record,data,visitedKeys){const{length}=record;for(let key=0;key<length;key+=1){this.deepCopy(record,data,key,visitedKeys);}}selectAllObject(record,data,visitedKeys){const recordKeys=keys$1(record);const{length}=recordKeys;for(let i=0;i<length;i+=1){const key=recordKeys[i];this.deepCopy(record,data,key,visitedKeys);}}selectAll(record,data,visitedKeys={}){const recordIsArray=isArray$1(record);if(recordIsArray===true){this.selectAllArray(record,data,visitedKeys);}else {this.selectAllObject(record,data,visitedKeys);}freeze$1(data);}markPending(){this.hasPendingData=true;}markMissing(){this.isMissingData=true;this.missingPaths[this.currentPath.fullPath]=true;this.checkIfChanged(undefined);}assignNonScalar(sink,key,value){sink[key]=value;freeze$1(value);}enterPath(key){const parent=this.currentPath;const{key:parentKey,fullPath:parentFullPath,baseSnapshotValue:parentBaseSnapshotValue}=parent;let baseSnapshotValue=undefined;if(parentBaseSnapshotValue!==undefined&&parentBaseSnapshotValue!==null){baseSnapshotValue=parentBaseSnapshotValue[key];}this.currentPath={parent,key,fullPath:parentKey===READER_PATH_ROOT?key:parentFullPath+'.'+key,baseSnapshotValue};}exitPath(){this.currentPath=this.currentPath.parent;}readSingleLink(propertyName,selection,record,data){const{seenIds:ids}=this;const link=record[propertyName];// This condition is hit when the link it self isn't present
    if(link===undefined){return this.markMissing();}if(selection.nullable===true&&link===null){this.readScalar(propertyName,record,data);return;}const{__ref:refId,pending,isMissing}=link;if(pending===true){this.markPending();return;}if(isMissing===true&&selection.required===false){return;}if(refId===undefined){return this.markMissing();}const linkedRecord=this.storeLookup(refId);// This condition is hit when the link is present
    // but the node it is pointing to is not present
    if(linkedRecord===undefined){if(selection.required===false){return;}return this.markMissing();}ids[refId]=true;const obj=isArray$1(linkedRecord)?[]:{};if(selection.selections===undefined){this.selectAll(linkedRecord,obj);}else {this.traverseSelections(selection,linkedRecord,obj);}this.assignNonScalar(data,propertyName,obj);}readObject(key,selection,source,sink){const sourceValue=source[key];if(selection.nullable===true&&sourceValue===null){this.readScalar(key,source,sink);return;}if(selection.opaque===true){this.readOpaque(sink,key,sourceValue);return;}if(sourceValue===undefined){if(selection.required===false){return;}return this.markMissing();}const sinkValue=isArray$1(sourceValue)?[]:{};if(selection.selections===undefined){this.selectAll(sourceValue,sinkValue);}else {this.traverseSelections(selection,sourceValue,sinkValue);}this.assignNonScalar(sink,key,sinkValue);}checkIfChanged(value){// If we've already detected a change, just return
    if(this.snapshotChanged===true){return;}this.snapshotChanged=this.currentPath.baseSnapshotValue!==value;}computeCopyBounds(array,selection){// pageToken *can* be undefined
    if(selection.tokenDataKey!==undefined&&selection.pageSize!==undefined){const pagination=this.pagination(selection.tokenDataKey);const startingOffset=pagination.offsetFor(selection.pageToken);if(startingOffset===undefined){return;}const endingOffset=pagination.limitToEnd(startingOffset+selection.pageSize);this.seenIds[selection.tokenDataKey]=true;return [startingOffset,endingOffset];}else {return [0,array.length];}}/**
         * This method is public *only* so CustomReaders can call it.
         */readPluralLink(propertyName,selection,record,data){if(selection.selections===undefined){return;}const{storeLookup,seenIds:ids}=this;const array=record[propertyName];const[start,end]=this.computeCopyBounds(array,selection)||[-1,-1];if(start<0){return this.markMissing();}const sink=data[propertyName]=[];for(let i=start;i<end;i+=1){this.enterPath(i);const next=array[i];const nextId=next&&next.__ref;const nextRecord=nextId&&storeLookup.call(this,nextId);if(nextRecord===undefined){this.markMissing();this.exitPath();return;}ids[nextId]=true;const obj={};this.traverseSelections(selection,nextRecord,obj);this.assignNonScalar(sink,i-start,obj);freeze$1(obj);this.exitPath();}freeze$1(sink);}readObjectMap(propertyName,selection,record,data){const obj=record[propertyName];if(obj===undefined){if(selection.required===false){return;}return this.markMissing();}const sink=data[propertyName]={};const keys$1$1=keys$1(obj);for(let i=0,len=keys$1$1.length;i<len;i+=1){const key=keys$1$1[i];this.enterPath(key);this.readObject(key,selection,obj,sink);this.exitPath();}freeze$1(sink);}readLinkMap(propertyName,selection,record,data){const{seenIds:ids}=this;const map=record[propertyName];const keys$1$1=keys$1(map);const sink=data[propertyName]={};for(let i=0,len=keys$1$1.length;i<len;i+=1){const key=keys$1$1[i];this.enterPath(key);const next=map[key];const nextId=next.__ref;const nextRecord=this.storeLookup(nextId);if(nextRecord===undefined){this.markMissing();this.exitPath();return;}ids[nextId]=true;const obj={};this.traverseSelections(selection,nextRecord,obj);this.assignNonScalar(sink,key,obj);freeze$1(obj);this.exitPath();}freeze$1(sink);}/**
         * This method is public *only* so CustomReaders can call it.
         */readPluralObject(propertyName,selection,record,data){if(selection.selections===undefined){return;}const array=record[propertyName];const[start,end]=this.computeCopyBounds(array,selection)||[-1,-1];if(start<0){return this.markMissing();}const sink=data[propertyName]=[];for(let i=start;i<end;i+=1){this.enterPath(i);const nextRecord=array[i];if(nextRecord===undefined){this.markMissing();this.exitPath();return;}const obj={};this.traverseSelections(selection,nextRecord,obj);push.call(sink,obj);freeze$1(obj);this.exitPath();}freeze$1(sink);}readOpaque(sink,propertyName,value){sink[propertyName]=value;this.checkIfChanged(value);}readScalarMap(propertyName,record,data){const obj=record[propertyName];const sink=data[propertyName]={};const keys$1$1=keys$1(obj);for(let i=0,len=keys$1$1.length;i<len;i+=1){const key=keys$1$1[i];this.enterPath(key);this.readScalar(key,obj,sink);this.exitPath();}freeze$1(sink);}readScalarPlural(propertyName,record,data){const array=record[propertyName];const sink=data[propertyName]=[];for(let i=0,len=array.length;i<len;i+=1){this.enterPath(i);const value=array[i];push.call(sink,value);this.checkIfChanged(value);this.exitPath();}freeze$1(sink);}/**
         * This method is public *only* so CustomReaders can call it.
         */readScalar(propertyName,record,data){if(!hasOwnProperty$1.call(record,propertyName)){return this.markMissing();}data[propertyName]=record[propertyName];this.checkIfChanged(record[propertyName]);}/**
         * This method is public *only* so CustomReaders can call it.
         */storeLookup(recordId){const value=this.records[recordId];if(value===undefined){return undefined;}const expiration=this.expirationMap[recordId];if(expiration!==undefined&&this.timestamp>expiration){return undefined;}return value;}selectUnion(selection,storeEntry,discriminatedObject,sink){const{discriminator}=selection;const discriminatorValue=discriminatedObject[discriminator];{if(discriminatorValue===undefined){throw new Error(`Invalid discriminator. Expected discriminator at path "${this.currentPath.fullPath}.${discriminator}" but received "${stringify(discriminatedObject)}"`);}}const unionSelection=selection.unionSelections[discriminatorValue];{if(unionSelection===undefined){throw new Error(`Invalid union selection. Expected selector for "${discriminatorValue}" but received "${unionSelection}"`);}}const childSelection={selections:unionSelection,name:selection.name,kind:selection.kind};this.traverseSelection(childSelection,storeEntry,sink);}selectObjectUnion(selection,source,sink){const{name:propertyName}=selection;const object=source[propertyName];if(object===undefined){this.markMissing();return;}if(selection.nullable===true&&object===null){this.readScalar(propertyName,source,sink);return;}this.selectUnion(selection,source,object,sink);}selectLinkUnion(selection,source,sink){const{name:propertyName}=selection;const sourceValue=source[propertyName];const link=source[propertyName];// This condition is hit when the link it self isn't present
    if(link===undefined){return this.markMissing();}if(selection.nullable===true&&sourceValue===null){this.readScalar(propertyName,sourceValue,sink);return;}const{__ref:refId}=link;if(refId===undefined){return this.markMissing();}const linkedRecord=this.records[refId];// If we can't find the link, mark it as missing
    if(linkedRecord===undefined){return this.markMissing();}this.selectUnion(selection,source,linkedRecord,sink);}traverseSelection(selection,record,data){const{variables}=this;const key=getStorageKey(selection,variables);if(isUnionLinkSelection(selection)){this.selectLinkUnion(selection,record,data);return;}else if(isUnionObjectSelection(selection)){this.selectObjectUnion(selection,record,data);return;}this.enterPath(key);if(selection.kind==='Link'){if(selection.plural===true){this.readPluralLink(key,selection,record,data);}else if(selection.map===true){this.readLinkMap(key,selection,record,data);}else {this.readSingleLink(key,selection,record,data);}}else if(selection.kind==='Scalar'){if(selection.map===true){this.readScalarMap(key,record,data);}else if(selection.plural===true){this.readScalarPlural(key,record,data);}else {this.readScalar(key,record,data);}}else if(selection.kind==='Object'){if(selection.map===true){this.readObjectMap(key,selection,record,data);}else if(selection.plural===true){this.readPluralObject(key,selection,record,data);}else {this.readObject(key,selection,record,data);}}else if(selection.kind==='Custom'){selection.reader(key,selection,record,data,variables,this);}this.exitPath();}traverseSelections(node,record,data){const{selections}=node;if(selections===undefined){this.selectAll(record,data);return;}const{length:len}=selections;for(let i=0;i<len;i+=1){const selection=selections[i];this.traverseSelection(selection,record,data);}}}function deepFreeze(value){// No need to freeze primitives
    if(typeof value!=='object'||value===null){return;}if(isArray$1(value)){for(let i=0,len=value.length;i<len;i+=1){deepFreeze(value[i]);}}else {const keys$1$1=keys$1(value);for(let i=0,len=keys$1$1.length;i<len;i+=1){deepFreeze(value[keys$1$1[i]]);}}freeze$1(value);}var SnapshotState;(function(SnapshotState){SnapshotState["Fulfilled"]="Fulfilled";SnapshotState["Unfulfilled"]="Unfulfilled";SnapshotState["Error"]="Error";SnapshotState["Pending"]="Pending";})(SnapshotState||(SnapshotState={}));function isErrorSnapshot(snapshot){return snapshot.state===SnapshotState.Error;}function isFulfilledSnapshot(snapshot){return snapshot.state===SnapshotState.Fulfilled;}function isUnfulfilledSnapshot(snapshot){return snapshot.state===SnapshotState.Unfulfilled;}function createErrorSnapshot(error){deepFreeze(error);const snap={error,state:SnapshotState.Error,data:undefined};return snap;}function createSnapshot(records,recordExpirations,selector,refresh){return new Reader(records,recordExpirations,selector.variables,refresh).read(selector);}function rebuildSnapshot(snapshot,records,recordExpirations){return new Reader(records,recordExpirations,snapshot.variables,snapshot.refresh,snapshot).read(snapshot.select);}// Cannot use a symbol because we cannot serialize a symbol
    // Also, IE11 polyfill have problems when a lot of symbols
    // are created
    var StoreErrorStatus;(function(StoreErrorStatus){StoreErrorStatus[StoreErrorStatus["RESOURCE_NOT_FOUND"]=404]="RESOURCE_NOT_FOUND";})(StoreErrorStatus||(StoreErrorStatus={}));var StoreRecordType;(function(StoreRecordType){StoreRecordType["Error"]="error";})(StoreRecordType||(StoreRecordType={}));function isStoreRecordError(storeRecord){return storeRecord.__type===StoreRecordType.Error;}function hasOverlappingIds(snapshot,visitedIds){const{length:len}=visitedIds;const{seenRecords}=snapshot;for(let i=0;i<len;i+=1){const id=visitedIds[i];if(seenRecords[id]||id===snapshot.recordId){return true;}}return false;}function getMatchingIds(prefix,visitedIds){const matchingIds=[];for(let i=0,len=visitedIds.length;i<len;i++){const visitedId=visitedIds[i];if(visitedId.indexOf(prefix)===0){push.call(matchingIds,visitedId);}}return matchingIds;}class Store{constructor(){this.recordExpirations=create$1(null);this.records=create$1(null);this.snapshotSubscriptions=[];this.watchSubscriptions=[];this.visitedIds=create$1(null);this.insertedIds=create$1(null);this.selectorToDataSnapshotMap=new WeakMap();}reset(){this.recordExpirations=create$1(null);this.records=create$1(null);this.snapshotSubscriptions=[];this.watchSubscriptions=[];this.visitedIds=create$1(null);this.insertedIds=create$1(null);}publish(recordId,record){const{records,visitedIds,insertedIds}=this;if(hasOwnProperty$1.call(records,recordId)===false){insertedIds[recordId]=true;}records[recordId]=record;{freeze$1(record);}visitedIds[recordId]=true;}setExpiration(recordId,time){this.recordExpirations[recordId]=time;}broadcast(){// Note: we should always get the subscription references from this at the beginning
    // of the function, in case the reference changes (because of an unsubscribe)
    const{snapshotSubscriptions,watchSubscriptions,visitedIds,insertedIds,records}=this;const allVisitedIds=keys$1(visitedIds);// Early exit if nothing has changed
    if(allVisitedIds.length===0){return;}// Process snapshot subscriptions
    for(let i=0,len=snapshotSubscriptions.length;i<len;i++){const subscription=snapshotSubscriptions[i];const{snapshot,callback}=subscription;// Don't re-emit the snapshot if there is no overlap between the visited keys and the
    // snapshot seen keys.
    if(isErrorSnapshot(snapshot)||hasOverlappingIds(snapshot,allVisitedIds)===false){continue;}const updatedSnapshot=subscription.snapshot=rebuildSnapshot(snapshot,records,{});if((isFulfilledSnapshot(updatedSnapshot)||isErrorSnapshot(updatedSnapshot))&&updatedSnapshot!==snapshot){callback(updatedSnapshot);}else if(isUnfulfilledSnapshot(updatedSnapshot)){const{refresh}=updatedSnapshot;if(refresh!==undefined){refresh.resolve(refresh.config);}}}// Process watch subscriptions
    for(let i=0,len=watchSubscriptions.length;i<len;i++){const{prefix,callback}=watchSubscriptions[i];const matchingIds=getMatchingIds(prefix,allVisitedIds);if(matchingIds.length>0){const watchCallbackEntries=[];for(let i=0,len=matchingIds.length;i<len;i++){const id=matchingIds[i];const inserted=insertedIds[id]||false;push.call(watchCallbackEntries,{id,inserted});}callback(watchCallbackEntries);}}this.visitedIds=create$1(null);this.insertedIds=create$1(null);}lookup(selector,refresh){const{records,recordExpirations}=this;return createSnapshot(records,recordExpirations,selector,refresh);}lookupMemoize(selector,refresh){const{records,recordExpirations}=this;const snapshot=this.selectorToDataSnapshotMap.get(selector);let returnSnapshot;if(snapshot===undefined){returnSnapshot=createSnapshot(records,recordExpirations,selector,refresh);}else {returnSnapshot=rebuildSnapshot(snapshot,records,recordExpirations);}this.selectorToDataSnapshotMap.set(selector,returnSnapshot);return returnSnapshot;}subscribe(snapshot,callback){const subscription={snapshot,callback};this.snapshotSubscriptions=[...this.snapshotSubscriptions,subscription];return ()=>{const{snapshotSubscriptions}=this;const index=indexOf.call(snapshotSubscriptions,subscription);this.snapshotSubscriptions=[...slice.call(snapshotSubscriptions,0,index),...slice.call(snapshotSubscriptions,index+1)];{this.snapshotSubscriptions=freeze$1(this.snapshotSubscriptions);}};}watch(prefix,callback){const subscription={prefix,callback};this.watchSubscriptions=[...this.watchSubscriptions,subscription];return ()=>{const{watchSubscriptions}=this;const index=indexOf.call(watchSubscriptions,subscription);this.watchSubscriptions=[...slice.call(watchSubscriptions,0,index),...slice.call(watchSubscriptions,index+1)];{this.watchSubscriptions=freeze$1(this.watchSubscriptions);}};}evict(key){delete this.records[key];this.visitedIds[key]=true;}}function isNodeLink(node){return typeof node==='object'&&node!==null&&hasOwnProperty$1.call(node,'__ref');}var GraphNodeType;(function(GraphNodeType){GraphNodeType["Link"]="Link";GraphNodeType["Node"]="Node";GraphNodeType["Error"]="Error";})(GraphNodeType||(GraphNodeType={}));class GraphNodeError{constructor(store,data){this.type=GraphNodeType.Error;this.store=store;this.data=data;}retrieve(){return this.data;}}function followLink(store,key){return store.records[key];}class GraphLink{constructor(store,data){this.type=GraphNodeType.Link;this.store=store;this.data=data;}isPending(){return this.data.pending===true;}isMissing(){return this.data.isMissing===true;}follow(){const{__ref}=this.data;if(__ref===undefined){return null;}const linked=followLink(this.store,__ref);if(linked===null||linked===undefined){return null;}if(isStoreRecordError(linked)){return new GraphNodeError(this.store,linked);}return new GraphNode(this.store,linked);}linkData(){return this.data.data;}writeLinkData(data){this.data.data=data;}}class GraphNode{constructor(store,data){this.type=GraphNodeType.Node;this.store=store;this.data=data;}object(propertyName){const value=this.data[propertyName];if(isNodeLink(value)){throw new Error(`Cannot walk to path ${propertyName}. "${propertyName}" is a link: "${value}"`);}if(typeof value!=='object'||value===null){throw new Error(`Cannot walk to path ${propertyName}. "${propertyName}" is a scalar: "${value}"`);}return new GraphNode(this.store,value);}link(propertyName){const value=this.data[propertyName];if(!isNodeLink(value)){throw new Error(`Cannot walk to link ${propertyName}. "${propertyName}" is not a link: "${value}"`);}return new GraphLink(this.store,value);}scalar(propertyName){const value=this.data[propertyName];if(typeof value==='object'&&value!==null){throw new Error(`Cannot return value at path ${propertyName}. ${propertyName} is not a scalar.`);}return value;}keys(){return keys$1(this.data);}isScalar(propertyName){// TODO W-6900046 - merge.ts casts these to any and manually sets `data`
    // so this guard is required
    if(this.data===undefined){return true;}const value=this.data[propertyName];return typeof value!=='object'||value===null;}write(propertyName,value){this.data[propertyName]=value;}isUndefined(propertyName){return this.data[propertyName]===undefined;}retrieve(){return this.data;}}class LDS{constructor(store,networkAdapter){this.store=store;this.networkAdapter=networkAdapter;}pagination(key){let data=this.store.records[key];data=data&&_objectSpread$5({},data);return pagination(data,pd=>{this.storePublish(key,pd);});}storePublish(key,data){this.store.publish(key,data);}storeBroadcast(){this.store.broadcast();}storeIngest(key,request,response){if(request.ingest!==null){request.ingest(response,{fullPath:key,parent:null},this,this.store,Date.now());}}storeIngestFetchResponse(key,response,ttl){const{status}=response;deepFreeze(response);if(status===404){const{store}=this;const entry={__type:StoreRecordType.Error,status:StoreErrorStatus.RESOURCE_NOT_FOUND,error:response};freeze$1(entry);store.publish(key,entry);if(ttl!==undefined){store.setExpiration(key,Date.now()+ttl);}}}storeSubscribe(snapshot,callback){return this.store.subscribe(snapshot,callback);}storeWatch(prefix,callback){return this.store.watch(prefix,callback);}storeLookup(sel){return this.store.lookup(sel);}storeLookupMemoize(sel){return this.store.lookupMemoize(sel);}storeEvict(key){this.store.evict(key);}errorSnapshot(error){return createErrorSnapshot(error);}dispatchResourceRequest(resourceRequest,overrides){let mergedResourceRequest=resourceRequest;// Apply resource request override if passed as argument.
    if(overrides!==undefined){mergedResourceRequest=_objectSpread$5({},resourceRequest,{headers:_objectSpread$5({},resourceRequest.headers,overrides.headers)});}return this.networkAdapter(mergedResourceRequest);}refreshSnapshot(snapshot){const{refresh}=snapshot;if(refresh!==undefined){return refresh.resolve(refresh.config);}throw new Error('Snapshot is not refreshable');}getNode(key){const{store}=this;const value=store.records[key];// doesn't exist
    if(value===undefined){return null;}return this.wrapNormalizedGraphNode(value);}wrapNormalizedGraphNode(normalized){if(normalized===null){return null;}if(isStoreRecordError(normalized)){return new GraphNodeError(this.store,normalized);}return new GraphNode(this.store,normalized);}}var HttpStatusCode;(function(HttpStatusCode){HttpStatusCode[HttpStatusCode["Ok"]=200]="Ok";HttpStatusCode[HttpStatusCode["NotModified"]=304]="NotModified";HttpStatusCode[HttpStatusCode["NotFound"]=404]="NotFound";HttpStatusCode[HttpStatusCode["BadRequest"]=400]="BadRequest";HttpStatusCode[HttpStatusCode["ServerError"]=500]="ServerError";})(HttpStatusCode||(HttpStatusCode={}));const{freeze:freeze$1$1,keys:keys$1$1}=Object;const{isArray:isArray$1$1}=Array;const{stringify:stringify$1}=JSON;class Sanitizer{constructor(obj){this.obj=obj;this.copy={};this.currentPath={key:'',value:obj,parent:null,data:this.copy};}sanitize(){const sanitizer=this;stringify$1(this.obj,function(key,value){if(key===''){return value;}const parent=this;if(parent!==sanitizer.currentPath.value){sanitizer.exit(parent);}if(typeof value==='object'&&value!==null){sanitizer.enter(key,value);return value;}sanitizer.currentPath.data[key]=value;return value;});return this.copy;}enter(key,value){const{currentPath:parentPath}=this;const data=parentPath.data[key]=isArray$1$1(value)?[]:{};this.currentPath={key,value,parent:parentPath,data};}exit(parent){while(this.currentPath.value!==parent){this.currentPath=this.currentPath.parent||this.currentPath;}}}/**
     * Returns a sanitized version of an object by recursively unwrapping the Proxies.
     *
     * In order to keep the LDS performance optimal on IE11, we need to make sure that LDS code get
     * transform by the es5-proxy-compat. At the same, time we need to ensure that no ProxyCompat leaks
     * into the LDS engine code nor into the adapters. All the data coming from LWC-land need to be
     * sanitized first.
     */function sanitize(obj){return new Sanitizer(obj).sanitize();}const USERLAND_PROVISION_ERROR_MESSAGE="LWC component's @wire target property or method threw an error during value provisioning. Original error:";const ADAPTER_SNAPSHOT_REJECTED_MESSAGE='Lightning Data Service wire adapter Promise<Snapshot> rejected. Original error:';const dataToSnapshotWeakMap=new WeakMap();function bindWireRefresh(lds){return function refresh(data){const snapshot=dataToSnapshotWeakMap.get(lwc.unwrap(data));if(snapshot!==undefined){return lds.refreshSnapshot(snapshot).then(refreshed=>{if(isErrorSnapshot(refreshed)){throw refreshed.error;}{if(isUnfulfilledSnapshot(refreshed)){throw new Error('Refresh resulted in unfulfilled snapshot');}}return undefined;});}{throw new Error('Refresh failed because resolved configuration is not available.');}};}function buildAdapterEventPayload(snapshot){// We should never broadcast an unfulfilled snapshot to a component
    {if(isUnfulfilledSnapshot(snapshot)){throw new Error(`Unfulfilled snapshot emitted to component from subscription, missingPaths: ${keys$1$1(snapshot.missingPaths)}`);}}if(isErrorSnapshot(snapshot)){return {data:undefined,error:snapshot.error};}else {// fulfilled
    return {data:snapshot.data,error:undefined};}}function dispatchValue(eventTarget,ValueChangedEvent,snapshot,_lds){const payload=buildAdapterEventPayload(snapshot);dataToSnapshotWeakMap.set(payload,snapshot);// ideally this should be handled by LWC event handler error handling
    try{eventTarget.dispatchEvent(new ValueChangedEvent(payload));}catch(error){if(error instanceof Error){error.message=`${USERLAND_PROVISION_ERROR_MESSAGE}\n[${error.message}]`;throw error;}}}function isPromise(value){// check for Thenable due to test frameworks using custom Promise impls
    return value.then!==undefined;}function dispatchAndSubscribe(wireService,eventTarget,lds){const{ValueChangedEvent}=wireService;return snapshot=>{if(isFulfilledSnapshot(snapshot)||isErrorSnapshot(snapshot)){dispatchValue(eventTarget,ValueChangedEvent,snapshot);}if(isErrorSnapshot(snapshot)){return;}if(isUnfulfilledSnapshot(snapshot)){{throw new Error(`Unfulfilled snapshot from adapterDispatchAndSubscribe, missingPaths: ${keys$1$1(snapshot.missingPaths)}`);}}return lds.storeSubscribe(snapshot,updated=>{dispatchValue(eventTarget,ValueChangedEvent,updated);});};}function register(lds,wireService,adapter,identifier){const wireIdentifier=identifier||(()=>{throw new Error();});const{register:wireServiceRegister,ValueChangedEvent}=wireService;wireServiceRegister(wireIdentifier,eventTarget=>{const adapterDispatchAndSubscribe=dispatchAndSubscribe(wireService,eventTarget,lds);let unsubscribe;let isConnected=false;let config;// initialize the wired property with a properly shaped object so cmps can use <template if:true={wiredProperty.data}>
    try{eventTarget.dispatchEvent(new ValueChangedEvent({data:undefined,error:undefined}));}catch(error){if(error instanceof Error){error.message=`${USERLAND_PROVISION_ERROR_MESSAGE}\n[${error.message}]`;throw error;}}function unsub(){if(unsubscribe){unsubscribe();unsubscribe=undefined;}}eventTarget.addEventListener('config',newConfig=>{unsub();config=newConfig;const snapshotOrPromise=adapter(sanitize(config));// insufficient config
    if(snapshotOrPromise===null){return;}// Data resolved sync
    if(!isPromise(snapshotOrPromise)){unsubscribe=adapterDispatchAndSubscribe(snapshotOrPromise);return;}// We want to let errors from this promise propagate to the app container,
    // which is why we do not have a reject handler here.
    // If an error is thrown here, it means that there was an error somewhere
    // inside an adapter which means that there was a mistake by the implementor.
    // Errors that come from the network should never hit this block because
    // they are treated like regular snapshots, not true error paths.
    function asyncHandler(oldConfig,snapshot){// if config has changed before promise resolves then ignore resolved value
    if(oldConfig!==config){return;}unsub();if(isConnected){unsubscribe=adapterDispatchAndSubscribe(snapshot);}}snapshotOrPromise.then(asyncHandler.bind(undefined,config),reason=>{if(reason instanceof Error){reason.message=`${ADAPTER_SNAPSHOT_REJECTED_MESSAGE}\n[${reason.message}]`;throw reason;}else {throw new Error(`${ADAPTER_SNAPSHOT_REJECTED_MESSAGE}\n[${stringify$1(reason)}]`);}});});eventTarget.addEventListener('connect',()=>{// TODO W-6568533 - wire reform changes this behavior
    isConnected=true;});eventTarget.addEventListener('disconnect',()=>{isConnected=false;unsub();});});return wireIdentifier;}const{keys:keys$2,values}=Object;const{isArray:isArray$2}=Array;const{stringify:stringify$2}=JSON;/**
     * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
     * This is needed because insertion order for JSON.stringify(object) affects output:
     * JSON.stringify({a: 1, b: 2})
     *      "{"a":1,"b":2}"
     * JSON.stringify({b: 2, a: 1})
     *      "{"b":2,"a":1}"
     * @param data Data to be JSON-stringified.
     * @returns JSON.stringified value with consistent ordering of keys.
     */function stableJSONStringify$1(node){// This is for Date values.
    if(node&&node.toJSON&&typeof node.toJSON==='function'){// eslint-disable-next-line no-param-reassign
    node=node.toJSON();}if(node===undefined){return;}if(typeof node==='number'){return isFinite(node)?''+node:'null';}if(typeof node!=='object'){return stringify$2(node);}let i;let out;if(isArray$2(node)){out='[';for(i=0;i<node.length;i++){if(i){out+=',';}out+=stableJSONStringify$1(node[i])||'null';}return out+']';}if(node===null){return 'null';}const keys$1=keys$2(node).sort();out='';for(i=0;i<keys$1.length;i++){const key=keys$1[i];const value=stableJSONStringify$1(node[key]);if(!value){continue;}if(out){out+=',';}out+=stringify$2(key)+':'+value;}return '{'+out+'}';}const{isArray:ArrayIsArray$1}=Array;function isPromise$1(value){return value.then!==undefined;}function untrustedIsObject$1(untrusted){return typeof untrusted==='object'&&untrusted!==null&&ArrayIsArray$1(untrusted)===false;}function refreshable(adapter,resolve){return config=>{const result=adapter(config);if(result===null){return result;}if(isPromise$1(result)){return result.then(snapshot=>{snapshot.refresh={config,resolve};return snapshot;});}result.refresh={config,resolve};return result;};}function postApex(config){const key=null;const headers={};return {path:'/apex',method:'post',body:config.body,urlParams:{},queryParams:{},key:key,ingest:null,headers};}const{freeze:ObjectFreeze,keys:ObjectKeys}=Object;const{isArray:ArrayIsArray$1$1}=Array;function deepFreeze$1(value){// No need to freeze primitives
    if(typeof value!=='object'||value===null){return;}if(ArrayIsArray$1$1(value)){for(let i=0,len=value.length;i<len;i+=1){deepFreeze$1(value[i]);}}else {const keys=ObjectKeys(value);for(let i=0,len=keys.length;i<len;i+=1){deepFreeze$1(value[keys[i]]);}}ObjectFreeze(value);}function cache(lds,config,namespace,classname,method,isContinuation){const recordId=getApexId(namespace,classname,method,isContinuation,config);const cacheableSnap=lds.storeLookup({recordId:recordId+'_cacheable',node:{kind:'Fragment',selections:[{kind:'Scalar',name:'cacheable'}]},variables:{}});// adapter always storeIngest the response, but only cacheable response should be used
    if(cacheableSnap.state!=='Fulfilled'||cacheableSnap.data.cacheable===false){return null;}const snap=lds.storeLookup({recordId,node:{kind:'Fragment',opaque:true},variables:{}});if(snap.state!=='Fulfilled'){return null;}return snap;}// TODO: APEX_TTL, apexResponseEquals, apexResponseIngest, and validateAdapterConfig should have been code generated
    // however compiler does not support response body type any so hand roll for now
    /**
     * Time to live for the Apex cache value. 5 minutes.
     */const APEX_TTL$1=5*60*1000;function apexResponseEquals(existing,incoming){return stringify$2(incoming)===stringify$2(existing);}function apexResponseIngest(input,path,_lds,store,timestamp){// skip validation since input type is any
    const key=path.fullPath;const existingRecord=store.records[key];// no normalization
    let incomingRecord=input;deepFreeze$1(input);if(existingRecord===undefined||apexResponseEquals(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+APEX_TTL$1);return key;}/**
     *  Validates the apex request configuration passed in from @wire.
     *  @param config The configuration object passed from @wire.
     *  @returns True if config is null/undefined or false if it does not contain undefined values.
     */function validateAdapterConfig(untrustedConfig){if(untrustedIsObject$1(untrustedConfig)){const values$1=values(untrustedConfig);return values$1.indexOf(undefined)===-1;}return true;}function network(lds,config,namespace,classname,method,isContinuation,cacheable){const recordId=getApexId(namespace,classname,method,isContinuation,config);const select={recordId,node:{kind:'Fragment',opaque:true},variables:{}};const body={namespace,classname,method,isContinuation,params:config,cacheable};const requestConfig={body};const request=_objectSpread$5({},postApex(requestConfig),{ingest:apexResponseIngest});return lds.dispatchResourceRequest(request).then(resp=>{const{cacheable}=resp.headers;if(cacheable===true){lds.storePublish(recordId+'_cacheable',resp.headers);lds.storeIngest(recordId,request,resp.body);lds.storeBroadcast();return lds.storeLookup(select);}// if cacheable is not set or set to false, return a synthetic snapshot
    return {recordId,variables:{},seenRecords:{},select,state:'Fulfilled',data:resp.body};},err=>{return lds.errorSnapshot(err);});}const factory=(lds,invokerParams)=>{const{namespace,classname,method,isContinuation}=invokerParams;const adapter=getLdsAdapterFactory(lds,namespace,classname,method,isContinuation,true);return refreshable(function apexWireAdapter(untrustedConfig){// Invalid or incomplete config
    if(!validateAdapterConfig(untrustedConfig)){return null;}return adapter(untrustedConfig);},untrustedConfig=>{// This should never happen
    if(!validateAdapterConfig(untrustedConfig)){throw new Error('Invalid config passed to "apexWireAdapter" refresh function');}return network(lds,untrustedConfig,namespace,classname,method,isContinuation,true);});};const invoker=(lds,invokerParams)=>{const{namespace,classname,method,isContinuation}=invokerParams;const ldsAdapter=getLdsAdapterFactory(lds,namespace,classname,method,isContinuation,false);return getInvoker(ldsAdapter);};function getInvoker(ldsAdapter){return config=>{const snapshotOrPromise=ldsAdapter(config);return Promise.resolve(snapshotOrPromise).then(snapshot=>{if(snapshot.state==='Error'){throw snapshot.error;}return snapshot.data;});};}/**
     * A standard delimiter when producing cache keys.
     */const KEY_DELIM$1=':';function isEmptyParam(param){return param===undefined||param===null||typeof param==='object'&&keys$2(param).length===0;}/**
     * Constructs a cache key for the Apex value type.
     * @param namespace The name space.
     * @param classname The class name.
     * @param functionName The function name.
     * @param isContinuation Indicates whether the Apex method returns a continuation.
     * @param params The params.
     * @returns A new cache key representing the Apex value type.
     */function getApexId(namespace,classname,functionName,isContinuation,params){return [namespace,classname,functionName,isContinuation,isEmptyParam(params)?'':stableJSONStringify$1(params)].join(`${KEY_DELIM$1}`);}function getLdsAdapterFactory(lds,namespace,classname,method,isContinuation,cacheable){return config=>{const snap=cache(lds,config,namespace,classname,method,isContinuation);if(snap!==null){return snap;}return network(lds,config,namespace,classname,method,isContinuation,cacheable);};}const{assign: assign$1,create:create$1$1,freeze:freeze$2,keys:keys$3}=Object;const{hasOwnProperty:hasOwnProperty$1$1}=Object.prototype;const{split,endsWith}=String.prototype;const{isArray:isArray$3}=Array;const{push:push$1}=Array.prototype;const{parse,stringify:stringify$3}=JSON;function deepFreeze$2(value){// No need to freeze primitives
    if(typeof value!=='object'||value===null){return;}if(isArray$3(value)){for(let i=0,len=value.length;i<len;i+=1){deepFreeze$2(value[i]);}}else {const keys$1=keys$3(value);for(let i=0,len=keys$1.length;i<len;i+=1){deepFreeze$2(value[keys$1[i]]);}}freeze$2(value);}const MAX_RECORD_DEPTH=5;const FIELD_SEPARATOR='.';const API_NAME_SELECTION={kind:'Scalar',name:'apiName'};const CHILD_RELATIONSHIP_SELECTION={// We don't support RecordRep.childRelationships because it has a nasty
    // degenerate case of multiple pages of child records
    kind:'Object',name:'childRelationships'};const ID_SELECTION={kind:'Scalar',name:'id'};const LAST_MODIFIED_BY_ID_SELECTION={kind:'Scalar',name:'lastModifiedById'};const LAST_MODIFIED_BY_DATE_SELECTION={kind:'Scalar',name:'lastModifiedDate'};const RECORD_TYPE_ID_SELECTION={kind:'Scalar',name:'recordTypeId'};const RECORD_TYPE_INFO_SELECTION={kind:'Object',name:'recordTypeInfo',nullable:true,selections:[{kind:'Scalar',name:'available'},{kind:'Scalar',name:'defaultRecordTypeMapping'},{kind:'Scalar',name:'master'},{kind:'Scalar',name:'name'},{kind:'Scalar',name:'recordTypeId'}]};const SYSTEM_MODSTAMP_SELECTION={kind:'Scalar',name:'systemModstamp'};const DISPLAY_VALUE_SELECTION={kind:'Scalar',name:'displayValue'};const SCALAR_VALUE_SELECTION={kind:'Scalar',name:'value'};function isSpanningRecord(fieldValue){return fieldValue!==null&&typeof fieldValue==='object';}function insertFieldsIntoTrie(root,fields,optional){for(let i=0,len=fields.length;i<len;i++){const field=fields[i].split(FIELD_SEPARATOR);let current=root;for(let j=1,len=field.length;j<len&&j<=MAX_RECORD_DEPTH+1;j++){const fieldName=field[j];let next=current.children[fieldName];if(next===undefined){// A field is scalar only if it is the last field name in the field.
    const scalar=j===len-1;// LDS restricts the numbers of fields that can be traversed to MAX_RECORD_DEPTH,
    // however we still denormalize fields at MAX_RECORD_DEPTH + 1, only if they are
    // scalar fields.
    if(j<=MAX_RECORD_DEPTH||scalar===true){// We now know that there are children fields, so we can mark the parent
    // as not a scalar
    current.scalar=false;next={name:fieldName,scalar,optional,children:{}};current.children[fieldName]=next;}}current=next;}}}function convertTrieToSelection(fieldDefinition){const fieldsSelection=[];const{children}=fieldDefinition;const childrenKeys=keys$3(children);for(let i=0,len=childrenKeys.length;i<len;i+=1){const childKey=childrenKeys[i];const childFieldDefinition=children[childKey];let fieldValueSelection;if(childFieldDefinition.scalar===true){fieldValueSelection=SCALAR_VALUE_SELECTION;}else {fieldValueSelection={kind:'Link',name:'value',nullable:true,selections:convertTrieToSelection(childFieldDefinition)};}push$1.call(fieldsSelection,{kind:'Link',name:childFieldDefinition.name,required:childFieldDefinition.optional===true?false:undefined,selections:[DISPLAY_VALUE_SELECTION,fieldValueSelection]});}return [API_NAME_SELECTION,CHILD_RELATIONSHIP_SELECTION,ID_SELECTION,LAST_MODIFIED_BY_ID_SELECTION,LAST_MODIFIED_BY_DATE_SELECTION,RECORD_TYPE_ID_SELECTION,RECORD_TYPE_INFO_SELECTION,SYSTEM_MODSTAMP_SELECTION,{kind:'Object',name:'fields',selections:fieldsSelection}];}/**
     * Convert a list of fields and optional fields into RecordRepresentation its equivalent
     * selection.
     */function buildSelectionFromFields(fields,optionalFields=[]){const root={name:'<root>',optional:false,scalar:false,children:{}};insertFieldsIntoTrie(root,fields,false);insertFieldsIntoTrie(root,optionalFields,true);return convertTrieToSelection(root);}/**
     * Convert a RecordRepresentationLike into its equivalent selection.
     */function buildSelectionFromRecord(record){const fieldsSelection=[];const{fields}=record;const fieldNames=keys$3(fields);for(let i=0,len=fieldNames.length;i<len;i++){const fieldName=fieldNames[i];const{value:fieldValue}=fields[fieldName];let fieldValueSelection=SCALAR_VALUE_SELECTION;if(isSpanningRecord(fieldValue)){fieldValueSelection={kind:'Link',name:'value',nullable:true,selections:buildSelectionFromRecord(fieldValue)};}push$1.call(fieldsSelection,{kind:'Link',name:fieldName,required:undefined,selections:[DISPLAY_VALUE_SELECTION,fieldValueSelection]});}return [API_NAME_SELECTION,CHILD_RELATIONSHIP_SELECTION,ID_SELECTION,LAST_MODIFIED_BY_ID_SELECTION,LAST_MODIFIED_BY_DATE_SELECTION,RECORD_TYPE_ID_SELECTION,RECORD_TYPE_INFO_SELECTION,SYSTEM_MODSTAMP_SELECTION,{kind:'Object',name:'fields',selections:fieldsSelection}];}function extractRecordFieldsRecursively(record){const fields=[];const fieldNames=keys$3(record.fields);for(let i=0,len=fieldNames.length;i<len;i++){const fieldName=fieldNames[i];const{value:fieldValue}=record.fields[fieldName];if(isSpanningRecord(fieldValue)){const spanningRecordFields=extractRecordFieldsRecursively(fieldValue);for(let j=0,len=spanningRecordFields.length;j<len;j++){spanningRecordFields[j]=`${fieldName}.${spanningRecordFields[j]}`;}push$1.apply(fields,spanningRecordFields);}else {push$1.call(fields,fieldName);}}return fields;}/**
     * Returns a list of fields for a RecordRepresentationLike.
     *
     * TODO W-6900271 - Remove this function once getRelatedList don't depend on it anymore. Always prefer
     * generating a selection out of a record, than convert a record to a field list and back to a
     * selection.
     */function extractRecordFields(record){const{apiName}=record;const fields=extractRecordFieldsRecursively(record);for(let i=0,len=fields.length;i<len;i++){fields[i]=`${apiName}.${fields[i]}`;}return fields;}const{freeze:ObjectFreeze$1,keys:ObjectKeys$1}=Object;const{isArray:ArrayIsArray$2}=Array;const{stringify:JSONStrinify}=JSON;function equalsArray(a,b,equalsItem){const aLength=a.length;const bLength=b.length;if(aLength!==bLength){return false;}for(let i=0;i<aLength;i++){if(equalsItem(a[i],b[i])===false){return false;}}return true;}function equalsObject(a,b,equalsProp){const aKeys=ObjectKeys$1(a).sort();const bKeys=ObjectKeys$1(b).sort();const aKeysLength=aKeys.length;const bKeysLength=bKeys.length;if(aKeysLength!==bKeysLength){return false;}for(let i=0;i<aKeys.length;i++){const key=aKeys[i];if(key!==bKeys[i]){return false;}if(equalsProp(a[key],b[key])===false){return false;}}return true;}function validate(obj,path='RecordTypeInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_available=obj.available;const path_available=path+'.available';if(typeof obj_available!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_available+'" (at "'+path_available+'")');}const obj_defaultRecordTypeMapping=obj.defaultRecordTypeMapping;const path_defaultRecordTypeMapping=path+'.defaultRecordTypeMapping';if(typeof obj_defaultRecordTypeMapping!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_defaultRecordTypeMapping+'" (at "'+path_defaultRecordTypeMapping+'")');}const obj_master=obj.master;const path_master=path+'.master';if(typeof obj_master!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_master+'" (at "'+path_master+'")');}const obj_name=obj.name;const path_name=path+'.name';if(typeof obj_name!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_name+'" (at "'+path_name+'")');}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}})();return v_error===undefined?null:v_error;}function equals$2(existing,incoming){const existing_available=existing.available;const incoming_available=incoming.available;if(!(existing_available===incoming_available)){return false;}const existing_defaultRecordTypeMapping=existing.defaultRecordTypeMapping;const incoming_defaultRecordTypeMapping=incoming.defaultRecordTypeMapping;if(!(existing_defaultRecordTypeMapping===incoming_defaultRecordTypeMapping)){return false;}const existing_master=existing.master;const incoming_master=incoming.master;if(!(existing_master===incoming_master)){return false;}const existing_name=existing.name;const incoming_name=incoming.name;if(!(existing_name===incoming_name)){return false;}const existing_recordTypeId=existing.recordTypeId;const incoming_recordTypeId=incoming.recordTypeId;if(!(existing_recordTypeId===incoming_recordTypeId)){return false;}return true;}function deepFreeze$1$1(input){ObjectFreeze$1(input);}function validate$1(obj,path='RecordCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_count=obj.count;const path_count=path+'.count';if(typeof obj_count!=='number'||typeof obj_count==='number'&&Math.floor(obj_count)!==obj_count){return new TypeError('Expected "number" but received "'+typeof obj_count+'" (at "'+path_count+'")');}const obj_currentPageToken=obj.currentPageToken;const path_currentPageToken=path+'.currentPageToken';let obj_currentPageToken_union0=null;const obj_currentPageToken_union0_error=(()=>{if(typeof obj_currentPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageToken+'" (at "'+path_currentPageToken+'")');}})();if(obj_currentPageToken_union0_error!=null){obj_currentPageToken_union0=obj_currentPageToken_union0_error.message;}let obj_currentPageToken_union1=null;const obj_currentPageToken_union1_error=(()=>{if(obj_currentPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_currentPageToken+'" (at "'+path_currentPageToken+'")');}})();if(obj_currentPageToken_union1_error!=null){obj_currentPageToken_union1=obj_currentPageToken_union1_error.message;}if(obj_currentPageToken_union0&&obj_currentPageToken_union1){let message='Object doesn\'t match union (at "'+path_currentPageToken+'")';message+='\n'+obj_currentPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_currentPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_currentPageUrl=obj.currentPageUrl;const path_currentPageUrl=path+'.currentPageUrl';if(typeof obj_currentPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageUrl+'" (at "'+path_currentPageUrl+'")');}const obj_nextPageToken=obj.nextPageToken;const path_nextPageToken=path+'.nextPageToken';let obj_nextPageToken_union0=null;const obj_nextPageToken_union0_error=(()=>{if(typeof obj_nextPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union0_error!=null){obj_nextPageToken_union0=obj_nextPageToken_union0_error.message;}let obj_nextPageToken_union1=null;const obj_nextPageToken_union1_error=(()=>{if(obj_nextPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union1_error!=null){obj_nextPageToken_union1=obj_nextPageToken_union1_error.message;}if(obj_nextPageToken_union0&&obj_nextPageToken_union1){let message='Object doesn\'t match union (at "'+path_nextPageToken+'")';message+='\n'+obj_nextPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_nextPageUrl=obj.nextPageUrl;const path_nextPageUrl=path+'.nextPageUrl';let obj_nextPageUrl_union0=null;const obj_nextPageUrl_union0_error=(()=>{if(typeof obj_nextPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union0_error!=null){obj_nextPageUrl_union0=obj_nextPageUrl_union0_error.message;}let obj_nextPageUrl_union1=null;const obj_nextPageUrl_union1_error=(()=>{if(obj_nextPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union1_error!=null){obj_nextPageUrl_union1=obj_nextPageUrl_union1_error.message;}if(obj_nextPageUrl_union0&&obj_nextPageUrl_union1){let message='Object doesn\'t match union (at "'+path_nextPageUrl+'")';message+='\n'+obj_nextPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_previousPageToken=obj.previousPageToken;const path_previousPageToken=path+'.previousPageToken';let obj_previousPageToken_union0=null;const obj_previousPageToken_union0_error=(()=>{if(typeof obj_previousPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union0_error!=null){obj_previousPageToken_union0=obj_previousPageToken_union0_error.message;}let obj_previousPageToken_union1=null;const obj_previousPageToken_union1_error=(()=>{if(obj_previousPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union1_error!=null){obj_previousPageToken_union1=obj_previousPageToken_union1_error.message;}if(obj_previousPageToken_union0&&obj_previousPageToken_union1){let message='Object doesn\'t match union (at "'+path_previousPageToken+'")';message+='\n'+obj_previousPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_previousPageUrl=obj.previousPageUrl;const path_previousPageUrl=path+'.previousPageUrl';let obj_previousPageUrl_union0=null;const obj_previousPageUrl_union0_error=(()=>{if(typeof obj_previousPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union0_error!=null){obj_previousPageUrl_union0=obj_previousPageUrl_union0_error.message;}let obj_previousPageUrl_union1=null;const obj_previousPageUrl_union1_error=(()=>{if(obj_previousPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union1_error!=null){obj_previousPageUrl_union1=obj_previousPageUrl_union1_error.message;}if(obj_previousPageUrl_union0&&obj_previousPageUrl_union1){let message='Object doesn\'t match union (at "'+path_previousPageUrl+'")';message+='\n'+obj_previousPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_records=obj.records;const path_records=path+'.records';if(!ArrayIsArray$2(obj_records)){return new TypeError('Expected "array" but received "'+typeof obj_records+'" (at "'+path_records+'")');}for(let i=0;i<obj_records.length;i++){const obj_records_item=obj_records[i];}})();return v_error===undefined?null:v_error;}function normalize(input,existing,path,lds,store,timestamp){const input_records=input.records;const input_records_id=path.fullPath+'__records';for(let i=0;i<input_records.length;i++){const input_records_item=input_records[i];let input_records_item_id=input_records_id+'__'+i;input_records[i]={__ref:ingest$2(input_records_item,{fullPath:input_records_item_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}return input;}function equals$1$1(existing,incoming){const existing_count=existing.count;const incoming_count=incoming.count;if(!(existing_count===incoming_count)){return false;}const existing_currentPageUrl=existing.currentPageUrl;const incoming_currentPageUrl=incoming.currentPageUrl;if(!(existing_currentPageUrl===incoming_currentPageUrl)){return false;}const existing_currentPageToken=existing.currentPageToken;const incoming_currentPageToken=incoming.currentPageToken;if(!(existing_currentPageToken===incoming_currentPageToken)){return false;}const existing_nextPageToken=existing.nextPageToken;const incoming_nextPageToken=incoming.nextPageToken;if(!(existing_nextPageToken===incoming_nextPageToken)){return false;}const existing_nextPageUrl=existing.nextPageUrl;const incoming_nextPageUrl=incoming.nextPageUrl;if(!(existing_nextPageUrl===incoming_nextPageUrl)){return false;}const existing_previousPageToken=existing.previousPageToken;const incoming_previousPageToken=incoming.previousPageToken;if(!(existing_previousPageToken===incoming_previousPageToken)){return false;}const existing_previousPageUrl=existing.previousPageUrl;const incoming_previousPageUrl=incoming.previousPageUrl;if(!(existing_previousPageUrl===incoming_previousPageUrl)){return false;}const existing_records=existing.records;const incoming_records=incoming.records;const equals_records_items=equalsArray(existing_records,incoming_records,(existing_records_item,incoming_records_item)=>{if(!(existing_records_item.__ref===incoming_records_item.__ref)){return false;}});if(equals_records_items===false){return false;}return true;}const ingest=function RecordCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$1(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$1$1(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+120000);return key;};function merge(existing,incoming,_lds,path){if(existing===undefined){return incoming;}// TODO: (W-7164913) remove once UISDK is done with a long term fix.
    // Temporary fix for the issue that non-null displayValue gets replaced by null.
    // If displayValue and value are both null, it means the field is empty.
    if(incoming.displayValue===null&&incoming.value!==null&&existing.displayValue!==null){incoming.displayValue=existing.displayValue;}const{value}=incoming;if(value===null||value.__ref===undefined){// Parent will never be null this field only exists in the context of a RecordRep.
    const parent=path.parent;// It may happen that a parent.exists is null, this is the case when the same field is
    // ingested multiple times in the same ingestion cycle. For example: when the same record
    // is present multiple time in the ingested payload.
    if(parent.existing===undefined){return incoming;}const existingVersion=parent.existing.weakEtag;const incomingVersion=parent.data.weakEtag;if(existingVersion>incomingVersion){return existing;}}return incoming;}function validate$2(obj,path='FieldValueRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_displayValue=obj.displayValue;const path_displayValue=path+'.displayValue';let obj_displayValue_union0=null;const obj_displayValue_union0_error=(()=>{if(typeof obj_displayValue!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_displayValue+'" (at "'+path_displayValue+'")');}})();if(obj_displayValue_union0_error!=null){obj_displayValue_union0=obj_displayValue_union0_error.message;}let obj_displayValue_union1=null;const obj_displayValue_union1_error=(()=>{if(obj_displayValue!==null){return new TypeError('Expected "null" but received "'+typeof obj_displayValue+'" (at "'+path_displayValue+'")');}})();if(obj_displayValue_union1_error!=null){obj_displayValue_union1=obj_displayValue_union1_error.message;}if(obj_displayValue_union0&&obj_displayValue_union1){let message='Object doesn\'t match union (at "'+path_displayValue+'")';message+='\n'+obj_displayValue_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_displayValue_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_value=obj.value;const path_value=path+'.value';let obj_value_union0=null;const obj_value_union0_error=(()=>{if(obj_value!==null){return new TypeError('Expected "null" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union0_error!=null){obj_value_union0=obj_value_union0_error.message;}let obj_value_union1=null;const obj_value_union1_error=(()=>{if(typeof obj_value!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union1_error!=null){obj_value_union1=obj_value_union1_error.message;}let obj_value_union2=null;const obj_value_union2_error=(()=>{if(typeof obj_value!=='number'||typeof obj_value==='number'&&Math.floor(obj_value)!==obj_value){return new TypeError('Expected "number" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union2_error!=null){obj_value_union2=obj_value_union2_error.message;}let obj_value_union3=null;const obj_value_union3_error=(()=>{if(typeof obj_value!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();if(obj_value_union3_error!=null){obj_value_union3=obj_value_union3_error.message;}let obj_value_union4=null;const obj_value_union4_error=(()=>{})();if(obj_value_union4_error!=null){obj_value_union4=obj_value_union4_error.message;}if(obj_value_union0&&obj_value_union1&&obj_value_union2&&obj_value_union3&&obj_value_union4){let message='Object doesn\'t match union (at "'+path_value+'")';message+='\n'+obj_value_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_value_union1.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_value_union2.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_value_union3.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_value_union4.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function normalize$1(input,existing,path,lds,store,timestamp){const input_value=input.value;const input_value_id=path.fullPath+'__value';if(input_value!==null&&typeof input_value==='object'){input.value={__ref:ingest$2(input_value,{fullPath:input_value_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}return input;}function equals$2$1(existing,incoming){const existing_displayValue=existing.displayValue;const incoming_displayValue=incoming.displayValue;if(!(existing_displayValue===incoming_displayValue)){return false;}const existing_value=existing.value;const incoming_value=incoming.value;if(!(existing_value===incoming_value||existing_value!=null&&incoming_value!=null&&existing_value.__ref!=null&&incoming_value.__ref!=null&&existing_value.__ref===incoming_value.__ref)){return false;}return true;}const ingest$1=function FieldValueRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$2(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$1(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];incomingRecord=merge(existingRecord,incomingRecord,lds,path);if(existingRecord===undefined||equals$2$1(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};const VIEW_ENTITY_API_NAME='Name';const VIEW_ENTITY_KEY_PREFIX=`UiApi::RecordViewEntityRepresentation:${VIEW_ENTITY_API_NAME}:`;function polymorph(input){const{apiName,id}=input;if(apiName===VIEW_ENTITY_API_NAME){return VIEW_ENTITY_KEY_PREFIX+id;}return keyBuilder({recordId:id});}function isFieldId$1(value){return value&&typeof value.objectApiName==='string'&&typeof value.fieldApiName==='string';}function stringToFieldId(fieldApiName){const split=fieldApiName.split('.');{if(split.length===1){// object api name must non-empty
    throw new TypeError('Value does not include an object API name.');}}return {objectApiName:split[0],fieldApiName:split[1]};}function getFieldId(value){if(isFieldId$1(value)){return value;}return stringToFieldId(value);}function isString$1(value){return typeof value==='string';}/**
     * @param value The array to inspect.
     * @returns True if the array is non-empty and contains only non-empty strings.
     */function isArrayOfNonEmptyStrings$1(value){if(value.length===0){return false;}return value.every(v=>isString$1(v)&&v.trim().length>0);}/**
     * @param value The array to dedupe
     * @returns An array without duplicates.
     */function dedupe(value){const result={};for(let i=0,len=value.length;i<len;i+=1){result[value[i]]=true;}return keys$3(result);}/**
     * @param source The array of string to filter
     * @param compare The array to filter against
     * @returns An array with values from source that do not exist in compare
     * If the "compare" array is empty, "source" array itself is returned, not a shallow copy
     */function difference$1(source,compare){const{length:sourceLength}=source;const{length:compareLength}=compare;if(sourceLength===0||source===compare){return [];}if(compareLength===0){return source;}// Put all the values from "compare" into a map
    // This should be faster than doing an indexOf for every string in source
    const map={};for(let i=0;i<compareLength;i+=1){map[compare[i]]=true;}const strings=[];for(let i=0;i<sourceLength;i+=1){const string=source[i];if(map[string]===undefined){strings.push(string);}}return strings;}/**
     * Returns the field API name, qualified with an object name if possible.
     * @param value The value from which to get the qualified field API name.
     * @return The qualified field API name.
     */function getFieldApiName$3(value){// Note: tightening validation logic changes behavior from userland getting
    // a server-provided error to the adapter noop'ing. In 224 we decided to not
    // change the behavior.
    if(isString$1(value)){const trimmed=value.trim();if(trimmed.length>0){return trimmed;}}else if(isFieldId$1(value)){return value.objectApiName+'.'+value.fieldApiName;}return undefined;}/**
     * The master record type id.
     */const MASTER_RECORD_TYPE_ID$4='012000000000000AAA';function isGraphNode(node){return node!==null&&node.type==='Node';}function extractTrackedFields(node,parentFieldName,fieldsList=[],visitedRecordIds={},depth=0){// Filter Error and null nodes
    if(!isGraphNode(node)||depth>MAX_RECORD_DEPTH){return [];}const recordId=node.data.id;// Stop the traversal if the key has already been visited, since the fields for this record
    // have already been gathered at this point.
    if(hasOwnProperty$1$1.call(visitedRecordIds,recordId)){return fieldsList;}// The visitedRecordIds object passed to the spanning record is a copy of the original
    // visitedRecordIds + the current record id, since we want to detect circular references within
    // a given path.
    let spanningVisitedRecordIds=_objectSpread$5({},visitedRecordIds,{[recordId]:true});const fields=node.object('fields');const keys=fields.keys();for(let i=0,len=keys.length;i<len;i+=1){const key=keys[i];const fieldValueRep=fields.link(key);const fieldName=`${parentFieldName}.${key}`;if(fieldValueRep.isMissing()){push$1.call(fieldsList,fieldName);continue;}const field=fieldValueRep.follow();// Filter Error and null nodes
    if(!isGraphNode(field)){continue;}if(field.isScalar('value')===false){const spanning=field.link('value').follow();extractTrackedFields(spanning,fieldName,fieldsList,spanningVisitedRecordIds,depth+1);}else {const state=fieldValueRep.linkData();if(state!==undefined){const{fields}=state;for(let s=0,len=fields.length;s<len;s+=1){const childFieldName=fields[s];push$1.call(fieldsList,`${fieldName}.${childFieldName}`);}}else {push$1.call(fieldsList,fieldName);}}}return fieldsList;}function getTrackedFields(lds,recordId,fieldsFromConfig){const key=keyBuilder({recordId});const fieldsList=fieldsFromConfig===undefined?[]:[...fieldsFromConfig];const graphNode=lds.getNode(key);if(!isGraphNode(graphNode)){return fieldsList;}const fileName=graphNode.scalar('apiName');const fields=extractTrackedFields(graphNode,fileName,fieldsList);return dedupe(fields).sort();}function getRecordTypeId(record){return record.recordTypeId===null?MASTER_RECORD_TYPE_ID$4:record.recordTypeId;}// This function traverses through a record and marks missing
    // optional fields as "missing"
    function markMissingOptionalFields(record,optionalFields){if(!isGraphNode(record)){return;}const apiName=record.scalar('apiName');for(let a=0,aLen=optionalFields.length;a<aLen;a++){const parts=optionalFields[a].split('.');if(parts[0]===apiName){_markMissingPath(record,parts.slice(1));}}}function markNulledOutPath(record,path){if(!isGraphNode(record)){return;}const fieldValueRepresentation=record.object('fields');const fieldName=path.shift();if(fieldValueRepresentation.isUndefined(fieldName)){return;}const link=fieldValueRepresentation.link(fieldName);const resolved=link.follow();if(isGraphNode(resolved)&&resolved.isScalar('value')&&path.length>0){const linkState=link.linkData();const fields=linkState===undefined?[]:linkState.fields;link.writeLinkData({fields:dedupe([...fields,path.join('.')])});}}function markNulledOutRequiredFields(record,fields){if(!isGraphNode(record)){return;}const apiName=record.scalar('apiName');for(let a=0,aLen=fields.length;a<aLen;a++){const parts=fields[a].split('.');if(parts[0]===apiName){markNulledOutPath(record,parts.slice(1));}}}function _markMissingPath(record,path){// Filter out Error and null nodes
    if(!isGraphNode(record)){return;}const fieldValueRepresentation=record.object('fields');const fieldName=path.shift();if(fieldValueRepresentation.isUndefined(fieldName)===true){// TODO W-6900046 - remove cast, make RecordRepresentationNormalized['fields'] accept
    // an undefined/non-present __ref if isMissing is present
    fieldValueRepresentation.write(fieldName,{__ref:undefined,isMissing:true});return;}const link=fieldValueRepresentation.link(fieldName);if(link.isPending()){// TODO W-6900046 - remove cast, make RecordRepresentationNormalized['fields'] accept
    // an undefined/non-present __ref if isMissing is present
    fieldValueRepresentation.write(fieldName,{__ref:undefined,isMissing:true});}else if(path.length>0&&link.isMissing()===false){const fieldValue=link.follow();// Filter out Error and null nodes
    if(!isGraphNode(fieldValue)){return;}// if value is not a scalar, follow the link and mark it as missing
    if(fieldValue.isScalar('value')===false){_markMissingPath(fieldValue.link('value').follow(),path);}}}const CUSTOM_API_NAME_SUFFIX='__c';/**
     * A set of the string names of known ui-api supported entities.
     * Source: ui-uisdk-connect-impl-object-whitelist.yaml
     */const UIAPI_SUPPORTED_ENTITY_API_NAMES$1={Account:true,AccountContactRelation:true,AccountPartner:true,AccountTeamMember:true,ActionCadence:true,ActionPlanItem:true,AssessmentTask:true,AssessmentTaskOrder:true,Asset:true,AssetRelationship:true,AssignedResource:true,AttachedContentNote:true,BCEntityPermission:true,BCEntityPermissionSet:true,BCFieldPermission:true,BCParticipant:true,BCParticipantAccess:true,BCPermissionSet:true,BCRecordAccess:true,BCRecordAccessApproval:true,BCRelatedParticipant:true,BasicDataRecord:true,BlockchainAppMember:true,BlockchainApplication:true,BlockchainEntity:true,BlockchainField:true,BlockchainMember:true,BusinessMilestone:true,BusinessProfile:true,Campaign:true,CampaignMember:true,CareBarrier:true,CareBarrierType:true,CareProgram:true,CareProgramEnrollee:true,Case:true,Claim:true,ClaimCase:true,ClaimItem:true,ClaimParticipant:true,Contact:true,ContactRequest:true,ContentDocument:true,ContentNote:true,ContentVersion:true,ContentWorkspace:true,Contract:true,ContractContactRole:true,ContractLineItem:true,CoverageType:true,CustomerProperty:true,DataExportDefinition:true,DeleteEvent:true,DigitalSignature:true,ElectronicMediaGroup:true,Entitlement:true,EntityArchivingSetup:true,EntityMilestone:true,EnvironmentHubMember:true,FtestZosUiPrototypeChild1:true,FtestZosUiPrototypeChild2:true,FtestZosUiPrototypeParent:true,Image:true,Individual:true,InsuranceClaimAsset:true,InsurancePolicy:true,InsurancePolicyAsset:true,InsurancePolicyCoverage:true,InsurancePolicyMemberAsset:true,InsurancePolicyParticipant:true,InsuranceProfile:true,JobProfile:true,KnowledgeArticleVersion:true,Lead:true,LicensingRequest:true,LoyaltyProgramCurrency:true,LoyaltyProgramMember:true,LoyaltyProgramPartner:true,LoyaltyTier:true,LoyaltyTierGroup:true,MaintenanceAsset:true,MaintenancePlan:true,MarketSegment:true,MarketingAction:true,MarketingResource:true,Note:true,OperatingHours:true,Opportunity:true,OpportunityLineItem:true,OpportunityLineItemSchedule:true,OpportunityPartner:true,OpportunityTeamMember:true,Order:true,OrderItem:true,OrderItemSummaryChange:true,OrderSummary:true,OrgMetric:true,OrgMetricScanResult:true,OrgMetricScanSummary:true,Partner:true,PersonAccount:true,PersonLifeEvent:true,PriceAdjustmentSchedule:true,Pricebook2:true,PricebookEntry:true,Producer:true,ProducerPolicyAssignment:true,Product2:true,Product2DataTranslation:true,ProductCategoryDataTranslation:true,ProductCoverage:true,ProductMedia:true,Quote:true,QuoteDocument:true,QuoteLineItem:true,RecordType:true,ResourceAbsence:true,ResourcePreference:true,RetailStore:true,RetailVisitKpi:true,ReturnOrder:true,ReturnOrderLineItem:true,SSR_IndividualDemo:true,SalesAgreement:true,SalesAgreementProduct:true,SalesAgreementProductSchedule:true,SecuritiesHolding:true,ServiceAppointment:true,ServiceContract:true,ServiceCrew:true,ServiceCrewMember:true,ServiceResource:true,ServiceResourceCapacity:true,ServiceResourceSkill:true,ServiceTerritory:true,ServiceTerritoryLocation:true,ServiceTerritoryMember:true,Shift:true,Shipment:true,SkillRequirement:true,SocialPost:true,SurveyInvitation:true,SurveyResponse:true,SurveySubject:true,Tenant:true,TimeSheet:true,TimeSheetEntry:true,TimeSlot:true,UsageEntitlement:true,UsageEntitlementPeriod:true,User:true,Visit:true,WebStoreSearchProdSettings:true,WorkOrder:true,WorkOrderLineItem:true,WorkType:true,WorkerCompCoverageClass:true};/**
     * Tells you if an objectApiName is supported by UI API or not.
     * Note: LDS does not currently support all the entities, the list is limited to UI API supported entities
     * @param objectApiName the object API name from a record.
     * @return True if the provided objectApiName is supported in UI API.
     */function isSupportedEntity$1(objectApiName){return UIAPI_SUPPORTED_ENTITY_API_NAMES$1[objectApiName]===true||endsWith.call(objectApiName,CUSTOM_API_NAME_SUFFIX);}/** Return true if a >= b */function isSuperset(a,b){if(b.length>a.length){return false;}const aMap={};// Put all keys from subset into a map
    // so we don't have to use subset.includes which will be slow
    for(let i=0,len=a.length;i<len;i+=1){aMap[a[i]]=true;}for(let i=0,len=b.length;i<len;i+=1){if(aMap[b[i]]===undefined){return false;}}return true;}function fulfill(existing,incoming){// early out if incoming isn't a request only for fields and optionalFields
    const{queryParams,headers,path}=incoming;const{path:existingPath,headers:existingHeaders}=existing;if(queryParams.layoutTypes!==undefined){return false;}if(existingPath!==path){return false;}const headersKeys=keys$3(headers);const headersKeyLength=headersKeys.length;if(headersKeyLength!==keys$3(existingHeaders).length){return false;}for(let i=0,len=headersKeyLength;i<len;i++){let key=headersKeys[i];if(headers[key]!==existingHeaders[key]){return false;}}// TODO W-6900100 - handle when incoming.fields are only in existing.optionalFields, and
    // existing's response doesn't include those fields. We need to detect this then
    // re-issue the request to get the relevant error response.
    const existingFieldsUnion=unionFields(existing.queryParams.fields,existing.queryParams.optionalFields);const incomingFieldsUnion=unionFields(queryParams.fields,queryParams.optionalFields);return isSuperset(existingFieldsUnion,incomingFieldsUnion);}function unionFields(fields,optionalFields){const fieldsArray=isArray$3(fields)?fields:[];const optionalFieldsArray=isArray$3(optionalFields)?optionalFields:[];return [...fieldsArray,...optionalFieldsArray];}function getUiApiRecordsByRecordId(config){const key=keyBuilder({recordId:config.urlParams.recordId});const headers={};return {path:'/services/data/v48.0/ui-api/records/'+config.urlParams.recordId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$2,headers,fulfill:fulfill};}function isFulfilledSnapshot$1(snapshot){return snapshot.state==='Fulfilled';}function isUnfulfilledSnapshot$1(snapshot){return snapshot.state==='Unfulfilled';}function isErrorSnapshot$1(snapshot){return snapshot.state==='Error';}function buildRecordSelector(recordId,fields,optionalFields){return {recordId:keyBuilder({recordId}),node:{kind:'Fragment',selections:buildSelectionFromFields(fields,optionalFields)},variables:{}};}function network$1(lds,config){const{recordId,fields}=config;// Should this go into the coersion logic?
    const allTrackedFields=getTrackedFields(lds,recordId,config.optionalFields);const request=getUiApiRecordsByRecordId({urlParams:{recordId},queryParams:{fields,optionalFields:fields===undefined?allTrackedFields:difference$1(allTrackedFields,fields)}});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const fields=config.fields===undefined?[]:config.fields;const optionalFields=config.optionalFields===undefined?[]:config.optionalFields;lds.storeIngest(request.key,request,body);const recordNode=lds.getNode(request.key);markNulledOutRequiredFields(recordNode,[...fields,...optionalFields]);markMissingOptionalFields(recordNode,allTrackedFields);lds.storeBroadcast();return lds.storeLookup(buildRecordSelector(config.recordId,fields,optionalFields));},err=>{lds.storeIngestFetchResponse(request.key,err,TTL);lds.storeBroadcast();return lds.errorSnapshot(err);});}// used by getRecordLayoutType#refresh
    function cache$1(lds,config){const fields=config.fields===undefined?[]:config.fields;const optionalFields=config.optionalFields===undefined?[]:config.optionalFields;const sel=buildRecordSelector(config.recordId,fields,optionalFields);return lds.storeLookup(sel);}function getRecordByFields(lds,config){const snapshot=cache$1(lds,config);if(isFulfilledSnapshot$1(snapshot)||isErrorSnapshot$1(snapshot)){return snapshot;}return network$1(lds,config);}// This function sets fields that we are refreshing to pending
    // These values will go into the store
    function mergePendingFields(newRecord,oldRecord){// TODO W-6900046 - avoid casting to any by updating
    // RecordRepresentationNormalized['fields'] to include `pending:true` property
    const mergedFields=_objectSpread$5({},newRecord.fields);const merged=_objectSpread$5({},newRecord,{fields:mergedFields});const existingFields=keys$3(oldRecord.fields);for(let i=0,len=existingFields.length;i<len;i+=1){const spanningFieldName=existingFields[i];if(newRecord.fields[spanningFieldName]===undefined){// TODO W-6900046 - fix above casting issue so we're not stuffing arbitrary things
    // into RecordRepresentationNormalized['fields']
    mergedFields[spanningFieldName]={__ref:undefined,pending:true};}}return merged;}// This method gets called
    // when incoming record has a higher version
    // than the record that is currently in the store
    function mergeAndRefreshHigherVersionRecord(lds,incoming,existing,incomingQualifiedApiNames,existingQualifiedApiNames){// If the higher version (incoming) does not contain a superset of fields as existing
    // then we need to refresh to get updated versions of fields in existing
    if(isSuperset(incomingQualifiedApiNames,existingQualifiedApiNames)===false){// If this is an unsupported entity, do NOT attempt to go to the network
    // Simply merge what we have and move on
    if(isSupportedEntity$1(incoming.apiName)===false){return mergeRecordFields(incoming,existing);}network$1(lds,{recordId:incoming.id,optionalFields:incomingQualifiedApiNames});// We want to mark fields in the store as pending
    // Because we don't want to emit any data to components
    return mergePendingFields(incoming,existing);}return incoming;}// This method gets called
    // when incoming record has a lower version
    // than the record that is currently in the store
    function mergeAndRefreshLowerVersionRecord(lds,incoming,existing,incomingQualifiedApiNames,existingQualifiedApiNames){// If the higher version (existing) does not have a superset of fields as incoming
    // then we need to refresh to get updated versions of fields on incoming
    if(isSuperset(existingQualifiedApiNames,incomingQualifiedApiNames)===false){// If this is an unsupported entity, do NOT attempt to go to the network
    // Simply merge what we have and move on
    if(isSupportedEntity$1(incoming.apiName)===false){return mergeRecordFields(existing,incoming);}const merged=mergePendingFields(existing,incoming);network$1(lds,{recordId:incoming.id,optionalFields:incomingQualifiedApiNames});return merged;}return existing;}function mergeRecordConflict(lds,incoming,existing){const{apiName}=incoming;const incomingNode=lds.wrapNormalizedGraphNode(incoming);const existingNode=lds.wrapNormalizedGraphNode(existing);const incomingQualifiedApiNames=extractTrackedFields(incomingNode,apiName);const existingQualifiedApiNames=extractTrackedFields(existingNode,apiName);if(incoming.weakEtag>existing.weakEtag){return mergeAndRefreshHigherVersionRecord(lds,incoming,existing,incomingQualifiedApiNames,existingQualifiedApiNames);}return mergeAndRefreshLowerVersionRecord(lds,incoming,existing,incomingQualifiedApiNames,existingQualifiedApiNames);}function getNotNull(recordAValue,recordBValue){return recordAValue===null?recordBValue:recordAValue;}function mergeRecordFields(recordA,recordB){const lastModifiedDate=getNotNull(recordA.lastModifiedDate,recordB.lastModifiedDate);const lastModifiedById=getNotNull(recordA.lastModifiedById,recordB.lastModifiedById);const systemModstamp=getNotNull(recordA.systemModstamp,recordB.systemModstamp);return _objectSpread$5({},recordA,{fields:_objectSpread$5({},recordB.fields,recordA.fields),lastModifiedDate,lastModifiedById,systemModstamp});}function isErrorEntry(entry){return entry.__type==='error';}function merge$1(existing,incoming,lds,_path){if(existing===undefined||isErrorEntry(existing)){return incoming;}// recordTypeId may get changed based on record state.
    // Evicts all dependencies from store.
    if(incoming.recordTypeId!==existing.recordTypeId){const recordDepKey=depenpendencyKeyBuilder({recordId:existing.id});const node=lds.getNode(recordDepKey);if(isGraphNode(node)){const dependencies=node.retrieve();if(dependencies!==null){const depKeys=keys$3(dependencies);for(let i=0,len=depKeys.length;i<len;i++){lds.storeEvict(depKeys[i]);}}}}// TODO - handle merging of records that change apiName
    // if (existing.apiName !== incoming.apiName) {
    //     if ("development" === 'production') {
    //         lds.log(`API Name changed from ${existing.apiName} to ${incoming.apiName}`);
    //     } else {
    //         throw new Error('API Name cannot be different for merging records.');
    //     }
    // }
    // TODO W-6900085 - UIAPI returns weakEtag=0 when the record is >2 levels nested. For now
    // we treat the record as mergeable.
    if(incoming.weakEtag!==0&&existing.weakEtag!==0&&incoming.weakEtag!==existing.weakEtag){return mergeRecordConflict(lds,incoming,existing);}return mergeRecordFields(incoming,existing);}function depenpendencyKeyBuilder(config){return `UiApi::RecordRepresentationDependency:${config.recordId}`;}const TTL=30000;function validate$3(obj,path='RecordRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_childRelationships=obj.childRelationships;const path_childRelationships=path+'.childRelationships';if(typeof obj_childRelationships!=='object'||ArrayIsArray$2(obj_childRelationships)||obj_childRelationships===null){return new TypeError('Expected "object" but received "'+typeof obj_childRelationships+'" (at "'+path_childRelationships+'")');}const obj_childRelationships_keys=ObjectKeys$1(obj_childRelationships);for(let i=0;i<obj_childRelationships_keys.length;i++){const key=obj_childRelationships_keys[i];const obj_childRelationships_prop=obj_childRelationships[key];}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_fields=obj.fields;const path_fields=path+'.fields';if(typeof obj_fields!=='object'||ArrayIsArray$2(obj_fields)||obj_fields===null){return new TypeError('Expected "object" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}const obj_fields_keys=ObjectKeys$1(obj_fields);for(let i=0;i<obj_fields_keys.length;i++){const key=obj_fields_keys[i];const obj_fields_prop=obj_fields[key];}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_lastModifiedById=obj.lastModifiedById;const path_lastModifiedById=path+'.lastModifiedById';let obj_lastModifiedById_union0=null;const obj_lastModifiedById_union0_error=(()=>{if(typeof obj_lastModifiedById!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lastModifiedById+'" (at "'+path_lastModifiedById+'")');}})();if(obj_lastModifiedById_union0_error!=null){obj_lastModifiedById_union0=obj_lastModifiedById_union0_error.message;}let obj_lastModifiedById_union1=null;const obj_lastModifiedById_union1_error=(()=>{if(obj_lastModifiedById!==null){return new TypeError('Expected "null" but received "'+typeof obj_lastModifiedById+'" (at "'+path_lastModifiedById+'")');}})();if(obj_lastModifiedById_union1_error!=null){obj_lastModifiedById_union1=obj_lastModifiedById_union1_error.message;}if(obj_lastModifiedById_union0&&obj_lastModifiedById_union1){let message='Object doesn\'t match union (at "'+path_lastModifiedById+'")';message+='\n'+obj_lastModifiedById_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lastModifiedById_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_lastModifiedDate=obj.lastModifiedDate;const path_lastModifiedDate=path+'.lastModifiedDate';let obj_lastModifiedDate_union0=null;const obj_lastModifiedDate_union0_error=(()=>{if(typeof obj_lastModifiedDate!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lastModifiedDate+'" (at "'+path_lastModifiedDate+'")');}})();if(obj_lastModifiedDate_union0_error!=null){obj_lastModifiedDate_union0=obj_lastModifiedDate_union0_error.message;}let obj_lastModifiedDate_union1=null;const obj_lastModifiedDate_union1_error=(()=>{if(obj_lastModifiedDate!==null){return new TypeError('Expected "null" but received "'+typeof obj_lastModifiedDate+'" (at "'+path_lastModifiedDate+'")');}})();if(obj_lastModifiedDate_union1_error!=null){obj_lastModifiedDate_union1=obj_lastModifiedDate_union1_error.message;}if(obj_lastModifiedDate_union0&&obj_lastModifiedDate_union1){let message='Object doesn\'t match union (at "'+path_lastModifiedDate+'")';message+='\n'+obj_lastModifiedDate_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lastModifiedDate_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';let obj_recordTypeId_union0=null;const obj_recordTypeId_union0_error=(()=>{if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}})();if(obj_recordTypeId_union0_error!=null){obj_recordTypeId_union0=obj_recordTypeId_union0_error.message;}let obj_recordTypeId_union1=null;const obj_recordTypeId_union1_error=(()=>{if(obj_recordTypeId!==null){return new TypeError('Expected "null" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}})();if(obj_recordTypeId_union1_error!=null){obj_recordTypeId_union1=obj_recordTypeId_union1_error.message;}if(obj_recordTypeId_union0&&obj_recordTypeId_union1){let message='Object doesn\'t match union (at "'+path_recordTypeId+'")';message+='\n'+obj_recordTypeId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_recordTypeId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recordTypeInfo=obj.recordTypeInfo;const path_recordTypeInfo=path+'.recordTypeInfo';let obj_recordTypeInfo_union0=null;const obj_recordTypeInfo_union0_error=(()=>{const referenceRecordTypeInfoRepresentationValidationError=validate(obj_recordTypeInfo,path_recordTypeInfo);if(referenceRecordTypeInfoRepresentationValidationError!==null){let message='Object doesn\'t match RecordTypeInfoRepresentation (at "'+path_recordTypeInfo+'")\n';message+=referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_recordTypeInfo_union0_error!=null){obj_recordTypeInfo_union0=obj_recordTypeInfo_union0_error.message;}let obj_recordTypeInfo_union1=null;const obj_recordTypeInfo_union1_error=(()=>{if(obj_recordTypeInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_recordTypeInfo+'" (at "'+path_recordTypeInfo+'")');}})();if(obj_recordTypeInfo_union1_error!=null){obj_recordTypeInfo_union1=obj_recordTypeInfo_union1_error.message;}if(obj_recordTypeInfo_union0&&obj_recordTypeInfo_union1){let message='Object doesn\'t match union (at "'+path_recordTypeInfo+'")';message+='\n'+obj_recordTypeInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_recordTypeInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_systemModstamp=obj.systemModstamp;const path_systemModstamp=path+'.systemModstamp';let obj_systemModstamp_union0=null;const obj_systemModstamp_union0_error=(()=>{if(typeof obj_systemModstamp!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_systemModstamp+'" (at "'+path_systemModstamp+'")');}})();if(obj_systemModstamp_union0_error!=null){obj_systemModstamp_union0=obj_systemModstamp_union0_error.message;}let obj_systemModstamp_union1=null;const obj_systemModstamp_union1_error=(()=>{if(obj_systemModstamp!==null){return new TypeError('Expected "null" but received "'+typeof obj_systemModstamp+'" (at "'+path_systemModstamp+'")');}})();if(obj_systemModstamp_union1_error!=null){obj_systemModstamp_union1=obj_systemModstamp_union1_error.message;}if(obj_systemModstamp_union0&&obj_systemModstamp_union1){let message='Object doesn\'t match union (at "'+path_systemModstamp+'")';message+='\n'+obj_systemModstamp_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_systemModstamp_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_weakEtag=obj.weakEtag;const path_weakEtag=path+'.weakEtag';if(typeof obj_weakEtag!=='number'||typeof obj_weakEtag==='number'&&Math.floor(obj_weakEtag)!==obj_weakEtag){return new TypeError('Expected "number" but received "'+typeof obj_weakEtag+'" (at "'+path_weakEtag+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder(config){return 'UiApi::RecordRepresentation:'+config.recordId;}function normalize$2(input,existing,path,lds,store,timestamp){const input_childRelationships=input.childRelationships;const input_childRelationships_id=path.fullPath+'__childRelationships';const input_childRelationships_keys=Object.keys(input_childRelationships);const input_childRelationships_length=input_childRelationships_keys.length;for(let i=0;i<input_childRelationships_length;i++){const key=input_childRelationships_keys[i];const input_childRelationships_prop=input_childRelationships[key];const input_childRelationships_prop_id=input_childRelationships_id+'__'+key;input_childRelationships[key]={__ref:ingest(input_childRelationships_prop,{fullPath:input_childRelationships_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}const input_fields=input.fields;const input_fields_id=path.fullPath+'__fields';const input_fields_keys=Object.keys(input_fields);const input_fields_length=input_fields_keys.length;for(let i=0;i<input_fields_length;i++){const key=input_fields_keys[i];const input_fields_prop=input_fields[key];const input_fields_prop_id=input_fields_id+'__'+key;input_fields[key]={__ref:ingest$1(input_fields_prop,{fullPath:input_fields_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}return input;}function equals$3(existing,incoming){const existing_weakEtag=existing.weakEtag;const incoming_weakEtag=incoming.weakEtag;if(!(existing_weakEtag===incoming_weakEtag)){return false;}const existing_apiName=existing.apiName;const incoming_apiName=incoming.apiName;if(!(existing_apiName===incoming_apiName)){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_childRelationships=existing.childRelationships;const incoming_childRelationships=incoming.childRelationships;const equals_childRelationships_props=equalsObject(existing_childRelationships,incoming_childRelationships,(existing_childRelationships_prop,incoming_childRelationships_prop)=>{if(!(existing_childRelationships_prop.__ref===incoming_childRelationships_prop.__ref)){return false;}});if(equals_childRelationships_props===false){return false;}const existing_fields=existing.fields;const incoming_fields=incoming.fields;const equals_fields_props=equalsObject(existing_fields,incoming_fields,(existing_fields_prop,incoming_fields_prop)=>{if(!(existing_fields_prop.__ref===incoming_fields_prop.__ref)){return false;}});if(equals_fields_props===false){return false;}const existing_lastModifiedById=existing.lastModifiedById;const incoming_lastModifiedById=incoming.lastModifiedById;if(!(existing_lastModifiedById===incoming_lastModifiedById)){return false;}const existing_lastModifiedDate=existing.lastModifiedDate;const incoming_lastModifiedDate=incoming.lastModifiedDate;if(!(existing_lastModifiedDate===incoming_lastModifiedDate)){return false;}const existing_recordTypeId=existing.recordTypeId;const incoming_recordTypeId=incoming.recordTypeId;if(!(existing_recordTypeId===incoming_recordTypeId)){return false;}const existing_recordTypeInfo=existing.recordTypeInfo;const incoming_recordTypeInfo=incoming.recordTypeInfo;if(!(existing_recordTypeInfo===incoming_recordTypeInfo||existing_recordTypeInfo!=null&&incoming_recordTypeInfo!=null&&equals$2(existing_recordTypeInfo,incoming_recordTypeInfo))){return false;}const existing_systemModstamp=existing.systemModstamp;const incoming_systemModstamp=incoming.systemModstamp;if(!(existing_systemModstamp===incoming_systemModstamp)){return false;}return true;}const ingest$2=function RecordRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$3(input);if(validateError!==null){throw validateError;}}const key=polymorph(input);let incomingRecord=normalize$2(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];incomingRecord=merge$1(existingRecord,incomingRecord,lds);if(existingRecord===undefined||equals$3(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+30000);return key;};function postUiApiRecords(config){const key='RecordRepresentation('+ +')';const headers={};return {path:'/services/data/v48.0/ui-api/records',method:'post',body:config.body,urlParams:{},queryParams:{},key:key,ingest:ingest$2,headers};}const factory$1=lds=>{return function(config){const request=postUiApiRecords({body:config});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const selections=buildSelectionFromRecord(body);const key=keyBuilder({recordId:body.id});lds.storeIngest(key,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:key,node:{kind:'Fragment',selections},variables:{}});},err=>{deepFreeze$2(err);throw err;});};};const RECORD_ID_DECODER='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456';/**
     * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
     * @param value A 15- or 18-char record id.
     * @returns An 18-char record id, and throws error if an invalid record id was provided.
     */function getRecordId18(value){if(!isString$1(value)){return undefined;}else if(value.length===18){return value;}else if(value.length===15){// Add the 3 character suffix
    let recordId=value;for(let offset=0;offset<15;offset+=5){let decodeValue=0;for(let bit=0;bit<5;bit++){const c=value[offset+bit];if(c>='A'&&c<='Z'){decodeValue+=1<<bit;}}recordId+=RECORD_ID_DECODER[decodeValue];}return recordId;}return undefined;}function deleteUiApiRecordsByRecordId(config){const key=null;const headers={};return {path:'/services/data/v48.0/ui-api/records/'+config.urlParams.recordId+'',method:'delete',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:null,headers};}const factory$1$1=lds=>recordId=>{const coercedRecordId=getRecordId18(recordId);if(coercedRecordId===undefined){throw new TypeError('Unexpected parameter, expected a Salesforce Record id.');}const request=deleteUiApiRecordsByRecordId({urlParams:{recordId:coercedRecordId}});return lds.dispatchResourceRequest(request).then(()=>{const storeRecordKey=keyBuilder({recordId:coercedRecordId});lds.storeEvict(storeRecordKey);lds.storeBroadcast();},err=>{deepFreeze$2(err);throw err;});};const{hasOwnProperty:ObjectPrototypeHasOwnProperty}=Object.prototype;const{keys:ObjectKeys$1$1}=Object;const{isArray:ArrayIsArray$1$1$1}=Array;function isPromise$2(value){return value.then!==undefined;}/**
     * Validates an adapter config is well-formed.
     * @param config The config to validate.
     * @param adapter The adapter validation configuration.
     * @param oneOf The keys the config must contain at least one of.
     * @throws A TypeError if config doesn't satisfy the adapter's config validation.
     */function validateConfig$2(config,adapter,oneOf){const{displayName}=adapter;const{required,optional,unsupported}=adapter.parameters;if(config===undefined||required.every(req=>ObjectPrototypeHasOwnProperty.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);}if(oneOf&&oneOf.some(req=>ObjectPrototypeHasOwnProperty.call(config,req))===false){throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);}if(unsupported!==undefined&&unsupported.some(req=>ObjectPrototypeHasOwnProperty.call(config,req))){throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);}const supported=required.concat(optional);if(ObjectKeys$1$1(config).some(key=>!supported.includes(key))){throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);}}function untrustedIsObject$1$1(untrusted){return typeof untrusted==='object'&&untrusted!==null&&ArrayIsArray$1$1$1(untrusted)===false;}function areRequiredParametersPresent(config,configPropertyNames){return configPropertyNames.parameters.required.every(req=>req in config);}function refreshable$1(adapter,resolve){return config=>{const result=adapter(config);if(result===null){return result;}if(isPromise$2(result)){return result.then(snapshot=>{snapshot.refresh={config,resolve};return snapshot;});}result.refresh={config,resolve};return result;};}const SNAPSHOT_STATE_FULFILLED='Fulfilled';function isObjectId(unknown){if(typeof unknown!=='object'||unknown===null){return false;}return isString$1(unknown.objectApiName);}/**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */function getObjectApiName$1(value){// Note: tightening validation logic changes behavior from userland getting
    // a server-provided error to the adapter noop'ing. In 224 we decided to not
    // change the behavior.
    if(typeof value==='string'){const trimmed=value.trim();if(trimmed.length>0){return trimmed;}}else if(isObjectId(value)){return value.objectApiName.trim();}return undefined;}var LayoutType$1;(function(LayoutType){LayoutType["Full"]="Full";LayoutType["Compact"]="Compact";})(LayoutType$1||(LayoutType$1={}));function coerceLayoutType(value){if(value===LayoutType$1.Full||value===LayoutType$1.Compact){return value;}return undefined;}var LayoutMode$1;(function(LayoutMode){LayoutMode["View"]="View";LayoutMode["Edit"]="Edit";LayoutMode["Create"]="Create";})(LayoutMode$1||(LayoutMode$1={}));function coerceLayoutMode(value){if(value===LayoutMode$1.Create||value===LayoutMode$1.Edit||value===LayoutMode$1.View){return value;}return undefined;}function validate$4(obj,path='AbstractRecordLayoutComponentRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';let obj_apiName_union0=null;const obj_apiName_union0_error=(()=>{if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}})();if(obj_apiName_union0_error!=null){obj_apiName_union0=obj_apiName_union0_error.message;}let obj_apiName_union1=null;const obj_apiName_union1_error=(()=>{if(obj_apiName!==null){return new TypeError('Expected "null" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}})();if(obj_apiName_union1_error!=null){obj_apiName_union1=obj_apiName_union1_error.message;}if(obj_apiName_union0&&obj_apiName_union1){let message='Object doesn\'t match union (at "'+path_apiName+'")';message+='\n'+obj_apiName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_apiName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_componentType=obj.componentType;const path_componentType=path+'.componentType';if(typeof obj_componentType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_componentType+'" (at "'+path_componentType+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$2$1(input){ObjectFreeze$1(input);}function validate$5(obj,path='RecordLayoutItemRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_editableForNew=obj.editableForNew;const path_editableForNew=path+'.editableForNew';if(typeof obj_editableForNew!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_editableForNew+'" (at "'+path_editableForNew+'")');}const obj_editableForUpdate=obj.editableForUpdate;const path_editableForUpdate=path+'.editableForUpdate';if(typeof obj_editableForUpdate!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_editableForUpdate+'" (at "'+path_editableForUpdate+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_layoutComponents=obj.layoutComponents;const path_layoutComponents=path+'.layoutComponents';if(!ArrayIsArray$2(obj_layoutComponents)){return new TypeError('Expected "array" but received "'+typeof obj_layoutComponents+'" (at "'+path_layoutComponents+'")');}for(let i=0;i<obj_layoutComponents.length;i++){const obj_layoutComponents_item=obj_layoutComponents[i];const path_layoutComponents_item=path_layoutComponents+'['+i+']';const referenceAbstractRecordLayoutComponentRepresentationValidationError=validate$4(obj_layoutComponents_item,path_layoutComponents_item);if(referenceAbstractRecordLayoutComponentRepresentationValidationError!==null){let message='Object doesn\'t match AbstractRecordLayoutComponentRepresentation (at "'+path_layoutComponents_item+'")\n';message+=referenceAbstractRecordLayoutComponentRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_lookupIdApiName=obj.lookupIdApiName;const path_lookupIdApiName=path+'.lookupIdApiName';let obj_lookupIdApiName_union0=null;const obj_lookupIdApiName_union0_error=(()=>{if(typeof obj_lookupIdApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lookupIdApiName+'" (at "'+path_lookupIdApiName+'")');}})();if(obj_lookupIdApiName_union0_error!=null){obj_lookupIdApiName_union0=obj_lookupIdApiName_union0_error.message;}let obj_lookupIdApiName_union1=null;const obj_lookupIdApiName_union1_error=(()=>{if(obj_lookupIdApiName!==null){return new TypeError('Expected "null" but received "'+typeof obj_lookupIdApiName+'" (at "'+path_lookupIdApiName+'")');}})();if(obj_lookupIdApiName_union1_error!=null){obj_lookupIdApiName_union1=obj_lookupIdApiName_union1_error.message;}if(obj_lookupIdApiName_union0&&obj_lookupIdApiName_union1){let message='Object doesn\'t match union (at "'+path_lookupIdApiName+'")';message+='\n'+obj_lookupIdApiName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lookupIdApiName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_required=obj.required;const path_required=path+'.required';if(typeof obj_required!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_required+'" (at "'+path_required+'")');}const obj_sortable=obj.sortable;const path_sortable=path+'.sortable';if(typeof obj_sortable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_sortable+'" (at "'+path_sortable+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$3(input){const input_layoutComponents=input.layoutComponents;for(let i=0;i<input_layoutComponents.length;i++){deepFreeze$2$1(input_layoutComponents[i]);}ObjectFreeze$1(input_layoutComponents);ObjectFreeze$1(input);}function validate$6(obj,path='RecordLayoutRowRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_layoutItems=obj.layoutItems;const path_layoutItems=path+'.layoutItems';if(!ArrayIsArray$2(obj_layoutItems)){return new TypeError('Expected "array" but received "'+typeof obj_layoutItems+'" (at "'+path_layoutItems+'")');}for(let i=0;i<obj_layoutItems.length;i++){const obj_layoutItems_item=obj_layoutItems[i];const path_layoutItems_item=path_layoutItems+'['+i+']';const referenceRecordLayoutItemRepresentationValidationError=validate$5(obj_layoutItems_item,path_layoutItems_item);if(referenceRecordLayoutItemRepresentationValidationError!==null){let message='Object doesn\'t match RecordLayoutItemRepresentation (at "'+path_layoutItems_item+'")\n';message+=referenceRecordLayoutItemRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function deepFreeze$4(input){const input_layoutItems=input.layoutItems;for(let i=0;i<input_layoutItems.length;i++){deepFreeze$3(input_layoutItems[i]);}ObjectFreeze$1(input_layoutItems);ObjectFreeze$1(input);}function validate$7(obj,path='RecordLayoutSectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_collapsible=obj.collapsible;const path_collapsible=path+'.collapsible';if(typeof obj_collapsible!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_collapsible+'" (at "'+path_collapsible+'")');}const obj_columns=obj.columns;const path_columns=path+'.columns';if(typeof obj_columns!=='number'||typeof obj_columns==='number'&&Math.floor(obj_columns)!==obj_columns){return new TypeError('Expected "number" but received "'+typeof obj_columns+'" (at "'+path_columns+'")');}const obj_heading=obj.heading;const path_heading=path+'.heading';let obj_heading_union0=null;const obj_heading_union0_error=(()=>{if(typeof obj_heading!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_heading+'" (at "'+path_heading+'")');}})();if(obj_heading_union0_error!=null){obj_heading_union0=obj_heading_union0_error.message;}let obj_heading_union1=null;const obj_heading_union1_error=(()=>{if(obj_heading!==null){return new TypeError('Expected "null" but received "'+typeof obj_heading+'" (at "'+path_heading+'")');}})();if(obj_heading_union1_error!=null){obj_heading_union1=obj_heading_union1_error.message;}if(obj_heading_union0&&obj_heading_union1){let message='Object doesn\'t match union (at "'+path_heading+'")';message+='\n'+obj_heading_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_heading_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_id=obj.id;const path_id=path+'.id';let obj_id_union0=null;const obj_id_union0_error=(()=>{if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union0_error!=null){obj_id_union0=obj_id_union0_error.message;}let obj_id_union1=null;const obj_id_union1_error=(()=>{if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union1_error!=null){obj_id_union1=obj_id_union1_error.message;}if(obj_id_union0&&obj_id_union1){let message='Object doesn\'t match union (at "'+path_id+'")';message+='\n'+obj_id_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_id_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_layoutRows=obj.layoutRows;const path_layoutRows=path+'.layoutRows';if(!ArrayIsArray$2(obj_layoutRows)){return new TypeError('Expected "array" but received "'+typeof obj_layoutRows+'" (at "'+path_layoutRows+'")');}for(let i=0;i<obj_layoutRows.length;i++){const obj_layoutRows_item=obj_layoutRows[i];const path_layoutRows_item=path_layoutRows+'['+i+']';const referenceRecordLayoutRowRepresentationValidationError=validate$6(obj_layoutRows_item,path_layoutRows_item);if(referenceRecordLayoutRowRepresentationValidationError!==null){let message='Object doesn\'t match RecordLayoutRowRepresentation (at "'+path_layoutRows_item+'")\n';message+=referenceRecordLayoutRowRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_rows=obj.rows;const path_rows=path+'.rows';if(typeof obj_rows!=='number'||typeof obj_rows==='number'&&Math.floor(obj_rows)!==obj_rows){return new TypeError('Expected "number" but received "'+typeof obj_rows+'" (at "'+path_rows+'")');}const obj_useHeading=obj.useHeading;const path_useHeading=path+'.useHeading';if(typeof obj_useHeading!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_useHeading+'" (at "'+path_useHeading+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$5(input){const input_layoutRows=input.layoutRows;for(let i=0;i<input_layoutRows.length;i++){deepFreeze$4(input_layoutRows[i]);}ObjectFreeze$1(input_layoutRows);ObjectFreeze$1(input);}function validate$8(obj,path='RecordLayoutRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_id=obj.id;const path_id=path+'.id';let obj_id_union0=null;const obj_id_union0_error=(()=>{if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union0_error!=null){obj_id_union0=obj_id_union0_error.message;}let obj_id_union1=null;const obj_id_union1_error=(()=>{if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union1_error!=null){obj_id_union1=obj_id_union1_error.message;}if(obj_id_union0&&obj_id_union1){let message='Object doesn\'t match union (at "'+path_id+'")';message+='\n'+obj_id_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_id_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}const obj_layoutType=obj.layoutType;const path_layoutType=path+'.layoutType';if(typeof obj_layoutType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_layoutType+'" (at "'+path_layoutType+'")');}const obj_mode=obj.mode;const path_mode=path+'.mode';if(typeof obj_mode!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_mode+'" (at "'+path_mode+'")');}const obj_sections=obj.sections;const path_sections=path+'.sections';if(!ArrayIsArray$2(obj_sections)){return new TypeError('Expected "array" but received "'+typeof obj_sections+'" (at "'+path_sections+'")');}for(let i=0;i<obj_sections.length;i++){const obj_sections_item=obj_sections[i];const path_sections_item=path_sections+'['+i+']';const referenceRecordLayoutSectionRepresentationValidationError=validate$7(obj_sections_item,path_sections_item);if(referenceRecordLayoutSectionRepresentationValidationError!==null){let message='Object doesn\'t match RecordLayoutSectionRepresentation (at "'+path_sections_item+'")\n';message+=referenceRecordLayoutSectionRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function keyBuilder$1(config){return 'UiApi::RecordLayoutRepresentation:'+config.recordTypeId+':'+config.apiName+':'+config.layoutType+':'+config.mode;}function normalize$3(input,existing,path,lds,store,timestamp){return input;}const select=function RecordLayoutRepresentationSelect(){return {kind:'Fragment',selections:[{name:'id',kind:'Scalar'},{name:'layoutType',kind:'Scalar'},{name:'mode',kind:'Scalar'},{name:'sections',kind:'Object',opaque:true}]};};function equals$4(existing,incoming){if(existing.eTag!==incoming.eTag){return false;}return true;}function deepFreeze$6(input){const input_sections=input.sections;for(let i=0;i<input_sections.length;i++){deepFreeze$5(input_sections[i]);}ObjectFreeze$1(input_sections);ObjectFreeze$1(input);}const ingest$3=function RecordLayoutRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$8(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$1({recordTypeId:input.recordTypeId,apiName:input.apiName,layoutType:input.layoutType,mode:input.mode});let incomingRecord=normalize$3(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$6(input);if(existingRecord===undefined||equals$4(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return key;};function getUiApiLayoutByObjectApiName(config){const key='RecordLayoutRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'layoutType:'+config.queryParams.layoutType+','+'mode:'+config.queryParams.mode+','+'recordTypeId:'+config.queryParams.recordTypeId+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v48.0/ui-api/layout/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$3,headers};}function coerceConfig(config){const coercedConfig={};const objectApiName=getObjectApiName$1(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const formFactor=config.formFactor;if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const layoutType=coerceLayoutType(config.layoutType);if(layoutType!==undefined){coercedConfig.layoutType=layoutType;}const mode=coerceLayoutMode(config.mode);if(mode!==undefined){coercedConfig.mode=mode;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}return coercedConfig;}function typeCheckConfig(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_layoutType=untrustedConfig.layoutType;if(typeof untrustedConfig_layoutType==='string'){config.layoutType=untrustedConfig_layoutType;}const untrustedConfig_mode=untrustedConfig.mode;if(typeof untrustedConfig_mode==='string'){config.mode=untrustedConfig_mode;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}return config;}function validateAdapterConfig$1(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig(untrustedConfig);const config=typeCheckConfig(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}const layoutSelections=select();// FYI stricter required set than RAML, matches lds222 behavior
    const getLayout_ConfigPropertyNames$1={displayName:'getLayout',parameters:{required:['objectApiName','layoutType','mode'],optional:['recordTypeId']}};function requestLayout(lds,config,requestOverride){const recordTypeId=config.recordTypeId;const request=getUiApiLayoutByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{layoutType:config.layoutType,mode:config.mode,recordTypeId}});const key=keyBuilder$1({apiName:config.objectApiName,recordTypeId,layoutType:config.layoutType,mode:config.mode});return lds.dispatchResourceRequest(request,requestOverride).then(response=>{const{body}=response;// TODO W-6399239 - fix API so we don't have to augment the response with request details in order
    // to support refresh. these are never emitted out per (private).
    body.apiName=config.objectApiName;body.recordTypeId=recordTypeId;lds.storeIngest(key,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:key,node:layoutSelections,variables:{}});},error=>{lds.storeIngestFetchResponse(key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}function cache$1$1(lds,config){const{recordTypeId,layoutType,mode}=config;const key=keyBuilder$1({apiName:config.objectApiName,recordTypeId,layoutType,mode});return lds.storeLookup({recordId:key,node:layoutSelections,variables:{}});}function coerceConfigWithDefaults(untrusted){const config=validateAdapterConfig$1(untrusted,getLayout_ConfigPropertyNames$1);if(config===null){return null;}// recordTypeId coercion is nuts: if `null` (but not undefined) then use MASTER record type id
    let recordTypeId=config.recordTypeId;if(recordTypeId===undefined){// must check untrusted bc config has been coerced
    if(untrusted.recordTypeId!==null){return null;}recordTypeId=MASTER_RECORD_TYPE_ID$4;}const layoutType=config.layoutType===undefined?LayoutType$1.Full:config.layoutType;const mode=config.mode===undefined?LayoutMode$1.View:config.mode;return _objectSpread$5({},config,{recordTypeId,layoutType,mode});}const factory$2=lds=>{return refreshable$1(untrusted=>{const config=coerceConfigWithDefaults(untrusted);if(config===null){return null;}const snapshot=cache$1$1(lds,config);// Cache hit
    if(isFulfilledSnapshot$1(snapshot)){return snapshot;}return requestLayout(lds,config);},untrusted=>{const config=coerceConfigWithDefaults(untrusted);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return requestLayout(lds,config,{headers:{'Cache-Control':'no-cache'}});});};function validate$9(obj,path='RecordLayoutSectionUserStateRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_collapsed=obj.collapsed;const path_collapsed=path+'.collapsed';if(typeof obj_collapsed!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_collapsed+'" (at "'+path_collapsed+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$7(input){ObjectFreeze$1(input);}function validate$a(obj,path='RecordLayoutUserStateRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_sectionUserStates=obj.sectionUserStates;const path_sectionUserStates=path+'.sectionUserStates';if(typeof obj_sectionUserStates!=='object'||ArrayIsArray$2(obj_sectionUserStates)||obj_sectionUserStates===null){return new TypeError('Expected "object" but received "'+typeof obj_sectionUserStates+'" (at "'+path_sectionUserStates+'")');}const obj_sectionUserStates_keys=ObjectKeys$1(obj_sectionUserStates);for(let i=0;i<obj_sectionUserStates_keys.length;i++){const key=obj_sectionUserStates_keys[i];const obj_sectionUserStates_prop=obj_sectionUserStates[key];const path_sectionUserStates_prop=path_sectionUserStates+'["'+key+'"]';const referenceRecordLayoutSectionUserStateRepresentationValidationError=validate$9(obj_sectionUserStates_prop,path_sectionUserStates_prop);if(referenceRecordLayoutSectionUserStateRepresentationValidationError!==null){let message='Object doesn\'t match RecordLayoutSectionUserStateRepresentation (at "'+path_sectionUserStates_prop+'")\n';message+=referenceRecordLayoutSectionUserStateRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_recordTypeId=obj.recordTypeId;const path_recordTypeId=path+'.recordTypeId';if(typeof obj_recordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordTypeId+'" (at "'+path_recordTypeId+'")');}const obj_layoutType=obj.layoutType;const path_layoutType=path+'.layoutType';if(typeof obj_layoutType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_layoutType+'" (at "'+path_layoutType+'")');}const obj_mode=obj.mode;const path_mode=path+'.mode';if(typeof obj_mode!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_mode+'" (at "'+path_mode+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$2(config){return 'UiApi::RecordLayoutUserStateRepresentation:'+config.recordTypeId+':'+config.apiName+':'+config.layoutType+':'+config.mode;}function normalize$4(input,existing,path,lds,store,timestamp){return input;}const select$1=function RecordLayoutUserStateRepresentationSelect(){return {kind:'Fragment',selections:[{name:'id',kind:'Scalar'},{name:'sectionUserStates',kind:'Object',opaque:true}]};};function equals$5(existing,incoming){if(JSONStrinify(incoming)!==JSONStrinify(existing)){return false;}return true;}function deepFreeze$8(input){const input_sectionUserStates=input.sectionUserStates;const input_sectionUserStates_keys=Object.keys(input_sectionUserStates);const input_sectionUserStates_length=input_sectionUserStates_keys.length;for(let i=0;i<input_sectionUserStates_length;i++){const key=input_sectionUserStates_keys[i];const input_sectionUserStates_prop=input_sectionUserStates[key];deepFreeze$7(input_sectionUserStates[key]);}ObjectFreeze$1(input_sectionUserStates);ObjectFreeze$1(input);}const ingest$4=function RecordLayoutUserStateRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$a(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$2({recordTypeId:input.recordTypeId,apiName:input.apiName,layoutType:input.layoutType,mode:input.mode});let incomingRecord=normalize$4(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$8(input);if(existingRecord===undefined||equals$5(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return key;};function getUiApiLayoutUserStateByObjectApiName(config){const key='RecordLayoutUserStateRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'layoutType:'+config.queryParams.layoutType+','+'mode:'+config.queryParams.mode+','+'recordTypeId:'+config.queryParams.recordTypeId+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v48.0/ui-api/layout/'+config.urlParams.objectApiName+'/user-state',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$4,headers};}function coerceConfig$1(config){const coercedConfig={};const objectApiName=getObjectApiName$1(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const formFactor=config.formFactor;if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const layoutType=coerceLayoutType(config.layoutType);if(layoutType!==undefined){coercedConfig.layoutType=layoutType;}const mode=coerceLayoutMode(config.mode);if(mode!==undefined){coercedConfig.mode=mode;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}return coercedConfig;}function typeCheckConfig$1(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_layoutType=untrustedConfig.layoutType;if(typeof untrustedConfig_layoutType==='string'){config.layoutType=untrustedConfig_layoutType;}const untrustedConfig_mode=untrustedConfig.mode;if(typeof untrustedConfig_mode==='string'){config.mode=untrustedConfig_mode;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}return config;}function validateAdapterConfig$1$1(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$1(untrustedConfig);const config=typeCheckConfig$1(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}const recordLayoutSelect=select$1();// FYI stricter required set than RAML defines, matches lds222 behavior
    const getLayoutUserState_ConfigPropertyNames$1={displayName:'getLayoutUserState',parameters:{required:['objectApiName','recordTypeId'],optional:['formFactor','layoutType','mode']}};function coerceConfigWithDefaults$1(untrustedConfig){const config=validateAdapterConfig$1$1(untrustedConfig,getLayoutUserState_ConfigPropertyNames$1);if(config===null){return null;}// recordTypeId is overridden to be required
    const recordTypeId=config.recordTypeId;const layoutType=config.layoutType===undefined?LayoutType$1.Full:config.layoutType;const mode=config.mode===undefined?LayoutMode$1.View:config.mode;return _objectSpread$5({},config,{recordTypeId,layoutType,mode});}function cache$2(lds,config){const{objectApiName,recordTypeId,layoutType,mode}=config;const key=keyBuilder$2({apiName:objectApiName,recordTypeId,layoutType,mode});return lds.storeLookup({recordId:key,node:recordLayoutSelect,variables:{}});}function network$1$1(lds,config){const{recordTypeId,layoutType,mode,objectApiName}=config;const key=keyBuilder$2({apiName:objectApiName,recordTypeId,layoutType,mode});const request=getUiApiLayoutUserStateByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{layoutType:config.layoutType,mode:config.mode,recordTypeId:config.recordTypeId}});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;// Hack- adding in this params so record-ui will be able to use normed values.
    body.apiName=config.objectApiName;body.recordTypeId=recordTypeId;body.layoutType=layoutType;body.mode=mode;lds.storeIngest(key,request,body);lds.storeBroadcast();return cache$2(lds,config);},error=>{lds.storeIngestFetchResponse(key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const factory$3=lds=>{return refreshable$1(function getLayoutUserState(untrustedConfig){const config=coerceConfigWithDefaults$1(untrustedConfig);if(config===null){return null;}const cacheSnapshot=cache$2(lds,config);// Cache Hit
    if(isFulfilledSnapshot$1(cacheSnapshot)){return cacheSnapshot;}return network$1$1(lds,config);},untrustedConfig=>{const config=coerceConfigWithDefaults$1(untrustedConfig);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return network$1$1(lds,config);});};/**
     * Returns the field API name.
     * @param value The value from which to get the field API name.
     * @returns The field API name.
     */function getFieldApiNamesArray(value){const valueArray=isArray$3(value)?value:[value];const array=[];for(let i=0,len=valueArray.length;i<len;i+=1){const item=valueArray[i];const apiName=getFieldApiName$3(item);if(apiName===undefined){return undefined;}push$1.call(array,apiName);}if(array.length===0){return undefined;}return dedupe(array).sort();}function validate$b(obj,path='ListColumnRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_fieldApiName=obj.fieldApiName;const path_fieldApiName=path+'.fieldApiName';if(typeof obj_fieldApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fieldApiName+'" (at "'+path_fieldApiName+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_sortable=obj.sortable;const path_sortable=path+'.sortable';if(typeof obj_sortable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_sortable+'" (at "'+path_sortable+'")');}})();return v_error===undefined?null:v_error;}const select$2=function ListColumnRepresentationSelect(){return {kind:'Fragment',selections:[{name:'fieldApiName',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'sortable',kind:'Scalar'}]};};function validate$c(obj,path='ListFilterByInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_fieldApiName=obj.fieldApiName;const path_fieldApiName=path+'.fieldApiName';if(typeof obj_fieldApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fieldApiName+'" (at "'+path_fieldApiName+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_operandLabels=obj.operandLabels;const path_operandLabels=path+'.operandLabels';if(!ArrayIsArray$2(obj_operandLabels)){return new TypeError('Expected "array" but received "'+typeof obj_operandLabels+'" (at "'+path_operandLabels+'")');}for(let i=0;i<obj_operandLabels.length;i++){const obj_operandLabels_item=obj_operandLabels[i];const path_operandLabels_item=path_operandLabels+'['+i+']';if(typeof obj_operandLabels_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_operandLabels_item+'" (at "'+path_operandLabels_item+'")');}}const obj_operator=obj.operator;const path_operator=path+'.operator';if(typeof obj_operator!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_operator+'" (at "'+path_operator+'")');}})();return v_error===undefined?null:v_error;}const select$3=function ListFilterByInfoRepresentationSelect(){return {kind:'Fragment',selections:[{name:'fieldApiName',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'operandLabels',kind:'Scalar',plural:true},{name:'operator',kind:'Scalar'}]};};function validate$d(obj,path='ListOrderByInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_fieldApiName=obj.fieldApiName;const path_fieldApiName=path+'.fieldApiName';if(typeof obj_fieldApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fieldApiName+'" (at "'+path_fieldApiName+'")');}const obj_isAscending=obj.isAscending;const path_isAscending=path+'.isAscending';if(typeof obj_isAscending!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_isAscending+'" (at "'+path_isAscending+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}})();return v_error===undefined?null:v_error;}const select$4=function ListOrderByInfoRepresentationSelect(){return {kind:'Fragment',selections:[{name:'fieldApiName',kind:'Scalar'},{name:'isAscending',kind:'Scalar'},{name:'label',kind:'Scalar'}]};};function validate$e(obj,path='ListUserPreferenceRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_columnWidths=obj.columnWidths;const path_columnWidths=path+'.columnWidths';if(typeof obj_columnWidths!=='object'||ArrayIsArray$2(obj_columnWidths)||obj_columnWidths===null){return new TypeError('Expected "object" but received "'+typeof obj_columnWidths+'" (at "'+path_columnWidths+'")');}const obj_columnWidths_keys=ObjectKeys$1(obj_columnWidths);for(let i=0;i<obj_columnWidths_keys.length;i++){const key=obj_columnWidths_keys[i];const obj_columnWidths_prop=obj_columnWidths[key];const path_columnWidths_prop=path_columnWidths+'["'+key+'"]';if(typeof obj_columnWidths_prop!=='number'||typeof obj_columnWidths_prop==='number'&&Math.floor(obj_columnWidths_prop)!==obj_columnWidths_prop){return new TypeError('Expected "number" but received "'+typeof obj_columnWidths_prop+'" (at "'+path_columnWidths_prop+'")');}}const obj_columnWrap=obj.columnWrap;const path_columnWrap=path+'.columnWrap';if(typeof obj_columnWrap!=='object'||ArrayIsArray$2(obj_columnWrap)||obj_columnWrap===null){return new TypeError('Expected "object" but received "'+typeof obj_columnWrap+'" (at "'+path_columnWrap+'")');}const obj_columnWrap_keys=ObjectKeys$1(obj_columnWrap);for(let i=0;i<obj_columnWrap_keys.length;i++){const key=obj_columnWrap_keys[i];const obj_columnWrap_prop=obj_columnWrap[key];const path_columnWrap_prop=path_columnWrap+'["'+key+'"]';if(typeof obj_columnWrap_prop!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_columnWrap_prop+'" (at "'+path_columnWrap_prop+'")');}}})();return v_error===undefined?null:v_error;}const select$5=function ListUserPreferenceRepresentationSelect(){return {kind:'Fragment',selections:[{name:'columnWidths',kind:'Scalar',map:true},{name:'columnWrap',kind:'Scalar',map:true}]};};function validate$f(obj,path='ListReferenceRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_id=obj.id;const path_id=path+'.id';let obj_id_union0=null;const obj_id_union0_error=(()=>{if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union0_error!=null){obj_id_union0=obj_id_union0_error.message;}let obj_id_union1=null;const obj_id_union1_error=(()=>{if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}})();if(obj_id_union1_error!=null){obj_id_union1=obj_id_union1_error.message;}if(obj_id_union0&&obj_id_union1){let message='Object doesn\'t match union (at "'+path_id+'")';message+='\n'+obj_id_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_id_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_listViewApiName=obj.listViewApiName;const path_listViewApiName=path+'.listViewApiName';let obj_listViewApiName_union0=null;const obj_listViewApiName_union0_error=(()=>{if(typeof obj_listViewApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_listViewApiName+'" (at "'+path_listViewApiName+'")');}})();if(obj_listViewApiName_union0_error!=null){obj_listViewApiName_union0=obj_listViewApiName_union0_error.message;}let obj_listViewApiName_union1=null;const obj_listViewApiName_union1_error=(()=>{if(obj_listViewApiName!==null){return new TypeError('Expected "null" but received "'+typeof obj_listViewApiName+'" (at "'+path_listViewApiName+'")');}})();if(obj_listViewApiName_union1_error!=null){obj_listViewApiName_union1=obj_listViewApiName_union1_error.message;}if(obj_listViewApiName_union0&&obj_listViewApiName_union1){let message='Object doesn\'t match union (at "'+path_listViewApiName+'")';message+='\n'+obj_listViewApiName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_listViewApiName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_objectApiName=obj.objectApiName;const path_objectApiName=path+'.objectApiName';if(typeof obj_objectApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_objectApiName+'" (at "'+path_objectApiName+'")');}const obj_type=obj.type;const path_type=path+'.type';if(typeof obj_type!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_type+'" (at "'+path_type+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$3(config){return 'UiApi::ListReferenceRepresentation:'+(config.id===null?'':config.id);}function normalize$5(input,existing,path,lds,store,timestamp){return input;}const select$6=function ListReferenceRepresentationSelect(){return {kind:'Fragment',selections:[{name:'id',kind:'Scalar'},{name:'listViewApiName',kind:'Scalar'},{name:'objectApiName',kind:'Scalar'},{name:'type',kind:'Scalar'}]};};function equals$6(existing,incoming){const existing_objectApiName=existing.objectApiName;const incoming_objectApiName=incoming.objectApiName;if(!(existing_objectApiName===incoming_objectApiName)){return false;}const existing_type=existing.type;const incoming_type=incoming.type;if(!(existing_type===incoming_type)){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_listViewApiName=existing.listViewApiName;const incoming_listViewApiName=incoming.listViewApiName;if(!(existing_listViewApiName===incoming_listViewApiName)){return false;}return true;}const ingest$5=function ListReferenceRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$f(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$3({id:input.id});let incomingRecord=normalize$5(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$6(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function validate$g(obj,path='ListInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_cloneable=obj.cloneable;const path_cloneable=path+'.cloneable';if(typeof obj_cloneable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_cloneable+'" (at "'+path_cloneable+'")');}const obj_createable=obj.createable;const path_createable=path+'.createable';if(typeof obj_createable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_createable+'" (at "'+path_createable+'")');}const obj_deletable=obj.deletable;const path_deletable=path+'.deletable';if(typeof obj_deletable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_deletable+'" (at "'+path_deletable+'")');}const obj_displayColumns=obj.displayColumns;const path_displayColumns=path+'.displayColumns';if(!ArrayIsArray$2(obj_displayColumns)){return new TypeError('Expected "array" but received "'+typeof obj_displayColumns+'" (at "'+path_displayColumns+'")');}for(let i=0;i<obj_displayColumns.length;i++){const obj_displayColumns_item=obj_displayColumns[i];const path_displayColumns_item=path_displayColumns+'['+i+']';const referenceListColumnRepresentationValidationError=validate$b(obj_displayColumns_item,path_displayColumns_item);if(referenceListColumnRepresentationValidationError!==null){let message='Object doesn\'t match ListColumnRepresentation (at "'+path_displayColumns_item+'")\n';message+=referenceListColumnRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_filterLogicString=obj.filterLogicString;const path_filterLogicString=path+'.filterLogicString';let obj_filterLogicString_union0=null;const obj_filterLogicString_union0_error=(()=>{if(typeof obj_filterLogicString!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_filterLogicString+'" (at "'+path_filterLogicString+'")');}})();if(obj_filterLogicString_union0_error!=null){obj_filterLogicString_union0=obj_filterLogicString_union0_error.message;}let obj_filterLogicString_union1=null;const obj_filterLogicString_union1_error=(()=>{if(obj_filterLogicString!==null){return new TypeError('Expected "null" but received "'+typeof obj_filterLogicString+'" (at "'+path_filterLogicString+'")');}})();if(obj_filterLogicString_union1_error!=null){obj_filterLogicString_union1=obj_filterLogicString_union1_error.message;}if(obj_filterLogicString_union0&&obj_filterLogicString_union1){let message='Object doesn\'t match union (at "'+path_filterLogicString+'")';message+='\n'+obj_filterLogicString_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_filterLogicString_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_filteredByInfo=obj.filteredByInfo;const path_filteredByInfo=path+'.filteredByInfo';if(!ArrayIsArray$2(obj_filteredByInfo)){return new TypeError('Expected "array" but received "'+typeof obj_filteredByInfo+'" (at "'+path_filteredByInfo+'")');}for(let i=0;i<obj_filteredByInfo.length;i++){const obj_filteredByInfo_item=obj_filteredByInfo[i];const path_filteredByInfo_item=path_filteredByInfo+'['+i+']';const referenceListFilterByInfoRepresentationValidationError=validate$c(obj_filteredByInfo_item,path_filteredByInfo_item);if(referenceListFilterByInfoRepresentationValidationError!==null){let message='Object doesn\'t match ListFilterByInfoRepresentation (at "'+path_filteredByInfo_item+'")\n';message+=referenceListFilterByInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_listReference=obj.listReference;const obj_orderedByInfo=obj.orderedByInfo;const path_orderedByInfo=path+'.orderedByInfo';if(!ArrayIsArray$2(obj_orderedByInfo)){return new TypeError('Expected "array" but received "'+typeof obj_orderedByInfo+'" (at "'+path_orderedByInfo+'")');}for(let i=0;i<obj_orderedByInfo.length;i++){const obj_orderedByInfo_item=obj_orderedByInfo[i];const path_orderedByInfo_item=path_orderedByInfo+'['+i+']';const referenceListOrderByInfoRepresentationValidationError=validate$d(obj_orderedByInfo_item,path_orderedByInfo_item);if(referenceListOrderByInfoRepresentationValidationError!==null){let message='Object doesn\'t match ListOrderByInfoRepresentation (at "'+path_orderedByInfo_item+'")\n';message+=referenceListOrderByInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_updateable=obj.updateable;const path_updateable=path+'.updateable';if(typeof obj_updateable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_updateable+'" (at "'+path_updateable+'")');}const obj_userPreferences=obj.userPreferences;const path_userPreferences=path+'.userPreferences';const referenceListUserPreferenceRepresentationValidationError=validate$e(obj_userPreferences,path_userPreferences);if(referenceListUserPreferenceRepresentationValidationError!==null){let message='Object doesn\'t match ListUserPreferenceRepresentation (at "'+path_userPreferences+'")\n';message+=referenceListUserPreferenceRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_visibility=obj.visibility;const path_visibility=path+'.visibility';if(typeof obj_visibility!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_visibility+'" (at "'+path_visibility+'")');}const obj_visibilityEditable=obj.visibilityEditable;const path_visibilityEditable=path+'.visibilityEditable';if(typeof obj_visibilityEditable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_visibilityEditable+'" (at "'+path_visibilityEditable+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$4(config){return 'UiApi::ListInfoRepresentation:'+(config.listViewApiName===null?'':config.listViewApiName)+':'+config.objectApiName+':'+config.type;}function normalize$6(input,existing,path,lds,store,timestamp){const input_listReference=input.listReference;const input_listReference_id=path.fullPath+'__listReference';input.listReference={__ref:ingest$5(input_listReference,{fullPath:input_listReference_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store)};return input;}const select$7=function ListInfoRepresentationSelect(){const{selections:ListColumnRepresentation__selections,opaque:ListColumnRepresentation__opaque}=select$2();const{selections:ListFilterByInfoRepresentation__selections,opaque:ListFilterByInfoRepresentation__opaque}=select$3();const{selections:ListReferenceRepresentation__selections,opaque:ListReferenceRepresentation__opaque}=select$6();const{selections:ListOrderByInfoRepresentation__selections,opaque:ListOrderByInfoRepresentation__opaque}=select$4();const{selections:ListUserPreferenceRepresentation__selections,opaque:ListUserPreferenceRepresentation__opaque}=select$5();return {kind:'Fragment',selections:[{name:'cloneable',kind:'Scalar'},{name:'createable',kind:'Scalar'},{name:'deletable',kind:'Scalar'},{name:'displayColumns',kind:'Object',plural:true,selections:ListColumnRepresentation__selections},{name:'filterLogicString',kind:'Scalar'},{name:'filteredByInfo',kind:'Object',plural:true,selections:ListFilterByInfoRepresentation__selections},{name:'label',kind:'Scalar'},{name:'listReference',kind:'Link',selections:ListReferenceRepresentation__selections},{name:'orderedByInfo',kind:'Object',plural:true,selections:ListOrderByInfoRepresentation__selections},{name:'updateable',kind:'Scalar'},{name:'userPreferences',kind:'Object',selections:ListUserPreferenceRepresentation__selections},{name:'visibility',kind:'Scalar'},{name:'visibilityEditable',kind:'Scalar'}]};};function equals$7(existing,incoming){if(existing.eTag!==incoming.eTag){return false;}return true;}const ingest$6=function ListInfoRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$g(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$4({listViewApiName:input.listReference.listViewApiName,objectApiName:input.listReference.objectApiName,type:input.listReference.type});let incomingRecord=normalize$6(input,store.records[key],{fullPath:key,parent:path.parent},lds,store);const existingRecord=store.records[key];if(existingRecord===undefined||equals$7(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function validate$h(obj,path='ListRecordCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_count=obj.count;const path_count=path+'.count';if(typeof obj_count!=='number'||typeof obj_count==='number'&&Math.floor(obj_count)!==obj_count){return new TypeError('Expected "number" but received "'+typeof obj_count+'" (at "'+path_count+'")');}const obj_currentPageToken=obj.currentPageToken;const path_currentPageToken=path+'.currentPageToken';if(typeof obj_currentPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageToken+'" (at "'+path_currentPageToken+'")');}const obj_currentPageUrl=obj.currentPageUrl;const path_currentPageUrl=path+'.currentPageUrl';if(typeof obj_currentPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageUrl+'" (at "'+path_currentPageUrl+'")');}const obj_fields=obj.fields;const path_fields=path+'.fields';if(!ArrayIsArray$2(obj_fields)){return new TypeError('Expected "array" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}for(let i=0;i<obj_fields.length;i++){const obj_fields_item=obj_fields[i];const path_fields_item=path_fields+'['+i+']';if(typeof obj_fields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fields_item+'" (at "'+path_fields_item+'")');}}const obj_listInfoETag=obj.listInfoETag;const path_listInfoETag=path+'.listInfoETag';if(typeof obj_listInfoETag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_listInfoETag+'" (at "'+path_listInfoETag+'")');}const obj_listReference=obj.listReference;const obj_nextPageToken=obj.nextPageToken;const path_nextPageToken=path+'.nextPageToken';let obj_nextPageToken_union0=null;const obj_nextPageToken_union0_error=(()=>{if(typeof obj_nextPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union0_error!=null){obj_nextPageToken_union0=obj_nextPageToken_union0_error.message;}let obj_nextPageToken_union1=null;const obj_nextPageToken_union1_error=(()=>{if(obj_nextPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union1_error!=null){obj_nextPageToken_union1=obj_nextPageToken_union1_error.message;}if(obj_nextPageToken_union0&&obj_nextPageToken_union1){let message='Object doesn\'t match union (at "'+path_nextPageToken+'")';message+='\n'+obj_nextPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_nextPageUrl=obj.nextPageUrl;const path_nextPageUrl=path+'.nextPageUrl';let obj_nextPageUrl_union0=null;const obj_nextPageUrl_union0_error=(()=>{if(typeof obj_nextPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union0_error!=null){obj_nextPageUrl_union0=obj_nextPageUrl_union0_error.message;}let obj_nextPageUrl_union1=null;const obj_nextPageUrl_union1_error=(()=>{if(obj_nextPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union1_error!=null){obj_nextPageUrl_union1=obj_nextPageUrl_union1_error.message;}if(obj_nextPageUrl_union0&&obj_nextPageUrl_union1){let message='Object doesn\'t match union (at "'+path_nextPageUrl+'")';message+='\n'+obj_nextPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_optionalFields=obj.optionalFields;const path_optionalFields=path+'.optionalFields';if(!ArrayIsArray$2(obj_optionalFields)){return new TypeError('Expected "array" but received "'+typeof obj_optionalFields+'" (at "'+path_optionalFields+'")');}for(let i=0;i<obj_optionalFields.length;i++){const obj_optionalFields_item=obj_optionalFields[i];const path_optionalFields_item=path_optionalFields+'['+i+']';if(typeof obj_optionalFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_optionalFields_item+'" (at "'+path_optionalFields_item+'")');}}const obj_pageSize=obj.pageSize;const path_pageSize=path+'.pageSize';if(typeof obj_pageSize!=='number'||typeof obj_pageSize==='number'&&Math.floor(obj_pageSize)!==obj_pageSize){return new TypeError('Expected "number" but received "'+typeof obj_pageSize+'" (at "'+path_pageSize+'")');}const obj_previousPageToken=obj.previousPageToken;const path_previousPageToken=path+'.previousPageToken';let obj_previousPageToken_union0=null;const obj_previousPageToken_union0_error=(()=>{if(typeof obj_previousPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union0_error!=null){obj_previousPageToken_union0=obj_previousPageToken_union0_error.message;}let obj_previousPageToken_union1=null;const obj_previousPageToken_union1_error=(()=>{if(obj_previousPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union1_error!=null){obj_previousPageToken_union1=obj_previousPageToken_union1_error.message;}if(obj_previousPageToken_union0&&obj_previousPageToken_union1){let message='Object doesn\'t match union (at "'+path_previousPageToken+'")';message+='\n'+obj_previousPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_previousPageUrl=obj.previousPageUrl;const path_previousPageUrl=path+'.previousPageUrl';let obj_previousPageUrl_union0=null;const obj_previousPageUrl_union0_error=(()=>{if(typeof obj_previousPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union0_error!=null){obj_previousPageUrl_union0=obj_previousPageUrl_union0_error.message;}let obj_previousPageUrl_union1=null;const obj_previousPageUrl_union1_error=(()=>{if(obj_previousPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union1_error!=null){obj_previousPageUrl_union1=obj_previousPageUrl_union1_error.message;}if(obj_previousPageUrl_union0&&obj_previousPageUrl_union1){let message='Object doesn\'t match union (at "'+path_previousPageUrl+'")';message+='\n'+obj_previousPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_records=obj.records;const path_records=path+'.records';if(!ArrayIsArray$2(obj_records)){return new TypeError('Expected "array" but received "'+typeof obj_records+'" (at "'+path_records+'")');}for(let i=0;i<obj_records.length;i++){const obj_records_item=obj_records[i];}const obj_sortBy=obj.sortBy;const path_sortBy=path+'.sortBy';let obj_sortBy_union0=null;const obj_sortBy_union0_error=(()=>{if(!ArrayIsArray$2(obj_sortBy)){return new TypeError('Expected "array" but received "'+typeof obj_sortBy+'" (at "'+path_sortBy+'")');}for(let i=0;i<obj_sortBy.length;i++){const obj_sortBy_item=obj_sortBy[i];const path_sortBy_item=path_sortBy+'['+i+']';if(typeof obj_sortBy_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_sortBy_item+'" (at "'+path_sortBy_item+'")');}}})();if(obj_sortBy_union0_error!=null){obj_sortBy_union0=obj_sortBy_union0_error.message;}let obj_sortBy_union1=null;const obj_sortBy_union1_error=(()=>{if(obj_sortBy!==null){return new TypeError('Expected "null" but received "'+typeof obj_sortBy+'" (at "'+path_sortBy+'")');}})();if(obj_sortBy_union1_error!=null){obj_sortBy_union1=obj_sortBy_union1_error.message;}if(obj_sortBy_union0&&obj_sortBy_union1){let message='Object doesn\'t match union (at "'+path_sortBy+'")';message+='\n'+obj_sortBy_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_sortBy_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function keyBuilder$5(config){return 'UiApi::ListRecordCollectionRepresentation:'+config.listViewId+':'+(config.sortBy===null?'':'['+config.sortBy.join(',')+']');}function paginationKeyBuilder(config){return keyBuilder$5(config)+'__pagination';}function normalize$7(input,existing,path,lds,store,timestamp){const input_listReference=input.listReference;const input_listReference_id=path.fullPath+'__listReference';input.listReference={__ref:ingest$5(input_listReference,{fullPath:input_listReference_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store)};const input_records=input.records;const input_records_id=path.fullPath+'__records';for(let i=0;i<input_records.length;i++){const input_records_item=input_records[i];let input_records_item_id=input_records_id+'__'+i;input_records[i]={__ref:ingest$2(input_records_item,{fullPath:input_records_item_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}return input;}function equals$8(existing,incoming){const existing_count=existing.count;const incoming_count=incoming.count;if(!(existing_count===incoming_count)){return false;}const existing_pageSize=existing.pageSize;const incoming_pageSize=incoming.pageSize;if(!(existing_pageSize===incoming_pageSize)){return false;}const existing_currentPageToken=existing.currentPageToken;const incoming_currentPageToken=incoming.currentPageToken;if(!(existing_currentPageToken===incoming_currentPageToken)){return false;}const existing_currentPageUrl=existing.currentPageUrl;const incoming_currentPageUrl=incoming.currentPageUrl;if(!(existing_currentPageUrl===incoming_currentPageUrl)){return false;}const existing_listInfoETag=existing.listInfoETag;const incoming_listInfoETag=incoming.listInfoETag;if(!(existing_listInfoETag===incoming_listInfoETag)){return false;}const existing_fields=existing.fields;const incoming_fields=incoming.fields;const equals_fields_items=equalsArray(existing_fields,incoming_fields,(existing_fields_item,incoming_fields_item)=>{if(!(existing_fields_item===incoming_fields_item)){return false;}});if(equals_fields_items===false){return false;}const existing_listReference=existing.listReference;const incoming_listReference=incoming.listReference;if(!(existing_listReference.__ref===incoming_listReference.__ref)){return false;}const existing_nextPageToken=existing.nextPageToken;const incoming_nextPageToken=incoming.nextPageToken;if(!(existing_nextPageToken===incoming_nextPageToken)){return false;}const existing_nextPageUrl=existing.nextPageUrl;const incoming_nextPageUrl=incoming.nextPageUrl;if(!(existing_nextPageUrl===incoming_nextPageUrl)){return false;}const existing_optionalFields=existing.optionalFields;const incoming_optionalFields=incoming.optionalFields;const equals_optionalFields_items=equalsArray(existing_optionalFields,incoming_optionalFields,(existing_optionalFields_item,incoming_optionalFields_item)=>{if(!(existing_optionalFields_item===incoming_optionalFields_item)){return false;}});if(equals_optionalFields_items===false){return false;}const existing_previousPageToken=existing.previousPageToken;const incoming_previousPageToken=incoming.previousPageToken;if(!(existing_previousPageToken===incoming_previousPageToken)){return false;}const existing_previousPageUrl=existing.previousPageUrl;const incoming_previousPageUrl=incoming.previousPageUrl;if(!(existing_previousPageUrl===incoming_previousPageUrl)){return false;}const existing_records=existing.records;const incoming_records=incoming.records;const equals_records_items=equalsArray(existing_records,incoming_records,(existing_records_item,incoming_records_item)=>{if(!(existing_records_item.__ref===incoming_records_item.__ref)){return false;}});if(equals_records_items===false){return false;}const existing_sortBy=existing.sortBy;const incoming_sortBy=incoming.sortBy;if(!(()=>{if(existing_sortBy===null||incoming_sortBy===null){return existing_sortBy===incoming_sortBy;}const equals_sortBy_items=equalsArray(existing_sortBy,incoming_sortBy,(existing_sortBy_item,incoming_sortBy_item)=>{if(!(existing_sortBy_item===incoming_sortBy_item)){return false;}});if(equals_sortBy_items===false){return false;}})()){return false;}return true;}const ingest$7=function ListRecordCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$h(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$5({listViewId:input.listInfoETag,sortBy:input.sortBy});let incomingRecord=normalize$7(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];const paginationKey=paginationKeyBuilder({listViewId:input.listInfoETag,sortBy:input.sortBy});const{isPastEnd,offsetFor,save,setEnd,setToken}=lds.pagination(paginationKey);const currentOffset=offsetFor(input.currentPageToken);{if(currentOffset===undefined||existingRecord&&existingRecord.records.length<currentOffset){throw new RangeError("currentPageToken value "+input.currentPageToken+" not recognized");}}const nextOffset=currentOffset+input.count;if(input.nextPageToken){setToken(input.nextPageToken,nextOffset);if(isPastEnd(nextOffset)){setEnd(undefined);}}else {setEnd(nextOffset);}if(input.previousPageToken){// TODO - need request's pageSize to ingest previousPageToken at end of list
    if(input.nextPageToken){setToken(input.previousPageToken,currentOffset-input.count);}}save();if(existingRecord){incomingRecord.currentPageUrl=existingRecord.currentPageUrl;// TODO: needs optimization
    incomingRecord.records=[...existingRecord.records.slice(0,currentOffset),...incomingRecord.records,...(input.nextPageToken?existingRecord.records.slice(nextOffset):[])];}if(existingRecord===undefined||equals$8(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function validate$i(obj,path='ListUiRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_info=obj.info;const obj_records=obj.records;})();return v_error===undefined?null:v_error;}function keyBuilder$6(config){return 'UiApi::ListUiRepresentation:'+(config.listViewApiName===null?'':config.listViewApiName)+':'+config.objectApiName+':'+config.type+':'+(config.sortBy===null?'':'['+config.sortBy.join(',')+']');}function normalize$8(input,existing,path,lds,store,timestamp){const input_info=input.info;const input_info_id=path.fullPath+'__info';input.info={__ref:ingest$6(input_info,{fullPath:input_info_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store)};const input_records=input.records;const input_records_id=path.fullPath+'__records';input.records={__ref:ingest$7(input_records,{fullPath:input_records_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};return input;}function equals$9(existing,incoming){const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_info=existing.info;const incoming_info=incoming.info;if(!(existing_info.__ref===incoming_info.__ref)){return false;}const existing_records=existing.records;const incoming_records=incoming.records;if(!(existing_records.__ref===incoming_records.__ref)){return false;}return true;}const ingest$8=function ListUiRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$i(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$6({listViewApiName:input.info.listReference.listViewApiName,objectApiName:input.info.listReference.objectApiName,type:input.info.listReference.type,sortBy:input.records.sortBy});let incomingRecord=normalize$8(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$9(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function getUiApiListUiByObjectApiNameAndListViewApiName(config){const key=keyBuilder$6({listViewApiName:config.urlParams.listViewApiName,objectApiName:config.urlParams.objectApiName,type:"listView",sortBy:config.queryParams.sortBy||null});const headers={};return {path:'/services/data/v48.0/ui-api/list-ui/'+config.urlParams.objectApiName+'/'+config.urlParams.listViewApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$8,headers};}const getListUiByApiName_ConfigPropertyNames$1={displayName:'getListUiByApiName',parameters:{required:['objectApiName','listViewApiName'],optional:['fields','optionalFields','pageSize','pageToken','sortBy']}};function coerceConfig$2(config){const coercedConfig={};const objectApiName=getObjectApiName$1(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const listViewApiName=config.listViewApiName;if(listViewApiName!==undefined){coercedConfig.listViewApiName=listViewApiName;}const fields=getFieldApiNamesArray(config.fields);if(fields!==undefined){coercedConfig.fields=fields;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const pageToken=config.pageToken;if(pageToken!==undefined){coercedConfig.pageToken=pageToken;}const sortBy=config.sortBy;if(sortBy!==undefined){coercedConfig.sortBy=sortBy;}return coercedConfig;}function typeCheckConfig$2(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_listViewApiName=untrustedConfig.listViewApiName;if(typeof untrustedConfig_listViewApiName==='string'){config.listViewApiName=untrustedConfig_listViewApiName;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$1$1$1(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$1$1(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_pageToken=untrustedConfig.pageToken;if(typeof untrustedConfig_pageToken==='string'){config.pageToken=untrustedConfig_pageToken;}const untrustedConfig_sortBy=untrustedConfig.sortBy;if(ArrayIsArray$1$1$1(untrustedConfig_sortBy)){const untrustedConfig_sortBy_array=[];for(let i=0,arrayLength=untrustedConfig_sortBy.length;i<arrayLength;i++){const untrustedConfig_sortBy_item=untrustedConfig_sortBy[i];if(typeof untrustedConfig_sortBy_item==='string'){untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);}}config.sortBy=untrustedConfig_sortBy_array;}return config;}function validateAdapterConfig$2(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$2(untrustedConfig);const config=typeCheckConfig$2(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function getUiApiListUiByListViewId(config){const key='ListUiRepresentation('+'fields:'+config.queryParams.fields+','+'optionalFields:'+config.queryParams.optionalFields+','+'pageSize:'+config.queryParams.pageSize+','+'pageToken:'+config.queryParams.pageToken+','+'sortBy:'+config.queryParams.sortBy+','+'listViewId:'+config.urlParams.listViewId+')';const headers={};return {path:'/services/data/v48.0/ui-api/list-ui/'+config.urlParams.listViewId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$8,headers};}const getListUiByListViewId_ConfigPropertyNames$1={displayName:'getListUiByListViewId',parameters:{required:['listViewId'],optional:['fields','optionalFields','pageSize','pageToken','sortBy']}};function coerceConfig$3(config){const coercedConfig={};const listViewId=config.listViewId;if(listViewId!==undefined){coercedConfig.listViewId=listViewId;}const fields=getFieldApiNamesArray(config.fields);if(fields!==undefined){coercedConfig.fields=fields;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const pageToken=config.pageToken;if(pageToken!==undefined){coercedConfig.pageToken=pageToken;}const sortBy=config.sortBy;if(sortBy!==undefined){coercedConfig.sortBy=sortBy;}return coercedConfig;}function typeCheckConfig$3(untrustedConfig){const config={};const untrustedConfig_listViewId=untrustedConfig.listViewId;if(typeof untrustedConfig_listViewId==='string'){config.listViewId=untrustedConfig_listViewId;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$1$1$1(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$1$1(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_pageToken=untrustedConfig.pageToken;if(typeof untrustedConfig_pageToken==='string'){config.pageToken=untrustedConfig_pageToken;}const untrustedConfig_sortBy=untrustedConfig.sortBy;if(ArrayIsArray$1$1$1(untrustedConfig_sortBy)){const untrustedConfig_sortBy_array=[];for(let i=0,arrayLength=untrustedConfig_sortBy.length;i<arrayLength;i++){const untrustedConfig_sortBy_item=untrustedConfig_sortBy[i];if(typeof untrustedConfig_sortBy_item==='string'){untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);}}config.sortBy=untrustedConfig_sortBy_array;}return config;}function validateAdapterConfig$3(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$3(untrustedConfig);const config=typeCheckConfig$3(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function validate$j(obj,path='ListViewSummaryRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_listUiUrl=obj.listUiUrl;const path_listUiUrl=path+'.listUiUrl';if(typeof obj_listUiUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_listUiUrl+'" (at "'+path_listUiUrl+'")');}})();return v_error===undefined?null:v_error;}const select$8=function ListViewSummaryRepresentationSelect(){return {kind:'Fragment',selections:[{name:'apiName',kind:'Scalar'},{name:'id',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'listUiUrl',kind:'Scalar'}]};};function equals$a(existing,incoming){const existing_apiName=existing.apiName;const incoming_apiName=incoming.apiName;if(!(existing_apiName===incoming_apiName)){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_label=existing.label;const incoming_label=incoming.label;if(!(existing_label===incoming_label)){return false;}const existing_listUiUrl=existing.listUiUrl;const incoming_listUiUrl=incoming.listUiUrl;if(!(existing_listUiUrl===incoming_listUiUrl)){return false;}return true;}function validate$k(obj,path='ListViewSummaryCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_count=obj.count;const path_count=path+'.count';if(typeof obj_count!=='number'||typeof obj_count==='number'&&Math.floor(obj_count)!==obj_count){return new TypeError('Expected "number" but received "'+typeof obj_count+'" (at "'+path_count+'")');}const obj_currentPageToken=obj.currentPageToken;const path_currentPageToken=path+'.currentPageToken';if(typeof obj_currentPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageToken+'" (at "'+path_currentPageToken+'")');}const obj_currentPageUrl=obj.currentPageUrl;const path_currentPageUrl=path+'.currentPageUrl';if(typeof obj_currentPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_currentPageUrl+'" (at "'+path_currentPageUrl+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_lists=obj.lists;const path_lists=path+'.lists';if(!ArrayIsArray$2(obj_lists)){return new TypeError('Expected "array" but received "'+typeof obj_lists+'" (at "'+path_lists+'")');}for(let i=0;i<obj_lists.length;i++){const obj_lists_item=obj_lists[i];const path_lists_item=path_lists+'['+i+']';const referenceListViewSummaryRepresentationValidationError=validate$j(obj_lists_item,path_lists_item);if(referenceListViewSummaryRepresentationValidationError!==null){let message='Object doesn\'t match ListViewSummaryRepresentation (at "'+path_lists_item+'")\n';message+=referenceListViewSummaryRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_nextPageToken=obj.nextPageToken;const path_nextPageToken=path+'.nextPageToken';let obj_nextPageToken_union0=null;const obj_nextPageToken_union0_error=(()=>{if(typeof obj_nextPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union0_error!=null){obj_nextPageToken_union0=obj_nextPageToken_union0_error.message;}let obj_nextPageToken_union1=null;const obj_nextPageToken_union1_error=(()=>{if(obj_nextPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageToken+'" (at "'+path_nextPageToken+'")');}})();if(obj_nextPageToken_union1_error!=null){obj_nextPageToken_union1=obj_nextPageToken_union1_error.message;}if(obj_nextPageToken_union0&&obj_nextPageToken_union1){let message='Object doesn\'t match union (at "'+path_nextPageToken+'")';message+='\n'+obj_nextPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_nextPageUrl=obj.nextPageUrl;const path_nextPageUrl=path+'.nextPageUrl';let obj_nextPageUrl_union0=null;const obj_nextPageUrl_union0_error=(()=>{if(typeof obj_nextPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union0_error!=null){obj_nextPageUrl_union0=obj_nextPageUrl_union0_error.message;}let obj_nextPageUrl_union1=null;const obj_nextPageUrl_union1_error=(()=>{if(obj_nextPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_nextPageUrl+'" (at "'+path_nextPageUrl+'")');}})();if(obj_nextPageUrl_union1_error!=null){obj_nextPageUrl_union1=obj_nextPageUrl_union1_error.message;}if(obj_nextPageUrl_union0&&obj_nextPageUrl_union1){let message='Object doesn\'t match union (at "'+path_nextPageUrl+'")';message+='\n'+obj_nextPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_nextPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_objectApiName=obj.objectApiName;const path_objectApiName=path+'.objectApiName';if(typeof obj_objectApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_objectApiName+'" (at "'+path_objectApiName+'")');}const obj_pageSize=obj.pageSize;const path_pageSize=path+'.pageSize';if(typeof obj_pageSize!=='number'||typeof obj_pageSize==='number'&&Math.floor(obj_pageSize)!==obj_pageSize){return new TypeError('Expected "number" but received "'+typeof obj_pageSize+'" (at "'+path_pageSize+'")');}const obj_previousPageToken=obj.previousPageToken;const path_previousPageToken=path+'.previousPageToken';let obj_previousPageToken_union0=null;const obj_previousPageToken_union0_error=(()=>{if(typeof obj_previousPageToken!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union0_error!=null){obj_previousPageToken_union0=obj_previousPageToken_union0_error.message;}let obj_previousPageToken_union1=null;const obj_previousPageToken_union1_error=(()=>{if(obj_previousPageToken!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageToken+'" (at "'+path_previousPageToken+'")');}})();if(obj_previousPageToken_union1_error!=null){obj_previousPageToken_union1=obj_previousPageToken_union1_error.message;}if(obj_previousPageToken_union0&&obj_previousPageToken_union1){let message='Object doesn\'t match union (at "'+path_previousPageToken+'")';message+='\n'+obj_previousPageToken_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageToken_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_previousPageUrl=obj.previousPageUrl;const path_previousPageUrl=path+'.previousPageUrl';let obj_previousPageUrl_union0=null;const obj_previousPageUrl_union0_error=(()=>{if(typeof obj_previousPageUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union0_error!=null){obj_previousPageUrl_union0=obj_previousPageUrl_union0_error.message;}let obj_previousPageUrl_union1=null;const obj_previousPageUrl_union1_error=(()=>{if(obj_previousPageUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_previousPageUrl+'" (at "'+path_previousPageUrl+'")');}})();if(obj_previousPageUrl_union1_error!=null){obj_previousPageUrl_union1=obj_previousPageUrl_union1_error.message;}if(obj_previousPageUrl_union0&&obj_previousPageUrl_union1){let message='Object doesn\'t match union (at "'+path_previousPageUrl+'")';message+='\n'+obj_previousPageUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_previousPageUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_q=obj.q;const path_q=path+'.q';let obj_q_union0=null;const obj_q_union0_error=(()=>{if(typeof obj_q!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_q+'" (at "'+path_q+'")');}})();if(obj_q_union0_error!=null){obj_q_union0=obj_q_union0_error.message;}let obj_q_union1=null;const obj_q_union1_error=(()=>{if(obj_q!==null){return new TypeError('Expected "null" but received "'+typeof obj_q+'" (at "'+path_q+'")');}})();if(obj_q_union1_error!=null){obj_q_union1=obj_q_union1_error.message;}if(obj_q_union0&&obj_q_union1){let message='Object doesn\'t match union (at "'+path_q+'")';message+='\n'+obj_q_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_q_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recentListsOnly=obj.recentListsOnly;const path_recentListsOnly=path+'.recentListsOnly';if(typeof obj_recentListsOnly!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_recentListsOnly+'" (at "'+path_recentListsOnly+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$7(config){return 'UiApi::ListViewSummaryCollectionRepresentation:'+config.objectApiName+':'+(config.q===null?'':config.q)+':'+config.recentListsOnly;}function paginationKeyBuilder$1(config){return keyBuilder$7(config)+'__pagination';}function normalize$9(input,existing,path,lds,store,timestamp){return input;}function equals$b(existing,incoming){const existing_recentListsOnly=existing.recentListsOnly;const incoming_recentListsOnly=incoming.recentListsOnly;if(!(existing_recentListsOnly===incoming_recentListsOnly)){return false;}const existing_count=existing.count;const incoming_count=incoming.count;if(!(existing_count===incoming_count)){return false;}const existing_pageSize=existing.pageSize;const incoming_pageSize=incoming.pageSize;if(!(existing_pageSize===incoming_pageSize)){return false;}const existing_currentPageToken=existing.currentPageToken;const incoming_currentPageToken=incoming.currentPageToken;if(!(existing_currentPageToken===incoming_currentPageToken)){return false;}const existing_currentPageUrl=existing.currentPageUrl;const incoming_currentPageUrl=incoming.currentPageUrl;if(!(existing_currentPageUrl===incoming_currentPageUrl)){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_objectApiName=existing.objectApiName;const incoming_objectApiName=incoming.objectApiName;if(!(existing_objectApiName===incoming_objectApiName)){return false;}const existing_lists=existing.lists;const incoming_lists=incoming.lists;const equals_lists_items=equalsArray(existing_lists,incoming_lists,(existing_lists_item,incoming_lists_item)=>{if(!equals$a(existing_lists_item,incoming_lists_item)){return false;}});if(equals_lists_items===false){return false;}const existing_nextPageToken=existing.nextPageToken;const incoming_nextPageToken=incoming.nextPageToken;if(!(existing_nextPageToken===incoming_nextPageToken)){return false;}const existing_nextPageUrl=existing.nextPageUrl;const incoming_nextPageUrl=incoming.nextPageUrl;if(!(existing_nextPageUrl===incoming_nextPageUrl)){return false;}const existing_previousPageToken=existing.previousPageToken;const incoming_previousPageToken=incoming.previousPageToken;if(!(existing_previousPageToken===incoming_previousPageToken)){return false;}const existing_previousPageUrl=existing.previousPageUrl;const incoming_previousPageUrl=incoming.previousPageUrl;if(!(existing_previousPageUrl===incoming_previousPageUrl)){return false;}const existing_q=existing.q;const incoming_q=incoming.q;if(!(existing_q===incoming_q)){return false;}return true;}const ingest$9=function ListViewSummaryCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$k(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$7({objectApiName:input.objectApiName,q:input.q,recentListsOnly:input.recentListsOnly});let incomingRecord=normalize$9(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];const paginationKey=paginationKeyBuilder$1({objectApiName:input.objectApiName,q:input.q,recentListsOnly:input.recentListsOnly});const{isPastEnd,offsetFor,save,setEnd,setToken}=lds.pagination(paginationKey);const currentOffset=offsetFor(input.currentPageToken);{if(currentOffset===undefined||existingRecord&&existingRecord.lists.length<currentOffset){throw new RangeError("currentPageToken value "+input.currentPageToken+" not recognized");}}const nextOffset=currentOffset+input.count;if(input.nextPageToken){setToken(input.nextPageToken,nextOffset);if(isPastEnd(nextOffset)){setEnd(undefined);}}else {setEnd(nextOffset);}if(input.previousPageToken){// TODO - need request's pageSize to ingest previousPageToken at end of list
    if(input.nextPageToken){setToken(input.previousPageToken,currentOffset-input.count);}}save();if(existingRecord){incomingRecord.currentPageUrl=existingRecord.currentPageUrl;// TODO: needs optimization
    incomingRecord.lists=[...existingRecord.lists.slice(0,currentOffset),...incomingRecord.lists,...(input.nextPageToken?existingRecord.lists.slice(nextOffset):[])];}if(existingRecord===undefined||equals$b(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function getUiApiListUiByObjectApiName(config){const key=keyBuilder$7({objectApiName:config.urlParams.objectApiName,q:config.queryParams.q||null,recentListsOnly:config.queryParams.recentListsOnly||false});const headers={};return {path:'/services/data/v48.0/ui-api/list-ui/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$9,headers};}const getListViewSummaryCollection_ConfigPropertyNames={displayName:'getListViewSummaryCollection',parameters:{required:['objectApiName'],optional:['pageSize','pageToken','q','recentListsOnly']}};function coerceConfig$4(config){const coercedConfig={};const objectApiName=getObjectApiName$1(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const pageToken=config.pageToken;if(pageToken!==undefined){coercedConfig.pageToken=pageToken;}const q=config.q;if(q!==undefined){coercedConfig.q=q;}const recentListsOnly=config.recentListsOnly;if(recentListsOnly!==undefined){coercedConfig.recentListsOnly=recentListsOnly;}return coercedConfig;}function typeCheckConfig$4(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_pageToken=untrustedConfig.pageToken;if(typeof untrustedConfig_pageToken==='string'){config.pageToken=untrustedConfig_pageToken;}const untrustedConfig_q=untrustedConfig.q;if(typeof untrustedConfig_q==='string'){config.q=untrustedConfig_q;}const untrustedConfig_recentListsOnly=untrustedConfig.recentListsOnly;if(typeof untrustedConfig_recentListsOnly==='boolean'){config.recentListsOnly=untrustedConfig_recentListsOnly;}return config;}function validateAdapterConfig$4(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$4(untrustedConfig);const config=typeCheckConfig$4(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function getUiApiMruListUiByObjectApiName(config){const key=keyBuilder$6({listViewApiName:null,objectApiName:config.urlParams.objectApiName,type:"mru",sortBy:config.queryParams.sortBy||null});const headers={};return {path:'/services/data/v48.0/ui-api/mru-list-ui/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$8,headers};}const getMruListUi_ConfigPropertyNames$1={displayName:'getMruListUi',parameters:{required:['objectApiName'],optional:['fields','optionalFields','pageSize','pageToken','sortBy']}};function coerceConfig$5(config){const coercedConfig={};const objectApiName=getObjectApiName$1(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const fields=getFieldApiNamesArray(config.fields);if(fields!==undefined){coercedConfig.fields=fields;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const pageToken=config.pageToken;if(pageToken!==undefined){coercedConfig.pageToken=pageToken;}const sortBy=config.sortBy;if(sortBy!==undefined){coercedConfig.sortBy=sortBy;}return coercedConfig;}function typeCheckConfig$5(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$1$1$1(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$1$1(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_pageToken=untrustedConfig.pageToken;if(typeof untrustedConfig_pageToken==='string'){config.pageToken=untrustedConfig_pageToken;}const untrustedConfig_sortBy=untrustedConfig.sortBy;if(ArrayIsArray$1$1$1(untrustedConfig_sortBy)){const untrustedConfig_sortBy_array=[];for(let i=0,arrayLength=untrustedConfig_sortBy.length;i<arrayLength;i++){const untrustedConfig_sortBy_item=untrustedConfig_sortBy[i];if(typeof untrustedConfig_sortBy_item==='string'){untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);}}config.sortBy=untrustedConfig_sortBy_array;}return config;}function validateAdapterConfig$5(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$5(untrustedConfig);const config=typeCheckConfig$5(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function getUiApiListRecordsByListViewId(config){const key=keyBuilder$5({listViewId:config.urlParams.listViewId,sortBy:config.queryParams.sortBy||null});const headers={};return {path:'/services/data/v48.0/ui-api/list-records/'+config.urlParams.listViewId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$7,headers};}function getUiApiListRecordsByObjectApiNameAndListViewApiName(config){const key='ListRecordCollectionRepresentation('+'fields:'+config.queryParams.fields+','+'optionalFields:'+config.queryParams.optionalFields+','+'pageSize:'+config.queryParams.pageSize+','+'pageToken:'+config.queryParams.pageToken+','+'sortBy:'+config.queryParams.sortBy+','+'objectApiName:'+config.urlParams.objectApiName+','+'listViewApiName:'+config.urlParams.listViewApiName+')';const headers={};return {path:'/services/data/v48.0/ui-api/list-records/'+config.urlParams.objectApiName+'/'+config.urlParams.listViewApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$7,headers};}const listReferences={byId:{},byApiNames:{}};/**
     * Adds a list reference so it can be retrieved with #getListReference later.
     *
     * @param listRef list refenence
     */function addListReference(listRef){const listRefKey=keyBuilder$3({id:listRef.id});if(listRef.id){listReferences.byId[listRef.id]=listRefKey;}listReferences.byApiNames[`${listRef.objectApiName}:${listRef.listViewApiName}`]=listRefKey;}/**
     * Reader selections to copy a list reference
     */const LIST_REFERENCE_SELECTIONS=select$6().selections;/**
     * Returns a list reference from the store if it's present.
     *
     * @param query list view to look for
     * @param lds LDS
     */function getListReference(query,lds){const key=query.listViewId?listReferences.byId[query.listViewId]:listReferences.byApiNames[`${query.objectApiName}:${query.listViewApiName}`];if(key){const lookupResult=lds.storeLookup({recordId:key,node:{kind:'Fragment',selections:LIST_REFERENCE_SELECTIONS},variables:{}});if(isFulfilledSnapshot$1(lookupResult)){return lookupResult.data;}}}/**
     * Reader selections to copy a list info
     */const LIST_INFO_SELECTIONS=select$7().selections;const LIST_INFO_SELECTIONS_ETAG=[...LIST_INFO_SELECTIONS,{kind:'Scalar',name:'eTag'}];/**
     * Retrieves the list info corresponding to the specified list reference from the store.
     *
     * @param listRef list reference
     * @param lds LDS
     */function getListInfo(listRef,lds){const key=keyBuilder$4(listRef);const lookupResult=lds.storeLookup({recordId:key,node:{kind:'Fragment',selections:LIST_INFO_SELECTIONS_ETAG},variables:{}});if(isFulfilledSnapshot$1(lookupResult)){return lookupResult.data;}}// Logic to deal with fields on the list view. This would be reasonably straightforward
    // except that the server sometimes adds 5 well-known fields to every record & nested
    // record in its responses.
    // hardcoded fields that the server adds
    const DEFAULT_SERVER_FIELDS=['CreatedDate','Id','LastModifiedById','LastModifiedDate','SystemModstamp'];/**
     * Adds default fields for every record referenced in a given field name. E.g. if field
     * is "Opportunity.Account.Name" then add default fields "Opportunity.CreatedDate",
     * "Opportunity.Id", ..., "Opportunity.Account.CreatedDate", "Opportunity.Account.Id", ... .
     *
     * @param field explicitly included field
     * @param defaultFields fields object to be updated with the fields that the server will
     *    implicitly add
     */function addDefaultFields(field,defaultFields){const fieldParts=field.split('.');for(let i=1;i<fieldParts.length;++i){const fieldPrefix=fieldParts.slice(0,i).join('.');for(let j=0;j<DEFAULT_SERVER_FIELDS.length;++j){defaultFields[`${fieldPrefix}.${DEFAULT_SERVER_FIELDS[j]}`]=true;}}}/**
     * Indicates if a RecordRepresntation contains a specified field.
     *
     * @param record record
     * @param field field to check for, split on '.'s, with the leading object api name omitted.
     *    E.g. if searching an Opportunity for "Opportunity.Account.Name" this parameter should
     *    be ['Account','Name'].
     */function recordContainsField(record,field){// make sure it looks like a record and the first piece of the field path has a value
    if(!record||!record.fields||!record.fields[field[0]]||record.fields[field[0]].value===undefined){return false;}// recurse if nested record
    else if(field.length>1){return recordContainsField(record.fields[field[0]].value,field.slice(1));}// found it
    return true;}function listFields(lds,{fields=[],optionalFields=[],sortBy},listInfo){const{displayColumns,listReference:{objectApiName}}=listInfo;let fields_={},optionalFields_={},defaultFields_={};// all the fields in the list info are required
    for(let i=0,len=displayColumns.length;i<len;++i){const qualifiedField=`${objectApiName}.${displayColumns[i].fieldApiName}`;fields_[qualifiedField]=true;addDefaultFields(qualifiedField,defaultFields_);}// required fields from the component
    for(let i=0,len=fields.length;i<len;++i){const qualifiedField=fields[i].startsWith(`${objectApiName}.`)?fields[i]:`${objectApiName}.${fields[i]}`;if(!fields_[qualifiedField]){fields_[qualifiedField]=true;addDefaultFields(qualifiedField,defaultFields_);}}// optional fields from the component
    for(let i=0,len=optionalFields.length;i<len;++i){const qualifiedField=optionalFields[i].startsWith(`${objectApiName}.`)?optionalFields[i]:`${objectApiName}.${optionalFields[i]}`;if(!fields_[qualifiedField]){optionalFields_[qualifiedField]=true;addDefaultFields(qualifiedField,defaultFields_);}}const key=keyBuilder$5({listViewId:listInfo.eTag,sortBy:sortBy||null})+'__fieldstatus';const node=lds.getNode(key);const defaultServerFieldStatus=isGraphNode(node)?node.retrieve():{missingFields:_objectSpread$5({},defaultFields_)};return {getRecordSelectionFieldSets(){const optionalPlusDefaultFields=_objectSpread$5({},optionalFields_);const fields=keys$3(defaultFields_);for(let i=0;i<fields.length;++i){const field=fields[i];if(!fields_[field]&&!defaultServerFieldStatus.missingFields[field]){optionalPlusDefaultFields[field]=true;}}return [keys$3(fields_).sort(),keys$3(optionalPlusDefaultFields).sort()];},processRecords(records){const{missingFields}=defaultServerFieldStatus;const fields=keys$3(missingFields);for(let i=0;i<fields.length;++i){const field=fields[i],splitField=field.split('.').slice(1);for(let i=0;i<records.length;++i){if(recordContainsField(records[i],splitField)){delete missingFields[field];break;}}}lds.storePublish(key,defaultServerFieldStatus);// snapshots do not subscribe to this key, so no need to broadcast
    return this;}};}function paginatedDataCustomReader(key,selection,record,data,variables,reader){const nonCustomSelection={name:selection.name,plural:true,selections:selection.selections,pageToken:selection.pageToken,pageSize:selection.pageSize,tokenDataKey:selection.tokenDataKey};if(record[selection.name]&&record[selection.name][0]&&record[selection.name][0].__ref){nonCustomSelection.kind='Link';reader.readPluralLink(key,nonCustomSelection,record,data);}else {nonCustomSelection.kind='Object';reader.readPluralObject(key,nonCustomSelection,record,data);}const pagination=reader.pagination(selection.tokenDataKey);variables.__pageSize=selection.pageSize;const currentOffset=pagination.offsetFor(selection.pageToken);const nextOffset=currentOffset+selection.pageSize;const previousOffset=currentOffset-selection.pageSize;// count
    variables.count=data[selection.name].length;// current/next/previousPageToken
    variables.currentPageToken=selection.pageToken||pagination.defaultToken();const nextPageToken=pagination.isPastEnd(nextOffset)?null:pagination.tokenFor(nextOffset);if(nextPageToken!==undefined){variables.nextPageToken=nextPageToken;}const previousPageToken=previousOffset<0?null:pagination.tokenFor(previousOffset);if(previousPageToken!==undefined){variables.previousPageToken=previousPageToken;}// current/next/previousPageUrls cannot be generated until we have a template url
    }function variablesCustomReader(key,selection,record,data,variables,reader){reader.readScalar(selection.name,variables,data);}function urlCustomReader(key,selection,record,data,variables,reader){let urlProp=selection.name;let tokenProp=`${urlProp.substring(0,urlProp.indexOf('Url'))}Token`;if(variables[tokenProp]){// currentPageUrl should never be empty so use that as the template
    variables[urlProp]=record.currentPageUrl.replace(/pageToken=[^&]+/,`pageToken=${variables[tokenProp]}`).replace(/pageSize=\d+/,`pageSize=${variables.__pageSize}`);}else if(variables[tokenProp]===null){variables[urlProp]=null;}reader.readScalar(selection.name,variables,data);}/**
     * Constructs a PathSelection[] to have Reader correctly populate paginated data
     * and metadata in a Snapshot. The metadata is assumed to follow the standard
     * UI API naming conventions: count, currentPageToken, currentPageUrl,
     * nextPageToken, nextPageUrl, previousPageToken, and previousPageUrl.
     *
     * @param config.name name of the field containing the paginated data
     * @param config.pageSize number of items to be included
     * @param config.pageToken token corresponding to starting offset
     * @param config.selections PathSelection[] to apply to each item
     * @param config.tokenDataKey store key of the pagination data
     * @returns PathSelection[] to populate the paginated data and associated metadata
     */function pathSelectionsFor(config){return [{kind:'Custom',name:config.name,pageToken:config.pageToken,pageSize:config.pageSize,plural:true,reader:paginatedDataCustomReader,selections:config.selections,tokenDataKey:config.tokenDataKey},{kind:'Custom',name:'count',reader:variablesCustomReader},{kind:'Custom',name:'currentPageToken',reader:variablesCustomReader},{kind:'Custom',name:'currentPageUrl',reader:urlCustomReader},{kind:'Custom',name:'nextPageToken',reader:variablesCustomReader},{kind:'Custom',name:'nextPageUrl',reader:urlCustomReader},{kind:'Custom',name:'previousPageToken',reader:variablesCustomReader},{kind:'Custom',name:'previousPageUrl',reader:urlCustomReader}];}/**
     * Returns a PathSelection that injects a predetermined value at the specified name.
     *
     * @param config.name key associated with the value
     * @param config.value value to be injected
     */function staticValuePathSelection(config){return {kind:'Custom',name:config.name,reader:(key,_selection,_record,data,_variables,_reader)=>{data[key]=config.value;}};}/**
     * Examines a set of paginated data & metadata from an UnfulfilledSnapshot and computes a
     * pageToken and pageSize that will minimize the amount of data requested while still
     * satisfying the original request.
     *
     * @param config.name name of the field within data that contains the items
     * @param conifg.data paginated data/metadata from an UnfulfilledSnapshot
     * @param config.pageSize requested pageSize
     * @param config.pagination pagination data/functions from engine
     * @returns pageToken & pageSize to fill in the missing data
     */function minimizeRequest(config){// the only way to handle missing current or previous token is to ask for the full set of requested records
    if(!config.data||!config.data[config.name]||config.data.previousPageToken===undefined){return {pageSize:config.pageSize,pageToken:config.pageToken};}else {// compute the offset of the last record that was found
    const pageTokenOffset=config.pagination.offsetFor(config.data.currentPageToken);const lastFoundOffset=pageTokenOffset+config.data[config.name].length;// backup to the nearest offset for which we have a token
    const[newToken,newOffset]=config.pagination.tokenForAtMost(lastFoundOffset);// recompute pageToken and pageSize for query based on new starting token
    return {pageSize:pageTokenOffset-newOffset+config.pageSize,pageToken:newToken};}}// TODO RAML - this more properly goes in the generated resource files
    const DEFAULT_PAGE_SIZE=20;const LISTVIEWSUMMARY_PATH_SELECTIONS=select$8().selections;function buildSelections(config){return pathSelectionsFor({name:'lists',selections:LISTVIEWSUMMARY_PATH_SELECTIONS,pageSize:config.pageSize||DEFAULT_PAGE_SIZE,pageToken:config.pageToken,tokenDataKey:paginationKeyBuilder$1({objectApiName:config.objectApiName,q:config.q===undefined?null:config.q,recentListsOnly:config.recentListsOnly===undefined?false:config.recentListsOnly})});}function buildInMemorySnapshot(lds,config){const request=getUiApiListUiByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{pageSize:config.pageSize,pageToken:config.pageToken,q:config.q,recentListsOnly:config.recentListsOnly}});const selector={recordId:request.key,node:{kind:'Fragment',selections:buildSelections(config)},variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot(lds,config,snapshot){const request=getUiApiListUiByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{pageSize:config.pageSize,pageToken:config.pageToken,q:config.q,recentListsOnly:config.recentListsOnly}});if(snapshot){// compute the minimum number of records we need to request
    const{pageSize,pageToken}=minimizeRequest({data:snapshot.data,name:'lists',pageSize:config.pageSize||DEFAULT_PAGE_SIZE,pageToken:config.pageToken,pagination:lds.pagination(paginationKeyBuilder$1({objectApiName:config.objectApiName,q:config.q===undefined?null:config.q,recentListsOnly:config.recentListsOnly===undefined?false:config.recentListsOnly}))});// update request, but don't harden default values unless they were already present
    if(pageSize!==DEFAULT_PAGE_SIZE||request.queryParams.pageSize!==undefined){request.queryParams.pageSize=pageSize;}if(pageToken||request.queryParams.pageToken!==undefined){request.queryParams.pageToken=pageToken;}}return lds.dispatchResourceRequest(request).then(resp=>{const{body}=resp;// TODO: temporary hack until lists team fixes W-6927292
    body.objectApiName=config.objectApiName;body.pageSize=config.pageSize===undefined?DEFAULT_PAGE_SIZE:config.pageSize;body.q=config.q===undefined?null:config.q;body.recentListsOnly=config.recentListsOnly===undefined?false:config.recentListsOnly;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getListViewSummaryCollectionAdapterFactory=lds=>{return refreshable$1(function getListViewSummaryCollection(untrustedConfig){const config=validateAdapterConfig$4(untrustedConfig,getListViewSummaryCollection_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot(lds,config);// Cache Hit
    if(isFulfilledSnapshot$1(cacheSnapshot)){return cacheSnapshot;}return buildNetworkSnapshot(lds,config,cacheSnapshot);},// Refresh snapshot
    untrustedConfig=>{const config=validateAdapterConfig$4(untrustedConfig,getListViewSummaryCollection_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getListViewSummaryCollection" refresh function');}return buildNetworkSnapshot(lds,config);});};function getUiApiMruListRecordsByObjectApiName(config){const key='ListRecordCollectionRepresentation('+'fields:'+config.queryParams.fields+','+'optionalFields:'+config.queryParams.optionalFields+','+'pageSize:'+config.queryParams.pageSize+','+'pageToken:'+config.queryParams.pageToken+','+'sortBy:'+config.queryParams.sortBy+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v48.0/ui-api/mru-list-records/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$7,headers};}const LIST_REFERENCE_SELECTIONS$1=select$6().selections;// TODO RAML - this more properly goes in the generated resource files
    const DEFAULT_PAGE_SIZE$1=50;// make local copies of the adapter configs so we can ignore other getListUi config parameters to match
    // lds222 behavior
    const getMruListUi_ConfigPropertyNames_augmented$1=_objectSpread$5({},getMruListUi_ConfigPropertyNames$1,{parameters:_objectSpread$5({},getMruListUi_ConfigPropertyNames$1.parameters,{optional:[...getMruListUi_ConfigPropertyNames$1.parameters.optional,'listViewApiName','listViewId']})});function buildListUiFragment(config,listInfo,fields){return {kind:'Fragment',selections:[{kind:'Link',name:'info',selections:LIST_INFO_SELECTIONS},{kind:'Link',name:'records',selections:[...pathSelectionsFor({name:'records',pageSize:config.pageSize||DEFAULT_PAGE_SIZE$1,pageToken:config.pageToken,selections:buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),tokenDataKey:paginationKeyBuilder({listViewId:listInfo.eTag,sortBy:config.sortBy===undefined?null:config.sortBy})}),{kind:'Scalar',name:'fields',plural:true},{kind:'Scalar',name:'listInfoETag'},{kind:'Link',name:'listReference',selections:LIST_REFERENCE_SELECTIONS$1},{kind:'Scalar',name:'optionalFields',plural:true},staticValuePathSelection({name:'pageSize',value:config.pageSize===undefined?DEFAULT_PAGE_SIZE$1:config.pageSize}),{// TODO - check type; re-verify after sortBy added to key
    kind:'Scalar',name:'sortBy'}]}]};}function buildInMemorySnapshot$1(lds,config,listInfo,fields){const listFields_=fields||listFields(lds,config,listInfo);const request=getUiApiMruListUiByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{fields:config.fields,optionalFields:config.optionalFields,pageSize:config.pageSize,pageToken:config.pageToken,sortBy:config.sortBy}});const selector={recordId:request.key,node:buildListUiFragment(config,listInfo,listFields_),variables:{}};return lds.storeLookup(selector);}/**
     * Builds, sends, and processes the result of a mru-list-ui request, ignoring any cached
     * data for the list.
     *
     * @param lds LDS engine
     * @param config wire config
     */function buildNetworkSnapshot_getMruListUi(lds,config){const{fields,optionalFields,pageSize,pageToken,sortBy}=config;const queryParams={fields,optionalFields,pageSize,pageToken,sortBy};let request=getUiApiMruListUiByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const listInfo=body.info;// TODO: server botches records.listReference but gets info.listReference correct,
    // see W-6933698
    body.records.listReference=body.info.listReference;// TODO: server should inject default pageSize when none was specified, see
    // W-6935308
    if(body.records.pageSize===null){body.records.pageSize=DEFAULT_PAGE_SIZE$1;}// TODO: server should inject default sortBy when none was specified, see
    // W-6935308
    if(body.records.sortBy===null);// server returns sortBy in csv format
    if(body.records.sortBy){body.records.sortBy=body.records.sortBy.split(',');}const listUiKey=keyBuilder$6(_objectSpread$5({},listInfo.listReference,{sortBy:body.records.sortBy}));// grab relevant bits before ingest destroys the structure
    const fields=listFields(lds,config,listInfo);fields.processRecords(body.records.records);// build the selector while the list info is still easily accessible
    const fragment=buildListUiFragment(config,listInfo,fields);lds.storeIngest(listUiKey,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:listUiKey,node:fragment,variables:{}});},err=>{return lds.errorSnapshot(err);});}function buildNetworkSnapshot_getMruListRecords(lds,config,listInfo,snapshot){const{fields,optionalFields,pageSize,pageToken,sortBy}=config;const queryParams={fields,optionalFields,pageSize,pageToken,sortBy};const request=getUiApiMruListRecordsByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams});if(snapshot){// compute the minimum number of records we need to request
    const{pageSize,pageToken}=minimizeRequest({data:snapshot.data?snapshot.data.records:null,name:'records',pageSize:config.pageSize||DEFAULT_PAGE_SIZE$1,pageToken:config.pageToken,pagination:lds.pagination(paginationKeyBuilder({listViewId:listInfo.eTag,sortBy:config.sortBy===undefined?null:config.sortBy}))});// update request, but don't harden default values unless they were already present
    if(pageSize!==DEFAULT_PAGE_SIZE$1||request.queryParams.pageSize!==undefined){request.queryParams.pageSize=pageSize;}if(pageToken!==undefined||request.queryParams.pageToken!==undefined){request.queryParams.pageToken=pageToken;}}return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const{listInfoETag}=body;// fall back to mru-list-ui if list view has changed
    if(listInfoETag!==listInfo.eTag){return buildNetworkSnapshot_getMruListUi(lds,config);}// TODO: server botches records.listReference but gets info.listReference correct,
    // see W-6933698
    body.listReference=listInfo.listReference;// TODO: server should inject default pageSize when none was specified, see
    // W-6935308
    if(body.pageSize===null){body.pageSize=DEFAULT_PAGE_SIZE$1;}// TODO: server should inject default sortBy when none was specified, see
    // W-6935308
    if(body.sortBy===null);// server returns sortBy in csv format
    if(body.sortBy){body.sortBy=body.sortBy.split(',');}const fields=listFields(lds,config,listInfo).processRecords(body.records);lds.storeIngest(keyBuilder$5({listViewId:listInfoETag,sortBy:body.sortBy}),request,body);lds.storeBroadcast();return buildInMemorySnapshot$1(lds,config,listInfo,fields);},err=>{lds.storeIngestFetchResponse(keyBuilder$6(_objectSpread$5({},listInfo.listReference,{sortBy:config.sortBy===undefined?null:config.sortBy})),err);lds.storeBroadcast();return lds.errorSnapshot(err);});}const getMruListUiAdapterFactory=lds=>{return refreshable$1(untrustedConfig=>{const config=validateAdapterConfig$5(untrustedConfig,getMruListUi_ConfigPropertyNames_augmented$1);if(config===null){return null;}// try to get a list reference and a list info for the list; this should come back
    // non-null if we have the list info cached
    const listInfo=getListInfo({id:null,listViewApiName:null,objectApiName:config.objectApiName,type:'mru'},lds);// no list info means it's not in the cache - make a full list-ui request
    if(!listInfo){return buildNetworkSnapshot_getMruListUi(lds,config);}// with the list info we can construct the full selector and try to get the
    // list ui from the store
    const snapshot=buildInMemorySnapshot$1(lds,config,listInfo);if(isFulfilledSnapshot$1(snapshot)){// cache hit :partyparrot:
    return snapshot;}// if there was an error or if the list ui was not found in the store then
    // make a full list-ui request
    else if(isErrorSnapshot$1(snapshot)||!snapshot.data){return buildNetworkSnapshot_getMruListUi(lds,config);}// we *should* only be missing records and/or tokens at this point; send a list-records
    // request to fill them in
    return buildNetworkSnapshot_getMruListRecords(lds,config,listInfo,snapshot);},untrustedConfig=>{const config=validateAdapterConfig$5(untrustedConfig,getMruListUi_ConfigPropertyNames$1);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getMruListUi" refresh function');}return buildNetworkSnapshot_getMruListUi(lds,config);});};const LIST_REFERENCE_SELECTIONS$2=select$6().selections;// TODO RAML - this more properly goes in the generated resource files
    const DEFAULT_PAGE_SIZE$2=50;// make local copies of the adapter configs so we can have them ignore each other's config parameters
    // to match lds222 behavior
    const getListUiByApiName_ConfigPropertyNames_augmented$1=_objectSpread$5({},getListUiByApiName_ConfigPropertyNames$1,{parameters:_objectSpread$5({},getListUiByApiName_ConfigPropertyNames$1.parameters,{optional:[...getListUiByApiName_ConfigPropertyNames$1.parameters.optional,'listViewId']})});const getListUiByListViewId_ConfigPropertyNames_augmented$1=_objectSpread$5({},getListUiByListViewId_ConfigPropertyNames$1,{parameters:_objectSpread$5({},getListUiByListViewId_ConfigPropertyNames$1.parameters,{optional:[...getListUiByListViewId_ConfigPropertyNames$1.parameters.optional,'listViewApiName','objectApiName']})});function buildListUiFragment$1(config,listInfo,fields){return {kind:'Fragment',selections:[{kind:'Link',name:'info',selections:LIST_INFO_SELECTIONS},{kind:'Link',name:'records',selections:[...pathSelectionsFor({name:'records',pageSize:config.pageSize||DEFAULT_PAGE_SIZE$2,pageToken:config.pageToken,selections:buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),tokenDataKey:paginationKeyBuilder({listViewId:listInfo.eTag,sortBy:config.sortBy===undefined?null:config.sortBy})}),{kind:'Scalar',name:'fields',plural:true},{kind:'Scalar',name:'listInfoETag'},{kind:'Link',name:'listReference',selections:LIST_REFERENCE_SELECTIONS$2},{kind:'Scalar',name:'optionalFields',plural:true},staticValuePathSelection({name:'pageSize',value:config.pageSize===undefined?DEFAULT_PAGE_SIZE$2:config.pageSize}),{// TODO - check type; re-verify after sortBy added to key
    kind:'Scalar',name:'sortBy'}]}]};}function buildInMemorySnapshot$2(lds,config,listInfo,fields){const listUiKey=keyBuilder$6(_objectSpread$5({},listInfo.listReference,{sortBy:config.sortBy===undefined?null:config.sortBy}));const listFields_=fields||listFields(lds,config,listInfo);const selector={recordId:listUiKey,node:buildListUiFragment$1(config,listInfo,listFields_),variables:{}};return lds.storeLookup(selector);}/**
     * Builds, sends, and processes the result of a list-ui request, ignoring any cached
     * data for the list view.
     *
     * @param lds LDS engine
     * @param config wire config
     */function buildNetworkSnapshot_getListUi(lds,config){const{fields,optionalFields,pageSize,pageToken,sortBy}=config;const queryParams={fields,optionalFields,pageSize,pageToken,sortBy};let request;if(isGetListUiByApiNameConfig(config)){request=getUiApiListUiByObjectApiNameAndListViewApiName({urlParams:{listViewApiName:config.listViewApiName,objectApiName:config.objectApiName},queryParams});}else if(isGetListUiByListViewIdConfig(config)){request=getUiApiListUiByListViewId({urlParams:{listViewId:config.listViewId},queryParams});}else {throw new Error('unrecognized config');}return lds.dispatchResourceRequest(request).then(response=>{const{body}=response,listInfo=body.info,{listReference}=listInfo;// TODO: server botches records.listReference but gets info.listReference correct,
    // see W-6933698
    body.records.listReference=listReference;// TODO: server should inject default pageSize when none was specified, see
    // W-6935308
    if(body.records.pageSize===null){body.records.pageSize=DEFAULT_PAGE_SIZE$2;}// TODO: server should inject default sortBy when none was specified, see
    // W-6935308
    if(body.records.sortBy===null);// server returns sortBy in csv format
    if(body.records.sortBy){body.records.sortBy=body.records.sortBy.split(',');}const listUiKey=keyBuilder$6(_objectSpread$5({},listReference,{sortBy:body.records.sortBy}));// grab relevant bits before ingest destroys the structure
    const fields=listFields(lds,config,listInfo);fields.processRecords(body.records.records);// build the selector while the list info is still easily accessible
    const fragment=buildListUiFragment$1(config,listInfo,fields);// remember the id/name of this list
    addListReference(listReference);lds.storeIngest(listUiKey,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:listUiKey,node:fragment,variables:{}});},err=>{return lds.errorSnapshot(err);});}function buildNetworkSnapshot_getListRecords(lds,config,listInfo,snapshot){const{fields,optionalFields,pageSize,pageToken,sortBy}=config;const queryParams={fields,optionalFields,pageSize,pageToken,sortBy};let request;if(isGetListUiByApiNameConfig(config)){request=getUiApiListRecordsByObjectApiNameAndListViewApiName({urlParams:{listViewApiName:config.listViewApiName,objectApiName:config.objectApiName},queryParams});}else if(isGetListUiByListViewIdConfig(config)){request=getUiApiListRecordsByListViewId({urlParams:{listViewId:config.listViewId},queryParams});}else {throw new Error('how did MRU config get here?');}if(snapshot){// compute the minimum number of records we need to request
    const{pageSize,pageToken}=minimizeRequest({data:snapshot.data?snapshot.data.records:null,name:'records',pageSize:config.pageSize||DEFAULT_PAGE_SIZE$2,pageToken:config.pageToken,pagination:lds.pagination(paginationKeyBuilder({listViewId:listInfo.eTag,sortBy:config.sortBy===undefined?null:config.sortBy}))});// update request, but don't harden default values unless they were already present
    if(pageSize!==DEFAULT_PAGE_SIZE$2||request.queryParams.pageSize!==undefined){request.queryParams.pageSize=pageSize;}if(pageToken||request.queryParams.pageToken!==undefined){request.queryParams.pageToken=pageToken;}}return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const{listInfoETag}=body;// fall back to list-ui if list view has changed
    if(listInfoETag!==listInfo.eTag){return buildNetworkSnapshot_getListUi(lds,config);}// TODO: server botches records.listReference but gets info.listReference correct,
    // see W-6933698
    body.listReference=listInfo.listReference;// TODO: server should inject default pageSize when none was specified, see
    // W-6935308
    if(body.pageSize===null){body.pageSize=DEFAULT_PAGE_SIZE$2;}// TODO: server should inject default sortBy when none was specified, see
    // W-6935308
    if(body.sortBy===null);// server returns sortBy in csv format
    if(body.sortBy){body.sortBy=body.sortBy.split(',');}const fields=listFields(lds,config,listInfo).processRecords(body.records);lds.storeIngest(keyBuilder$5({listViewId:listInfoETag,sortBy:body.sortBy}),request,body);lds.storeBroadcast();return buildInMemorySnapshot$2(lds,config,listInfo,fields);},err=>{lds.storeIngestFetchResponse(keyBuilder$6(_objectSpread$5({},listInfo.listReference,{sortBy:config.sortBy===undefined?null:config.sortBy})),err);lds.storeBroadcast();return lds.errorSnapshot(err);});}// functions to discern config variations
    function isGetListUiByApiNameConfig(config){return config.listViewApiName!==undefined;}function looksLikeGetListUiByApiNameConfig(untrustedConfig){return untrustedIsObject$1$1(untrustedConfig)&&untrustedConfig.objectApiName&&untrustedConfig.listViewApiName;}function isGetListUiByListViewIdConfig(config){return !!config.listViewId;}function looksLikeGetListUiByListViewIdConfig(untrustedConfig){return untrustedIsObject$1$1(untrustedConfig)&&untrustedConfig.listViewId;}function looksLikeGetListViewSummaryCollectionConfig(untrustedConfig){return untrustedIsObject$1$1(untrustedConfig)&&untrustedConfig.objectApiName&&!untrustedConfig.listViewId&&!untrustedConfig.listViewApiName;}function looksLikeGetMruListUiConfig(untrustedConfig){// the MRU symbol is a carryover hack from 222 and doesn't show up in any
    // of the generated config types, so we cast to any in order to check for it
    return untrustedIsObject$1$1(untrustedConfig)&&untrustedConfig.listViewApiName===MRU$1;}function validateGetListUiConfig(untrustedConfig){return looksLikeGetListUiByApiNameConfig(untrustedConfig)?validateAdapterConfig$2(untrustedConfig,getListUiByApiName_ConfigPropertyNames_augmented$1):looksLikeGetListUiByListViewIdConfig(untrustedConfig)?validateAdapterConfig$3(untrustedConfig,getListUiByListViewId_ConfigPropertyNames_augmented$1):null;}// the listViewApiName value to pass to getListUi() to request the MRU list
    const MRU$1=Symbol.for('MRU');const factory$4=lds=>{// adapter implementation for getListUiBy*
    const listUiAdapter=refreshable$1(untrustedConfig=>{const config=validateGetListUiConfig(untrustedConfig);if(config===null){return null;}// try to get a list reference and a list info for the list; this should come back
    // non-null if we have the list info cached
    const listRef=getListReference(config,lds);const listInfo=listRef&&getListInfo(listRef,lds);// no list info means it's not in the cache - make a full list-ui request
    if(!listInfo){return buildNetworkSnapshot_getListUi(lds,config);}// with the list info we can construct the full selector and try to get the
    // list ui from the store
    const snapshot=buildInMemorySnapshot$2(lds,config,listInfo);if(isFulfilledSnapshot$1(snapshot)){// cache hit :partyparrot:
    return snapshot;}// if there was an error or if the list ui was not found in the store then
    // make a full list-ui request
    else if(isErrorSnapshot$1(snapshot)||!snapshot.data){return buildNetworkSnapshot_getListUi(lds,config);}// we *should* only be missing records and/or tokens at this point; send a list-records
    // request to fill them in
    return buildNetworkSnapshot_getListRecords(lds,config,listInfo,snapshot);},untrustedConfig=>{const config=validateGetListUiConfig(untrustedConfig);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getListUi" refresh function');}return buildNetworkSnapshot_getListUi(lds,config);});let listViewSummaryCollectionAdapter=null;let mruAdapter=null;// delegate to various other adapter based on what config looks like; note that the adapters
    // we delegate to are responsible for returning refreshable results
    return function(untrustedConfig){// if the MRU symbol is there then just return the getMruListUi adapter
    if(looksLikeGetMruListUiConfig(untrustedConfig)){if(mruAdapter===null){mruAdapter=getMruListUiAdapterFactory(lds);}// the symbol in the listViewApiName is just a hack so we can recognize the request as MRU
    const mruConfig=_objectSpread$5({},untrustedConfig);delete mruConfig.listViewApiName;return mruAdapter(mruConfig);}// if config has objectApiName but no listViewId or listViewApiName then hand off
    // to listViewSummaryCollectionAdapter
    if(looksLikeGetListViewSummaryCollectionConfig(untrustedConfig)){if(listViewSummaryCollectionAdapter===null){listViewSummaryCollectionAdapter=getListViewSummaryCollectionAdapterFactory(lds);}return listViewSummaryCollectionAdapter(untrustedConfig);}// see if config looks like a listViewId or listViewApiName request
    if(looksLikeGetListUiByApiNameConfig(untrustedConfig)||looksLikeGetListUiByListViewIdConfig(untrustedConfig)){return listUiAdapter(untrustedConfig);}return null;};};function getUiApiLookupsByObjectApiNameAndFieldApiNameAndTargetApiName(config){const key='RecordCollectionRepresentation('+'dependentFieldBindings:'+config.queryParams.dependentFieldBindings+','+'page:'+config.queryParams.page+','+'pageSize:'+config.queryParams.pageSize+','+'q:'+config.queryParams.q+','+'searchType:'+config.queryParams.searchType+','+'objectApiName:'+config.urlParams.objectApiName+','+'fieldApiName:'+config.urlParams.fieldApiName+','+'targetApiName:'+config.urlParams.targetApiName+')';const headers={};return {path:'/services/data/v48.0/ui-api/lookups/'+config.urlParams.objectApiName+'/'+config.urlParams.fieldApiName+'/'+config.urlParams.targetApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest,headers};}function coerceConfig$6(config){const coercedConfig={};const objectApiName=config.objectApiName;if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const fieldApiName=getFieldApiName$3(config.fieldApiName);if(fieldApiName!==undefined){coercedConfig.fieldApiName=fieldApiName;}const targetApiName=getObjectApiName$1(config.targetApiName);if(targetApiName!==undefined){coercedConfig.targetApiName=targetApiName;}const dependentFieldBindings=config.dependentFieldBindings;if(dependentFieldBindings!==undefined){coercedConfig.dependentFieldBindings=dependentFieldBindings;}const page=config.page;if(page!==undefined){coercedConfig.page=page;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const q=config.q;if(q!==undefined){coercedConfig.q=q;}const searchType=config.searchType;if(searchType!==undefined){coercedConfig.searchType=searchType;}return coercedConfig;}function typeCheckConfig$6(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_fieldApiName=untrustedConfig.fieldApiName;if(typeof untrustedConfig_fieldApiName==='string'){config.fieldApiName=untrustedConfig_fieldApiName;}const untrustedConfig_targetApiName=untrustedConfig.targetApiName;if(typeof untrustedConfig_targetApiName==='string'){config.targetApiName=untrustedConfig_targetApiName;}const untrustedConfig_dependentFieldBindings=untrustedConfig.dependentFieldBindings;if(ArrayIsArray$1$1$1(untrustedConfig_dependentFieldBindings)){const untrustedConfig_dependentFieldBindings_array=[];for(let i=0,arrayLength=untrustedConfig_dependentFieldBindings.length;i<arrayLength;i++){const untrustedConfig_dependentFieldBindings_item=untrustedConfig_dependentFieldBindings[i];if(typeof untrustedConfig_dependentFieldBindings_item==='string'){untrustedConfig_dependentFieldBindings_array.push(untrustedConfig_dependentFieldBindings_item);}}config.dependentFieldBindings=untrustedConfig_dependentFieldBindings_array;}const untrustedConfig_page=untrustedConfig.page;if(typeof untrustedConfig_page==='number'&&Math.floor(untrustedConfig_page)===untrustedConfig_page){config.page=untrustedConfig_page;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_q=untrustedConfig.q;if(typeof untrustedConfig_q==='string'){config.q=untrustedConfig_q;}const untrustedConfig_searchType=untrustedConfig.searchType;if(typeof untrustedConfig_searchType==='string'){config.searchType=untrustedConfig_searchType;}return config;}function validateAdapterConfig$6(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$6(untrustedConfig);const config=typeCheckConfig$6(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}const paramNames={displayName:'getLookupRecords',parameters:{required:['fieldApiName','targetApiName'],optional:['requestParams']}};function coerceRequestParams(untrusted){if(!untrustedIsObject$1$1(untrusted)){return {};}const coercedConfig={};const requestParams=untrusted.requestParams||{};const dependentFieldBindings=requestParams.dependentFieldBindings;if(dependentFieldBindings!==undefined){coercedConfig.dependentFieldBindings=dependentFieldBindings;}const page=requestParams.page;if(page!==undefined){coercedConfig.page=page;}const pageSize=requestParams.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const q=requestParams.q;if(q!==undefined){coercedConfig.q=q;}const searchType=requestParams.searchType;if(searchType!==undefined){coercedConfig.searchType=searchType;}return coercedConfig;}function coerceConfigWithDefaults$2(untrusted){const config=validateAdapterConfig$6(untrusted,paramNames);if(config===null){return config;}const coercedRequestParams=coerceRequestParams(untrusted);const{objectApiName,fieldApiName}=getFieldId(config.fieldApiName);return _objectSpread$5({},config,{objectApiName,fieldApiName},coercedRequestParams);}function removeEtags(recordRep){const{fields}=recordRep;delete recordRep.eTag;delete recordRep.weakEtag;Object.keys(fields).forEach(fieldName=>{const{value:nestedValue}=fields[fieldName];if(isSpanningRecord(nestedValue)){removeEtags(nestedValue);}});}function network$2(lds,config){const{objectApiName,fieldApiName,targetApiName}=config;const request=getUiApiLookupsByObjectApiNameAndFieldApiNameAndTargetApiName({urlParams:{objectApiName,fieldApiName,targetApiName},queryParams:{page:config.page,pageSize:config.pageSize,q:config.q,searchType:config.searchType,dependentFieldBindings:config.dependentFieldBindings}});return lds.dispatchResourceRequest(request).then(response=>{// TODO W-7235112 - remove this hack to never ingest lookup responses that
    // avoids issues caused by them not being real RecordRepresentations
    const{body}=response;const{records}=body;for(let i=0,len=records.length;i<len;i+=1){removeEtags(records[i]);}deepFreeze$2(body);return {state:'Fulfilled',recordId:request.key,variables:{},seenRecords:{},select:{recordId:request.key,node:{kind:'Fragment'},variables:{}},data:body};},err=>{return lds.errorSnapshot(err);});}const factory$5=lds=>{return refreshable$1(function(untrusted){const config=coerceConfigWithDefaults$2(untrusted);if(config===null){return null;}return network$2(lds,config);},untrusted=>{const config=coerceConfigWithDefaults$2(untrusted);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return network$2(lds,config);});};function toSortedStringArray(value){const valueArray=isArray$3(value)?value:[value];if(valueArray.length!==0&&isArrayOfNonEmptyStrings$1(valueArray)){return dedupe(valueArray).sort();}return undefined;}const onOfConfigPropertiesIdentifier=['layoutTypes','fields','optionalFields'];function coerceConfig$7(config){const coercedConfig={};const recordId=getRecordId18(config.recordId);if(recordId!==undefined){coercedConfig.recordId=recordId;}const childRelationships=config.childRelationships;if(childRelationships!==undefined){coercedConfig.childRelationships=childRelationships;}const fields=getFieldApiNamesArray(config.fields);if(fields!==undefined){coercedConfig.fields=fields;}const forms=config.forms;if(forms!==undefined){coercedConfig.forms=forms;}const layoutTypes=toSortedStringArray(config.layoutTypes);if(layoutTypes!==undefined){coercedConfig.layoutTypes=layoutTypes;}const modes=toSortedStringArray(config.modes);if(modes!==undefined){coercedConfig.modes=modes;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const updateMru=config.updateMru;if(updateMru!==undefined){coercedConfig.updateMru=updateMru;}return coercedConfig;}function typeCheckConfig$7(untrustedConfig){const config={};const untrustedConfig_recordId=untrustedConfig.recordId;if(typeof untrustedConfig_recordId==='string'){config.recordId=untrustedConfig_recordId;}const untrustedConfig_childRelationships=untrustedConfig.childRelationships;if(ArrayIsArray$1$1$1(untrustedConfig_childRelationships)){const untrustedConfig_childRelationships_array=[];for(let i=0,arrayLength=untrustedConfig_childRelationships.length;i<arrayLength;i++){const untrustedConfig_childRelationships_item=untrustedConfig_childRelationships[i];if(typeof untrustedConfig_childRelationships_item==='string'){untrustedConfig_childRelationships_array.push(untrustedConfig_childRelationships_item);}}config.childRelationships=untrustedConfig_childRelationships_array;}const untrustedConfig_fields=untrustedConfig.fields;if(ArrayIsArray$1$1$1(untrustedConfig_fields)){const untrustedConfig_fields_array=[];for(let i=0,arrayLength=untrustedConfig_fields.length;i<arrayLength;i++){const untrustedConfig_fields_item=untrustedConfig_fields[i];if(typeof untrustedConfig_fields_item==='string'){untrustedConfig_fields_array.push(untrustedConfig_fields_item);}}config.fields=untrustedConfig_fields_array;}const untrustedConfig_forms=untrustedConfig.forms;if(ArrayIsArray$1$1$1(untrustedConfig_forms)){const untrustedConfig_forms_array=[];for(let i=0,arrayLength=untrustedConfig_forms.length;i<arrayLength;i++){const untrustedConfig_forms_item=untrustedConfig_forms[i];if(typeof untrustedConfig_forms_item==='string'){untrustedConfig_forms_array.push(untrustedConfig_forms_item);}}config.forms=untrustedConfig_forms_array;}const untrustedConfig_layoutTypes=untrustedConfig.layoutTypes;if(ArrayIsArray$1$1$1(untrustedConfig_layoutTypes)){const untrustedConfig_layoutTypes_array=[];for(let i=0,arrayLength=untrustedConfig_layoutTypes.length;i<arrayLength;i++){const untrustedConfig_layoutTypes_item=untrustedConfig_layoutTypes[i];if(typeof untrustedConfig_layoutTypes_item==='string'){untrustedConfig_layoutTypes_array.push(untrustedConfig_layoutTypes_item);}}config.layoutTypes=untrustedConfig_layoutTypes_array;}const untrustedConfig_modes=untrustedConfig.modes;if(ArrayIsArray$1$1$1(untrustedConfig_modes)){const untrustedConfig_modes_array=[];for(let i=0,arrayLength=untrustedConfig_modes.length;i<arrayLength;i++){const untrustedConfig_modes_item=untrustedConfig_modes[i];if(typeof untrustedConfig_modes_item==='string'){untrustedConfig_modes_array.push(untrustedConfig_modes_item);}}config.modes=untrustedConfig_modes_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$1$1(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_updateMru=untrustedConfig.updateMru;if(typeof untrustedConfig_updateMru==='boolean'){config.updateMru=untrustedConfig_updateMru;}return config;}function validateAdapterConfig$7(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames,onOfConfigPropertiesIdentifier);}const coercedConfig=coerceConfig$7(untrustedConfig);const config=typeCheckConfig$7(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}if(config.layoutTypes===undefined&&config.fields===undefined&&config.optionalFields===undefined){return null;}return config;}function validate$l(obj,path='ChildRelationshipRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_childObjectApiName=obj.childObjectApiName;const path_childObjectApiName=path+'.childObjectApiName';if(typeof obj_childObjectApiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_childObjectApiName+'" (at "'+path_childObjectApiName+'")');}const obj_fieldName=obj.fieldName;const path_fieldName=path+'.fieldName';if(typeof obj_fieldName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_fieldName+'" (at "'+path_fieldName+'")');}const obj_junctionIdListNames=obj.junctionIdListNames;const path_junctionIdListNames=path+'.junctionIdListNames';if(!ArrayIsArray$2(obj_junctionIdListNames)){return new TypeError('Expected "array" but received "'+typeof obj_junctionIdListNames+'" (at "'+path_junctionIdListNames+'")');}for(let i=0;i<obj_junctionIdListNames.length;i++){const obj_junctionIdListNames_item=obj_junctionIdListNames[i];const path_junctionIdListNames_item=path_junctionIdListNames+'['+i+']';if(typeof obj_junctionIdListNames_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_junctionIdListNames_item+'" (at "'+path_junctionIdListNames_item+'")');}}const obj_junctionReferenceTo=obj.junctionReferenceTo;const path_junctionReferenceTo=path+'.junctionReferenceTo';if(!ArrayIsArray$2(obj_junctionReferenceTo)){return new TypeError('Expected "array" but received "'+typeof obj_junctionReferenceTo+'" (at "'+path_junctionReferenceTo+'")');}for(let i=0;i<obj_junctionReferenceTo.length;i++){const obj_junctionReferenceTo_item=obj_junctionReferenceTo[i];const path_junctionReferenceTo_item=path_junctionReferenceTo+'['+i+']';if(typeof obj_junctionReferenceTo_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_junctionReferenceTo_item+'" (at "'+path_junctionReferenceTo_item+'")');}}const obj_relationshipName=obj.relationshipName;const path_relationshipName=path+'.relationshipName';if(typeof obj_relationshipName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_relationshipName+'" (at "'+path_relationshipName+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$9(input){const input_junctionIdListNames=input.junctionIdListNames;ObjectFreeze$1(input_junctionIdListNames);const input_junctionReferenceTo=input.junctionReferenceTo;ObjectFreeze$1(input_junctionReferenceTo);ObjectFreeze$1(input);}function validate$m(obj,path='FilteredLookupInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_controllingFields=obj.controllingFields;const path_controllingFields=path+'.controllingFields';if(!ArrayIsArray$2(obj_controllingFields)){return new TypeError('Expected "array" but received "'+typeof obj_controllingFields+'" (at "'+path_controllingFields+'")');}for(let i=0;i<obj_controllingFields.length;i++){const obj_controllingFields_item=obj_controllingFields[i];const path_controllingFields_item=path_controllingFields+'['+i+']';if(typeof obj_controllingFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_controllingFields_item+'" (at "'+path_controllingFields_item+'")');}}const obj_dependent=obj.dependent;const path_dependent=path+'.dependent';if(typeof obj_dependent!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_dependent+'" (at "'+path_dependent+'")');}const obj_optionalFilter=obj.optionalFilter;const path_optionalFilter=path+'.optionalFilter';if(typeof obj_optionalFilter!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_optionalFilter+'" (at "'+path_optionalFilter+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$a(input){const input_controllingFields=input.controllingFields;ObjectFreeze$1(input_controllingFields);ObjectFreeze$1(input);}function validate$n(obj,path='ReferenceToInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_nameFields=obj.nameFields;const path_nameFields=path+'.nameFields';if(!ArrayIsArray$2(obj_nameFields)){return new TypeError('Expected "array" but received "'+typeof obj_nameFields+'" (at "'+path_nameFields+'")');}for(let i=0;i<obj_nameFields.length;i++){const obj_nameFields_item=obj_nameFields[i];const path_nameFields_item=path_nameFields+'['+i+']';if(typeof obj_nameFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nameFields_item+'" (at "'+path_nameFields_item+'")');}}})();return v_error===undefined?null:v_error;}function deepFreeze$b(input){const input_nameFields=input.nameFields;ObjectFreeze$1(input_nameFields);ObjectFreeze$1(input);}function validate$o(obj,path='FieldRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_calculated=obj.calculated;const path_calculated=path+'.calculated';if(typeof obj_calculated!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_calculated+'" (at "'+path_calculated+'")');}const obj_compound=obj.compound;const path_compound=path+'.compound';if(typeof obj_compound!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_compound+'" (at "'+path_compound+'")');}const obj_compoundComponentName=obj.compoundComponentName;const path_compoundComponentName=path+'.compoundComponentName';let obj_compoundComponentName_union0=null;const obj_compoundComponentName_union0_error=(()=>{if(typeof obj_compoundComponentName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_compoundComponentName+'" (at "'+path_compoundComponentName+'")');}})();if(obj_compoundComponentName_union0_error!=null){obj_compoundComponentName_union0=obj_compoundComponentName_union0_error.message;}let obj_compoundComponentName_union1=null;const obj_compoundComponentName_union1_error=(()=>{if(obj_compoundComponentName!==null){return new TypeError('Expected "null" but received "'+typeof obj_compoundComponentName+'" (at "'+path_compoundComponentName+'")');}})();if(obj_compoundComponentName_union1_error!=null){obj_compoundComponentName_union1=obj_compoundComponentName_union1_error.message;}if(obj_compoundComponentName_union0&&obj_compoundComponentName_union1){let message='Object doesn\'t match union (at "'+path_compoundComponentName+'")';message+='\n'+obj_compoundComponentName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_compoundComponentName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_compoundFieldName=obj.compoundFieldName;const path_compoundFieldName=path+'.compoundFieldName';let obj_compoundFieldName_union0=null;const obj_compoundFieldName_union0_error=(()=>{if(typeof obj_compoundFieldName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_compoundFieldName+'" (at "'+path_compoundFieldName+'")');}})();if(obj_compoundFieldName_union0_error!=null){obj_compoundFieldName_union0=obj_compoundFieldName_union0_error.message;}let obj_compoundFieldName_union1=null;const obj_compoundFieldName_union1_error=(()=>{if(obj_compoundFieldName!==null){return new TypeError('Expected "null" but received "'+typeof obj_compoundFieldName+'" (at "'+path_compoundFieldName+'")');}})();if(obj_compoundFieldName_union1_error!=null){obj_compoundFieldName_union1=obj_compoundFieldName_union1_error.message;}if(obj_compoundFieldName_union0&&obj_compoundFieldName_union1){let message='Object doesn\'t match union (at "'+path_compoundFieldName+'")';message+='\n'+obj_compoundFieldName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_compoundFieldName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_controllerName=obj.controllerName;const path_controllerName=path+'.controllerName';let obj_controllerName_union0=null;const obj_controllerName_union0_error=(()=>{if(typeof obj_controllerName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_controllerName+'" (at "'+path_controllerName+'")');}})();if(obj_controllerName_union0_error!=null){obj_controllerName_union0=obj_controllerName_union0_error.message;}let obj_controllerName_union1=null;const obj_controllerName_union1_error=(()=>{if(obj_controllerName!==null){return new TypeError('Expected "null" but received "'+typeof obj_controllerName+'" (at "'+path_controllerName+'")');}})();if(obj_controllerName_union1_error!=null){obj_controllerName_union1=obj_controllerName_union1_error.message;}if(obj_controllerName_union0&&obj_controllerName_union1){let message='Object doesn\'t match union (at "'+path_controllerName+'")';message+='\n'+obj_controllerName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_controllerName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_controllingFields=obj.controllingFields;const path_controllingFields=path+'.controllingFields';if(!ArrayIsArray$2(obj_controllingFields)){return new TypeError('Expected "array" but received "'+typeof obj_controllingFields+'" (at "'+path_controllingFields+'")');}for(let i=0;i<obj_controllingFields.length;i++){const obj_controllingFields_item=obj_controllingFields[i];const path_controllingFields_item=path_controllingFields+'['+i+']';if(typeof obj_controllingFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_controllingFields_item+'" (at "'+path_controllingFields_item+'")');}}const obj_createable=obj.createable;const path_createable=path+'.createable';if(typeof obj_createable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_createable+'" (at "'+path_createable+'")');}const obj_custom=obj.custom;const path_custom=path+'.custom';if(typeof obj_custom!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_custom+'" (at "'+path_custom+'")');}const obj_dataType=obj.dataType;const path_dataType=path+'.dataType';if(typeof obj_dataType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_dataType+'" (at "'+path_dataType+'")');}const obj_extraTypeInfo=obj.extraTypeInfo;const path_extraTypeInfo=path+'.extraTypeInfo';let obj_extraTypeInfo_union0=null;const obj_extraTypeInfo_union0_error=(()=>{if(typeof obj_extraTypeInfo!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_extraTypeInfo+'" (at "'+path_extraTypeInfo+'")');}})();if(obj_extraTypeInfo_union0_error!=null){obj_extraTypeInfo_union0=obj_extraTypeInfo_union0_error.message;}let obj_extraTypeInfo_union1=null;const obj_extraTypeInfo_union1_error=(()=>{if(obj_extraTypeInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_extraTypeInfo+'" (at "'+path_extraTypeInfo+'")');}})();if(obj_extraTypeInfo_union1_error!=null){obj_extraTypeInfo_union1=obj_extraTypeInfo_union1_error.message;}if(obj_extraTypeInfo_union0&&obj_extraTypeInfo_union1){let message='Object doesn\'t match union (at "'+path_extraTypeInfo+'")';message+='\n'+obj_extraTypeInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_extraTypeInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_filterable=obj.filterable;const path_filterable=path+'.filterable';if(typeof obj_filterable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_filterable+'" (at "'+path_filterable+'")');}const obj_filteredLookupInfo=obj.filteredLookupInfo;const path_filteredLookupInfo=path+'.filteredLookupInfo';let obj_filteredLookupInfo_union0=null;const obj_filteredLookupInfo_union0_error=(()=>{const referenceFilteredLookupInfoRepresentationValidationError=validate$m(obj_filteredLookupInfo,path_filteredLookupInfo);if(referenceFilteredLookupInfoRepresentationValidationError!==null){let message='Object doesn\'t match FilteredLookupInfoRepresentation (at "'+path_filteredLookupInfo+'")\n';message+=referenceFilteredLookupInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_filteredLookupInfo_union0_error!=null){obj_filteredLookupInfo_union0=obj_filteredLookupInfo_union0_error.message;}let obj_filteredLookupInfo_union1=null;const obj_filteredLookupInfo_union1_error=(()=>{if(obj_filteredLookupInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_filteredLookupInfo+'" (at "'+path_filteredLookupInfo+'")');}})();if(obj_filteredLookupInfo_union1_error!=null){obj_filteredLookupInfo_union1=obj_filteredLookupInfo_union1_error.message;}if(obj_filteredLookupInfo_union0&&obj_filteredLookupInfo_union1){let message='Object doesn\'t match union (at "'+path_filteredLookupInfo+'")';message+='\n'+obj_filteredLookupInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_filteredLookupInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_highScaleNumber=obj.highScaleNumber;const path_highScaleNumber=path+'.highScaleNumber';if(typeof obj_highScaleNumber!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_highScaleNumber+'" (at "'+path_highScaleNumber+'")');}const obj_htmlFormatted=obj.htmlFormatted;const path_htmlFormatted=path+'.htmlFormatted';if(typeof obj_htmlFormatted!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_htmlFormatted+'" (at "'+path_htmlFormatted+'")');}const obj_inlineHelpText=obj.inlineHelpText;const path_inlineHelpText=path+'.inlineHelpText';let obj_inlineHelpText_union0=null;const obj_inlineHelpText_union0_error=(()=>{if(typeof obj_inlineHelpText!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_inlineHelpText+'" (at "'+path_inlineHelpText+'")');}})();if(obj_inlineHelpText_union0_error!=null){obj_inlineHelpText_union0=obj_inlineHelpText_union0_error.message;}let obj_inlineHelpText_union1=null;const obj_inlineHelpText_union1_error=(()=>{if(obj_inlineHelpText!==null){return new TypeError('Expected "null" but received "'+typeof obj_inlineHelpText+'" (at "'+path_inlineHelpText+'")');}})();if(obj_inlineHelpText_union1_error!=null){obj_inlineHelpText_union1=obj_inlineHelpText_union1_error.message;}if(obj_inlineHelpText_union0&&obj_inlineHelpText_union1){let message='Object doesn\'t match union (at "'+path_inlineHelpText+'")';message+='\n'+obj_inlineHelpText_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_inlineHelpText_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_length=obj.length;const path_length=path+'.length';if(typeof obj_length!=='number'||typeof obj_length==='number'&&Math.floor(obj_length)!==obj_length){return new TypeError('Expected "number" but received "'+typeof obj_length+'" (at "'+path_length+'")');}const obj_nameField=obj.nameField;const path_nameField=path+'.nameField';if(typeof obj_nameField!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_nameField+'" (at "'+path_nameField+'")');}const obj_polymorphicForeignKey=obj.polymorphicForeignKey;const path_polymorphicForeignKey=path+'.polymorphicForeignKey';if(typeof obj_polymorphicForeignKey!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_polymorphicForeignKey+'" (at "'+path_polymorphicForeignKey+'")');}const obj_precision=obj.precision;const path_precision=path+'.precision';if(typeof obj_precision!=='number'||typeof obj_precision==='number'&&Math.floor(obj_precision)!==obj_precision){return new TypeError('Expected "number" but received "'+typeof obj_precision+'" (at "'+path_precision+'")');}const obj_reference=obj.reference;const path_reference=path+'.reference';if(typeof obj_reference!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_reference+'" (at "'+path_reference+'")');}const obj_referenceTargetField=obj.referenceTargetField;const path_referenceTargetField=path+'.referenceTargetField';let obj_referenceTargetField_union0=null;const obj_referenceTargetField_union0_error=(()=>{if(typeof obj_referenceTargetField!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_referenceTargetField+'" (at "'+path_referenceTargetField+'")');}})();if(obj_referenceTargetField_union0_error!=null){obj_referenceTargetField_union0=obj_referenceTargetField_union0_error.message;}let obj_referenceTargetField_union1=null;const obj_referenceTargetField_union1_error=(()=>{if(obj_referenceTargetField!==null){return new TypeError('Expected "null" but received "'+typeof obj_referenceTargetField+'" (at "'+path_referenceTargetField+'")');}})();if(obj_referenceTargetField_union1_error!=null){obj_referenceTargetField_union1=obj_referenceTargetField_union1_error.message;}if(obj_referenceTargetField_union0&&obj_referenceTargetField_union1){let message='Object doesn\'t match union (at "'+path_referenceTargetField+'")';message+='\n'+obj_referenceTargetField_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_referenceTargetField_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_referenceToInfos=obj.referenceToInfos;const path_referenceToInfos=path+'.referenceToInfos';if(!ArrayIsArray$2(obj_referenceToInfos)){return new TypeError('Expected "array" but received "'+typeof obj_referenceToInfos+'" (at "'+path_referenceToInfos+'")');}for(let i=0;i<obj_referenceToInfos.length;i++){const obj_referenceToInfos_item=obj_referenceToInfos[i];const path_referenceToInfos_item=path_referenceToInfos+'['+i+']';const referenceReferenceToInfoRepresentationValidationError=validate$n(obj_referenceToInfos_item,path_referenceToInfos_item);if(referenceReferenceToInfoRepresentationValidationError!==null){let message='Object doesn\'t match ReferenceToInfoRepresentation (at "'+path_referenceToInfos_item+'")\n';message+=referenceReferenceToInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_relationshipName=obj.relationshipName;const path_relationshipName=path+'.relationshipName';let obj_relationshipName_union0=null;const obj_relationshipName_union0_error=(()=>{if(typeof obj_relationshipName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_relationshipName+'" (at "'+path_relationshipName+'")');}})();if(obj_relationshipName_union0_error!=null){obj_relationshipName_union0=obj_relationshipName_union0_error.message;}let obj_relationshipName_union1=null;const obj_relationshipName_union1_error=(()=>{if(obj_relationshipName!==null){return new TypeError('Expected "null" but received "'+typeof obj_relationshipName+'" (at "'+path_relationshipName+'")');}})();if(obj_relationshipName_union1_error!=null){obj_relationshipName_union1=obj_relationshipName_union1_error.message;}if(obj_relationshipName_union0&&obj_relationshipName_union1){let message='Object doesn\'t match union (at "'+path_relationshipName+'")';message+='\n'+obj_relationshipName_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_relationshipName_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_required=obj.required;const path_required=path+'.required';if(typeof obj_required!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_required+'" (at "'+path_required+'")');}const obj_scale=obj.scale;const path_scale=path+'.scale';if(typeof obj_scale!=='number'||typeof obj_scale==='number'&&Math.floor(obj_scale)!==obj_scale){return new TypeError('Expected "number" but received "'+typeof obj_scale+'" (at "'+path_scale+'")');}const obj_searchPrefilterable=obj.searchPrefilterable;const path_searchPrefilterable=path+'.searchPrefilterable';if(typeof obj_searchPrefilterable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_searchPrefilterable+'" (at "'+path_searchPrefilterable+'")');}const obj_sortable=obj.sortable;const path_sortable=path+'.sortable';if(typeof obj_sortable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_sortable+'" (at "'+path_sortable+'")');}const obj_unique=obj.unique;const path_unique=path+'.unique';if(typeof obj_unique!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_unique+'" (at "'+path_unique+'")');}const obj_updateable=obj.updateable;const path_updateable=path+'.updateable';if(typeof obj_updateable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_updateable+'" (at "'+path_updateable+'")');}})();return v_error===undefined?null:v_error;}function deepFreeze$c(input){const input_controllingFields=input.controllingFields;ObjectFreeze$1(input_controllingFields);const input_filteredLookupInfo=input.filteredLookupInfo;if(input_filteredLookupInfo!==null&&typeof input_filteredLookupInfo==='object'){deepFreeze$a(input_filteredLookupInfo);}const input_referenceToInfos=input.referenceToInfos;for(let i=0;i<input_referenceToInfos.length;i++){deepFreeze$b(input_referenceToInfos[i]);}ObjectFreeze$1(input_referenceToInfos);ObjectFreeze$1(input);}function validate$p(obj,path='ThemeInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_color=obj.color;const path_color=path+'.color';if(typeof obj_color!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_color+'" (at "'+path_color+'")');}const obj_iconUrl=obj.iconUrl;const path_iconUrl=path+'.iconUrl';let obj_iconUrl_union0=null;const obj_iconUrl_union0_error=(()=>{if(typeof obj_iconUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union0_error!=null){obj_iconUrl_union0=obj_iconUrl_union0_error.message;}let obj_iconUrl_union1=null;const obj_iconUrl_union1_error=(()=>{if(obj_iconUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union1_error!=null){obj_iconUrl_union1=obj_iconUrl_union1_error.message;}if(obj_iconUrl_union0&&obj_iconUrl_union1){let message='Object doesn\'t match union (at "'+path_iconUrl+'")';message+='\n'+obj_iconUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_iconUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function deepFreeze$d(input){ObjectFreeze$1(input);}const TTL$1=900000;function validate$q(obj,path='ObjectInfoRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_childRelationships=obj.childRelationships;const path_childRelationships=path+'.childRelationships';if(!ArrayIsArray$2(obj_childRelationships)){return new TypeError('Expected "array" but received "'+typeof obj_childRelationships+'" (at "'+path_childRelationships+'")');}for(let i=0;i<obj_childRelationships.length;i++){const obj_childRelationships_item=obj_childRelationships[i];const path_childRelationships_item=path_childRelationships+'['+i+']';const referenceChildRelationshipRepresentationValidationError=validate$l(obj_childRelationships_item,path_childRelationships_item);if(referenceChildRelationshipRepresentationValidationError!==null){let message='Object doesn\'t match ChildRelationshipRepresentation (at "'+path_childRelationships_item+'")\n';message+=referenceChildRelationshipRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_createable=obj.createable;const path_createable=path+'.createable';if(typeof obj_createable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_createable+'" (at "'+path_createable+'")');}const obj_custom=obj.custom;const path_custom=path+'.custom';if(typeof obj_custom!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_custom+'" (at "'+path_custom+'")');}const obj_defaultRecordTypeId=obj.defaultRecordTypeId;const path_defaultRecordTypeId=path+'.defaultRecordTypeId';let obj_defaultRecordTypeId_union0=null;const obj_defaultRecordTypeId_union0_error=(()=>{if(typeof obj_defaultRecordTypeId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_defaultRecordTypeId+'" (at "'+path_defaultRecordTypeId+'")');}})();if(obj_defaultRecordTypeId_union0_error!=null){obj_defaultRecordTypeId_union0=obj_defaultRecordTypeId_union0_error.message;}let obj_defaultRecordTypeId_union1=null;const obj_defaultRecordTypeId_union1_error=(()=>{if(obj_defaultRecordTypeId!==null){return new TypeError('Expected "null" but received "'+typeof obj_defaultRecordTypeId+'" (at "'+path_defaultRecordTypeId+'")');}})();if(obj_defaultRecordTypeId_union1_error!=null){obj_defaultRecordTypeId_union1=obj_defaultRecordTypeId_union1_error.message;}if(obj_defaultRecordTypeId_union0&&obj_defaultRecordTypeId_union1){let message='Object doesn\'t match union (at "'+path_defaultRecordTypeId+'")';message+='\n'+obj_defaultRecordTypeId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_defaultRecordTypeId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_deletable=obj.deletable;const path_deletable=path+'.deletable';if(typeof obj_deletable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_deletable+'" (at "'+path_deletable+'")');}const obj_dependentFields=obj.dependentFields;const path_dependentFields=path+'.dependentFields';if(typeof obj_dependentFields!=='object'||ArrayIsArray$2(obj_dependentFields)||obj_dependentFields===null){return new TypeError('Expected "object" but received "'+typeof obj_dependentFields+'" (at "'+path_dependentFields+'")');}const obj_dependentFields_keys=ObjectKeys$1(obj_dependentFields);for(let i=0;i<obj_dependentFields_keys.length;i++){const key=obj_dependentFields_keys[i];const obj_dependentFields_prop=obj_dependentFields[key];const path_dependentFields_prop=path_dependentFields+'["'+key+'"]';if(typeof obj_dependentFields_prop!=='object'||ArrayIsArray$2(obj_dependentFields_prop)||obj_dependentFields_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_dependentFields_prop+'" (at "'+path_dependentFields_prop+'")');}}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_feedEnabled=obj.feedEnabled;const path_feedEnabled=path+'.feedEnabled';if(typeof obj_feedEnabled!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_feedEnabled+'" (at "'+path_feedEnabled+'")');}const obj_fields=obj.fields;const path_fields=path+'.fields';if(typeof obj_fields!=='object'||ArrayIsArray$2(obj_fields)||obj_fields===null){return new TypeError('Expected "object" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}const obj_fields_keys=ObjectKeys$1(obj_fields);for(let i=0;i<obj_fields_keys.length;i++){const key=obj_fields_keys[i];const obj_fields_prop=obj_fields[key];const path_fields_prop=path_fields+'["'+key+'"]';const referenceFieldRepresentationValidationError=validate$o(obj_fields_prop,path_fields_prop);if(referenceFieldRepresentationValidationError!==null){let message='Object doesn\'t match FieldRepresentation (at "'+path_fields_prop+'")\n';message+=referenceFieldRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_keyPrefix=obj.keyPrefix;const path_keyPrefix=path+'.keyPrefix';let obj_keyPrefix_union0=null;const obj_keyPrefix_union0_error=(()=>{if(typeof obj_keyPrefix!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_keyPrefix+'" (at "'+path_keyPrefix+'")');}})();if(obj_keyPrefix_union0_error!=null){obj_keyPrefix_union0=obj_keyPrefix_union0_error.message;}let obj_keyPrefix_union1=null;const obj_keyPrefix_union1_error=(()=>{if(obj_keyPrefix!==null){return new TypeError('Expected "null" but received "'+typeof obj_keyPrefix+'" (at "'+path_keyPrefix+'")');}})();if(obj_keyPrefix_union1_error!=null){obj_keyPrefix_union1=obj_keyPrefix_union1_error.message;}if(obj_keyPrefix_union0&&obj_keyPrefix_union1){let message='Object doesn\'t match union (at "'+path_keyPrefix+'")';message+='\n'+obj_keyPrefix_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_keyPrefix_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_labelPlural=obj.labelPlural;const path_labelPlural=path+'.labelPlural';if(typeof obj_labelPlural!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_labelPlural+'" (at "'+path_labelPlural+'")');}const obj_layoutable=obj.layoutable;const path_layoutable=path+'.layoutable';if(typeof obj_layoutable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_layoutable+'" (at "'+path_layoutable+'")');}const obj_mruEnabled=obj.mruEnabled;const path_mruEnabled=path+'.mruEnabled';if(typeof obj_mruEnabled!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_mruEnabled+'" (at "'+path_mruEnabled+'")');}const obj_nameFields=obj.nameFields;const path_nameFields=path+'.nameFields';if(!ArrayIsArray$2(obj_nameFields)){return new TypeError('Expected "array" but received "'+typeof obj_nameFields+'" (at "'+path_nameFields+'")');}for(let i=0;i<obj_nameFields.length;i++){const obj_nameFields_item=obj_nameFields[i];const path_nameFields_item=path_nameFields+'['+i+']';if(typeof obj_nameFields_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_nameFields_item+'" (at "'+path_nameFields_item+'")');}}const obj_queryable=obj.queryable;const path_queryable=path+'.queryable';if(typeof obj_queryable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_queryable+'" (at "'+path_queryable+'")');}const obj_recordTypeInfos=obj.recordTypeInfos;const path_recordTypeInfos=path+'.recordTypeInfos';if(typeof obj_recordTypeInfos!=='object'||ArrayIsArray$2(obj_recordTypeInfos)||obj_recordTypeInfos===null){return new TypeError('Expected "object" but received "'+typeof obj_recordTypeInfos+'" (at "'+path_recordTypeInfos+'")');}const obj_recordTypeInfos_keys=ObjectKeys$1(obj_recordTypeInfos);for(let i=0;i<obj_recordTypeInfos_keys.length;i++){const key=obj_recordTypeInfos_keys[i];const obj_recordTypeInfos_prop=obj_recordTypeInfos[key];const path_recordTypeInfos_prop=path_recordTypeInfos+'["'+key+'"]';const referenceRecordTypeInfoRepresentationValidationError=validate(obj_recordTypeInfos_prop,path_recordTypeInfos_prop);if(referenceRecordTypeInfoRepresentationValidationError!==null){let message='Object doesn\'t match RecordTypeInfoRepresentation (at "'+path_recordTypeInfos_prop+'")\n';message+=referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_searchable=obj.searchable;const path_searchable=path+'.searchable';if(typeof obj_searchable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_searchable+'" (at "'+path_searchable+'")');}const obj_themeInfo=obj.themeInfo;const path_themeInfo=path+'.themeInfo';let obj_themeInfo_union0=null;const obj_themeInfo_union0_error=(()=>{const referenceThemeInfoRepresentationValidationError=validate$p(obj_themeInfo,path_themeInfo);if(referenceThemeInfoRepresentationValidationError!==null){let message='Object doesn\'t match ThemeInfoRepresentation (at "'+path_themeInfo+'")\n';message+=referenceThemeInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_themeInfo_union0_error!=null){obj_themeInfo_union0=obj_themeInfo_union0_error.message;}let obj_themeInfo_union1=null;const obj_themeInfo_union1_error=(()=>{if(obj_themeInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_themeInfo+'" (at "'+path_themeInfo+'")');}})();if(obj_themeInfo_union1_error!=null){obj_themeInfo_union1=obj_themeInfo_union1_error.message;}if(obj_themeInfo_union0&&obj_themeInfo_union1){let message='Object doesn\'t match union (at "'+path_themeInfo+'")';message+='\n'+obj_themeInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_themeInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_updateable=obj.updateable;const path_updateable=path+'.updateable';if(typeof obj_updateable!=='boolean'){return new TypeError('Expected "boolean" but received "'+typeof obj_updateable+'" (at "'+path_updateable+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$8(config){return 'UiApi::ObjectInfoRepresentation:'+config.apiName;}function normalize$a(input,existing,path,lds,store,timestamp){return input;}const select$9=function ObjectInfoRepresentationSelect(){return {kind:'Fragment',selections:[{name:'apiName',kind:'Scalar'},{name:'childRelationships',kind:'Object',opaque:true},{name:'createable',kind:'Scalar'},{name:'custom',kind:'Scalar'},{name:'defaultRecordTypeId',kind:'Scalar'},{name:'deletable',kind:'Scalar'},{name:'dependentFields',kind:'Object',opaque:true},{name:'feedEnabled',kind:'Scalar'},{name:'fields',kind:'Object',opaque:true},{name:'keyPrefix',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'labelPlural',kind:'Scalar'},{name:'layoutable',kind:'Scalar'},{name:'mruEnabled',kind:'Scalar'},{name:'nameFields',kind:'Object',opaque:true},{name:'queryable',kind:'Scalar'},{name:'recordTypeInfos',kind:'Object',opaque:true},{name:'searchable',kind:'Scalar'},{name:'themeInfo',kind:'Object',opaque:true},{name:'updateable',kind:'Scalar'}]};};function equals$c(existing,incoming){if(existing.eTag!==incoming.eTag){return false;}return true;}function deepFreeze$e(input){const input_childRelationships=input.childRelationships;for(let i=0;i<input_childRelationships.length;i++){deepFreeze$9(input_childRelationships[i]);}ObjectFreeze$1(input_childRelationships);const input_dependentFields=input.dependentFields;const input_dependentFields_keys=Object.keys(input_dependentFields);const input_dependentFields_length=input_dependentFields_keys.length;for(let i=0;i<input_dependentFields_length;i++){const key=input_dependentFields_keys[i];const input_dependentFields_prop=input_dependentFields[key];ObjectFreeze$1(input_dependentFields[key]);}ObjectFreeze$1(input_dependentFields);const input_fields=input.fields;const input_fields_keys=Object.keys(input_fields);const input_fields_length=input_fields_keys.length;for(let i=0;i<input_fields_length;i++){const key=input_fields_keys[i];const input_fields_prop=input_fields[key];deepFreeze$c(input_fields[key]);}ObjectFreeze$1(input_fields);const input_nameFields=input.nameFields;ObjectFreeze$1(input_nameFields);const input_recordTypeInfos=input.recordTypeInfos;const input_recordTypeInfos_keys=Object.keys(input_recordTypeInfos);const input_recordTypeInfos_length=input_recordTypeInfos_keys.length;for(let i=0;i<input_recordTypeInfos_length;i++){const key=input_recordTypeInfos_keys[i];const input_recordTypeInfos_prop=input_recordTypeInfos[key];deepFreeze$1$1(input_recordTypeInfos[key]);}ObjectFreeze$1(input_recordTypeInfos);const input_themeInfo=input.themeInfo;if(input_themeInfo!==null&&typeof input_themeInfo==='object'){deepFreeze$d(input_themeInfo);}ObjectFreeze$1(input);}const ingest$a=function ObjectInfoRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$q(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$8({apiName:input.apiName});let incomingRecord=normalize$a(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];deepFreeze$e(input);if(existingRecord===undefined||equals$c(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return key;};function getUiApiObjectInfoByObjectApiName(config){const key=keyBuilder$8({apiName:config.urlParams.objectApiName});const headers={};return {path:'/services/data/v48.0/ui-api/object-info/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$a,headers};}const getObjectInfo_ConfigPropertyNames={displayName:'getObjectInfo',parameters:{required:['objectApiName'],optional:[]}};function coerceConfig$8(config){const coercedConfig={};const objectApiName=getObjectApiName$1(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}return coercedConfig;}function typeCheckConfig$8(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}return config;}function validateAdapterConfig$8(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$8(untrustedConfig);const config=typeCheckConfig$8(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$3(lds,config){const request=getUiApiObjectInfoByObjectApiName({urlParams:{objectApiName:config.objectApiName}});const selector={recordId:request.key,node:select$9(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$1(lds,config,override){const request=getUiApiObjectInfoByObjectApiName({urlParams:{objectApiName:config.objectApiName}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$3(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error,TTL$1);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getObjectInfoAdapterFactory=lds=>{return refreshable$1(// Create snapshot either via a cache hit or via the network
    function getObjectInfo(untrustedConfig){const config=validateAdapterConfig$8(untrustedConfig,getObjectInfo_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$3(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED){return cacheSnapshot;}return buildNetworkSnapshot$1(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$8(untrustedConfig,getObjectInfo_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getObjectInfo" refresh function');}return buildNetworkSnapshot$1(lds,config,{headers:{'Cache-Control':'no-cache'}});});};const FIELD_ID='Id';const FIELD_NAME='Name';const COMPONENT_TYPE_FIELD='Field';function isFieldAReferenceWithRelationshipName(objectInfo,fieldApiName){const field=objectInfo.fields[fieldApiName];if(field===undefined){return false;}// TODO - can reference===true and relationshipName===null?
    return field.reference===true&&field.relationshipName!==null;}function getRelationshipName(objectInfo,fieldApiName){// TODO RAML - fix typing so isFieldAReferenceWithRelationshipName enables calling this without `relationshipName!`
    return objectInfo.fields[fieldApiName].relationshipName;}function getNameField(objectInfo,fieldApiName){// TODO - this logic is adopted from lds222. It searches
    // ObjectInfoRep.ReferenceToInfoRep[].nameFields[]:
    // 1. If any of the arrays are empty returns `Name`
    // 2. If `Name` is found in any array position then returns it
    // 2. Else returns ObjectInfoRep.ReferenceToInfoRep[0].nameFields[0]
    // Rationale for this is unclear and needs clarification.
    const referenceToInfos=objectInfo.fields[fieldApiName].referenceToInfos;if(referenceToInfos.length<1){return FIELD_NAME;}const firstReferenceNameFields=referenceToInfos[0].nameFields;if(firstReferenceNameFields.length<1){return FIELD_NAME;}for(let a=0,alen=referenceToInfos.length;a<alen;a++){const nameFields=referenceToInfos[a].nameFields;for(let b=0,blen=nameFields.length;b<blen;b++){const nameField=nameFields[b];if(nameField===FIELD_NAME){return nameField;}}}return firstReferenceNameFields[0];}function getQualifiedFieldApiNamesFromLayout$1(layout,objectInfo){const qualifiedFieldNames=[];for(let a=0,alen=layout.sections.length;a<alen;a++){const section=layout.sections[a];for(let b=0,blen=section.layoutRows.length;b<blen;b++){const row=section.layoutRows[b];for(let c=0,clen=row.layoutItems.length;c<clen;c++){const item=row.layoutItems[c];for(let d=0,dlen=item.layoutComponents.length;d<dlen;d++){const component=item.layoutComponents[d];const{apiName}=component;if(apiName&&component.componentType===COMPONENT_TYPE_FIELD){if(isFieldAReferenceWithRelationshipName(objectInfo,apiName)){const relationshipFieldApiName=getRelationshipName(objectInfo,apiName);// By default, include the "Id" field on spanning records that are on the layout.
    qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${FIELD_ID}`);const nameField=getNameField(objectInfo,apiName);qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${nameField}`);}qualifiedFieldNames.push(`${objectInfo.apiName}.${component.apiName}`);}}}}}return qualifiedFieldNames;}/**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */function getRecordId18Array(value){const valueArray=isArray$3(value)?value:[value];const array=[];for(let i=0,len=valueArray.length;i<len;i+=1){const item=valueArray[i];const apiName=getRecordId18(item);if(apiName===undefined){return undefined;}push$1.call(array,apiName);}if(array.length===0){return undefined;}return dedupe(array).sort();}function validate$r(obj,path='RecordUiRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_layoutUserStates=obj.layoutUserStates;const path_layoutUserStates=path+'.layoutUserStates';if(typeof obj_layoutUserStates!=='object'||ArrayIsArray$2(obj_layoutUserStates)||obj_layoutUserStates===null){return new TypeError('Expected "object" but received "'+typeof obj_layoutUserStates+'" (at "'+path_layoutUserStates+'")');}const obj_layoutUserStates_keys=ObjectKeys$1(obj_layoutUserStates);for(let i=0;i<obj_layoutUserStates_keys.length;i++){const key=obj_layoutUserStates_keys[i];const obj_layoutUserStates_prop=obj_layoutUserStates[key];}const obj_layouts=obj.layouts;const path_layouts=path+'.layouts';if(typeof obj_layouts!=='object'||ArrayIsArray$2(obj_layouts)||obj_layouts===null){return new TypeError('Expected "object" but received "'+typeof obj_layouts+'" (at "'+path_layouts+'")');}const obj_layouts_keys=ObjectKeys$1(obj_layouts);for(let i=0;i<obj_layouts_keys.length;i++){const key=obj_layouts_keys[i];const obj_layouts_prop=obj_layouts[key];const path_layouts_prop=path_layouts+'["'+key+'"]';if(typeof obj_layouts_prop!=='object'||ArrayIsArray$2(obj_layouts_prop)||obj_layouts_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_layouts_prop+'" (at "'+path_layouts_prop+'")');}const obj_layouts_prop_keys=ObjectKeys$1(obj_layouts_prop);for(let i=0;i<obj_layouts_prop_keys.length;i++){const key=obj_layouts_prop_keys[i];const obj_layouts_prop_prop=obj_layouts_prop[key];const path_layouts_prop_prop=path_layouts_prop+'["'+key+'"]';if(typeof obj_layouts_prop_prop!=='object'||ArrayIsArray$2(obj_layouts_prop_prop)||obj_layouts_prop_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_layouts_prop_prop+'" (at "'+path_layouts_prop_prop+'")');}const obj_layouts_prop_prop_keys=ObjectKeys$1(obj_layouts_prop_prop);for(let i=0;i<obj_layouts_prop_prop_keys.length;i++){const key=obj_layouts_prop_prop_keys[i];const obj_layouts_prop_prop_prop=obj_layouts_prop_prop[key];const path_layouts_prop_prop_prop=path_layouts_prop_prop+'["'+key+'"]';if(typeof obj_layouts_prop_prop_prop!=='object'||ArrayIsArray$2(obj_layouts_prop_prop_prop)||obj_layouts_prop_prop_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_layouts_prop_prop_prop+'" (at "'+path_layouts_prop_prop_prop+'")');}const obj_layouts_prop_prop_prop_keys=ObjectKeys$1(obj_layouts_prop_prop_prop);for(let i=0;i<obj_layouts_prop_prop_prop_keys.length;i++){const key=obj_layouts_prop_prop_prop_keys[i];const obj_layouts_prop_prop_prop_prop=obj_layouts_prop_prop_prop[key];}}}}const obj_objectInfos=obj.objectInfos;const path_objectInfos=path+'.objectInfos';if(typeof obj_objectInfos!=='object'||ArrayIsArray$2(obj_objectInfos)||obj_objectInfos===null){return new TypeError('Expected "object" but received "'+typeof obj_objectInfos+'" (at "'+path_objectInfos+'")');}const obj_objectInfos_keys=ObjectKeys$1(obj_objectInfos);for(let i=0;i<obj_objectInfos_keys.length;i++){const key=obj_objectInfos_keys[i];const obj_objectInfos_prop=obj_objectInfos[key];}const obj_records=obj.records;const path_records=path+'.records';if(typeof obj_records!=='object'||ArrayIsArray$2(obj_records)||obj_records===null){return new TypeError('Expected "object" but received "'+typeof obj_records+'" (at "'+path_records+'")');}const obj_records_keys=ObjectKeys$1(obj_records);for(let i=0;i<obj_records_keys.length;i++){const key=obj_records_keys[i];const obj_records_prop=obj_records[key];}})();return v_error===undefined?null:v_error;}function normalize$b(input,existing,path,lds,store,timestamp){const input_layoutUserStates=input.layoutUserStates;const input_layoutUserStates_id=path.fullPath+'__layoutUserStates';const input_layoutUserStates_keys=Object.keys(input_layoutUserStates);const input_layoutUserStates_length=input_layoutUserStates_keys.length;for(let i=0;i<input_layoutUserStates_length;i++){const key=input_layoutUserStates_keys[i];const input_layoutUserStates_prop=input_layoutUserStates[key];const input_layoutUserStates_prop_id=input_layoutUserStates_id+'__'+key;input_layoutUserStates[key]={__ref:ingest$4(input_layoutUserStates_prop,{fullPath:input_layoutUserStates_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}const input_layouts=input.layouts;const input_layouts_id=path.fullPath+'__layouts';const input_layouts_keys=Object.keys(input_layouts);const input_layouts_length=input_layouts_keys.length;for(let i=0;i<input_layouts_length;i++){const key=input_layouts_keys[i];const input_layouts_prop=input_layouts[key];const input_layouts_prop_id=input_layouts_id+'__'+key;const input_layouts_prop_keys=Object.keys(input_layouts_prop);const input_layouts_prop_length=input_layouts_prop_keys.length;for(let i=0;i<input_layouts_prop_length;i++){const key=input_layouts_prop_keys[i];const input_layouts_prop_prop=input_layouts_prop[key];const input_layouts_prop_prop_id=input_layouts_prop_id+'__'+key;const input_layouts_prop_prop_keys=Object.keys(input_layouts_prop_prop);const input_layouts_prop_prop_length=input_layouts_prop_prop_keys.length;for(let i=0;i<input_layouts_prop_prop_length;i++){const key=input_layouts_prop_prop_keys[i];const input_layouts_prop_prop_prop=input_layouts_prop_prop[key];const input_layouts_prop_prop_prop_id=input_layouts_prop_prop_id+'__'+key;const input_layouts_prop_prop_prop_keys=Object.keys(input_layouts_prop_prop_prop);const input_layouts_prop_prop_prop_length=input_layouts_prop_prop_prop_keys.length;for(let i=0;i<input_layouts_prop_prop_prop_length;i++){const key=input_layouts_prop_prop_prop_keys[i];const input_layouts_prop_prop_prop_prop=input_layouts_prop_prop_prop[key];const input_layouts_prop_prop_prop_prop_id=input_layouts_prop_prop_prop_id+'__'+key;input_layouts_prop_prop_prop[key]={__ref:ingest$3(input_layouts_prop_prop_prop_prop,{fullPath:input_layouts_prop_prop_prop_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}}}}const input_objectInfos=input.objectInfos;const input_objectInfos_id=path.fullPath+'__objectInfos';const input_objectInfos_keys=Object.keys(input_objectInfos);const input_objectInfos_length=input_objectInfos_keys.length;for(let i=0;i<input_objectInfos_length;i++){const key=input_objectInfos_keys[i];const input_objectInfos_prop=input_objectInfos[key];const input_objectInfos_prop_id=input_objectInfos_id+'__'+key;input_objectInfos[key]={__ref:ingest$a(input_objectInfos_prop,{fullPath:input_objectInfos_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}const input_records=input.records;const input_records_id=path.fullPath+'__records';const input_records_keys=Object.keys(input_records);const input_records_length=input_records_keys.length;for(let i=0;i<input_records_length;i++){const key=input_records_keys[i];const input_records_prop=input_records[key];const input_records_prop_id=input_records_id+'__'+key;input_records[key]={__ref:ingest$2(input_records_prop,{fullPath:input_records_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}return input;}function equals$d(existing,incoming){const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_layoutUserStates=existing.layoutUserStates;const incoming_layoutUserStates=incoming.layoutUserStates;const equals_layoutUserStates_props=equalsObject(existing_layoutUserStates,incoming_layoutUserStates,(existing_layoutUserStates_prop,incoming_layoutUserStates_prop)=>{if(!(existing_layoutUserStates_prop.__ref===incoming_layoutUserStates_prop.__ref)){return false;}});if(equals_layoutUserStates_props===false){return false;}const existing_layouts=existing.layouts;const incoming_layouts=incoming.layouts;const equals_layouts_props=equalsObject(existing_layouts,incoming_layouts,(existing_layouts_prop,incoming_layouts_prop)=>{const equals_layouts_props=equalsObject(existing_layouts_prop,incoming_layouts_prop,(existing_layouts_prop_prop,incoming_layouts_prop_prop)=>{const equals_layouts_props=equalsObject(existing_layouts_prop_prop,incoming_layouts_prop_prop,(existing_layouts_prop_prop_prop,incoming_layouts_prop_prop_prop)=>{const equals_layouts_props=equalsObject(existing_layouts_prop_prop_prop,incoming_layouts_prop_prop_prop,(existing_layouts_prop_prop_prop_prop,incoming_layouts_prop_prop_prop_prop)=>{if(!(existing_layouts_prop_prop_prop_prop.__ref===incoming_layouts_prop_prop_prop_prop.__ref)){return false;}});if(equals_layouts_props===false){return false;}});if(equals_layouts_props===false){return false;}});if(equals_layouts_props===false){return false;}});if(equals_layouts_props===false){return false;}const existing_objectInfos=existing.objectInfos;const incoming_objectInfos=incoming.objectInfos;const equals_objectInfos_props=equalsObject(existing_objectInfos,incoming_objectInfos,(existing_objectInfos_prop,incoming_objectInfos_prop)=>{if(!(existing_objectInfos_prop.__ref===incoming_objectInfos_prop.__ref)){return false;}});if(equals_objectInfos_props===false){return false;}const existing_records=existing.records;const incoming_records=incoming.records;const equals_records_props=equalsObject(existing_records,incoming_records,(existing_records_prop,incoming_records_prop)=>{if(!(existing_records_prop.__ref===incoming_records_prop.__ref)){return false;}});if(equals_records_props===false){return false;}return true;}const ingest$b=function RecordUiRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$r(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$b(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$d(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return key;};function getUiApiRecordUiByRecordIds(config){const key='RecordUiRepresentation('+'childRelationships:'+config.queryParams.childRelationships+','+'formFactor:'+config.queryParams.formFactor+','+'layoutTypes:'+config.queryParams.layoutTypes+','+'modes:'+config.queryParams.modes+','+'optionalFields:'+config.queryParams.optionalFields+','+'pageSize:'+config.queryParams.pageSize+','+'updateMru:'+config.queryParams.updateMru+','+'recordIds:'+config.urlParams.recordIds+')';const headers={};return {path:'/services/data/v48.0/ui-api/record-ui/'+config.urlParams.recordIds+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$b,headers};}function coerceConfig$9(config){const coercedConfig={};const recordIds=getRecordId18Array(config.recordIds);if(recordIds!==undefined){coercedConfig.recordIds=recordIds;}const childRelationships=config.childRelationships;if(childRelationships!==undefined){coercedConfig.childRelationships=childRelationships;}const formFactor=config.formFactor;if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const layoutTypes=toSortedStringArray(config.layoutTypes);if(layoutTypes!==undefined){coercedConfig.layoutTypes=layoutTypes;}const modes=toSortedStringArray(config.modes);if(modes!==undefined){coercedConfig.modes=modes;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const pageSize=config.pageSize;if(pageSize!==undefined){coercedConfig.pageSize=pageSize;}const updateMru=config.updateMru;if(updateMru!==undefined){coercedConfig.updateMru=updateMru;}return coercedConfig;}function typeCheckConfig$9(untrustedConfig){const config={};const untrustedConfig_recordIds=untrustedConfig.recordIds;if(ArrayIsArray$1$1$1(untrustedConfig_recordIds)){const untrustedConfig_recordIds_array=[];for(let i=0,arrayLength=untrustedConfig_recordIds.length;i<arrayLength;i++){const untrustedConfig_recordIds_item=untrustedConfig_recordIds[i];if(typeof untrustedConfig_recordIds_item==='string'){untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);}}config.recordIds=untrustedConfig_recordIds_array;}const untrustedConfig_childRelationships=untrustedConfig.childRelationships;if(ArrayIsArray$1$1$1(untrustedConfig_childRelationships)){const untrustedConfig_childRelationships_array=[];for(let i=0,arrayLength=untrustedConfig_childRelationships.length;i<arrayLength;i++){const untrustedConfig_childRelationships_item=untrustedConfig_childRelationships[i];if(typeof untrustedConfig_childRelationships_item==='string'){untrustedConfig_childRelationships_array.push(untrustedConfig_childRelationships_item);}}config.childRelationships=untrustedConfig_childRelationships_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_layoutTypes=untrustedConfig.layoutTypes;if(ArrayIsArray$1$1$1(untrustedConfig_layoutTypes)){const untrustedConfig_layoutTypes_array=[];for(let i=0,arrayLength=untrustedConfig_layoutTypes.length;i<arrayLength;i++){const untrustedConfig_layoutTypes_item=untrustedConfig_layoutTypes[i];if(typeof untrustedConfig_layoutTypes_item==='string'){untrustedConfig_layoutTypes_array.push(untrustedConfig_layoutTypes_item);}}config.layoutTypes=untrustedConfig_layoutTypes_array;}const untrustedConfig_modes=untrustedConfig.modes;if(ArrayIsArray$1$1$1(untrustedConfig_modes)){const untrustedConfig_modes_array=[];for(let i=0,arrayLength=untrustedConfig_modes.length;i<arrayLength;i++){const untrustedConfig_modes_item=untrustedConfig_modes[i];if(typeof untrustedConfig_modes_item==='string'){untrustedConfig_modes_array.push(untrustedConfig_modes_item);}}config.modes=untrustedConfig_modes_array;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$1$1(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_pageSize=untrustedConfig.pageSize;if(typeof untrustedConfig_pageSize==='number'&&Math.floor(untrustedConfig_pageSize)===untrustedConfig_pageSize){config.pageSize=untrustedConfig_pageSize;}const untrustedConfig_updateMru=untrustedConfig.updateMru;if(typeof untrustedConfig_updateMru==='boolean'){config.updateMru=untrustedConfig_updateMru;}return config;}function validateAdapterConfig$9(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$9(untrustedConfig);const config=typeCheckConfig$9(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}const layoutSelections$1=select().selections;const objectInfoPathSelection=select$9().selections;const layoutUserStatePathSelector=select$1().selections;function buildRecordUiSelector(recordDefs,layoutTypes,modes,recordOptionalFields){const layoutTypeSelections=[];for(let i=0,len=layoutTypes.length;i<len;i+=1){const layoutType=layoutTypes[i];const modeSelections=[];const sel={kind:'Object',name:layoutType,selections:modeSelections};for(let m=0;m<modes.length;m+=1){const mode=modes[m];const modeSel={kind:'Link',name:mode,selections:layoutSelections$1};push$1.call(modeSelections,modeSel);}push$1.call(layoutTypeSelections,sel);}const recordLayoutSelections=[];const recordSelections=[];for(let i=0,len=recordDefs.length;i<len;i+=1){const{recordId,recordData}=recordDefs[i];const optionalFields=recordOptionalFields[recordId];const fields=extractRecordFields(recordData);push$1.call(recordLayoutSelections,{kind:'Object',name:recordData.apiName,required:false,map:true,selections:layoutTypeSelections});push$1.call(recordSelections,{kind:'Link',name:recordId,selections:buildSelectionFromFields(fields,optionalFields)});}return {kind:'Fragment',selections:[{kind:'Link',name:'layoutUserStates',map:true,selections:layoutUserStatePathSelector},{kind:'Object',name:'layouts',selections:recordLayoutSelections},{kind:'Link',name:'objectInfos',map:true,selections:objectInfoPathSelection},{name:'records',kind:'Object',selections:recordSelections}]};}function getMissingRecordLookupFields(record,objectInfo){const lookupFields={};const{apiName,fields:recordFields}=record;const{fields:objectInfoFields}=objectInfo;const objectInfoFieldNames=keys$3(objectInfoFields);for(let i=0,len=objectInfoFieldNames.length;i<len;i+=1){const fieldName=objectInfoFieldNames[i];const field=objectInfoFields[fieldName];const{relationshipName}=field;if(relationshipName===null){continue;}const recordFieldValue=recordFields[relationshipName];// Only interested in record fields that are present and that are null
    if(recordFieldValue===undefined||recordFieldValue.value!==null){continue;}const{referenceToInfos}=field;for(let r=0,referenceLen=referenceToInfos.length;r<referenceLen;r+=1){const referenceToInfo=referenceToInfos[r];// Include the Id field. Ex: Opportunity.Account.Id, Opportunity.relation1__r.Id
    const idFieldName=`${apiName}.${relationshipName}.Id`;lookupFields[idFieldName]=true;const{nameFields}=referenceToInfo;// Include all name fields so UIAPI populates the displayValue. Ex: Account.Owner.FirstName, Account.Owner.LastName. Or Account.custom__r.Name.
    for(let n=0,nameFieldsLen=nameFields.length;n<nameFieldsLen;n+=1){const nameField=nameFields[n];const nameFieldName=`${apiName}.${relationshipName}.${nameField}`;lookupFields[nameFieldName]=true;}}}return keys$3(lookupFields);}function getRecordUiMissingRecordLookupFields(recordUi){const{records,objectInfos}=recordUi;const recordLookupFields={};const recordIds=keys$3(records);for(let i=0,len=recordIds.length;i<len;i+=1){const recordId=recordIds[i];const recordData=records[recordId];const{apiName}=recordData;const objectInfo=objectInfos[apiName];recordLookupFields[recordId]=getMissingRecordLookupFields(recordData,objectInfo);}return recordLookupFields;}// Custom adapter config due to `unsupported` items
    const GET_RECORDUI_ADAPTER_CONFIG={displayName:'getRecordUi',parameters:{required:['recordIds','layoutTypes','modes'],optional:['optionalFields'],unsupported:['formFactor','childRelationships','pageSize','updateMru']}};function eachLayout(recordUi,cb){const{layouts}=recordUi;const layoutApiNames=keys$3(layouts);for(let a=0,len=layoutApiNames.length;a<len;a+=1){const apiName=layoutApiNames[a];const apiNameData=layouts[apiName];const recordTypeIds=keys$3(apiNameData);for(let b=0,recordTypeIdsLen=recordTypeIds.length;b<recordTypeIdsLen;b+=1){const recordTypeId=recordTypeIds[b];const recordTypeData=apiNameData[recordTypeId];const layoutTypes=keys$3(recordTypeData);for(let c=0,layoutTypesLen=layoutTypes.length;c<layoutTypesLen;c+=1){const layoutType=layoutTypes[c];const layoutTypeData=recordTypeData[layoutType];const modes=keys$3(layoutTypeData);for(let d=0,modesLen=modes.length;d<modesLen;d+=1){const mode=modes[d];const layout=layoutTypeData[mode];cb(apiName,recordTypeId,layout);}}}}}function collectRecordDefs(resp,recordIds){const recordDefs=[];for(let i=0,len=recordIds.length;i<len;i+=1){const recordId=recordIds[i];const recordData=resp.records[recordId];push$1.call(recordDefs,{recordId,recordData,recordTypeId:getRecordTypeId(recordData)});}return recordDefs;}function keyBuilder$9(recordIds,layoutTypes,modes,optionalFields){const joinedRecordIds=recordIds.sort().join(',');const joinedOptionalFields=optionalFields.sort().join(',');const joinedLayoutTypes=layoutTypes.sort().join(',');const joinedModes=modes.sort().join(',');return `UiApi::RecordUiRepresentation:${joinedRecordIds}:${joinedLayoutTypes}:${joinedModes}:${joinedOptionalFields}`;}function cache$3(lds,config){const{recordIds,layoutTypes,modes,optionalFields}=config;// TODO: a better hash function for config -> configKey
    const configKey=stringify$3(config);// check to see if we see the selector (config) before
    const selectorNode=getSelectorNode(lds,configKey);// if we do, return the same snapshot instance by calling storeLookupMemoize
    if(selectorNode!==null){const cacheData=lds.storeLookupMemoize(selectorNode);// CACHE HIT
    if(isFulfilledSnapshot$1(cacheData)){return cacheData;}}const key=keyBuilder$9(recordIds,layoutTypes,modes,optionalFields);const cachedSelectorKey=`${key}__selector`;const cacheSel=lds.storeLookup({recordId:cachedSelectorKey,node:{kind:'Fragment',opaque:true},variables:{}});if(isFulfilledSnapshot$1(cacheSel)){const cachedSelector=cacheSel.data;// publish the selector instance for later getNode check
    lds.storePublish(configKey,cachedSelector);const cacheData=lds.storeLookupMemoize(cachedSelector);// CACHE HIT
    if(isFulfilledSnapshot$1(cacheData)){return cacheData;}}return null;}function markRecordUiOptionalFields(lds,optionalFields,recordNodes){if(optionalFields.length===0){return;}for(let i=0,len=recordNodes.length;i<len;i++){markMissingOptionalFields(recordNodes[i],optionalFields);}}function getSelectorNode(lds,key){const selectorNode=lds.getNode(key);if(selectorNode!==null){return selectorNode.retrieve();}return null;}function network$3(lds,config){const{recordIds,layoutTypes,modes,optionalFields}=config;// TODO: a better hash function for config -> configKey
    const configKey=stringify$3(config);let allOptionalFields=[];for(let i=0,len=recordIds.length;i<len;i++){const recordId=recordIds[i];allOptionalFields=allOptionalFields.concat(getTrackedFields(lds,recordId,optionalFields));}const key=keyBuilder$9(recordIds,layoutTypes,modes,optionalFields);const resourceRequest=getUiApiRecordUiByRecordIds({urlParams:{recordIds},queryParams:{layoutTypes,modes,optionalFields:dedupe(allOptionalFields).sort()}});return lds.dispatchResourceRequest(resourceRequest).then(response=>{const{body}=response;// TODO fix API so we don't have to augment the response with request details in order
    // to support refresh. these are never emitted out per (private).
    eachLayout(body,(apiName,recordTypeId,layout)=>{layout.apiName=apiName;layout.recordTypeId=recordTypeId;if(layout.id===null){return;}const layoutUserState=body.layoutUserStates[layout.id];// Temporary hack since we can't match keys from getLayoutUserState response
    // to record ui's layout users states.
    if(layoutUserState===undefined){return;}layoutUserState.apiName=apiName;layoutUserState.recordTypeId=recordTypeId;layoutUserState.mode=layout.mode;layoutUserState.layoutType=layout.layoutType;});const recordLookupFields=getRecordUiMissingRecordLookupFields(body);const cachedSelectorKey=`${key}__selector`;const selPath=buildRecordUiSelector(collectRecordDefs(body,recordIds),layoutTypes,modes,recordLookupFields);const sel={recordId:key,node:selPath,variables:{}};lds.storePublish(cachedSelectorKey,sel);lds.storeIngest(key,resourceRequest,body);// During ingestion, only valid records are stored.
    const recordNodes=[];const validRecordIds=[];for(let i=0,len=recordIds.length;i<len;i+=1){const recordId=recordIds[i];const recordKey=keyBuilder({recordId});const node=lds.getNode(recordKey);if(isGraphNode(node)){recordNodes.push(node);validRecordIds.push(recordId);}}const{optionalFields}=config;if(optionalFields.length>0){markRecordUiOptionalFields(lds,optionalFields,recordNodes);}lds.storeBroadcast();const selectorNode=getSelectorNode(lds,configKey);if(selectorNode!==null){const snapshot=lds.storeLookupMemoize(selectorNode);if(isFulfilledSnapshot$1(snapshot)){publishDependencies(lds,validRecordIds,[key,cachedSelectorKey]);return snapshot;}}lds.storePublish(configKey,sel);publishDependencies(lds,validRecordIds,[key,cachedSelectorKey,configKey]);return lds.storeLookupMemoize(sel);},err=>{lds.storeIngestFetchResponse(key,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}function publishDependencies(lds,recordIds,depKeys){for(let i=0,len=recordIds.length;i<len;i+=1){const recordDepKey=depenpendencyKeyBuilder({recordId:recordIds[i]});const dependencies=create$1$1(null);for(let j=0,len=depKeys.length;j<len;j++){dependencies[depKeys[j]]=true;}const node=lds.getNode(recordDepKey);if(isGraphNode(node)){const recordDeps=node.retrieve();assign$1(dependencies,recordDeps);}lds.storePublish(recordDepKey,dependencies);}}function coerceConfigWithDefaults$3(untrustedConfig){const config=validateAdapterConfig$9(untrustedConfig,GET_RECORDUI_ADAPTER_CONFIG);if(config===null){return null;}const{layoutTypes,modes}=config;// custom config validation
    if(layoutTypes===undefined||modes===undefined){return null;}return _objectSpread$5({},config,{layoutTypes:layoutTypes,modes:modes,optionalFields:config.optionalFields===undefined?[]:config.optionalFields});}const factory$6=lds=>{return refreshable$1(function getRecordUi(untrustedConfig){// standard config validation and coercion
    const config=coerceConfigWithDefaults$3(untrustedConfig);if(config===null){return null;}const cacheSnapshot=cache$3(lds,config);if(cacheSnapshot!==null&&isFulfilledSnapshot$1(cacheSnapshot)){return cacheSnapshot;}return network$3(lds,config);},untrustedConfig=>{const config=coerceConfigWithDefaults$3(untrustedConfig);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return network$3(lds,config);});};const DEFAULT_MODE$1=LayoutMode$1.View;const layoutSelections$2=select();function refresh(lds,config){const{recordId,layoutTypes,modes:configModes,optionalFields:configOptionalFields}=config;const modes=configModes===undefined?[DEFAULT_MODE$1]:configModes;const optionalFields=configOptionalFields===undefined?[]:configOptionalFields;const recordUiConfig={recordIds:[recordId],layoutTypes,modes,optionalFields};return network$3(lds,recordUiConfig).then(snapshot=>{if(isErrorSnapshot$1(snapshot)){return lds.errorSnapshot(snapshot.error);}if(isUnfulfilledSnapshot$1(snapshot)){throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys$3(snapshot.missingPaths)}`);}const{layoutMap,objectInfo}=getLayoutMapAndObjectInfo(recordId,snapshot.data);const fields=getFieldsFromLayoutMap(layoutMap,objectInfo);return cache$1(lds,{recordId,fields,modes});});}// Makes a request directly to /record-ui/{recordIds}
    function fetchRecordLayout(lds,recordId,layoutTypes,modes,optionalFields){const recordUiConfig={recordIds:[recordId],layoutTypes,modes,optionalFields};const recordUiAdapter=factory$6(lds);const recordUiSnapshotOrPromise=recordUiAdapter(recordUiConfig);if(isPromise$1$1(recordUiSnapshotOrPromise)){return recordUiSnapshotOrPromise.then(snapshot=>{return processRecordUiRepresentation(lds,recordId,modes,snapshot);});}{if(recordUiSnapshotOrPromise===null){throw new Error('RecordUi adapter synchronously resolved with a null snapshot');}}return processRecordUiRepresentation(lds,recordId,modes,recordUiSnapshotOrPromise);}function getLayoutMapAndObjectInfo(recordId,data){const{objectInfos,layouts,records}=data;const record=records[recordId];const{apiName}=record;const objectInfo=objectInfos[apiName];const recordTypeId=getRecordTypeId(record);const layoutMap=layouts[apiName][recordTypeId];return {layoutMap,objectInfo};}function processRecordUiRepresentation(lds,recordId,modes,snapshot){if(isErrorSnapshot$1(snapshot)){return lds.errorSnapshot(snapshot.error);}if(isUnfulfilledSnapshot$1(snapshot)){throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys$3(snapshot.missingPaths)}`);}const{layoutMap,objectInfo}=getLayoutMapAndObjectInfo(recordId,snapshot.data);return getRecord$1(lds,recordId,layoutMap,objectInfo);}function isPromise$1$1(value){// check for Thenable due to test frameworks using custom Promise impls
    return value!==null&&value.then!==undefined;}function lookupObjectInfo(lds,apiName){const snapshot=buildInMemorySnapshot$3(lds,{objectApiName:apiName});return isFulfilledSnapshot$1(snapshot)?snapshot.data:null;}function lookupLayouts(lds,apiName,recordTypeId,layoutTypes,modes){const map={};for(let i=0;i<layoutTypes.length;i+=1){const layoutType=layoutTypes[i];let layoutMap=map[layoutType];if(layoutMap===undefined){layoutMap=map[layoutType]={};}for(let m=0;m<modes.length;m+=1){const mode=modes[m];const key=keyBuilder$1({apiName,recordTypeId,layoutType,mode});const snapshot=lds.storeLookup({recordId:key,node:layoutSelections$2,variables:{}});// Cache hit
    if(isFulfilledSnapshot$1(snapshot)){layoutMap[mode]=snapshot.data;}else {return null;}}}return map;}const recordLayoutFragmentSelector=[{name:'apiName',kind:'Scalar'},{name:'recordTypeId',kind:'Scalar'}];function getFieldsFromLayoutMap(layoutMap,objectInfo){let fields=[];const layoutTypes=Object.keys(layoutMap);for(let i=0,layoutTypesLen=layoutTypes.length;i<layoutTypesLen;i+=1){const layoutType=layoutTypes[i];const modesMap=layoutMap[layoutType];const modes=Object.keys(modesMap);for(let m=0,modesLen=modes.length;m<modesLen;m+=1){const mode=modes[m];const modeKeys=getQualifiedFieldApiNamesFromLayout$1(modesMap[mode],objectInfo);fields=fields.concat(modeKeys);}}return dedupe(fields).sort();}function getRecord$1(lds,recordId,layoutMap,objectInfo){const fields=getFieldsFromLayoutMap(layoutMap,objectInfo);// We know what fields we need so delegate to getRecordByFields
    // This should be a cache hit because we just fetched the record-ui
    return getRecordByFields(lds,{recordId,fields});}function getRecordLayoutType(lds,config){const{recordId,layoutTypes,modes:configModes,optionalFields}=config;const modes=configModes===undefined?[DEFAULT_MODE$1]:configModes;const storeKey=keyBuilder({recordId});const recordSnapshot=lds.storeLookup({recordId:storeKey,node:{kind:'Fragment',selections:recordLayoutFragmentSelector},variables:{}});// If we haven't seen the record then go to the server
    if(!isFulfilledSnapshot$1(recordSnapshot)){return fetchRecordLayout(lds,recordId,layoutTypes,modes,optionalFields);}const record=recordSnapshot.data;const{apiName}=record;const objectInfo=lookupObjectInfo(lds,apiName);// If we do not have object info in cache, call record-ui endpoint directly
    if(objectInfo===null){return fetchRecordLayout(lds,recordId,layoutTypes,modes,optionalFields);}const recordTypeId=getRecordTypeId(record);const layoutMap=lookupLayouts(lds,apiName,recordTypeId,layoutTypes,modes);// It takes one xhr per layout to load so if there are missing layouts
    // give up and call record-ui endpoint directly
    if(layoutMap===null){return fetchRecordLayout(lds,recordId,layoutTypes,modes,optionalFields);}return getRecord$1(lds,recordId,layoutMap,objectInfo);}// Custom adapter config due to `unsupported` items
    const GET_RECORD_ADAPTER_CONFIG={displayName:'getRecord',parameters:{required:['recordId'],optional:['fields','layoutTypes','modes','optionalFields'],unsupported:['childRelationships','pageSize','updateMru']}};function hasLayoutTypes(config){return 'layoutTypes'in config;}function hasFieldsOrOptionalFields(config){return 'fields'in config||'optionalFields'in config;}const factory$7=lds=>{return refreshable$1(function getRecord(untrustedConfig){// standard config validation and coercion
    const config=validateAdapterConfig$7(untrustedConfig,GET_RECORD_ADAPTER_CONFIG);if(config===null){return null;}if(hasLayoutTypes(config)){return getRecordLayoutType(lds,config);}else if(hasFieldsOrOptionalFields(config)){return getRecordByFields(lds,config);}return null;},untrustedConfig=>{const config=validateAdapterConfig$7(untrustedConfig,GET_RECORD_ADAPTER_CONFIG);if(config===null){throw new Error('Refresh should not be called with partial configuration');}if(hasLayoutTypes(config)){return refresh(lds,config);}else if(hasFieldsOrOptionalFields(config)){return network$1(lds,config);}throw new Error('Refresh should be called with either record fields configuration or record by layout configuration');});};function validate$s(obj,path='ErrorSingleRecordAvatarRepresentation'){const validateAbstractRecordAvatarRepresentation_validateError=validate$u(obj,path);if(validateAbstractRecordAvatarRepresentation_validateError!==null){return validateAbstractRecordAvatarRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_errorCode=obj.errorCode;const path_errorCode=path+'.errorCode';if(typeof obj_errorCode!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_errorCode+'" (at "'+path_errorCode+'")');}const obj_message=obj.message;const path_message=path+'.message';if(typeof obj_message!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_message+'" (at "'+path_message+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$a(config){return keyBuilder$c(config);}function normalize$c(input,existing,path,lds,store,timestamp){return input;}function equals$e(existing,incoming){if(equals$g(existing,incoming)===false){return false;}const existing_errorCode=existing.errorCode;const incoming_errorCode=incoming.errorCode;if(!(existing_errorCode===incoming_errorCode)){return false;}const existing_message=existing.message;const incoming_message=incoming.message;if(!(existing_message===incoming_message)){return false;}return true;}const ingest$c=function ErrorSingleRecordAvatarRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$s(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$a({recordId:input.recordId});let incomingRecord=normalize$c(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$e(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function validate$t(obj,path='ThemeRecordAvatarRepresentation'){const validateAbstractRecordAvatarRepresentation_validateError=validate$u(obj,path);if(validateAbstractRecordAvatarRepresentation_validateError!==null){return validateAbstractRecordAvatarRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_backgroundColor=obj.backgroundColor;const path_backgroundColor=path+'.backgroundColor';let obj_backgroundColor_union0=null;const obj_backgroundColor_union0_error=(()=>{if(typeof obj_backgroundColor!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_backgroundColor+'" (at "'+path_backgroundColor+'")');}})();if(obj_backgroundColor_union0_error!=null){obj_backgroundColor_union0=obj_backgroundColor_union0_error.message;}let obj_backgroundColor_union1=null;const obj_backgroundColor_union1_error=(()=>{if(obj_backgroundColor!==null){return new TypeError('Expected "null" but received "'+typeof obj_backgroundColor+'" (at "'+path_backgroundColor+'")');}})();if(obj_backgroundColor_union1_error!=null){obj_backgroundColor_union1=obj_backgroundColor_union1_error.message;}if(obj_backgroundColor_union0&&obj_backgroundColor_union1){let message='Object doesn\'t match union (at "'+path_backgroundColor+'")';message+='\n'+obj_backgroundColor_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_backgroundColor_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_iconUrl=obj.iconUrl;const path_iconUrl=path+'.iconUrl';let obj_iconUrl_union0=null;const obj_iconUrl_union0_error=(()=>{if(typeof obj_iconUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union0_error!=null){obj_iconUrl_union0=obj_iconUrl_union0_error.message;}let obj_iconUrl_union1=null;const obj_iconUrl_union1_error=(()=>{if(obj_iconUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union1_error!=null){obj_iconUrl_union1=obj_iconUrl_union1_error.message;}if(obj_iconUrl_union0&&obj_iconUrl_union1){let message='Object doesn\'t match union (at "'+path_iconUrl+'")';message+='\n'+obj_iconUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_iconUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function keyBuilder$b(config){return keyBuilder$c(config);}function normalize$d(input,existing,path,lds,store,timestamp){return input;}const select$a=function ThemeRecordAvatarRepresentationSelect(){const{selections:AbstractRecordAvatarRepresentationSelections}=select$b();return {kind:'Fragment',selections:[...AbstractRecordAvatarRepresentationSelections,{name:'backgroundColor',kind:'Scalar'},{name:'iconUrl',kind:'Scalar'}]};};function equals$f(existing,incoming){if(equals$g(existing,incoming)===false){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_backgroundColor=existing.backgroundColor;const incoming_backgroundColor=incoming.backgroundColor;if(!(existing_backgroundColor===incoming_backgroundColor)){return false;}const existing_iconUrl=existing.iconUrl;const incoming_iconUrl=incoming.iconUrl;if(!(existing_iconUrl===incoming_iconUrl)){return false;}return true;}const ingest$d=function ThemeRecordAvatarRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$t(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$b({recordId:input.recordId});let incomingRecord=normalize$d(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$f(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function validate$u(obj,path='AbstractRecordAvatarRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_recordId=obj.recordId;const path_recordId=path+'.recordId';if(typeof obj_recordId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_recordId+'" (at "'+path_recordId+'")');}const obj_type=obj.type;const path_type=path+'.type';if(typeof obj_type!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_type+'" (at "'+path_type+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$c(config){return 'UiApi::AbstractRecordAvatarRepresentation:'+config.recordId;}function normalize$e(input,existing,path,lds,store,timestamp){return input;}const select$b=function AbstractRecordAvatarRepresentationSelect(){return {kind:'Fragment',selections:[{name:'recordId',kind:'Scalar'},{name:'type',kind:'Scalar'}]};};function equals$g(existing,incoming){const existing_recordId=existing.recordId;const incoming_recordId=incoming.recordId;if(!(existing_recordId===incoming_recordId)){return false;}const existing_type=existing.type;const incoming_type=incoming.type;if(!(existing_type===incoming_type)){return false;}return true;}const ingest$e=function AbstractRecordAvatarRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$u(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$c({recordId:input.recordId});let incomingRecord=normalize$e(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$g(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function validate$v(obj,path='PhotoMetadataRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_companyBluemasterId=obj.companyBluemasterId;const path_companyBluemasterId=path+'.companyBluemasterId';let obj_companyBluemasterId_union0=null;const obj_companyBluemasterId_union0_error=(()=>{if(typeof obj_companyBluemasterId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_companyBluemasterId+'" (at "'+path_companyBluemasterId+'")');}})();if(obj_companyBluemasterId_union0_error!=null){obj_companyBluemasterId_union0=obj_companyBluemasterId_union0_error.message;}let obj_companyBluemasterId_union1=null;const obj_companyBluemasterId_union1_error=(()=>{if(obj_companyBluemasterId!==null){return new TypeError('Expected "null" but received "'+typeof obj_companyBluemasterId+'" (at "'+path_companyBluemasterId+'")');}})();if(obj_companyBluemasterId_union1_error!=null){obj_companyBluemasterId_union1=obj_companyBluemasterId_union1_error.message;}if(obj_companyBluemasterId_union0&&obj_companyBluemasterId_union1){let message='Object doesn\'t match union (at "'+path_companyBluemasterId+'")';message+='\n'+obj_companyBluemasterId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_companyBluemasterId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_responseId=obj.responseId;const path_responseId=path+'.responseId';let obj_responseId_union0=null;const obj_responseId_union0_error=(()=>{if(typeof obj_responseId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_responseId+'" (at "'+path_responseId+'")');}})();if(obj_responseId_union0_error!=null){obj_responseId_union0=obj_responseId_union0_error.message;}let obj_responseId_union1=null;const obj_responseId_union1_error=(()=>{if(obj_responseId!==null){return new TypeError('Expected "null" but received "'+typeof obj_responseId+'" (at "'+path_responseId+'")');}})();if(obj_responseId_union1_error!=null){obj_responseId_union1=obj_responseId_union1_error.message;}if(obj_responseId_union0&&obj_responseId_union1){let message='Object doesn\'t match union (at "'+path_responseId+'")';message+='\n'+obj_responseId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_responseId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}const select$c=function PhotoMetadataRepresentationSelect(){return {kind:'Fragment',selections:[{name:'companyBluemasterId',kind:'Scalar'},{name:'responseId',kind:'Scalar'}]};};function equals$h(existing,incoming){const existing_companyBluemasterId=existing.companyBluemasterId;const incoming_companyBluemasterId=incoming.companyBluemasterId;if(!(existing_companyBluemasterId===incoming_companyBluemasterId)){return false;}const existing_responseId=existing.responseId;const incoming_responseId=incoming.responseId;if(!(existing_responseId===incoming_responseId)){return false;}return true;}function validate$w(obj,path='PhotoRecordAvatarRepresentation'){const validateAbstractRecordAvatarRepresentation_validateError=validate$u(obj,path);if(validateAbstractRecordAvatarRepresentation_validateError!==null){return validateAbstractRecordAvatarRepresentation_validateError;}const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_backgroundColor=obj.backgroundColor;const path_backgroundColor=path+'.backgroundColor';let obj_backgroundColor_union0=null;const obj_backgroundColor_union0_error=(()=>{if(typeof obj_backgroundColor!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_backgroundColor+'" (at "'+path_backgroundColor+'")');}})();if(obj_backgroundColor_union0_error!=null){obj_backgroundColor_union0=obj_backgroundColor_union0_error.message;}let obj_backgroundColor_union1=null;const obj_backgroundColor_union1_error=(()=>{if(obj_backgroundColor!==null){return new TypeError('Expected "null" but received "'+typeof obj_backgroundColor+'" (at "'+path_backgroundColor+'")');}})();if(obj_backgroundColor_union1_error!=null){obj_backgroundColor_union1=obj_backgroundColor_union1_error.message;}if(obj_backgroundColor_union0&&obj_backgroundColor_union1){let message='Object doesn\'t match union (at "'+path_backgroundColor+'")';message+='\n'+obj_backgroundColor_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_backgroundColor_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_height=obj.height;const path_height=path+'.height';let obj_height_union0=null;const obj_height_union0_error=(()=>{if(typeof obj_height!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_height+'" (at "'+path_height+'")');}})();if(obj_height_union0_error!=null){obj_height_union0=obj_height_union0_error.message;}let obj_height_union1=null;const obj_height_union1_error=(()=>{if(obj_height!==null){return new TypeError('Expected "null" but received "'+typeof obj_height+'" (at "'+path_height+'")');}})();if(obj_height_union1_error!=null){obj_height_union1=obj_height_union1_error.message;}if(obj_height_union0&&obj_height_union1){let message='Object doesn\'t match union (at "'+path_height+'")';message+='\n'+obj_height_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_height_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_photoMetadata=obj.photoMetadata;const path_photoMetadata=path+'.photoMetadata';const referencePhotoMetadataRepresentationValidationError=validate$v(obj_photoMetadata,path_photoMetadata);if(referencePhotoMetadataRepresentationValidationError!==null){let message='Object doesn\'t match PhotoMetadataRepresentation (at "'+path_photoMetadata+'")\n';message+=referencePhotoMetadataRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_photoUrl=obj.photoUrl;const path_photoUrl=path+'.photoUrl';if(typeof obj_photoUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_photoUrl+'" (at "'+path_photoUrl+'")');}const obj_provider=obj.provider;const path_provider=path+'.provider';let obj_provider_union0=null;const obj_provider_union0_error=(()=>{if(typeof obj_provider!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_provider+'" (at "'+path_provider+'")');}})();if(obj_provider_union0_error!=null){obj_provider_union0=obj_provider_union0_error.message;}let obj_provider_union1=null;const obj_provider_union1_error=(()=>{if(obj_provider!==null){return new TypeError('Expected "null" but received "'+typeof obj_provider+'" (at "'+path_provider+'")');}})();if(obj_provider_union1_error!=null){obj_provider_union1=obj_provider_union1_error.message;}if(obj_provider_union0&&obj_provider_union1){let message='Object doesn\'t match union (at "'+path_provider+'")';message+='\n'+obj_provider_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_provider_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_width=obj.width;const path_width=path+'.width';let obj_width_union0=null;const obj_width_union0_error=(()=>{if(typeof obj_width!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_width+'" (at "'+path_width+'")');}})();if(obj_width_union0_error!=null){obj_width_union0=obj_width_union0_error.message;}let obj_width_union1=null;const obj_width_union1_error=(()=>{if(obj_width!==null){return new TypeError('Expected "null" but received "'+typeof obj_width+'" (at "'+path_width+'")');}})();if(obj_width_union1_error!=null){obj_width_union1=obj_width_union1_error.message;}if(obj_width_union0&&obj_width_union1){let message='Object doesn\'t match union (at "'+path_width+'")';message+='\n'+obj_width_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_width_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();return v_error===undefined?null:v_error;}function keyBuilder$d(config){return keyBuilder$c(config);}function normalize$f(input,existing,path,lds,store,timestamp){return input;}const select$d=function PhotoRecordAvatarRepresentationSelect(){const{selections:AbstractRecordAvatarRepresentationSelections}=select$b();const{selections:PhotoMetadataRepresentation__selections,opaque:PhotoMetadataRepresentation__opaque}=select$c();return {kind:'Fragment',selections:[...AbstractRecordAvatarRepresentationSelections,{name:'backgroundColor',kind:'Scalar'},{name:'height',kind:'Scalar'},{name:'photoMetadata',kind:'Object',selections:PhotoMetadataRepresentation__selections},{name:'photoUrl',kind:'Scalar'},{name:'provider',kind:'Scalar'},{name:'width',kind:'Scalar'}]};};function equals$i(existing,incoming){if(equals$g(existing,incoming)===false){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_photoUrl=existing.photoUrl;const incoming_photoUrl=incoming.photoUrl;if(!(existing_photoUrl===incoming_photoUrl)){return false;}const existing_backgroundColor=existing.backgroundColor;const incoming_backgroundColor=incoming.backgroundColor;if(!(existing_backgroundColor===incoming_backgroundColor)){return false;}const existing_height=existing.height;const incoming_height=incoming.height;if(!(existing_height===incoming_height)){return false;}const existing_photoMetadata=existing.photoMetadata;const incoming_photoMetadata=incoming.photoMetadata;if(!equals$h(existing_photoMetadata,incoming_photoMetadata)){return false;}const existing_provider=existing.provider;const incoming_provider=incoming.provider;if(!(existing_provider===incoming_provider)){return false;}const existing_width=existing.width;const incoming_width=incoming.width;if(!(existing_width===incoming_width)){return false;}return true;}const ingest$f=function PhotoRecordAvatarRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$w(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$d({recordId:input.recordId});let incomingRecord=normalize$f(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$i(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function validate$x(obj,path='RecordAvatarRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_result=obj.result;const obj_statusCode=obj.statusCode;const path_statusCode=path+'.statusCode';if(typeof obj_statusCode!=='number'){return new TypeError('Expected "number" but received "'+typeof obj_statusCode+'" (at "'+path_statusCode+'")');}})();return v_error===undefined?null:v_error;}function normalize$g(input,existing,path,lds,store,timestamp){const input_result=input.result;const input_result_id=path.fullPath+'__result';if(input_result.type==='Photo'){input.result={__ref:ingest$f(input_result,{fullPath:input_result_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store)};}if(input_result.type==='MissingSingle'){input.result={__ref:ingest$c(input_result,{fullPath:input_result_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store)};}if(input_result.type==='Theme'){input.result={__ref:ingest$d(input_result,{fullPath:input_result_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store)};}return input;}function equals$j(existing,incoming){const existing_statusCode=existing.statusCode;const incoming_statusCode=incoming.statusCode;if(!(existing_statusCode===incoming_statusCode)){return false;}const existing_result=existing.result;const incoming_result=incoming.result;if(!(existing_result.__ref===incoming_result.__ref)){return false;}return true;}const ingest$g=function RecordAvatarRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$x(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$g(input,store.records[key],{fullPath:key,parent:path.parent},lds,store);const existingRecord=store.records[key];if(existingRecord===undefined||equals$j(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return key;};function merge$2(existing,incoming,_lds,_path){if(existing===undefined){return incoming;}// Merge RecordRepresentation field values together
    return _objectSpread$5({},existing,incoming);}function validate$y(obj,path='RecordAvatarBulkRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_keys=ObjectKeys$1(obj);for(let i=0;i<obj_keys.length;i++){const key=obj_keys[i];const obj_prop=obj[key];}})();return v_error===undefined?null:v_error;}function normalize$h(input,existing,path,lds,store,timestamp){const input_keys=Object.keys(input);const input_length=input_keys.length;for(let i=0;i<input_length;i++){const key=input_keys[i];const input_prop=input[key];const input_prop_id=path.fullPath+'__'+key;input[key]={__ref:ingest$g(input_prop,{fullPath:input_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}return input;}function equals$k(existing,incoming){const equals_props=equalsObject(existing,incoming,(existing_prop,incoming_prop)=>{if(!(existing_prop.__ref===incoming_prop.__ref)){return false;}});if(equals_props===false){return false;}return true;}const ingest$h=function RecordAvatarBulkRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$y(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$h(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];incomingRecord=merge$2(existingRecord,incomingRecord);if(existingRecord===undefined||equals$k(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return key;};function getUiApiRecordAvatarsBatchByRecordIds(config){const key='RecordAvatarBulkRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'recordIds:'+config.urlParams.recordIds+')';const headers={};return {path:'/services/data/v48.0/ui-api/record-avatars/batch/'+config.urlParams.recordIds+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$h,headers};}var FormFactor$1;(function(FormFactor){FormFactor["Large"]="Large";FormFactor["Medium"]="Medium";FormFactor["Small"]="Small";})(FormFactor$1||(FormFactor$1={}));function coerceFormFactor(form){if(form===FormFactor$1.Large||form===FormFactor$1.Medium||form===FormFactor$1.Small){return form;}return undefined;}const getRecordAvatars_ConfigPropertyNames={displayName:'getRecordAvatars',parameters:{required:['recordIds'],optional:['formFactor']}};function coerceConfig$a(config){const coercedConfig={};const recordIds=getRecordId18Array(config.recordIds);if(recordIds!==undefined){coercedConfig.recordIds=recordIds;}const formFactor=coerceFormFactor(config.formFactor);if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}return coercedConfig;}function typeCheckConfig$a(untrustedConfig){const config={};const untrustedConfig_recordIds=untrustedConfig.recordIds;if(ArrayIsArray$1$1$1(untrustedConfig_recordIds)){const untrustedConfig_recordIds_array=[];for(let i=0,arrayLength=untrustedConfig_recordIds.length;i<arrayLength;i++){const untrustedConfig_recordIds_item=untrustedConfig_recordIds[i];if(typeof untrustedConfig_recordIds_item==='string'){untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);}}config.recordIds=untrustedConfig_recordIds_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}return config;}function validateAdapterConfig$a(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$a(untrustedConfig);const config=typeCheckConfig$a(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}const recordAvatarSelections=[{kind:'Link',name:'result',union:true,discriminator:'type',unionSelections:{Photo:select$d().selections,Theme:select$a().selections,// Hand rolled, we don't want to emit the properties from AbstractAvatarRepresentation
    MissingSingle:[{name:'errorCode',kind:'Scalar'},{name:'message',kind:'Scalar'}]}},{kind:'Scalar',name:'statusCode'}];function selectAvatars(recordIds){return recordIds.map(recordId=>{return {kind:'Link',name:recordId,selections:recordAvatarSelections};});}// All of the avatars are ingested into
    // the same top level object
    const KEY='RecordAvatarsBulk';function cache$4(lds,config){const sel=selectAvatars(config.recordIds);return lds.storeLookup({recordId:KEY,node:{kind:'Fragment',selections:sel},variables:{}});}/**
     *
     * The third argument, "recordIds", is here because
     * We only want to fetch avatars that are actually missing
     * This list will be a subset of the recordIds that are on the adapter config.
     *
     */function network$4(lds,config,recordIds){const resourceRequest=getUiApiRecordAvatarsBatchByRecordIds({urlParams:{recordIds},queryParams:{}});return lds.dispatchResourceRequest(resourceRequest).then(response=>{const formatted=response.body.results.reduce((seed,avatar,index)=>{const recordId=recordIds[index];// error responses
    // Fill in the missing discriminators
    if(avatar.statusCode!==200){const{result}=avatar;avatar.result=isArray$3(result)?result[0]:result;avatar.result.recordId=recordId;avatar.result.type='MissingSingle';}seed[recordId]=avatar;return seed;},{});lds.storeIngest(KEY,resourceRequest,formatted);lds.storeBroadcast();return cache$4(lds,config);},err=>{lds.storeIngestFetchResponse(KEY,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}// We have to type guard against pending snapshots
    // We should only ever get UnfulfilledSnapshot here
    function getRecordIds(config,snapshot){{if(isUnfulfilledSnapshot$1(snapshot)===false){throw new Error('Unexpected snapshot state in "getRecordIds" in "getRecordAvatars"');}}// Missing all avatars
    if(snapshot.data===undefined){return config.recordIds;}return keys$3(snapshot.missingPaths).sort();}const factory$8=lds=>{return refreshable$1(function(unknown){const config=validateAdapterConfig$a(unknown,getRecordAvatars_ConfigPropertyNames);if(config===null){return null;}const cacheLookup=cache$4(lds,config);// CACHE HIT
    if(isFulfilledSnapshot$1(cacheLookup)){return cacheLookup;}// CACHE MISS
    // Only fetch avatars that are missing
    const recordIds=getRecordIds(config,cacheLookup);return network$4(lds,config,recordIds);},untrusted=>{const config=validateAdapterConfig$a(untrusted,getRecordAvatars_ConfigPropertyNames);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return network$4(lds,config,config.recordIds);});};const select$e$1=function LeadStatusPicklistValueAttributesRepresentationSelect(){const{selections:AbstractPicklistValueAttributesRepresentationSelections}=select$h$1();return {kind:'Fragment',selections:[...AbstractPicklistValueAttributesRepresentationSelections,{name:'converted',kind:'Scalar'}]};};const select$f$1=function CaseStatusPicklistValueAttributesRepresentationSelect(){const{selections:AbstractPicklistValueAttributesRepresentationSelections}=select$h$1();return {kind:'Fragment',selections:[...AbstractPicklistValueAttributesRepresentationSelections,{name:'closed',kind:'Scalar'}]};};const select$g$1=function OpportunityStagePicklistValueAttributesRepresentationSelect(){const{selections:AbstractPicklistValueAttributesRepresentationSelections}=select$h$1();return {kind:'Fragment',selections:[...AbstractPicklistValueAttributesRepresentationSelections,{name:'closed',kind:'Scalar'},{name:'defaultProbability',kind:'Scalar'},{name:'forecastCategoryName',kind:'Scalar'},{name:'won',kind:'Scalar'}]};};function validate$z(obj,path='AbstractPicklistValueAttributesRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_picklistAtrributesValueType=obj.picklistAtrributesValueType;const path_picklistAtrributesValueType=path+'.picklistAtrributesValueType';if(typeof obj_picklistAtrributesValueType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_picklistAtrributesValueType+'" (at "'+path_picklistAtrributesValueType+'")');}})();return v_error===undefined?null:v_error;}const selectChildren$1=function AbstractPicklistValueAttributesRepresentationSelectChildren(params){const{selections:LeadStatusPicklistValueAttributesRepresentationSelections}=select$e$1();const{selections:CaseStatusPicklistValueAttributesRepresentationSelections}=select$f$1();const{selections:OpportunityStagePicklistValueAttributesRepresentationSelections}=select$g$1();return {kind:'Object',name:params.propertyName,nullable:params.nullable,union:true,discriminator:'picklistAtrributesValueType',unionSelections:{LeadStatus:LeadStatusPicklistValueAttributesRepresentationSelections,CaseStatus:CaseStatusPicklistValueAttributesRepresentationSelections,OpportunityStage:OpportunityStagePicklistValueAttributesRepresentationSelections}};};const select$h$1=function AbstractPicklistValueAttributesRepresentationSelect(){return {kind:'Fragment',selections:[{name:'picklistAtrributesValueType',kind:'Scalar'}]};};function validate$A(obj,path='PicklistValueRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_attributes=obj.attributes;const path_attributes=path+'.attributes';let obj_attributes_union0=null;const obj_attributes_union0_error=(()=>{const referenceAbstractPicklistValueAttributesRepresentationValidationError=validate$z(obj_attributes,path_attributes);if(referenceAbstractPicklistValueAttributesRepresentationValidationError!==null){let message='Object doesn\'t match AbstractPicklistValueAttributesRepresentation (at "'+path_attributes+'")\n';message+=referenceAbstractPicklistValueAttributesRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_attributes_union0_error!=null){obj_attributes_union0=obj_attributes_union0_error.message;}let obj_attributes_union1=null;const obj_attributes_union1_error=(()=>{if(obj_attributes!==null){return new TypeError('Expected "null" but received "'+typeof obj_attributes+'" (at "'+path_attributes+'")');}})();if(obj_attributes_union1_error!=null){obj_attributes_union1=obj_attributes_union1_error.message;}if(obj_attributes_union0&&obj_attributes_union1){let message='Object doesn\'t match union (at "'+path_attributes+'")';message+='\n'+obj_attributes_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_attributes_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_validFor=obj.validFor;const path_validFor=path+'.validFor';if(!ArrayIsArray$2(obj_validFor)){return new TypeError('Expected "array" but received "'+typeof obj_validFor+'" (at "'+path_validFor+'")');}for(let i=0;i<obj_validFor.length;i++){const obj_validFor_item=obj_validFor[i];const path_validFor_item=path_validFor+'['+i+']';if(typeof obj_validFor_item!=='number'||typeof obj_validFor_item==='number'&&Math.floor(obj_validFor_item)!==obj_validFor_item){return new TypeError('Expected "number" but received "'+typeof obj_validFor_item+'" (at "'+path_validFor_item+'")');}}const obj_value=obj.value;const path_value=path+'.value';if(typeof obj_value!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_value+'" (at "'+path_value+'")');}})();return v_error===undefined?null:v_error;}const select$i$1=function PicklistValueRepresentationSelect(){const AbstractPicklistValueAttributesRepresentation__unionSelections=selectChildren$1({propertyName:'attributes',nullable:true});return {kind:'Fragment',selections:[AbstractPicklistValueAttributesRepresentation__unionSelections,{name:'label',kind:'Scalar'},{name:'validFor',kind:'Scalar',plural:true},{name:'value',kind:'Scalar'}]};};function validate$B(obj,path='PicklistValuesRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_controllerValues=obj.controllerValues;const path_controllerValues=path+'.controllerValues';if(typeof obj_controllerValues!=='object'||ArrayIsArray$2(obj_controllerValues)||obj_controllerValues===null){return new TypeError('Expected "object" but received "'+typeof obj_controllerValues+'" (at "'+path_controllerValues+'")');}const obj_controllerValues_keys=ObjectKeys$1(obj_controllerValues);for(let i=0;i<obj_controllerValues_keys.length;i++){const key=obj_controllerValues_keys[i];const obj_controllerValues_prop=obj_controllerValues[key];const path_controllerValues_prop=path_controllerValues+'["'+key+'"]';if(typeof obj_controllerValues_prop!=='number'||typeof obj_controllerValues_prop==='number'&&Math.floor(obj_controllerValues_prop)!==obj_controllerValues_prop){return new TypeError('Expected "number" but received "'+typeof obj_controllerValues_prop+'" (at "'+path_controllerValues_prop+'")');}}const obj_defaultValue=obj.defaultValue;const path_defaultValue=path+'.defaultValue';let obj_defaultValue_union0=null;const obj_defaultValue_union0_error=(()=>{const referencePicklistValueRepresentationValidationError=validate$A(obj_defaultValue,path_defaultValue);if(referencePicklistValueRepresentationValidationError!==null){let message='Object doesn\'t match PicklistValueRepresentation (at "'+path_defaultValue+'")\n';message+=referencePicklistValueRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_defaultValue_union0_error!=null){obj_defaultValue_union0=obj_defaultValue_union0_error.message;}let obj_defaultValue_union1=null;const obj_defaultValue_union1_error=(()=>{if(obj_defaultValue!==null){return new TypeError('Expected "null" but received "'+typeof obj_defaultValue+'" (at "'+path_defaultValue+'")');}})();if(obj_defaultValue_union1_error!=null){obj_defaultValue_union1=obj_defaultValue_union1_error.message;}if(obj_defaultValue_union0&&obj_defaultValue_union1){let message='Object doesn\'t match union (at "'+path_defaultValue+'")';message+='\n'+obj_defaultValue_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_defaultValue_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_url=obj.url;const path_url=path+'.url';if(typeof obj_url!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_url+'" (at "'+path_url+'")');}const obj_values=obj.values;const path_values=path+'.values';if(!ArrayIsArray$2(obj_values)){return new TypeError('Expected "array" but received "'+typeof obj_values+'" (at "'+path_values+'")');}for(let i=0;i<obj_values.length;i++){const obj_values_item=obj_values[i];const path_values_item=path_values+'['+i+']';const referencePicklistValueRepresentationValidationError=validate$A(obj_values_item,path_values_item);if(referencePicklistValueRepresentationValidationError!==null){let message='Object doesn\'t match PicklistValueRepresentation (at "'+path_values_item+'")\n';message+=referencePicklistValueRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}})();return v_error===undefined?null:v_error;}function keyBuilder$e(config){return 'UiApi::PicklistValuesRepresentation:'+config.id;}function normalize$i(input,existing,path,lds,store,timestamp){return input;}const select$j$1=function PicklistValuesRepresentationSelect(){const{selections:PicklistValueRepresentation__selections,opaque:PicklistValueRepresentation__opaque}=select$i$1();return {kind:'Fragment',selections:[{name:'controllerValues',kind:'Scalar',map:true},{name:'defaultValue',kind:'Object',nullable:true,selections:PicklistValueRepresentation__selections},{name:'url',kind:'Scalar'},{name:'values',kind:'Object',plural:true,selections:PicklistValueRepresentation__selections}]};};function equals$l(existing,incoming){if(existing.eTag!==incoming.eTag){return false;}return true;}const ingest$i=function PicklistValuesRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$B(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$e({id:input.url});let incomingRecord=normalize$i(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$l(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return key;};function getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeIdAndFieldApiName(config){const key='PicklistValuesRepresentation('+'objectApiName:'+config.urlParams.objectApiName+','+'recordTypeId:'+config.urlParams.recordTypeId+','+'fieldApiName:'+config.urlParams.fieldApiName+')';const headers={};return {path:'/services/data/v48.0/ui-api/object-info/'+config.urlParams.objectApiName+'/picklist-values/'+config.urlParams.recordTypeId+'/'+config.urlParams.fieldApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$i,headers};}const adapterName$b='getPicklistValues';function coerceConfig$b(config){const coercedConfig={};const objectApiName=config.objectApiName;if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}const fieldApiName=getFieldApiName$3(config.fieldApiName);if(fieldApiName!==undefined){coercedConfig.fieldApiName=fieldApiName;}return coercedConfig;}function typeCheckConfig$b(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}const untrustedConfig_fieldApiName=untrustedConfig.fieldApiName;if(typeof untrustedConfig_fieldApiName==='string'){config.fieldApiName=untrustedConfig_fieldApiName;}return config;}function validateAdapterConfig$b(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$b(untrustedConfig);const config=typeCheckConfig$b(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}const path$1=select$j$1().selections;function network$5(lds,config){const{recordTypeId,fieldApiName}=config;const fieldNames=getFieldId(fieldApiName);const request=getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeIdAndFieldApiName({urlParams:{objectApiName:fieldNames.objectApiName,fieldApiName:fieldNames.fieldApiName,recordTypeId}});const key=keyBuilder$e({id:request.path});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;lds.storeIngest(key,request,body);lds.storeBroadcast();return cache$5(lds,config);},err=>{lds.storeIngestFetchResponse(key,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}function cache$5(lds,config){const fieldNames=getFieldId(config.fieldApiName);const request=getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeIdAndFieldApiName({urlParams:{objectApiName:fieldNames.objectApiName,fieldApiName:fieldNames.fieldApiName,recordTypeId:config.recordTypeId}});const key=keyBuilder$e({id:request.path});return lds.storeLookup({recordId:key,node:{kind:'Fragment',selections:path$1},variables:{}});}const picklistValuesConfigPropertyNames={displayName:adapterName$b,parameters:{required:['recordTypeId','fieldApiName'],optional:[]}};const factory$9=lds=>{return refreshable$1(function(untrusted){const config=validateAdapterConfig$b(untrusted,picklistValuesConfigPropertyNames);if(config===null){return null;}const snapshot=cache$5(lds,config);if(isFulfilledSnapshot$1(snapshot)){return snapshot;}return network$5(lds,config);},untrusted=>{const config=validateAdapterConfig$b(untrusted,picklistValuesConfigPropertyNames);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return network$5(lds,config);});};function validate$C(obj,path='PicklistValuesCollectionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_picklistFieldValues=obj.picklistFieldValues;const path_picklistFieldValues=path+'.picklistFieldValues';if(typeof obj_picklistFieldValues!=='object'||ArrayIsArray$2(obj_picklistFieldValues)||obj_picklistFieldValues===null){return new TypeError('Expected "object" but received "'+typeof obj_picklistFieldValues+'" (at "'+path_picklistFieldValues+'")');}const obj_picklistFieldValues_keys=ObjectKeys$1(obj_picklistFieldValues);for(let i=0;i<obj_picklistFieldValues_keys.length;i++){const key=obj_picklistFieldValues_keys[i];const obj_picklistFieldValues_prop=obj_picklistFieldValues[key];}})();return v_error===undefined?null:v_error;}function normalize$j(input,existing,path,lds,store,timestamp){const input_picklistFieldValues=input.picklistFieldValues;const input_picklistFieldValues_id=path.fullPath+'__picklistFieldValues';const input_picklistFieldValues_keys=Object.keys(input_picklistFieldValues);const input_picklistFieldValues_length=input_picklistFieldValues_keys.length;for(let i=0;i<input_picklistFieldValues_length;i++){const key=input_picklistFieldValues_keys[i];const input_picklistFieldValues_prop=input_picklistFieldValues[key];const input_picklistFieldValues_prop_id=input_picklistFieldValues_id+'__'+key;input_picklistFieldValues[key]={__ref:ingest$i(input_picklistFieldValues_prop,{fullPath:input_picklistFieldValues_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}return input;}function equals$m(existing,incoming){const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_picklistFieldValues=existing.picklistFieldValues;const incoming_picklistFieldValues=incoming.picklistFieldValues;const equals_picklistFieldValues_props=equalsObject(existing_picklistFieldValues,incoming_picklistFieldValues,(existing_picklistFieldValues_prop,incoming_picklistFieldValues_prop)=>{if(!(existing_picklistFieldValues_prop.__ref===incoming_picklistFieldValues_prop.__ref)){return false;}});if(equals_picklistFieldValues_props===false){return false;}return true;}const ingest$j=function PicklistValuesCollectionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$C(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$j(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$m(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return key;};function getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeId(config){const key='PicklistValuesCollectionRepresentation('+'objectApiName:'+config.urlParams.objectApiName+','+'recordTypeId:'+config.urlParams.recordTypeId+')';const headers={};return {path:'/services/data/v48.0/ui-api/object-info/'+config.urlParams.objectApiName+'/picklist-values/'+config.urlParams.recordTypeId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$j,headers};}const getPicklistValuesByRecordType_ConfigPropertyNames={displayName:'getPicklistValuesByRecordType',parameters:{required:['objectApiName','recordTypeId'],optional:[]}};function coerceConfig$c(config){const coercedConfig={};const objectApiName=getObjectApiName$1(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}return coercedConfig;}function typeCheckConfig$c(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}return config;}function validateAdapterConfig$c(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$c(untrustedConfig);const config=typeCheckConfig$c(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function select$k(picklistNames){return [{kind:'Object',name:'picklistFieldValues',selections:picklistNames.map(name=>{return {kind:'Link',name,selections:path$1};})}];}function network$6(lds,config){const{objectApiName,recordTypeId}=config;const request=getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeId({urlParams:{objectApiName,recordTypeId}});const selectorKey=request.key+'__selector';return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const picklistFieldValueNames=keys$3(body.picklistFieldValues);const sel={recordId:request.key,node:{kind:'Fragment',selections:select$k(picklistFieldValueNames)},variables:{}};// Remember the selector
    lds.storePublish(selectorKey,sel);lds.storeIngest(request.key,request,body);lds.storeBroadcast();return lds.storeLookup(sel);},err=>{lds.storeIngestFetchResponse(request.key,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}function cache$6(lds,config){const request=getUiApiObjectInfoPicklistValuesByObjectApiNameAndRecordTypeId({urlParams:{objectApiName:config.objectApiName,recordTypeId:config.recordTypeId}});const selectorKey=request.key+'__selector';const selectorSnapshot=lds.storeLookup({recordId:selectorKey,node:{kind:'Fragment',opaque:true},variables:{}});// We've seen the response for this request before
    if(isFulfilledSnapshot$1(selectorSnapshot)){const cacheSnapshot=lds.storeLookup(selectorSnapshot.data);// Cache hit
    if(isFulfilledSnapshot$1(cacheSnapshot)){return cacheSnapshot;}}return null;}const factory$a=lds=>{return refreshable$1(untrusted=>{const config=validateAdapterConfig$c(untrusted,getPicklistValuesByRecordType_ConfigPropertyNames);if(config===null){return null;}const snapshot=cache$6(lds,config);if(snapshot!==null){return snapshot;}return network$6(lds,config);},untrusted=>{const config=validateAdapterConfig$c(untrusted,getPicklistValuesByRecordType_ConfigPropertyNames);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return network$6(lds,config);});};function patchUiApiRecordsByRecordId(config){const key='RecordRepresentation('+'recordId:'+config.urlParams.recordId+')';const headers={};const header_ifUnmodifiedSince=config.headers.ifUnmodifiedSince;if(header_ifUnmodifiedSince!==undefined){headers['If-Unmodified-Since']=header_ifUnmodifiedSince;}return {path:'/services/data/v48.0/ui-api/records/'+config.urlParams.recordId+'',method:'patch',body:config.body,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$2,headers};}const updateRecord_ConfigPropertyNames={displayName:'updateRecord',parameters:{required:['recordId','fields'],optional:['allowSaveOnDuplicate','apiName','ifUnmodifiedSince']}};function coerceConfig$d(config){const coercedConfig={};const recordId=getRecordId18(config.recordId);if(recordId!==undefined){coercedConfig.recordId=recordId;}const allowSaveOnDuplicate=config.allowSaveOnDuplicate;if(allowSaveOnDuplicate!==undefined){coercedConfig.allowSaveOnDuplicate=allowSaveOnDuplicate;}const apiName=config.apiName;if(apiName!==undefined){coercedConfig.apiName=apiName;}const fields=config.fields;if(fields!==undefined){coercedConfig.fields=fields;}const ifUnmodifiedSince=config.ifUnmodifiedSince;if(ifUnmodifiedSince!==undefined){coercedConfig.ifUnmodifiedSince=ifUnmodifiedSince;}return coercedConfig;}function typeCheckConfig$d(untrustedConfig){const config={};const untrustedConfig_recordId=untrustedConfig.recordId;if(typeof untrustedConfig_recordId==='string'){config.recordId=untrustedConfig_recordId;}const untrustedConfig_allowSaveOnDuplicate=untrustedConfig.allowSaveOnDuplicate;if(typeof untrustedConfig_allowSaveOnDuplicate==='boolean'){config.allowSaveOnDuplicate=untrustedConfig_allowSaveOnDuplicate;}const untrustedConfig_apiName=untrustedConfig.apiName;if(typeof untrustedConfig_apiName==='string'){config.apiName=untrustedConfig_apiName;}const untrustedConfig_fields=untrustedConfig.fields;if(untrustedIsObject$1$1(untrustedConfig_fields)){const untrustedConfig_fields_object={};const untrustedConfig_fields_keys=Object.keys(untrustedConfig_fields);for(let i=0,arrayLength=untrustedConfig_fields_keys.length;i<arrayLength;i++){const key=untrustedConfig_fields_keys[i];const untrustedConfig_fields_prop=untrustedConfig_fields[key];if(typeof untrustedConfig_fields_prop==='string'){untrustedConfig_fields_object[key]=untrustedConfig_fields_prop;}if(typeof untrustedConfig_fields_prop==='number'){untrustedConfig_fields_object[key]=untrustedConfig_fields_prop;}if(untrustedConfig_fields_prop===null){untrustedConfig_fields_object[key]=untrustedConfig_fields_prop;}if(typeof untrustedConfig_fields_prop==='boolean'){untrustedConfig_fields_object[key]=untrustedConfig_fields_prop;}}if(Object.keys(untrustedConfig_fields_object).length>0){config.fields=untrustedConfig_fields_object;}}const untrustedConfig_ifUnmodifiedSince=untrustedConfig.ifUnmodifiedSince;if(typeof untrustedConfig_ifUnmodifiedSince==='string'){config.ifUnmodifiedSince=untrustedConfig_ifUnmodifiedSince;}return config;}function validateAdapterConfig$d(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$d(untrustedConfig);const config=typeCheckConfig$d(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function getHeaders(clientOptions){const headers={};if(untrustedIsObject$1$1(clientOptions)){if(typeof clientOptions.ifUnmodifiedSince==='string'){headers.ifUnmodifiedSince=clientOptions.ifUnmodifiedSince;}}return headers;}const factory$b=lds=>{return (untrusted,clientOptions)=>{let config=null;if(untrustedIsObject$1$1(untrusted)&&untrustedIsObject$1$1(untrusted.fields)){config=validateAdapterConfig$d(_objectSpread$5({recordId:untrusted.fields.Id},untrusted),updateRecord_ConfigPropertyNames);}// Invalid or incomplete config
    if(config===null){throw new Error('Invalid recordInput');}const{recordId}=config;const headers=getHeaders(clientOptions);const request=patchUiApiRecordsByRecordId({urlParams:{recordId},body:{apiName:config.apiName,fields:config.fields,allowSaveOnDuplicate:config.allowSaveOnDuplicate},headers});return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;const sel=buildSelectionFromRecord(body);const key=keyBuilder({recordId});lds.storeIngest(key,request,body);lds.storeBroadcast();return lds.storeLookup({recordId:key,node:{kind:'Fragment',selections:sel},variables:{}});},err=>{deepFreeze$2(err);throw err;});};};function patchUiApiLayoutUserStateByObjectApiName(config){const key='RecordLayoutUserStateRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'layoutType:'+config.queryParams.layoutType+','+'mode:'+config.queryParams.mode+','+'recordTypeId:'+config.queryParams.recordTypeId+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v48.0/ui-api/layout/'+config.urlParams.objectApiName+'/user-state',method:'patch',body:config.body,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$4,headers};}function validate$D(obj,path='RecordLayoutUserStateInputRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_sectionUserStates=obj.sectionUserStates;const path_sectionUserStates=path+'.sectionUserStates';if(typeof obj_sectionUserStates!=='object'||ArrayIsArray$2(obj_sectionUserStates)||obj_sectionUserStates===null){return new TypeError('Expected "object" but received "'+typeof obj_sectionUserStates+'" (at "'+path_sectionUserStates+'")');}const obj_sectionUserStates_keys=ObjectKeys$1(obj_sectionUserStates);for(let i=0;i<obj_sectionUserStates_keys.length;i++){const key=obj_sectionUserStates_keys[i];const obj_sectionUserStates_prop=obj_sectionUserStates[key];const path_sectionUserStates_prop=path_sectionUserStates+'["'+key+'"]';if(typeof obj_sectionUserStates_prop!=='object'||ArrayIsArray$2(obj_sectionUserStates_prop)||obj_sectionUserStates_prop===null){return new TypeError('Expected "object" but received "'+typeof obj_sectionUserStates_prop+'" (at "'+path_sectionUserStates_prop+'")');}}})();return v_error===undefined?null:v_error;}// Hack method- this should be removed eventually when layoutUserState raml is fixed.
    function addAdditionalFieldsForNorming(layoutUserState,apiName,recordTypeId,layoutType,mode){// Hack- adding in this params so record-ui will be able to use normed values.
    layoutUserState.apiName=apiName;layoutUserState.recordTypeId=recordTypeId;layoutUserState.layoutType=layoutType;layoutUserState.mode=mode;}function updateLayoutUserState$1(lds,config,key,updateRequest){return lds.dispatchResourceRequest(updateRequest).then(response=>{return ingestAndBroadcast(lds,key,updateRequest,config,response.body);},err=>{deepFreeze$2(err);throw err;});}function ingestAndBroadcast(lds,key,request,config,body){addAdditionalFieldsForNorming(body,config.objectApiName,config.recordTypeId,config.layoutType,config.mode);lds.storeIngest(key,request,body);lds.storeBroadcast();return cache$2(lds,config);}function clone(userLayoutState){return parse(stringify$3(userLayoutState));}// Applies optimisticUpdate to layoutUserState
    // If the optimistic update can be applied, returns RecordLayoutUserStateRepresentation
    // If the optimistic update cannot be applied, returns null
    // The optimistic update can be applied only IF the cached layoutUserState has all the sections
    // enumerated on the layout user state input
    function optimisticUpdate(cachedLayoutUserState,layoutUserStateInput){let clonedLayoutUserState;let clonedLayoutUserStateSections;const{sectionUserStates}=layoutUserStateInput;const{sectionUserStates:cachedSectionUserStates}=cachedLayoutUserState;const sectionUserStateKeys=keys$3(sectionUserStates);for(let i=0,len=sectionUserStateKeys.length;i<len;i+=1){const sectionId=sectionUserStateKeys[i];if(cachedSectionUserStates[sectionId]===undefined){// Cannot update a section that isn't in the cache. Cancel the optimistic update.
    return null;}if(clonedLayoutUserState===undefined){// We have to clone cachedLayoutUserState because this object is coming from
    // a snapshot, where it is frozen
    clonedLayoutUserState=clone(cachedLayoutUserState);// hold onto sectionUserStates from clonedLayoutUserState
    clonedLayoutUserStateSections=clonedLayoutUserState.sectionUserStates;}// DEV MODE sanity check
    {if(clonedLayoutUserStateSections===undefined){throw new Error('clonedLayoutUserStateSections is undefined in updateLayoutUserState optimisticUpdate');}}const userState=sectionUserStates[sectionId];clonedLayoutUserStateSections[sectionId].collapsed=userState.collapsed;}// DEV MODE sanity check
    {if(clonedLayoutUserState===undefined){throw new Error('clonedLayoutUserState is undefined in updateLayoutUserState optimisticUpdate');}}return clonedLayoutUserState;}function coerceConfigWithDefaults$4(untrusted,layoutUserStateInput){const config=coerceConfigWithDefaults$1(untrusted);if(config===null){throw new Error(`@wire(updateLayoutUserState) invalid configuration ${stringify$3(untrusted)}`);}// This will throw if layoutUserStateInput is not a valid input
    validate$D(layoutUserStateInput,'layoutUserStateInput');return _objectSpread$5({},config,{layoutUserStateInput:layoutUserStateInput});}const factory$c=lds=>{return (untrustedObjectApiName,untrustedRecordTypeId,untrustedLayoutType,untrustedMode,untrustedLayoutUserStateInput)=>{const untrusted={objectApiName:untrustedObjectApiName,recordTypeId:untrustedRecordTypeId,layoutType:untrustedLayoutType,mode:untrustedMode};const config=coerceConfigWithDefaults$4(untrusted,untrustedLayoutUserStateInput);if(config===null){throw new Error(`@wire(updateLayoutUserState) invalid configuration ${stringify$3(untrusted)}`);}const{objectApiName,layoutType,mode,recordTypeId,layoutUserStateInput}=config;const updateRequest=patchUiApiLayoutUserStateByObjectApiName({urlParams:{objectApiName},body:layoutUserStateInput,queryParams:{layoutType,mode,recordTypeId}});const key=keyBuilder$2({apiName:objectApiName,recordTypeId,layoutType,mode});const cacheSnapshot=cache$2(lds,config);if(isFulfilledSnapshot$1(cacheSnapshot)){// Create an optimistic update if we can
    const updatedLayoutUserState=optimisticUpdate(cacheSnapshot.data,layoutUserStateInput);if(updatedLayoutUserState!==null){// Ingest optimistic update done client side
    ingestAndBroadcast(lds,key,updateRequest,config,updatedLayoutUserState);}}return updateLayoutUserState$1(lds,config,key,updateRequest);};};function postUiApiRecordAvatarsAssociationByRecordId(config){const key=keyBuilder$c({recordId:config.urlParams.recordId});const headers={};return {path:'/services/data/v48.0/ui-api/record-avatars/'+config.urlParams.recordId+'/association',method:'post',body:config.body,urlParams:config.urlParams,queryParams:{},key:key,ingest:ingest$e,headers};}const updateRecordAvatar_ConfigPropertyNames={displayName:'updateRecordAvatar',parameters:{required:['recordId','actionType'],optional:['externalId','blueMasterId','profileName','photoUrl']}};function typeCheckConfig$e(untrustedConfig){const config={};const untrustedConfig_recordId=untrustedConfig.recordId;if(typeof untrustedConfig_recordId==='string'){config.recordId=untrustedConfig_recordId;}const untrustedConfig_externalId=untrustedConfig.externalId;if(typeof untrustedConfig_externalId==='string'){config.externalId=untrustedConfig_externalId;}const untrustedConfig_blueMasterId=untrustedConfig.blueMasterId;if(typeof untrustedConfig_blueMasterId==='string'){config.blueMasterId=untrustedConfig_blueMasterId;}const untrustedConfig_profileName=untrustedConfig.profileName;if(typeof untrustedConfig_profileName==='string'){config.profileName=untrustedConfig_profileName;}const untrustedConfig_photoUrl=untrustedConfig.photoUrl;if(typeof untrustedConfig_photoUrl==='string'){config.photoUrl=untrustedConfig_photoUrl;}const untrustedConfig_actionType=untrustedConfig.actionType;if(typeof untrustedConfig_actionType==='string'){config.actionType=untrustedConfig_actionType;}return config;}function validateAdapterConfig$e(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const config=typeCheckConfig$e(untrustedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}const factory$d=lds=>{return untrustedConfig=>{const config=validateAdapterConfig$e(untrustedConfig,updateRecordAvatar_ConfigPropertyNames);if(config===null){throw new Error('updateRecordAvatar invalid configuration');}const request=postUiApiRecordAvatarsAssociationByRecordId({urlParams:{recordId:config.recordId},body:{externalId:config.externalId,blueMasterId:config.blueMasterId,profileName:config.profileName,photoUrl:config.photoUrl,actionType:config.actionType}});return lds.dispatchResourceRequest(request).then(response=>{let selectors;if(response.body.type==='Theme'){selectors=select$a;lds.storeIngest(request.key,_objectSpread$5({},request,{ingest:ingest$d}),response.body);}else if(response.body.type==='Photo'){selectors=select$d;lds.storeIngest(request.key,_objectSpread$5({},request,{ingest:ingest$f}),response.body);}else {throw new Error('Unsupported avatar type');}lds.storeBroadcast();// TODO W-6804405 - support unions on fragments (only supported on links today)
    return lds.storeLookup({recordId:request.key,node:selectors(),variables:{}});},err=>{deepFreeze$2(err);throw err;});};};function merge$3(existing,incoming,_lds,_path){if(existing===undefined){return incoming;}// Merge RecordCreateDefaultRecordRepresentationNormalized record field values together
    return _objectSpread$5({},incoming,{fields:_objectSpread$5({},existing.fields,incoming.fields)});}function validate$E(obj,path='RecordCreateDefaultRecordRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_childRelationships=obj.childRelationships;const path_childRelationships=path+'.childRelationships';if(typeof obj_childRelationships!=='object'||ArrayIsArray$2(obj_childRelationships)||obj_childRelationships===null){return new TypeError('Expected "object" but received "'+typeof obj_childRelationships+'" (at "'+path_childRelationships+'")');}const obj_childRelationships_keys=ObjectKeys$1(obj_childRelationships);for(let i=0;i<obj_childRelationships_keys.length;i++){const key=obj_childRelationships_keys[i];const obj_childRelationships_prop=obj_childRelationships[key];}const obj_fields=obj.fields;const path_fields=path+'.fields';if(typeof obj_fields!=='object'||ArrayIsArray$2(obj_fields)||obj_fields===null){return new TypeError('Expected "object" but received "'+typeof obj_fields+'" (at "'+path_fields+'")');}const obj_fields_keys=ObjectKeys$1(obj_fields);for(let i=0;i<obj_fields_keys.length;i++){const key=obj_fields_keys[i];const obj_fields_prop=obj_fields[key];}const obj_id=obj.id;const path_id=path+'.id';if(obj_id!==null){return new TypeError('Expected "null" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_lastModifiedById=obj.lastModifiedById;const path_lastModifiedById=path+'.lastModifiedById';let obj_lastModifiedById_union0=null;const obj_lastModifiedById_union0_error=(()=>{if(typeof obj_lastModifiedById!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lastModifiedById+'" (at "'+path_lastModifiedById+'")');}})();if(obj_lastModifiedById_union0_error!=null){obj_lastModifiedById_union0=obj_lastModifiedById_union0_error.message;}let obj_lastModifiedById_union1=null;const obj_lastModifiedById_union1_error=(()=>{if(obj_lastModifiedById!==null){return new TypeError('Expected "null" but received "'+typeof obj_lastModifiedById+'" (at "'+path_lastModifiedById+'")');}})();if(obj_lastModifiedById_union1_error!=null){obj_lastModifiedById_union1=obj_lastModifiedById_union1_error.message;}if(obj_lastModifiedById_union0&&obj_lastModifiedById_union1){let message='Object doesn\'t match union (at "'+path_lastModifiedById+'")';message+='\n'+obj_lastModifiedById_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lastModifiedById_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_lastModifiedDate=obj.lastModifiedDate;const path_lastModifiedDate=path+'.lastModifiedDate';let obj_lastModifiedDate_union0=null;const obj_lastModifiedDate_union0_error=(()=>{if(typeof obj_lastModifiedDate!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_lastModifiedDate+'" (at "'+path_lastModifiedDate+'")');}})();if(obj_lastModifiedDate_union0_error!=null){obj_lastModifiedDate_union0=obj_lastModifiedDate_union0_error.message;}let obj_lastModifiedDate_union1=null;const obj_lastModifiedDate_union1_error=(()=>{if(obj_lastModifiedDate!==null){return new TypeError('Expected "null" but received "'+typeof obj_lastModifiedDate+'" (at "'+path_lastModifiedDate+'")');}})();if(obj_lastModifiedDate_union1_error!=null){obj_lastModifiedDate_union1=obj_lastModifiedDate_union1_error.message;}if(obj_lastModifiedDate_union0&&obj_lastModifiedDate_union1){let message='Object doesn\'t match union (at "'+path_lastModifiedDate+'")';message+='\n'+obj_lastModifiedDate_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_lastModifiedDate_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_recordTypeInfo=obj.recordTypeInfo;const path_recordTypeInfo=path+'.recordTypeInfo';let obj_recordTypeInfo_union0=null;const obj_recordTypeInfo_union0_error=(()=>{const referenceRecordTypeInfoRepresentationValidationError=validate(obj_recordTypeInfo,path_recordTypeInfo);if(referenceRecordTypeInfoRepresentationValidationError!==null){let message='Object doesn\'t match RecordTypeInfoRepresentation (at "'+path_recordTypeInfo+'")\n';message+=referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}})();if(obj_recordTypeInfo_union0_error!=null){obj_recordTypeInfo_union0=obj_recordTypeInfo_union0_error.message;}let obj_recordTypeInfo_union1=null;const obj_recordTypeInfo_union1_error=(()=>{if(obj_recordTypeInfo!==null){return new TypeError('Expected "null" but received "'+typeof obj_recordTypeInfo+'" (at "'+path_recordTypeInfo+'")');}})();if(obj_recordTypeInfo_union1_error!=null){obj_recordTypeInfo_union1=obj_recordTypeInfo_union1_error.message;}if(obj_recordTypeInfo_union0&&obj_recordTypeInfo_union1){let message='Object doesn\'t match union (at "'+path_recordTypeInfo+'")';message+='\n'+obj_recordTypeInfo_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_recordTypeInfo_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_systemModstamp=obj.systemModstamp;const path_systemModstamp=path+'.systemModstamp';let obj_systemModstamp_union0=null;const obj_systemModstamp_union0_error=(()=>{if(typeof obj_systemModstamp!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_systemModstamp+'" (at "'+path_systemModstamp+'")');}})();if(obj_systemModstamp_union0_error!=null){obj_systemModstamp_union0=obj_systemModstamp_union0_error.message;}let obj_systemModstamp_union1=null;const obj_systemModstamp_union1_error=(()=>{if(obj_systemModstamp!==null){return new TypeError('Expected "null" but received "'+typeof obj_systemModstamp+'" (at "'+path_systemModstamp+'")');}})();if(obj_systemModstamp_union1_error!=null){obj_systemModstamp_union1=obj_systemModstamp_union1_error.message;}if(obj_systemModstamp_union0&&obj_systemModstamp_union1){let message='Object doesn\'t match union (at "'+path_systemModstamp+'")';message+='\n'+obj_systemModstamp_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_systemModstamp_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_weakEtag=obj.weakEtag;const path_weakEtag=path+'.weakEtag';if(typeof obj_weakEtag!=='number'||typeof obj_weakEtag==='number'&&Math.floor(obj_weakEtag)!==obj_weakEtag){return new TypeError('Expected "number" but received "'+typeof obj_weakEtag+'" (at "'+path_weakEtag+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$f(config){return 'UiApi::RecordCreateDefaultRecordRepresentation:'+config.apiName;}function normalize$k(input,existing,path,lds,store,timestamp){const input_childRelationships=input.childRelationships;const input_childRelationships_id=path.fullPath+'__childRelationships';const input_childRelationships_keys=Object.keys(input_childRelationships);const input_childRelationships_length=input_childRelationships_keys.length;for(let i=0;i<input_childRelationships_length;i++){const key=input_childRelationships_keys[i];const input_childRelationships_prop=input_childRelationships[key];const input_childRelationships_prop_id=input_childRelationships_id+'__'+key;input_childRelationships[key]={__ref:ingest(input_childRelationships_prop,{fullPath:input_childRelationships_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}const input_fields=input.fields;const input_fields_id=path.fullPath+'__fields';const input_fields_keys=Object.keys(input_fields);const input_fields_length=input_fields_keys.length;for(let i=0;i<input_fields_length;i++){const key=input_fields_keys[i];const input_fields_prop=input_fields[key];const input_fields_prop_id=input_fields_id+'__'+key;input_fields[key]={__ref:ingest$1(input_fields_prop,{fullPath:input_fields_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}return input;}function equals$n(existing,incoming){const existing_weakEtag=existing.weakEtag;const incoming_weakEtag=incoming.weakEtag;if(!(existing_weakEtag===incoming_weakEtag)){return false;}const existing_apiName=existing.apiName;const incoming_apiName=incoming.apiName;if(!(existing_apiName===incoming_apiName)){return false;}const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_childRelationships=existing.childRelationships;const incoming_childRelationships=incoming.childRelationships;const equals_childRelationships_props=equalsObject(existing_childRelationships,incoming_childRelationships,(existing_childRelationships_prop,incoming_childRelationships_prop)=>{if(!(existing_childRelationships_prop.__ref===incoming_childRelationships_prop.__ref)){return false;}});if(equals_childRelationships_props===false){return false;}const existing_fields=existing.fields;const incoming_fields=incoming.fields;const equals_fields_props=equalsObject(existing_fields,incoming_fields,(existing_fields_prop,incoming_fields_prop)=>{if(!(existing_fields_prop.__ref===incoming_fields_prop.__ref)){return false;}});if(equals_fields_props===false){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_lastModifiedById=existing.lastModifiedById;const incoming_lastModifiedById=incoming.lastModifiedById;if(!(existing_lastModifiedById===incoming_lastModifiedById)){return false;}const existing_lastModifiedDate=existing.lastModifiedDate;const incoming_lastModifiedDate=incoming.lastModifiedDate;if(!(existing_lastModifiedDate===incoming_lastModifiedDate)){return false;}const existing_recordTypeInfo=existing.recordTypeInfo;const incoming_recordTypeInfo=incoming.recordTypeInfo;if(!(existing_recordTypeInfo===incoming_recordTypeInfo||existing_recordTypeInfo!=null&&incoming_recordTypeInfo!=null&&equals$2(existing_recordTypeInfo,incoming_recordTypeInfo))){return false;}const existing_systemModstamp=existing.systemModstamp;const incoming_systemModstamp=incoming.systemModstamp;if(!(existing_systemModstamp===incoming_systemModstamp)){return false;}return true;}const ingest$k=function RecordCreateDefaultRecordRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$E(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$f({apiName:input.apiName});let incomingRecord=normalize$k(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];incomingRecord=merge$3(existingRecord,incomingRecord);if(existingRecord===undefined||equals$n(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};function validate$F(obj,path='RecordDefaultsRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_layout=obj.layout;const path_layout=path+'.layout';let obj_layout_union0=null;const obj_layout_union0_error=(()=>{})();if(obj_layout_union0_error!=null){obj_layout_union0=obj_layout_union0_error.message;}let obj_layout_union1=null;const obj_layout_union1_error=(()=>{if(obj_layout!==null){return new TypeError('Expected "null" but received "'+typeof obj_layout+'" (at "'+path_layout+'")');}})();if(obj_layout_union1_error!=null){obj_layout_union1=obj_layout_union1_error.message;}if(obj_layout_union0&&obj_layout_union1){let message='Object doesn\'t match union (at "'+path_layout+'")';message+='\n'+obj_layout_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_layout_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_objectInfos=obj.objectInfos;const path_objectInfos=path+'.objectInfos';if(typeof obj_objectInfos!=='object'||ArrayIsArray$2(obj_objectInfos)||obj_objectInfos===null){return new TypeError('Expected "object" but received "'+typeof obj_objectInfos+'" (at "'+path_objectInfos+'")');}const obj_objectInfos_keys=ObjectKeys$1(obj_objectInfos);for(let i=0;i<obj_objectInfos_keys.length;i++){const key=obj_objectInfos_keys[i];const obj_objectInfos_prop=obj_objectInfos[key];}const obj_record=obj.record;})();return v_error===undefined?null:v_error;}function normalize$l(input,existing,path,lds,store,timestamp){const input_layout=input.layout;const input_layout_id=path.fullPath+'__layout';if(input_layout!==null&&typeof input_layout==='object'){input.layout={__ref:ingest$3(input_layout,{fullPath:input_layout_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}const input_objectInfos=input.objectInfos;const input_objectInfos_id=path.fullPath+'__objectInfos';const input_objectInfos_keys=Object.keys(input_objectInfos);const input_objectInfos_length=input_objectInfos_keys.length;for(let i=0;i<input_objectInfos_length;i++){const key=input_objectInfos_keys[i];const input_objectInfos_prop=input_objectInfos[key];const input_objectInfos_prop_id=input_objectInfos_id+'__'+key;input_objectInfos[key]={__ref:ingest$a(input_objectInfos_prop,{fullPath:input_objectInfos_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};}const input_record=input.record;const input_record_id=path.fullPath+'__record';input.record={__ref:ingest$k(input_record,{fullPath:input_record_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store,timestamp)};return input;}function equals$o(existing,incoming){const existing_layout=existing.layout;const incoming_layout=incoming.layout;if(!(existing_layout===incoming_layout||existing_layout!=null&&incoming_layout!=null&&existing_layout.__ref!=null&&incoming_layout.__ref!=null&&existing_layout.__ref===incoming_layout.__ref)){return false;}const existing_objectInfos=existing.objectInfos;const incoming_objectInfos=incoming.objectInfos;const equals_objectInfos_props=equalsObject(existing_objectInfos,incoming_objectInfos,(existing_objectInfos_prop,incoming_objectInfos_prop)=>{if(!(existing_objectInfos_prop.__ref===incoming_objectInfos_prop.__ref)){return false;}});if(equals_objectInfos_props===false){return false;}const existing_record=existing.record;const incoming_record=incoming.record;if(!(existing_record.__ref===incoming_record.__ref)){return false;}return true;}const ingest$l=function RecordDefaultsRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$F(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$l(input,store.records[key],{fullPath:key,parent:path.parent},lds,store,timestamp);const existingRecord=store.records[key];if(existingRecord===undefined||equals$o(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+900000);return key;};function getUiApiRecordDefaultsCreateByObjectApiName(config){const key='RecordDefaultsRepresentation('+'formFactor:'+config.queryParams.formFactor+','+'optionalFields:'+config.queryParams.optionalFields+','+'recordTypeId:'+config.queryParams.recordTypeId+','+'objectApiName:'+config.urlParams.objectApiName+')';const headers={};return {path:'/services/data/v48.0/ui-api/record-defaults/create/'+config.urlParams.objectApiName+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$l,headers};}const getRecordCreateDefaults_ConfigPropertyNames={displayName:'getRecordCreateDefaults',parameters:{required:['objectApiName'],optional:['formFactor','optionalFields','recordTypeId']}};function coerceConfig$e(config){const coercedConfig={};const objectApiName=getObjectApiName$1(config.objectApiName);if(objectApiName!==undefined){coercedConfig.objectApiName=objectApiName;}const formFactor=coerceFormFactor(config.formFactor);if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const optionalFields=getFieldApiNamesArray(config.optionalFields);if(optionalFields!==undefined){coercedConfig.optionalFields=optionalFields;}const recordTypeId=getRecordId18(config.recordTypeId);if(recordTypeId!==undefined){coercedConfig.recordTypeId=recordTypeId;}return coercedConfig;}function typeCheckConfig$f(untrustedConfig){const config={};const untrustedConfig_objectApiName=untrustedConfig.objectApiName;if(typeof untrustedConfig_objectApiName==='string'){config.objectApiName=untrustedConfig_objectApiName;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_optionalFields=untrustedConfig.optionalFields;if(ArrayIsArray$1$1$1(untrustedConfig_optionalFields)){const untrustedConfig_optionalFields_array=[];for(let i=0,arrayLength=untrustedConfig_optionalFields.length;i<arrayLength;i++){const untrustedConfig_optionalFields_item=untrustedConfig_optionalFields[i];if(typeof untrustedConfig_optionalFields_item==='string'){untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);}}config.optionalFields=untrustedConfig_optionalFields_array;}const untrustedConfig_recordTypeId=untrustedConfig.recordTypeId;if(typeof untrustedConfig_recordTypeId==='string'){config.recordTypeId=untrustedConfig_recordTypeId;}return config;}function validateAdapterConfig$f(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$e(untrustedConfig);const config=typeCheckConfig$f(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}const layoutSelections$3=select();const objectInfoSelections=select$9();function buildSelector(resp){const objectInfoKeys=keys$3(resp.objectInfos);const recordSelections=buildSelectionFromRecord(resp.record);return [{kind:'Link',name:'layout',nullable:true,selections:layoutSelections$3.selections},{kind:'Object',name:'objectInfos',selections:objectInfoKeys.map(key=>{return {kind:'Link',name:key,selections:objectInfoSelections.selections};})},{kind:'Link',name:'record',selections:recordSelections}];}function network$7(lds,config){const{formFactor,optionalFields,recordTypeId}=config;const request=getUiApiRecordDefaultsCreateByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{formFactor,optionalFields,recordTypeId}});const{key}=request;const selectorKey=`${key}__selector`;return lds.dispatchResourceRequest(request).then(response=>{const{body}=response;// TODO W-6399239 - fix API so we don't have to augment the response with request details in order
    // to support refresh. these are never emitted out per (private).
    if(body.layout!==null){body.layout.apiName=config.objectApiName;body.layout.recordTypeId=recordTypeId;}const cacheSelector={recordId:key,node:{kind:'Fragment',selections:buildSelector(body)},variables:{}};lds.storePublish(selectorKey,cacheSelector);lds.storeIngest(key,request,body);lds.storeBroadcast();return lds.storeLookup(cacheSelector);},err=>{lds.storeIngestFetchResponse(key,err);lds.storeBroadcast();return lds.errorSnapshot(err);});}function coerceConfigWithDefaults$5(untrusted){const config=validateAdapterConfig$f(untrusted,getRecordCreateDefaults_ConfigPropertyNames);if(config===null){return null;}let formFactor=config.formFactor;if(formFactor===undefined){if(untrusted.formFactor===undefined){formFactor=FormFactor$1.Large;}else {return null;}}const recordTypeId=config.recordTypeId===undefined?MASTER_RECORD_TYPE_ID$4:config.recordTypeId;const optionalFields=config.optionalFields===undefined?[]:config.optionalFields;return _objectSpread$5({},config,{formFactor,recordTypeId,optionalFields});}function cache$7(lds,config){const{formFactor,optionalFields,recordTypeId}=config;const request=getUiApiRecordDefaultsCreateByObjectApiName({urlParams:{objectApiName:config.objectApiName},queryParams:{formFactor,optionalFields,recordTypeId}});const{key}=request;const selectorKey=`${key}__selector`;/**
         * getRecordCreateDefaults returns a value that includes a map of ObjectInfos,
         * a layout and a record. The returned record includes fields that are not
         * known to the client. Because we don't know what the return shape will be,
         * we have to store a selector from a previous response and see if we can
         * extract those values back out.
         *
         * cacheSnapshot is the cached selector from a previous request. It is just
         * a stashed selector
         */const cacheSnapshot=lds.storeLookup({recordId:selectorKey,node:{kind:'Fragment',opaque:true},variables:{}});// We've seen this request before
    if(isFulfilledSnapshot$1(cacheSnapshot)){const snapshot=lds.storeLookup(cacheSnapshot.data);// Cache hit
    if(isFulfilledSnapshot$1(snapshot)){return snapshot;}}return null;}const factory$e=lds=>{return refreshable$1(untrusted=>{const config=coerceConfigWithDefaults$5(untrusted);if(config===null){return null;}const snapshot=cache$7(lds,config);if(snapshot!==null){return snapshot;}return network$7(lds,config);},untrusted=>{const config=coerceConfigWithDefaults$5(untrusted);if(config===null){throw new Error('Refresh should not be called with partial configuration');}return network$7(lds,config);});};/**
     * Returns the object API name.
     * @param value The value from which to get the object API name.
     * @returns The object API name.
     */function getObjectApiNamesArray(value){const valueArray=isArray$3(value)?value:[value];const array=[];for(let i=0,len=valueArray.length;i<len;i+=1){const item=valueArray[i];const apiName=getObjectApiName$1(item);if(apiName===undefined){return undefined;}push$1.call(array,apiName);}if(array.length===0){return undefined;}return dedupe(array).sort();}function validate$G(obj,path='PlatformActionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_actionListContext=obj.actionListContext;const path_actionListContext=path+'.actionListContext';if(typeof obj_actionListContext!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_actionListContext+'" (at "'+path_actionListContext+'")');}const obj_actionTarget=obj.actionTarget;const path_actionTarget=path+'.actionTarget';let obj_actionTarget_union0=null;const obj_actionTarget_union0_error=(()=>{if(typeof obj_actionTarget!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_actionTarget+'" (at "'+path_actionTarget+'")');}})();if(obj_actionTarget_union0_error!=null){obj_actionTarget_union0=obj_actionTarget_union0_error.message;}let obj_actionTarget_union1=null;const obj_actionTarget_union1_error=(()=>{if(obj_actionTarget!==null){return new TypeError('Expected "null" but received "'+typeof obj_actionTarget+'" (at "'+path_actionTarget+'")');}})();if(obj_actionTarget_union1_error!=null){obj_actionTarget_union1=obj_actionTarget_union1_error.message;}if(obj_actionTarget_union0&&obj_actionTarget_union1){let message='Object doesn\'t match union (at "'+path_actionTarget+'")';message+='\n'+obj_actionTarget_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_actionTarget_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_actionTargetType=obj.actionTargetType;const path_actionTargetType=path+'.actionTargetType';let obj_actionTargetType_union0=null;const obj_actionTargetType_union0_error=(()=>{if(typeof obj_actionTargetType!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_actionTargetType+'" (at "'+path_actionTargetType+'")');}})();if(obj_actionTargetType_union0_error!=null){obj_actionTargetType_union0=obj_actionTargetType_union0_error.message;}let obj_actionTargetType_union1=null;const obj_actionTargetType_union1_error=(()=>{if(obj_actionTargetType!==null){return new TypeError('Expected "null" but received "'+typeof obj_actionTargetType+'" (at "'+path_actionTargetType+'")');}})();if(obj_actionTargetType_union1_error!=null){obj_actionTargetType_union1=obj_actionTargetType_union1_error.message;}if(obj_actionTargetType_union0&&obj_actionTargetType_union1){let message='Object doesn\'t match union (at "'+path_actionTargetType+'")';message+='\n'+obj_actionTargetType_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_actionTargetType_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_apiName=obj.apiName;const path_apiName=path+'.apiName';if(typeof obj_apiName!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_apiName+'" (at "'+path_apiName+'")');}const obj_externalId=obj.externalId;const path_externalId=path+'.externalId';if(typeof obj_externalId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_externalId+'" (at "'+path_externalId+'")');}const obj_iconUrl=obj.iconUrl;const path_iconUrl=path+'.iconUrl';let obj_iconUrl_union0=null;const obj_iconUrl_union0_error=(()=>{if(typeof obj_iconUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union0_error!=null){obj_iconUrl_union0=obj_iconUrl_union0_error.message;}let obj_iconUrl_union1=null;const obj_iconUrl_union1_error=(()=>{if(obj_iconUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_iconUrl+'" (at "'+path_iconUrl+'")');}})();if(obj_iconUrl_union1_error!=null){obj_iconUrl_union1=obj_iconUrl_union1_error.message;}if(obj_iconUrl_union0&&obj_iconUrl_union1){let message='Object doesn\'t match union (at "'+path_iconUrl+'")';message+='\n'+obj_iconUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_iconUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_id=obj.id;const path_id=path+'.id';if(typeof obj_id!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_id+'" (at "'+path_id+'")');}const obj_isMassAction=obj.isMassAction;const path_isMassAction=path+'.isMassAction';if(typeof obj_isMassAction!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_isMassAction+'" (at "'+path_isMassAction+'")');}const obj_label=obj.label;const path_label=path+'.label';if(typeof obj_label!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_label+'" (at "'+path_label+'")');}const obj_primaryColor=obj.primaryColor;const path_primaryColor=path+'.primaryColor';let obj_primaryColor_union0=null;const obj_primaryColor_union0_error=(()=>{if(typeof obj_primaryColor!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_primaryColor+'" (at "'+path_primaryColor+'")');}})();if(obj_primaryColor_union0_error!=null){obj_primaryColor_union0=obj_primaryColor_union0_error.message;}let obj_primaryColor_union1=null;const obj_primaryColor_union1_error=(()=>{if(obj_primaryColor!==null){return new TypeError('Expected "null" but received "'+typeof obj_primaryColor+'" (at "'+path_primaryColor+'")');}})();if(obj_primaryColor_union1_error!=null){obj_primaryColor_union1=obj_primaryColor_union1_error.message;}if(obj_primaryColor_union0&&obj_primaryColor_union1){let message='Object doesn\'t match union (at "'+path_primaryColor+'")';message+='\n'+obj_primaryColor_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_primaryColor_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_relatedListRecordId=obj.relatedListRecordId;const path_relatedListRecordId=path+'.relatedListRecordId';let obj_relatedListRecordId_union0=null;const obj_relatedListRecordId_union0_error=(()=>{if(typeof obj_relatedListRecordId!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_relatedListRecordId+'" (at "'+path_relatedListRecordId+'")');}})();if(obj_relatedListRecordId_union0_error!=null){obj_relatedListRecordId_union0=obj_relatedListRecordId_union0_error.message;}let obj_relatedListRecordId_union1=null;const obj_relatedListRecordId_union1_error=(()=>{if(obj_relatedListRecordId!==null){return new TypeError('Expected "null" but received "'+typeof obj_relatedListRecordId+'" (at "'+path_relatedListRecordId+'")');}})();if(obj_relatedListRecordId_union1_error!=null){obj_relatedListRecordId_union1=obj_relatedListRecordId_union1_error.message;}if(obj_relatedListRecordId_union0&&obj_relatedListRecordId_union1){let message='Object doesn\'t match union (at "'+path_relatedListRecordId+'")';message+='\n'+obj_relatedListRecordId_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_relatedListRecordId_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_relatedSourceObject=obj.relatedSourceObject;const path_relatedSourceObject=path+'.relatedSourceObject';let obj_relatedSourceObject_union0=null;const obj_relatedSourceObject_union0_error=(()=>{if(typeof obj_relatedSourceObject!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_relatedSourceObject+'" (at "'+path_relatedSourceObject+'")');}})();if(obj_relatedSourceObject_union0_error!=null){obj_relatedSourceObject_union0=obj_relatedSourceObject_union0_error.message;}let obj_relatedSourceObject_union1=null;const obj_relatedSourceObject_union1_error=(()=>{if(obj_relatedSourceObject!==null){return new TypeError('Expected "null" but received "'+typeof obj_relatedSourceObject+'" (at "'+path_relatedSourceObject+'")');}})();if(obj_relatedSourceObject_union1_error!=null){obj_relatedSourceObject_union1=obj_relatedSourceObject_union1_error.message;}if(obj_relatedSourceObject_union0&&obj_relatedSourceObject_union1){let message='Object doesn\'t match union (at "'+path_relatedSourceObject+'")';message+='\n'+obj_relatedSourceObject_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_relatedSourceObject_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_section=obj.section;const path_section=path+'.section';let obj_section_union0=null;const obj_section_union0_error=(()=>{if(typeof obj_section!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_section+'" (at "'+path_section+'")');}})();if(obj_section_union0_error!=null){obj_section_union0=obj_section_union0_error.message;}let obj_section_union1=null;const obj_section_union1_error=(()=>{if(obj_section!==null){return new TypeError('Expected "null" but received "'+typeof obj_section+'" (at "'+path_section+'")');}})();if(obj_section_union1_error!=null){obj_section_union1=obj_section_union1_error.message;}if(obj_section_union0&&obj_section_union1){let message='Object doesn\'t match union (at "'+path_section+'")';message+='\n'+obj_section_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_section_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_sourceObject=obj.sourceObject;const path_sourceObject=path+'.sourceObject';if(typeof obj_sourceObject!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_sourceObject+'" (at "'+path_sourceObject+'")');}const obj_subtype=obj.subtype;const path_subtype=path+'.subtype';let obj_subtype_union0=null;const obj_subtype_union0_error=(()=>{if(typeof obj_subtype!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_subtype+'" (at "'+path_subtype+'")');}})();if(obj_subtype_union0_error!=null){obj_subtype_union0=obj_subtype_union0_error.message;}let obj_subtype_union1=null;const obj_subtype_union1_error=(()=>{if(obj_subtype!==null){return new TypeError('Expected "null" but received "'+typeof obj_subtype+'" (at "'+path_subtype+'")');}})();if(obj_subtype_union1_error!=null){obj_subtype_union1=obj_subtype_union1_error.message;}if(obj_subtype_union0&&obj_subtype_union1){let message='Object doesn\'t match union (at "'+path_subtype+'")';message+='\n'+obj_subtype_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_subtype_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_targetObject=obj.targetObject;const path_targetObject=path+'.targetObject';let obj_targetObject_union0=null;const obj_targetObject_union0_error=(()=>{if(typeof obj_targetObject!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_targetObject+'" (at "'+path_targetObject+'")');}})();if(obj_targetObject_union0_error!=null){obj_targetObject_union0=obj_targetObject_union0_error.message;}let obj_targetObject_union1=null;const obj_targetObject_union1_error=(()=>{if(obj_targetObject!==null){return new TypeError('Expected "null" but received "'+typeof obj_targetObject+'" (at "'+path_targetObject+'")');}})();if(obj_targetObject_union1_error!=null){obj_targetObject_union1=obj_targetObject_union1_error.message;}if(obj_targetObject_union0&&obj_targetObject_union1){let message='Object doesn\'t match union (at "'+path_targetObject+'")';message+='\n'+obj_targetObject_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_targetObject_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_targetUrl=obj.targetUrl;const path_targetUrl=path+'.targetUrl';let obj_targetUrl_union0=null;const obj_targetUrl_union0_error=(()=>{if(typeof obj_targetUrl!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_targetUrl+'" (at "'+path_targetUrl+'")');}})();if(obj_targetUrl_union0_error!=null){obj_targetUrl_union0=obj_targetUrl_union0_error.message;}let obj_targetUrl_union1=null;const obj_targetUrl_union1_error=(()=>{if(obj_targetUrl!==null){return new TypeError('Expected "null" but received "'+typeof obj_targetUrl+'" (at "'+path_targetUrl+'")');}})();if(obj_targetUrl_union1_error!=null){obj_targetUrl_union1=obj_targetUrl_union1_error.message;}if(obj_targetUrl_union0&&obj_targetUrl_union1){let message='Object doesn\'t match union (at "'+path_targetUrl+'")';message+='\n'+obj_targetUrl_union0.split('\n').map(line=>'\t'+line).join('\n');message+='\n'+obj_targetUrl_union1.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}const obj_type=obj.type;const path_type=path+'.type';if(typeof obj_type!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_type+'" (at "'+path_type+'")');}})();return v_error===undefined?null:v_error;}const select$l=function PlatformActionRepresentationSelect(){return {kind:'Fragment',selections:[{name:'actionListContext',kind:'Scalar'},{name:'actionTarget',kind:'Scalar'},{name:'actionTargetType',kind:'Scalar'},{name:'apiName',kind:'Scalar'},{name:'externalId',kind:'Scalar'},{name:'iconUrl',kind:'Scalar'},{name:'id',kind:'Scalar'},{name:'isMassAction',kind:'Scalar'},{name:'label',kind:'Scalar'},{name:'primaryColor',kind:'Scalar'},{name:'relatedListRecordId',kind:'Scalar'},{name:'relatedSourceObject',kind:'Scalar'},{name:'section',kind:'Scalar'},{name:'sourceObject',kind:'Scalar'},{name:'subtype',kind:'Scalar'},{name:'targetObject',kind:'Scalar'},{name:'targetUrl',kind:'Scalar'},{name:'type',kind:'Scalar'}]};};function equals$p(existing,incoming){const existing_actionListContext=existing.actionListContext;const incoming_actionListContext=incoming.actionListContext;if(!(existing_actionListContext===incoming_actionListContext)){return false;}const existing_apiName=existing.apiName;const incoming_apiName=incoming.apiName;if(!(existing_apiName===incoming_apiName)){return false;}const existing_externalId=existing.externalId;const incoming_externalId=incoming.externalId;if(!(existing_externalId===incoming_externalId)){return false;}const existing_id=existing.id;const incoming_id=incoming.id;if(!(existing_id===incoming_id)){return false;}const existing_isMassAction=existing.isMassAction;const incoming_isMassAction=incoming.isMassAction;if(!(existing_isMassAction===incoming_isMassAction)){return false;}const existing_label=existing.label;const incoming_label=incoming.label;if(!(existing_label===incoming_label)){return false;}const existing_sourceObject=existing.sourceObject;const incoming_sourceObject=incoming.sourceObject;if(!(existing_sourceObject===incoming_sourceObject)){return false;}const existing_type=existing.type;const incoming_type=incoming.type;if(!(existing_type===incoming_type)){return false;}const existing_actionTarget=existing.actionTarget;const incoming_actionTarget=incoming.actionTarget;if(!(existing_actionTarget===incoming_actionTarget)){return false;}const existing_actionTargetType=existing.actionTargetType;const incoming_actionTargetType=incoming.actionTargetType;if(!(existing_actionTargetType===incoming_actionTargetType)){return false;}const existing_iconUrl=existing.iconUrl;const incoming_iconUrl=incoming.iconUrl;if(!(existing_iconUrl===incoming_iconUrl)){return false;}const existing_primaryColor=existing.primaryColor;const incoming_primaryColor=incoming.primaryColor;if(!(existing_primaryColor===incoming_primaryColor)){return false;}const existing_relatedListRecordId=existing.relatedListRecordId;const incoming_relatedListRecordId=incoming.relatedListRecordId;if(!(existing_relatedListRecordId===incoming_relatedListRecordId)){return false;}const existing_relatedSourceObject=existing.relatedSourceObject;const incoming_relatedSourceObject=incoming.relatedSourceObject;if(!(existing_relatedSourceObject===incoming_relatedSourceObject)){return false;}const existing_section=existing.section;const incoming_section=incoming.section;if(!(existing_section===incoming_section)){return false;}const existing_subtype=existing.subtype;const incoming_subtype=incoming.subtype;if(!(existing_subtype===incoming_subtype)){return false;}const existing_targetObject=existing.targetObject;const incoming_targetObject=incoming.targetObject;if(!(existing_targetObject===incoming_targetObject)){return false;}const existing_targetUrl=existing.targetUrl;const incoming_targetUrl=incoming.targetUrl;if(!(existing_targetUrl===incoming_targetUrl)){return false;}return true;}function validate$H(obj,path='EntityActionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_actions=obj.actions;const path_actions=path+'.actions';if(!ArrayIsArray$2(obj_actions)){return new TypeError('Expected "array" but received "'+typeof obj_actions+'" (at "'+path_actions+'")');}for(let i=0;i<obj_actions.length;i++){const obj_actions_item=obj_actions[i];const path_actions_item=path_actions+'['+i+']';const referencePlatformActionRepresentationValidationError=validate$G(obj_actions_item,path_actions_item);if(referencePlatformActionRepresentationValidationError!==null){let message='Object doesn\'t match PlatformActionRepresentation (at "'+path_actions_item+'")\n';message+=referencePlatformActionRepresentationValidationError.message.split('\n').map(line=>'\t'+line).join('\n');return new TypeError(message);}}const obj_links=obj.links;const path_links=path+'.links';if(!ArrayIsArray$2(obj_links)){return new TypeError('Expected "array" but received "'+typeof obj_links+'" (at "'+path_links+'")');}for(let i=0;i<obj_links.length;i++){const obj_links_item=obj_links[i];const path_links_item=path_links+'['+i+']';if(typeof obj_links_item!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_links_item+'" (at "'+path_links_item+'")');}}const obj_url=obj.url;const path_url=path+'.url';if(typeof obj_url!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_url+'" (at "'+path_url+'")');}})();return v_error===undefined?null:v_error;}function keyBuilder$g(config){return 'UiApi::EntityActionRepresentation:'+config.url;}function normalize$m(input,existing,path,lds,store,timestamp){return input;}const select$m=function EntityActionRepresentationSelect(){const{selections:PlatformActionRepresentation__selections,opaque:PlatformActionRepresentation__opaque}=select$l();return {kind:'Fragment',selections:[{name:'actions',kind:'Object',plural:true,selections:PlatformActionRepresentation__selections}]};};function equals$q(existing,incoming){const existing_url=existing.url;const incoming_url=incoming.url;if(!(existing_url===incoming_url)){return false;}const existing_actions=existing.actions;const incoming_actions=incoming.actions;const equals_actions_items=equalsArray(existing_actions,incoming_actions,(existing_actions_item,incoming_actions_item)=>{if(!equals$p(existing_actions_item,incoming_actions_item)){return false;}});if(equals_actions_items===false){return false;}const existing_links=existing.links;const incoming_links=incoming.links;const equals_links_items=equalsArray(existing_links,incoming_links,(existing_links_item,incoming_links_item)=>{if(!(existing_links_item===incoming_links_item)){return false;}});if(equals_links_items===false){return false;}return true;}const ingest$m=function EntityActionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$H(input);if(validateError!==null){throw validateError;}}const key=keyBuilder$g({url:input.url});let incomingRecord=normalize$m(input,store.records[key],{fullPath:key,parent:path.parent});const existingRecord=store.records[key];if(existingRecord===undefined||equals$q(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}return key;};const TTL$2=300000;function validate$I(obj,path='ActionRepresentation'){const v_error=(()=>{if(typeof obj!=='object'||ArrayIsArray$2(obj)||obj===null){return new TypeError('Expected "object" but received "'+typeof obj+'" (at "'+path+'")');}const obj_actions=obj.actions;const path_actions=path+'.actions';if(typeof obj_actions!=='object'||ArrayIsArray$2(obj_actions)||obj_actions===null){return new TypeError('Expected "object" but received "'+typeof obj_actions+'" (at "'+path_actions+'")');}const obj_actions_keys=ObjectKeys$1(obj_actions);for(let i=0;i<obj_actions_keys.length;i++){const key=obj_actions_keys[i];const obj_actions_prop=obj_actions[key];}const obj_eTag=obj.eTag;const path_eTag=path+'.eTag';if(typeof obj_eTag!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_eTag+'" (at "'+path_eTag+'")');}const obj_url=obj.url;const path_url=path+'.url';if(typeof obj_url!=='string'){return new TypeError('Expected "string" but received "'+typeof obj_url+'" (at "'+path_url+'")');}})();return v_error===undefined?null:v_error;}function normalize$n(input,existing,path,lds,store,timestamp){const input_actions=input.actions;const input_actions_id=path.fullPath+'__actions';const input_actions_keys=Object.keys(input_actions);const input_actions_length=input_actions_keys.length;for(let i=0;i<input_actions_length;i++){const key=input_actions_keys[i];const input_actions_prop=input_actions[key];const input_actions_prop_id=input_actions_id+'__'+key;input_actions[key]={__ref:ingest$m(input_actions_prop,{fullPath:input_actions_prop_id,parent:{data:input,key:path.fullPath,existing:existing}},lds,store)};}return input;}const select$n=function ActionRepresentationSelect(){const{selections:EntityActionRepresentation__selections,opaque:EntityActionRepresentation__opaque}=select$m();return {kind:'Fragment',selections:[{name:'actions',kind:'Link',map:true,selections:EntityActionRepresentation__selections}]};};function equals$r(existing,incoming){const existing_eTag=existing.eTag;const incoming_eTag=incoming.eTag;if(!(existing_eTag===incoming_eTag)){return false;}const existing_url=existing.url;const incoming_url=incoming.url;if(!(existing_url===incoming_url)){return false;}const existing_actions=existing.actions;const incoming_actions=incoming.actions;const equals_actions_props=equalsObject(existing_actions,incoming_actions,(existing_actions_prop,incoming_actions_prop)=>{if(!(existing_actions_prop.__ref===incoming_actions_prop.__ref)){return false;}});if(equals_actions_props===false){return false;}return true;}const ingest$n=function ActionRepresentationIngest(input,path,lds,store,timestamp){{const validateError=validate$I(input);if(validateError!==null){throw validateError;}}const key=path.fullPath;let incomingRecord=normalize$n(input,store.records[key],{fullPath:key,parent:path.parent},lds,store);const existingRecord=store.records[key];if(existingRecord===undefined||equals$r(existingRecord,incomingRecord)===false){store.publish(key,incomingRecord);}store.setExpiration(key,timestamp+300000);return key;};function getUiApiActionsLookupByObjectApiNames(config){const key='ActionRepresentation('+'actionTypes:'+config.queryParams.actionTypes+','+'formFactor:'+config.queryParams.formFactor+','+'sections:'+config.queryParams.sections+','+'objectApiNames:'+config.urlParams.objectApiNames+')';const headers={};return {path:'/services/data/v48.0/ui-api/actions/lookup/'+config.urlParams.objectApiNames+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$n,headers};}const getLookupActions_ConfigPropertyNames={displayName:'getLookupActions',parameters:{required:['objectApiNames'],optional:['actionTypes','formFactor','sections']}};function coerceConfig$f(config){const coercedConfig={};const objectApiNames=getObjectApiNamesArray(config.objectApiNames);if(objectApiNames!==undefined){coercedConfig.objectApiNames=objectApiNames;}const actionTypes=toSortedStringArray(config.actionTypes);if(actionTypes!==undefined){coercedConfig.actionTypes=actionTypes;}const formFactor=coerceFormFactor(config.formFactor);if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const sections=toSortedStringArray(config.sections);if(sections!==undefined){coercedConfig.sections=sections;}return coercedConfig;}function typeCheckConfig$h(untrustedConfig){const config={};const untrustedConfig_objectApiNames=untrustedConfig.objectApiNames;if(ArrayIsArray$1$1$1(untrustedConfig_objectApiNames)){const untrustedConfig_objectApiNames_array=[];for(let i=0,arrayLength=untrustedConfig_objectApiNames.length;i<arrayLength;i++){const untrustedConfig_objectApiNames_item=untrustedConfig_objectApiNames[i];if(typeof untrustedConfig_objectApiNames_item==='string'){untrustedConfig_objectApiNames_array.push(untrustedConfig_objectApiNames_item);}}config.objectApiNames=untrustedConfig_objectApiNames_array;}const untrustedConfig_actionTypes=untrustedConfig.actionTypes;if(ArrayIsArray$1$1$1(untrustedConfig_actionTypes)){const untrustedConfig_actionTypes_array=[];for(let i=0,arrayLength=untrustedConfig_actionTypes.length;i<arrayLength;i++){const untrustedConfig_actionTypes_item=untrustedConfig_actionTypes[i];if(typeof untrustedConfig_actionTypes_item==='string'){untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);}}config.actionTypes=untrustedConfig_actionTypes_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_sections=untrustedConfig.sections;if(ArrayIsArray$1$1$1(untrustedConfig_sections)){const untrustedConfig_sections_array=[];for(let i=0,arrayLength=untrustedConfig_sections.length;i<arrayLength;i++){const untrustedConfig_sections_item=untrustedConfig_sections[i];if(typeof untrustedConfig_sections_item==='string'){untrustedConfig_sections_array.push(untrustedConfig_sections_item);}}config.sections=untrustedConfig_sections_array;}return config;}function validateAdapterConfig$h(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames);}const coercedConfig=coerceConfig$f(untrustedConfig);const config=typeCheckConfig$h(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}return config;}function buildInMemorySnapshot$4(lds,config){const request=getUiApiActionsLookupByObjectApiNames({urlParams:{objectApiNames:config.objectApiNames},queryParams:{actionTypes:config.actionTypes,formFactor:config.formFactor,sections:config.sections}});const selector={recordId:request.key,node:select$n(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$2(lds,config,override){const request=getUiApiActionsLookupByObjectApiNames({urlParams:{objectApiNames:config.objectApiNames},queryParams:{actionTypes:config.actionTypes,formFactor:config.formFactor,sections:config.sections}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$4(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error,TTL$2);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getLookupActionsAdapterFactory=lds=>{return refreshable$1(// Create snapshot either via a cache hit or via the network
    function getLookupActions(untrustedConfig){const config=validateAdapterConfig$h(untrustedConfig,getLookupActions_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$4(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED){return cacheSnapshot;}return buildNetworkSnapshot$2(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$h(untrustedConfig,getLookupActions_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getLookupActions" refresh function');}return buildNetworkSnapshot$2(lds,config,{headers:{'Cache-Control':'no-cache'}});});};function getUiApiActionsRecordByRecordId(config){const key='ActionRepresentation('+'actionTypes:'+config.queryParams.actionTypes+','+'apiNames:'+config.queryParams.apiNames+','+'formFactor:'+config.queryParams.formFactor+','+'retrievalMode:'+config.queryParams.retrievalMode+','+'sections:'+config.queryParams.sections+','+'recordId:'+config.urlParams.recordId+')';const headers={};return {path:'/services/data/v48.0/ui-api/actions/record/'+config.urlParams.recordId+'',method:'get',body:null,urlParams:config.urlParams,queryParams:config.queryParams,key:key,ingest:ingest$n,headers};}const onOfConfigPropertiesIdentifier$1=['sections','apiNames'];const getRecordActions_ConfigPropertyNames={displayName:'getRecordActions',parameters:{required:['recordId'],optional:['actionTypes','apiNames','formFactor','retrievalMode','sections']}};function coerceConfig$g(config){const coercedConfig={};const recordId=getRecordId18Array(config.recordId);if(recordId!==undefined){coercedConfig.recordId=recordId;}const actionTypes=config.actionTypes;if(actionTypes!==undefined){coercedConfig.actionTypes=actionTypes;}const apiNames=toSortedStringArray(config.apiNames);if(apiNames!==undefined){coercedConfig.apiNames=apiNames;}const formFactor=coerceFormFactor(config.formFactor);if(formFactor!==undefined){coercedConfig.formFactor=formFactor;}const retrievalMode=config.retrievalMode;if(retrievalMode!==undefined){coercedConfig.retrievalMode=retrievalMode;}const sections=toSortedStringArray(config.sections);if(sections!==undefined){coercedConfig.sections=sections;}return coercedConfig;}function typeCheckConfig$i(untrustedConfig){const config={};const untrustedConfig_recordId=untrustedConfig.recordId;if(ArrayIsArray$1$1$1(untrustedConfig_recordId)){const untrustedConfig_recordId_array=[];for(let i=0,arrayLength=untrustedConfig_recordId.length;i<arrayLength;i++){const untrustedConfig_recordId_item=untrustedConfig_recordId[i];if(typeof untrustedConfig_recordId_item==='string'){untrustedConfig_recordId_array.push(untrustedConfig_recordId_item);}}config.recordId=untrustedConfig_recordId_array;}const untrustedConfig_actionTypes=untrustedConfig.actionTypes;if(ArrayIsArray$1$1$1(untrustedConfig_actionTypes)){const untrustedConfig_actionTypes_array=[];for(let i=0,arrayLength=untrustedConfig_actionTypes.length;i<arrayLength;i++){const untrustedConfig_actionTypes_item=untrustedConfig_actionTypes[i];if(typeof untrustedConfig_actionTypes_item==='string'){untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);}}config.actionTypes=untrustedConfig_actionTypes_array;}const untrustedConfig_apiNames=untrustedConfig.apiNames;if(ArrayIsArray$1$1$1(untrustedConfig_apiNames)){const untrustedConfig_apiNames_array=[];for(let i=0,arrayLength=untrustedConfig_apiNames.length;i<arrayLength;i++){const untrustedConfig_apiNames_item=untrustedConfig_apiNames[i];if(typeof untrustedConfig_apiNames_item==='string'){untrustedConfig_apiNames_array.push(untrustedConfig_apiNames_item);}}config.apiNames=untrustedConfig_apiNames_array;}const untrustedConfig_formFactor=untrustedConfig.formFactor;if(typeof untrustedConfig_formFactor==='string'){config.formFactor=untrustedConfig_formFactor;}const untrustedConfig_retrievalMode=untrustedConfig.retrievalMode;if(typeof untrustedConfig_retrievalMode==='string'){config.retrievalMode=untrustedConfig_retrievalMode;}const untrustedConfig_sections=untrustedConfig.sections;if(ArrayIsArray$1$1$1(untrustedConfig_sections)){const untrustedConfig_sections_array=[];for(let i=0,arrayLength=untrustedConfig_sections.length;i<arrayLength;i++){const untrustedConfig_sections_item=untrustedConfig_sections[i];if(typeof untrustedConfig_sections_item==='string'){untrustedConfig_sections_array.push(untrustedConfig_sections_item);}}config.sections=untrustedConfig_sections_array;}return config;}function validateAdapterConfig$i(untrustedConfig,configPropertyNames){if(!untrustedIsObject$1$1(untrustedConfig)){return null;}{validateConfig$2(untrustedConfig,configPropertyNames,onOfConfigPropertiesIdentifier$1);}const coercedConfig=coerceConfig$g(untrustedConfig);const config=typeCheckConfig$i(coercedConfig);if(!areRequiredParametersPresent(config,configPropertyNames)){return null;}if(config.sections===undefined&&config.apiNames===undefined){return null;}return config;}function buildInMemorySnapshot$5(lds,config){const request=getUiApiActionsRecordByRecordId({urlParams:{recordId:config.recordId},queryParams:{actionTypes:config.actionTypes,apiNames:config.apiNames,formFactor:config.formFactor,retrievalMode:config.retrievalMode,sections:config.sections}});const selector={recordId:request.key,node:select$n(),variables:{}};return lds.storeLookup(selector);}function buildNetworkSnapshot$3(lds,config,override){const request=getUiApiActionsRecordByRecordId({urlParams:{recordId:config.recordId},queryParams:{actionTypes:config.actionTypes,apiNames:config.apiNames,formFactor:config.formFactor,retrievalMode:config.retrievalMode,sections:config.sections}});return lds.dispatchResourceRequest(request,override).then(response=>{const{body}=response;lds.storeIngest(request.key,request,body);lds.storeBroadcast();return buildInMemorySnapshot$5(lds,config);},error=>{lds.storeIngestFetchResponse(request.key,error,TTL$2);lds.storeBroadcast();return lds.errorSnapshot(error);});}const getRecordActionsAdapterFactory=lds=>{return refreshable$1(// Create snapshot either via a cache hit or via the network
    function getRecordActions(untrustedConfig){const config=validateAdapterConfig$i(untrustedConfig,getRecordActions_ConfigPropertyNames);// Invalid or incomplete config
    if(config===null){return null;}const cacheSnapshot=buildInMemorySnapshot$5(lds,config);// Cache Hit
    if(cacheSnapshot.state===SNAPSHOT_STATE_FULFILLED){return cacheSnapshot;}return buildNetworkSnapshot$3(lds,config);},// Refresh snapshot
    // TODO W-6900511 - This currently passes the untrusted config
    // because we don't have a way to pass the validated config back to LDS
    untrustedConfig=>{const config=validateAdapterConfig$i(untrustedConfig,getRecordActions_ConfigPropertyNames);// This should never happen
    if(config===null){throw new Error('Invalid config passed to "getRecordActions" refresh function');}return buildNetworkSnapshot$3(lds,config,{headers:{'Cache-Control':'no-cache'}});});};const{push:push$2}=Array.prototype;const{entries,keys:keys$4}=Object;const{hasOwnProperty:hasOwnProperty$2}=Object.prototype;const{parse:parse$1,stringify:stringify$4}=JSON;// No need to pass the actual record key `lds.ingestStore`. The `RecordRepresentation.ts#ingest`
    // function extracts the appropriate record id from the ingested record.
    const INGEST_KEY='';// A fake record resource request to trick the LDS engine to ingest records coming from ADS.
    const FAKE_RECORD_REQUEST={ingest:ingest$2};const RECORD_ID_PREFIX='UiApi::RecordRepresentation:';const RECORD_ID_REGEXP=/^UiApi::RecordRepresentation:([a-zA-Z0-9])+$/;const MASTER_RECORD_TYPE_ID$1$1='012000000000000AAA';function isGraphNode$1(node){return node!==null&&node.type==='Node';}function isSpanningRecord$1(fieldValue){return fieldValue!==null&&typeof fieldValue==='object';}/**
     * Returns a shallow copy of a record with its field values if it is a scalar and a reference and a
     * a RecordRepresentation with no field if the value if a spanning record.
     * It returns null if the record contains any pending field.
     */function getShallowRecord(lds,storeRecordId){const recordNode=lds.getNode(storeRecordId);if(!isGraphNode$1(recordNode)){return null;}const fieldsCopy={};const copy=_objectSpread$5({},recordNode.retrieve(),{fields:fieldsCopy,childRelationships:{}});const fieldsNode=recordNode.object('fields');const fieldNames=fieldsNode.keys();for(let i=0,len=fieldNames.length;i<len;i++){let fieldCopy;const fieldName=fieldNames[i];const fieldLink=fieldsNode.link(fieldName);if(fieldLink.isPending()===true){return null;}const fieldNode=fieldLink.follow();if(!isGraphNode$1(fieldNode)){continue;}const{displayValue,value}=fieldNode.retrieve();if(fieldNode.isScalar('value')){fieldCopy={displayValue:displayValue,value:value};}else {const spanningRecordLink=fieldNode.link('value');if(spanningRecordLink.isPending()===true){return null;}const spanningRecordNode=spanningRecordLink.follow();if(!isGraphNode$1(spanningRecordNode)){continue;}fieldCopy={displayValue,value:_objectSpread$5({},spanningRecordNode.retrieve(),{fields:{},childRelationships:{}})};}fieldsCopy[fieldName]=fieldCopy;}return copy;}/**
     * Returns the ADS object metadata representation for a specific record.
     */function getObjectMetadata(lds,record){const{data:objectInfo}=lds.storeLookup({recordId:keyBuilder$8({apiName:record.apiName}),node:{kind:'Fragment',opaque:true},variables:{}});if(objectInfo!==undefined){let nameField='Name';// Extract the entity name field from the object info. In the case where there are multiple
    // field names then pick up the first one.
    if(objectInfo.nameFields.length!==0&&objectInfo.nameFields.indexOf('Name')===-1){nameField=objectInfo.nameFields[0];}return {_nameField:nameField,_entityLabel:objectInfo.label,_keyPrefix:objectInfo.keyPrefix};}return {_nameField:'Name',_entityLabel:record.apiName,_keyPrefix:record.id.substring(0,3)};}/**
     * RecordGvp can send records back to ADS with record types incorrectly set to the master
     * record type. Since there are no known legitimate scenarios where a record can change from a
     * non-master record type back to the master record type, we assume such a transition
     * indicates a RecordGvp mistake. This function checks for that scenario and overwrites the
     * incoming ADS record type information with what we already have in the store when it
     * occurs.
     *
     * @param lds LDS
     * @param record record from ADS, will be fixed in situ
     */function fixRecordTypes(lds,record){// non-master record types should always be correct
    if(record.recordTypeId===MASTER_RECORD_TYPE_ID$1$1){const key=keyBuilder({recordId:record.id});const recordNode=lds.getNode(key);if(isGraphNode$1(recordNode)&&recordNode.scalar('recordTypeId')!==MASTER_RECORD_TYPE_ID$1$1){// ignore bogus incoming record type information & keep what we have
    record.recordTypeId=recordNode.scalar('recordTypeId');record.recordTypeInfo=recordNode.object('recordTypeInfo').data;}}// recurse on nested records
    const fieldKeys=keys$4(record.fields);const fieldKeysLen=fieldKeys.length;for(let i=0;i<fieldKeysLen;++i){const fieldValue=record.fields[fieldKeys[i]].value;if(isSpanningRecord$1(fieldValue)){fixRecordTypes(lds,fieldValue);}}}class AdsBridge$1{constructor(lds){this.lds=lds;this.isRecordEmitLocked=false;}/**
         * This setter invoked by recordLibrary to listen for records ingested by LDS. The passed method
         * is invoked whenever a record is ingested. It may be via getRecord, getRecordUi, getListUi, ...
         */set receiveFromLdsCallback(callback){// Unsubscribe if there is an existing subscription.
    if(this.watchUnsubscribe!==undefined){this.watchUnsubscribe();this.watchUnsubscribe=undefined;}if(callback!==undefined){this.watchUnsubscribe=this.lds.storeWatch(RECORD_ID_PREFIX,entries=>{if(this.isRecordEmitLocked===true){return;}this.emitRecordChanged(entries,callback);});}}/**
         * This method is invoked when a record has been ingested by ADS.
         *
         * ADS may invoke this method with records that are not UIAPI whitelisted so not refreshable by
         * LDS. LDS filters the provided list so it ingests only UIAPI whitelisted records.
         */addRecords(records,uiApiEntityWhitelist){const{lds}=this;let didIngestRecord=false;return this.lockLdsRecordEmit(()=>{for(let i=0;i<records.length;i++){const record=records[i];const{apiName}=record;// Ingest the record if no whitelist is passed or the entity name is whitelisted.
    if(uiApiEntityWhitelist===undefined||uiApiEntityWhitelist[apiName]!=='false'){didIngestRecord=true;// Deep-copy the record to ingest and ingest the record copy. This avoids
    // corrupting the ADS cache since ingestion mutates the passed record.
    const recordCopy=parse$1(stringify$4(record));// Don't let incorrect ADS/RecordGVP recordTypeIds replace a valid record type in our store
    // with the master record type. See W-7302870 for details.
    fixRecordTypes(lds,recordCopy);lds.storeIngest(INGEST_KEY,FAKE_RECORD_REQUEST,recordCopy);}}if(didIngestRecord===true){lds.storeBroadcast();}});}/**
         * This method is invoked whenever a record has been evicted from ADS.
         */evict(recordId){const{lds}=this;const key=keyBuilder({recordId});return this.lockLdsRecordEmit(()=>{lds.storeEvict(key);lds.storeBroadcast();return Promise.resolve();});}/**
         * Gets the list of fields of a record that LDS has in its store. The field list doesn't
         * contains the spanning record fields. ADS uses this list when it loads a record from the
         * server. This is an optimization to make a single roundtrip it queries for all fields required
         * by ADS and LDS.
         */getTrackedFieldsForRecord(recordId){const{lds}=this;const storeRecordId=keyBuilder({recordId});const recordNode=lds.getNode(storeRecordId);if(!isGraphNode$1(recordNode)){return Promise.resolve([]);}const apiName=recordNode.scalar('apiName');const fieldNames=recordNode.object('fields').keys();// Prefix all the fields with the record API name.
    const qualifiedFieldNames=[];for(let i=0,len=fieldNames.length;i<len;i++){push$2.call(qualifiedFieldNames,`${apiName}.${fieldNames[i]}`);}return Promise.resolve(qualifiedFieldNames);}/**
         * Prevents the bridge to emit record change during the execution of the callback.
         * This methods should wrap all the LDS store mutation done by the bridge. It prevents LDS store
         * mutations triggered by ADS to be emit back to ADS.
         */lockLdsRecordEmit(callback){this.isRecordEmitLocked=true;try{return callback();}finally{this.isRecordEmitLocked=false;}}/**
         * This method retrieves queries the store with with passed record ids to retrieve their
         * associated records and object info. Note that the passed ids are not Salesforce record id
         * but rather LDS internals store ids.
         */emitRecordChanged(updatedEntries,callback){const{lds}=this;let shouldEmit=false;const adsRecordMap={};const adsObjectMap={};for(let i=0;i<updatedEntries.length;i++){const storeRecordId=updatedEntries[i].id;// Exclude all the store record ids not matching with the record id pattern.
    // Note: FieldValueRepresentation have the same prefix than RecordRepresentation so we
    // need to filter them out.
    if(!storeRecordId.match(RECORD_ID_REGEXP)){continue;}const record=getShallowRecord(lds,storeRecordId);if(record===null){continue;}const{id,apiName}=record;shouldEmit=true;adsRecordMap[id]={[apiName]:{isPrimary:true,record}};// Extract and add the object metadata to the map if not already present.
    if(!hasOwnProperty$2.call(adsObjectMap,apiName)){adsObjectMap[apiName]=getObjectMetadata(lds,record);}}if(shouldEmit===true){callback(adsRecordMap,adsObjectMap);}}}class AuraFetchResponse{constructor(status,body,headers){this.status=status;this.body=body;this.headers=headers||{};}get statusText(){const{status}=this;switch(status){case HttpStatusCode.Ok:return 'OK';case HttpStatusCode.NotModified:return 'Not Modified';case HttpStatusCode.NotFound:return 'Not Found';case HttpStatusCode.BadRequest:return 'Bad Request';case HttpStatusCode.ServerError:return 'Server Error';default:return `Unexpected HTTP Status Code: ${status}`;}}get ok(){return this.status===200;}}const APEX_BASE_URI='/apex';const ApexController='ApexActionController.execute';function executeApex(resourceRequest){const{body}=resourceRequest;return dispatchApexAction(ApexController,body,{background:false,hotspot:false,longRunning:body.isContinuation});}function dispatchApexAction(endpoint,params,config){return aura.executeGlobalController(endpoint,params,config).then(body=>{// massage aura action response to
    //  headers: { cacheable }
    //  body: returnValue
    return new AuraFetchResponse(HttpStatusCode.Ok,body.returnValue===undefined?null:body.returnValue,// Headers expects properties of [name: string]: string
    // However this is a synthetic header and we want to keep the boolean
    {cacheable:body.cacheable});},err=>{// Handle ConnectedInJava exception shapes
    if(err.data!==undefined&&err.data.statusCode!==undefined){const{data}=err;throw new AuraFetchResponse(data.statusCode,data);}// Handle all the other kind of errors
    throw new AuraFetchResponse(HttpStatusCode.ServerError,err);});}const UI_API_BASE_URI='/services/data/v48.0/ui-api';const ACTION_CONFIG={background:false,hotspot:true,longRunning:false};const actionConfig={action:ACTION_CONFIG};function createOkResponse(body){return new AuraFetchResponse(HttpStatusCode.Ok,body);}/** Invoke an Aura controller with the pass parameters. */function dispatchAction(endpoint,params,config={}){const{action:actionConfig,cache:cacheConfig}=config;const fetchFromNetwork=()=>{return aura.executeGlobalController(endpoint,params,actionConfig).then(body=>{// If a cache is passed, store the action body in the cache before returning the
    // value. Even though `AuraStorage.set` is an asynchronous operation we don't
    // need to wait for the store to resolve/reject before returning the value.
    // Swallow the error to not have an unhandled promise rejection.
    if(cacheConfig!==undefined&&cacheConfig.storage!==null){cacheConfig.storage.set(cacheConfig.key,body).catch(_error=>{});}return createOkResponse(body);},err=>{// Handle ConnectedInJava exception shapes
    if(err.data!==undefined&&err.data.statusCode!==undefined){const{data}=err;throw new AuraFetchResponse(data.statusCode,data);}// Handle all the other kind of errors
    throw new AuraFetchResponse(HttpStatusCode.ServerError,{error:err.message});});};// If no cache is passed or if the action should be refreshed, directly fetch the action from
    // the server.
    if(cacheConfig===undefined||cacheConfig.forceRefresh===true||cacheConfig.storage===null){return fetchFromNetwork();}// Otherwise check for the action body in the cache. If action is not present in the cache or if
    // the cache lookup fails for any reason fallback to the network.
    return cacheConfig.storage.get(cacheConfig.key).then(cacheResult=>{if(cacheResult!==undefined){cacheConfig.statsLogger.logHits();return createOkResponse(cacheResult);}cacheConfig.statsLogger.logMisses();return fetchFromNetwork();},()=>{return fetchFromNetwork();});}/**
     * All the methods exposed out of the UiApiController accept a clientOption config. This method
     * adds methods returns a new params object with the client option if necessary, otherwise it
     * returns the passed params object.
     */function buildUiApiParams(params,resourceRequest){const ifModifiedSince=resourceRequest.headers['If-Modified-Since'];const ifUnmodifiedSince=resourceRequest.headers['If-Unmodified-Since'];let clientOptions={};if(ifModifiedSince!==undefined){clientOptions.ifModifiedSince=ifModifiedSince;}if(ifUnmodifiedSince!==undefined){clientOptions.ifUnmodifiedSince=ifUnmodifiedSince;}return Object.keys(clientOptions).length>0?_objectSpread$5({},params,{clientOptions:clientOptions}):params;}/** Returns true if an action should ignore the network cache data. */function shouldForceRefresh(resourceRequest){const cacheControl=resourceRequest.headers['Cache-Control'];return cacheControl!==undefined||cacheControl==='no-cache';}var UiApiActionsController;(function(UiApiActionsController){UiApiActionsController["GetLookupActions"]="ActionsController.getLookupActions";UiApiActionsController["GetRecordActions"]="ActionsController.getRecordActions";UiApiActionsController["GetRecordEditActions"]="ActionsController.getRecordEditActions";UiApiActionsController["GetRelatedListRecordActions"]="ActionsController.getRelatedListRecordActions";})(UiApiActionsController||(UiApiActionsController={}));const UIAPI_ACTIONS_LOOKUP_PATH=`${UI_API_BASE_URI}/actions/lookup/`;const UIAPI_ACTIONS_RECORD_PATH=`${UI_API_BASE_URI}/actions/record/`;const UIAPI_ACTIONS_RECORD_EDIT='/record-edit';const UIAPI_ACTIONS_RELATED_LIST_RECORD='/related-list-record/';function getLookupActions$1(resourceRequest){const{urlParams:{objectApiNames},queryParams}=resourceRequest;const parameters=buildUiApiParams(_objectSpread$5({objectApiNames},queryParams),resourceRequest);return dispatchAction(UiApiActionsController.GetLookupActions,parameters);}function getRecordActions$1(resourceRequest){const{urlParams:{recordId},queryParams}=resourceRequest;const parameters=buildUiApiParams(_objectSpread$5({recordId},queryParams),resourceRequest);return dispatchAction(UiApiActionsController.GetRecordActions,parameters);}function getRecordEditActions(resourceRequest){const{urlParams:{recordId},queryParams}=resourceRequest;const parameters=buildUiApiParams(_objectSpread$5({recordId},queryParams),resourceRequest);return dispatchAction(UiApiActionsController.GetRecordEditActions,parameters);}function getRelatedListRecordActions(resourceRequest){const{urlParams:{recordId,relatedListRecordIds},queryParams}=resourceRequest;const parameters=buildUiApiParams(_objectSpread$5({recordId,relatedListRecordIds},queryParams),resourceRequest);return dispatchAction(UiApiActionsController.GetRelatedListRecordActions,parameters);}var UiApiListsController;(function(UiApiListsController){UiApiListsController["GetListsByObjectName"]="ListUiController.getListsByObjectName";UiApiListsController["GetListUiById"]="ListUiController.getListUiById";UiApiListsController["GetListRecordsById"]="ListUiController.getListRecordsById";UiApiListsController["GetListUiByName"]="ListUiController.getListUiByName";UiApiListsController["GetListRecordsByName"]="ListUiController.getListRecordsByName";})(UiApiListsController||(UiApiListsController={}));const UIAPI_LIST_RECORDS_PATH=`${UI_API_BASE_URI}/list-records/`;const UIAPI_LIST_UI_PATH=`${UI_API_BASE_URI}/list-ui/`;function getListRecordsByName(resourceRequest){const{urlParams:{objectApiName,listViewApiName},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({objectApiName,listViewApiName,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiListsController.GetListRecordsByName,params);}function getListRecordsById(resourceRequest){const{urlParams:{listViewId},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({listViewId,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiListsController.GetListRecordsById,params);}function getListUiByName(resourceRequest){const{urlParams:{objectApiName,listViewApiName},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({objectApiName,listViewApiName,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiListsController.GetListUiByName,params);}function getListUiById(resourceRequest){const{urlParams:{listViewId},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({listViewId,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiListsController.GetListUiById,params);}function getListsByObjectName(resourceRequest){const{urlParams:{objectApiName},queryParams:{pageSize,pageToken,q,recentListsOnly}}=resourceRequest;const params=buildUiApiParams({objectApiName,pageSize,pageToken,q,recentListsOnly},resourceRequest);return dispatchAction(UiApiListsController.GetListsByObjectName,params);}const UIAPI_LOOKUP_RECORDS=`${UI_API_BASE_URI}/lookups`;const LookupRecords='LookupController.getLookupRecords';function lookupRecords(resourceRequest){const{urlParams,queryParams}=resourceRequest;const params=buildUiApiParams(_objectSpread$5({},urlParams,queryParams),resourceRequest);return dispatchAction(LookupRecords,params);}var UiApiMruListsController;(function(UiApiMruListsController){UiApiMruListsController["GetMruListUi"]="MruListUiController.getMruListUi";UiApiMruListsController["GetMruListRecords"]="MruListUiController.getMruListRecords";})(UiApiMruListsController||(UiApiMruListsController={}));const UIAPI_MRU_LIST_RECORDS_PATH=`${UI_API_BASE_URI}/mru-list-records/`;const UIAPI_MRU_LIST_UI_PATH=`${UI_API_BASE_URI}/mru-list-ui/`;function getMruListRecords(resourceRequest){const{urlParams:{objectApiName},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({objectApiName,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiMruListsController.GetMruListRecords,params);}function getMruListUi(resourceRequest){const{urlParams:{objectApiName},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({objectApiName,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiMruListsController.GetMruListUi,params);}const NAMESPACE='lds';const STORE_STATS_MARK_NAME='store-stats';const RUNTIME_PERF_MARK_NAME='runtime-perf';/**
     * Aura Metrics Service plugin in charge of aggregating all the LDS performance marks before they
     * get sent to the server. All the marks are summed by operation type and the aggregated result
     * is then stored an a new mark.
     */const markAggregatorPlugin={name:NAMESPACE,enabled:true,initialize(){/* noop */},postProcess(marks){const postProcessedMarks=[];let shouldLogAggregated=false;const startTs={};const aggregated={};for(let i=0,len=marks.length;i<len;i++){const mark=marks[i];const{name,phase,ts}=mark;if(phase==='start'){startTs[name]=ts;}else if(phase==='end'){if(aggregated[name]===undefined){aggregated[name]=0;}shouldLogAggregated=true;aggregated[name]+=ts-startTs[name];}else {postProcessedMarks.push(mark);}}if(shouldLogAggregated){postProcessedMarks.push({ns:NAMESPACE,name:RUNTIME_PERF_MARK_NAME,phase:'stamp',ts:service.time(),context:aggregated});}return postProcessedMarks;}};function instrumentMethod(obj,methodNames){for(let i=0,len=methodNames.length;i<len;i++){const methodName=methodNames[i];const originalMethod=obj[methodName];obj[methodName]=function(...args){service.markStart(NAMESPACE,methodName);const res=originalMethod.call(this,...args);service.markEnd(NAMESPACE,methodName);return res;};}}function getStoreStats(store){const{records,snapshotSubscriptions,watchSubscriptions}=store;const recordCount=keys$4(records).length;const subscriptionCount=keys$4(snapshotSubscriptions).length+keys$4(watchSubscriptions).length;return {recordCount,subscriptionCount};}/**
     * Add a mark to the metrics service.
     *
     * @param name The mark name.
     * @param content The mark content.
     */function mark(name,content){service.mark(NAMESPACE,name,content);}/**
     * Create a new instrumentation cache stats and return it.
     *
     * @param name The cache logger name.
     */function registerLdsCacheStats(name){return service.registerCacheStats(`${NAMESPACE}:${name}`);}/**
     * Initialize the instrumentation and instrument the LDS instance and the Store.
     *
     * @param lds The LDS to instrument.
     * @param store The Store to instrument.
     */function setupInstrumentation(lds,store){service.registerPlugin({name:NAMESPACE,plugin:markAggregatorPlugin});instrumentMethod(lds,['storeLookup','storeIngest','storeBroadcast']);service.registerPeriodicLogger(NAMESPACE,()=>{const storeStats=getStoreStats(store);service.mark(NAMESPACE,STORE_STATS_MARK_NAME,storeStats);});}/**
     * Instrument an existing adapter that would logs the cache hits and misses.
     *
     * @param name The adapter name.
     * @param adapter The adapter function.
     * @returns The wrapped adapter.
     */function instrumentAdapter(name,adapter){const stats=registerLdsCacheStats(name);return config=>{const result=adapter(config);// In the case where the adapter returns a Snapshot it is constructed out of the store
    // (cache hit) whereas a Promise<Snapshot> indicates a network request (cache miss).
    //
    // Note: we can't do a plain instanceof check for a promise here since the Promise may
    // originate from another javascript realm (for example: in jest test). Instead we use a
    // duck-typing approach by checking is the result has a then property.
    //
    // For adapters without persistant store:
    //  - total cache hit ratio:
    //      [in-memory cache hit count] / ([in-memory cache hit count] + [in-memory cache miss count])
    // For adapters with persistant store:
    //  - in-memory cache hit ratio:
    //      [in-memory cache hit count] / ([in-memory cache hit count] + [in-memory cache miss count])
    //  - total cache hit ratio:
    //      ([in-memory cache hit count] + [store cache hit count]) / ([in-memory cache hit count] + [in-memory cache miss count])
    //
    if(result!==null&&result!==undefined&&'then'in result){stats.logMisses();}else {stats.logHits();}return result;};}// The VERSION environment variable is replaced by rollup during the bundling and replaces it with
    // the commit hash. This avoid having a cache hit on data that has been stored by a previous
    // version of LDS.
    const STORAGE_VERSION="ed123d04";// AuraStorage treats `secure` as a must-have whereas `persistent` is a nice-to-have. Secure and
    // persistent storage is only possible with CryptoAdapter. Availability of that adapter is
    // controlled by the application.
    const STORAGE_CONFIG={persistent:true,secure:true,maxSize:5*1024*1024,clearOnInit:false,debugLogging:false,version:STORAGE_VERSION};const STORAGE_INSTANCES=[];function createStorage(config){if(auraStorage.initStorage===undefined){return null;}const storageConfig=_objectSpread$5({},STORAGE_CONFIG,config);const storage=auraStorage.initStorage(storageConfig);if(!storage.isPersistent()){if(auraStorage.deleteStorage!==undefined){auraStorage.deleteStorage(storageConfig.name).catch(()=>{});// intentional noop on error
    }return null;}STORAGE_INSTANCES.push(storage);return storage;}function clearStorages(){return Promise.all(STORAGE_INSTANCES.map(storage=>storage.clear()));}var UiApiRecordController;(function(UiApiRecordController){UiApiRecordController["CreateRecord"]="RecordUiController.createRecord";UiApiRecordController["DeleteRecord"]="RecordUiController.deleteRecord";UiApiRecordController["ExecuteAggregateUi"]="RecordUiController.executeAggregateUi";UiApiRecordController["GetLayout"]="RecordUiController.getLayout";UiApiRecordController["GetLayoutUserState"]="RecordUiController.getLayoutUserState";UiApiRecordController["GetRecordAvatars"]="RecordUiController.getRecordAvatars";UiApiRecordController["GetRecordCreateDefaults"]="RecordUiController.getRecordCreateDefaults";UiApiRecordController["GetRecordUi"]="RecordUiController.getRecordUis";UiApiRecordController["GetRecordWithFields"]="RecordUiController.getRecordWithFields";UiApiRecordController["GetRecordWithLayouts"]="RecordUiController.getRecordWithLayouts";UiApiRecordController["GetObjectInfo"]="RecordUiController.getObjectInfo";UiApiRecordController["GetPicklistValues"]="RecordUiController.getPicklistValues";UiApiRecordController["GetPicklistValuesByRecordType"]="RecordUiController.getPicklistValuesByRecordType";UiApiRecordController["UpdateRecord"]="RecordUiController.updateRecord";UiApiRecordController["UpdateRecordAvatar"]="RecordUiController.postRecordAvatarAssociation";UiApiRecordController["UpdateLayoutUserState"]="RecordUiController.updateLayoutUserState";})(UiApiRecordController||(UiApiRecordController={}));const UIAPI_GET_LAYOUT=`${UI_API_BASE_URI}/layout/`;const UIAPI_RECORDS_PATH=`${UI_API_BASE_URI}/records`;const UIAPI_RECORD_AVATARS_BASE=`${UI_API_BASE_URI}/record-avatars/`;const UIAPI_RECORD_AVATARS_BATCH_PATH=`${UI_API_BASE_URI}/record-avatars/batch/`;const UIAPI_RECORD_AVATAR_UPDATE=`/association`;const UIAPI_RECORD_CREATE_DEFAULTS_PATH=`${UI_API_BASE_URI}/record-defaults/create/`;const UIAPI_RECORD_UI_PATH=`${UI_API_BASE_URI}/record-ui/`;const UIAPI_GET_LAYOUT_USER_STATE='/user-state';const UIAPI_OBJECT_INFO_PATH=`${UI_API_BASE_URI}/object-info/`;const objectInfoStorage=createStorage({name:'ldsObjectInfo',expiration:5*60});const objectInfoStorageStatsLogger=registerLdsCacheStats('getObjectInfo:storage');const layoutStorage=createStorage({name:'ldsLayout',expiration:15*60});const layoutStorageStatsLogger=registerLdsCacheStats('getLayout:storage');const layoutUserStateStorage=createStorage({name:'ldsLayoutUserState',expiration:15*60});const layoutUserStateStorageStatsLogger=registerLdsCacheStats('getLayoutUserState:storage');function getObjectInfo$1(resourceRequest,cacheKey){const params=buildUiApiParams({objectApiName:resourceRequest.urlParams.objectApiName},resourceRequest);const config=_objectSpread$5({},actionConfig);if(objectInfoStorage!==null){config.cache={storage:objectInfoStorage,key:cacheKey,statsLogger:objectInfoStorageStatsLogger,forceRefresh:shouldForceRefresh(resourceRequest)};}return dispatchAction(UiApiRecordController.GetObjectInfo,params,config);}function getRecord$1$1(resourceRequest){const{urlParams,queryParams}=resourceRequest;const{recordId}=urlParams;const{fields,layoutTypes,modes,optionalFields}=queryParams;let getRecordParams={};let controller;if(layoutTypes!==undefined){getRecordParams={recordId,layoutTypes,modes,optionalFields};controller=UiApiRecordController.GetRecordWithLayouts;}else {getRecordParams={recordId,fields,optionalFields};controller=UiApiRecordController.GetRecordWithFields;}const params=buildUiApiParams(getRecordParams,resourceRequest);return dispatchAction(controller,params,actionConfig);}function createRecord$1(resourceRequest){const params=buildUiApiParams({recordInput:resourceRequest.body},resourceRequest);return dispatchAction(UiApiRecordController.CreateRecord,params,actionConfig);}function deleteRecord$1(resourceRequest){const{urlParams}=resourceRequest;const params=buildUiApiParams({recordId:urlParams.recordId},resourceRequest);return dispatchAction(UiApiRecordController.DeleteRecord,params,actionConfig);}function updateRecord$1(resourceRequest){const{body,urlParams}=resourceRequest;const params=buildUiApiParams({recordId:urlParams.recordId,recordInput:body},resourceRequest);return dispatchAction(UiApiRecordController.UpdateRecord,params,actionConfig);}function updateLayoutUserState$1$1(resourceRequest){const{body,urlParams:{objectApiName},queryParams:{layoutType,mode,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,layoutType,mode,recordTypeId,userState:body},resourceRequest);return dispatchAction(UiApiRecordController.UpdateLayoutUserState,params,actionConfig).then(response=>{// TODO: Instead of surgically evicting the record that has been updated in the cache we
    // currently dump all the entries. We need a way to recreate the same cache key between
    // getLayoutUserState and updateLayoutUserState.
    if(layoutUserStateStorage!==null){layoutUserStateStorage.clear();}return response;});}function getRecordAvatars$1(resourceRequest){const{urlParams}=resourceRequest;const recordIds=urlParams.recordIds;const params=buildUiApiParams({recordIds},resourceRequest);return dispatchAction(UiApiRecordController.GetRecordAvatars,params,actionConfig);}function updateRecordAvatar$1(resourceRequest){const{urlParams,body}=resourceRequest;const params=buildUiApiParams({input:body,recordId:urlParams.recordId},resourceRequest);return dispatchAction(UiApiRecordController.UpdateRecordAvatar,params,actionConfig);}function getRecordUi$1(resourceRequest){const{urlParams:{recordIds},queryParams:{layoutTypes,modes,optionalFields}}=resourceRequest;const params=buildUiApiParams({layoutTypes,modes,optionalFields,recordIds},resourceRequest);return dispatchAction(UiApiRecordController.GetRecordUi,params,actionConfig);}function getPicklistValues$1(resourceRequest){const{urlParams}=resourceRequest;const params=buildUiApiParams({objectApiName:urlParams.objectApiName,recordTypeId:urlParams.recordTypeId,fieldApiName:urlParams.fieldApiName},resourceRequest);return dispatchAction(UiApiRecordController.GetPicklistValues,params,actionConfig);}function getPicklistValuesByRecordType$1(resourceRequest){const{urlParams:{objectApiName,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,recordTypeId},resourceRequest);return dispatchAction(UiApiRecordController.GetPicklistValuesByRecordType,params,actionConfig);}function getLayout$1(resourceRequest,cacheKey){const{urlParams:{objectApiName},queryParams:{layoutType,mode,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,layoutType,mode,recordTypeId},resourceRequest);const config=_objectSpread$5({},actionConfig);if(layoutStorage!==null){config.cache={storage:layoutStorage,key:cacheKey,statsLogger:layoutStorageStatsLogger,forceRefresh:shouldForceRefresh(resourceRequest)};}return dispatchAction(UiApiRecordController.GetLayout,params,config);}function getLayoutUserState$1(resourceRequest,cacheKey){const{urlParams:{objectApiName},queryParams:{layoutType,mode,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,layoutType,mode,recordTypeId},resourceRequest);const config=_objectSpread$5({},actionConfig);if(layoutUserStateStorage!==null){config.cache={storage:layoutUserStateStorage,key:cacheKey,statsLogger:layoutUserStateStorageStatsLogger,forceRefresh:shouldForceRefresh(resourceRequest)};}return dispatchAction(UiApiRecordController.GetLayoutUserState,params,config);}function getRecordCreateDefaults$1(resourceRequest){const{urlParams:{objectApiName},queryParams:{formFactor,optionalFields,recordTypeId}}=resourceRequest;const params=buildUiApiParams({objectApiName,formFactor,recordTypeId,optionalFields},resourceRequest);return dispatchAction(UiApiRecordController.GetRecordCreateDefaults,params,actionConfig);}var UiApiRecordController$1;(function(UiApiRecordController){UiApiRecordController["GetRelatedListInfo"]="RelatedListUiController.getRelatedListInfoByApiName";UiApiRecordController["GetRelatedListInfos"]="RelatedListUiController.getRelatedListInfoCollection";UiApiRecordController["GetRelatedListRecords"]="RelatedListUiController.getRelatedListRecords";})(UiApiRecordController$1||(UiApiRecordController$1={}));const UIAPI_RELATED_LIST_INFO_PATH=`${UI_API_BASE_URI}/related-list-info`;const UIAPI_RELATED_LIST_RECORDS_PATH=`${UI_API_BASE_URI}/related-list-records`;function getRelatedListInfo(resourceRequest){const{urlParams}=resourceRequest;const params=buildUiApiParams({parentObjectApiName:urlParams.parentObjectApiName,recordTypeId:urlParams.recordTypeId,relatedListId:urlParams.relatedListId},resourceRequest);return dispatchAction(UiApiRecordController$1.GetRelatedListInfo,params);}function getRelatedListInfos(resourceRequest){const{urlParams}=resourceRequest;const params=buildUiApiParams({parentObjectApiName:urlParams.parentObjectApiName,recordTypeId:urlParams.recordTypeId},resourceRequest);return dispatchAction(UiApiRecordController$1.GetRelatedListInfos,params);}function getRelatedListRecords(resourceRequest){const{urlParams:{parentRecordId,relatedListId},queryParams:{fields,optionalFields,pageSize,pageToken,sortBy}}=resourceRequest;const params=buildUiApiParams({parentRecordId:parentRecordId,relatedListId:relatedListId,fields,optionalFields,pageSize,pageToken,sortBy},resourceRequest);return dispatchAction(UiApiRecordController$1.GetRelatedListRecords,params);}function controllerInvokerFactory(resourceRequest){const{path,method}=resourceRequest;switch(method){case'delete':if(path.startsWith(UIAPI_RECORDS_PATH)){return deleteRecord$1;}break;case'post':if(path===UIAPI_RECORDS_PATH){return createRecord$1;}if(path===APEX_BASE_URI){return executeApex;}if(path.startsWith(UIAPI_RECORD_AVATARS_BASE)){if(path.endsWith(UIAPI_RECORD_AVATAR_UPDATE)){return updateRecordAvatar$1;}}break;case'patch':if(path.startsWith(UIAPI_RECORDS_PATH)){return updateRecord$1;}if(path.startsWith(UIAPI_GET_LAYOUT)){if(path.endsWith(UIAPI_GET_LAYOUT_USER_STATE)){return updateLayoutUserState$1$1;}}break;case'get':if(path.startsWith(UIAPI_ACTIONS_LOOKUP_PATH)){return getLookupActions$1;}if(path.startsWith(UIAPI_ACTIONS_RECORD_PATH)){if(path.endsWith(UIAPI_ACTIONS_RECORD_EDIT)){return getRecordEditActions;}else if(path.indexOf(UIAPI_ACTIONS_RELATED_LIST_RECORD)>0){return getRelatedListRecordActions;}else {return getRecordActions$1;}}if(path.startsWith(UIAPI_LIST_RECORDS_PATH)){if(/list-records\/.*\//.test(path)){// .../list-records/${objectApiName}/${listViewApiName}
    return getListRecordsByName;}else {// .../list-records/${listViewId}
    return getListRecordsById;}}if(path.startsWith(UIAPI_LIST_UI_PATH)){if(/list-ui\/.*\//.test(path)){// .../list-ui/${objectApiName}/${listViewApiName}
    return getListUiByName;}else if(/00B[a-zA-Z\d]{15}$/.test(path)){// .../list-ui/${listViewId}
    return getListUiById;}else {// .../list-ui/${objectApiName}
    return getListsByObjectName;}}if(path.startsWith(UIAPI_MRU_LIST_RECORDS_PATH)){return getMruListRecords;}if(path.startsWith(UIAPI_MRU_LIST_UI_PATH)){return getMruListUi;}if(path.startsWith(UIAPI_OBJECT_INFO_PATH)){// object-info/API_NAME/picklist-values/RECORD_TYPE_ID/FIELD_API_NAME
    if(/picklist-values\/[a-zA-Z\d]+\/[a-zA-Z\d]+/.test(path)){return getPicklistValues$1;// object-info/API_NAME/picklist-values/RECORD_TYPE_ID
    }else if(/picklist-values\/[a-zA-Z\d]+/.test(path)){return getPicklistValuesByRecordType$1;}return getObjectInfo$1;}if(path.startsWith(UIAPI_RECORDS_PATH)){return getRecord$1$1;}if(path.startsWith(UIAPI_RECORD_CREATE_DEFAULTS_PATH)){return getRecordCreateDefaults$1;}if(path.startsWith(UIAPI_RECORD_AVATARS_BATCH_PATH)){return getRecordAvatars$1;}if(path.startsWith(UIAPI_RECORD_UI_PATH)){return getRecordUi$1;}if(path.startsWith(UIAPI_LOOKUP_RECORDS)){return lookupRecords;}if(path.startsWith(UIAPI_GET_LAYOUT)){if(path.endsWith(UIAPI_GET_LAYOUT_USER_STATE)){return getLayoutUserState$1;}return getLayout$1;}if(path.startsWith(UIAPI_RELATED_LIST_INFO_PATH)){// related-list-info/API_NAME/RECORD_TYPE_ID/RELATED_LIST_ID
    if(/related-list-info\/[a-zA-Z_\d]+\/[a-zA-Z_\d]+\/[a-zA-Z_\d]+/.test(path)){return getRelatedListInfo;}return getRelatedListInfos;}if(path.startsWith(UIAPI_RELATED_LIST_RECORDS_PATH)){return getRelatedListRecords;}break;}throw new Error(`No invoker matching controller factory: ${path} ${method}.`);}function getFulfillingRequest(inflightRequests,resourceRequest){const{fulfill}=resourceRequest;if(fulfill===undefined){return null;}const handlersMap=entries(inflightRequests);for(let i=0,len=handlersMap.length;i<len;i+=1){const[transactionKey,handlers]=handlersMap[i];// check fulfillment against only the first handler ([0]) because it's equal or
    // fulfills all subsequent handlers in the array
    const existing=handlers[0].resourceRequest;if(fulfill(existing,resourceRequest)===true){return transactionKey;}}return null;}function getTransactionKey(resourceRequest){const{path,key,queryParams,headers}=resourceRequest;return `${path}::${stringify$4(headers)}::${queryParams?stringify$4(queryParams):''}::${key}`;}const inflightRequests=Object.create(null);function networkAdapter(resourceRequest){const{method}=resourceRequest;const transactionKey=getTransactionKey(resourceRequest);const controllerInvoker=controllerInvokerFactory(resourceRequest);if(method!=='get'){return controllerInvoker(resourceRequest,transactionKey);}// if an identical request is in-flight then queue for its response (do not re-issue the request)
    if(transactionKey in inflightRequests){return new Promise((resolve,reject)=>{push$2.call(inflightRequests[transactionKey],{resolve,reject,resourceRequest});});}// fallback to checking a custom deduper to find a similar (but not identical) request
    const similarTransactionKey=getFulfillingRequest(inflightRequests,resourceRequest);if(similarTransactionKey!==null){return new Promise(resolve=>{// custom dedupers find similar (not identical) requests. if the similar request fails
    // there's no guarantee the deduped request should fail. thus we re-issue the
    // original request in the case of a failure
    function reissueRequest(){resolve(networkAdapter(resourceRequest));}push$2.call(inflightRequests[similarTransactionKey],{resolve,reject:reissueRequest,resourceRequest});});}// not a duplicate request so invoke the network
    // when it resolves, clear the queue then invoke queued handlers
    // (must clear the queue first in case handlers re-invoke the network)
    controllerInvoker(resourceRequest,transactionKey).then(response=>{const handlers=inflightRequests[transactionKey];delete inflightRequests[transactionKey];// handlers mutate responses so must clone the response for each.
    // the first handler is given the original version to avoid an
    // extra clone (particularly when there's only 1 handler).
    for(let i=1,len=handlers.length;i<len;i++){const handler=handlers[i];handler.resolve(parse$1(stringify$4(response)));}handlers[0].resolve(response);},error=>{const handlers=inflightRequests[transactionKey];delete inflightRequests[transactionKey];for(let i=0,len=handlers.length;i<len;i++){const handler=handlers[i];handler.reject(error);}});// rely on sync behavior of Promise creation to create the list for handlers
    return new Promise((resolve,reject)=>{inflightRequests[transactionKey]=[{resolve,reject,resourceRequest}];});}const OBJECT_INFO_PREFIX='UiApi::ObjectInfoRepresentation:';const STORAGE_DROP_MARK_NAME='storage-drop';const STORAGE_DROP_MARK_CONTEXT={reason:'Object info changed'};/**
     * Watch an LDS instance for metadata changes.
     */function setupMetadataWatcher(lds){// Watch for object info changes. Since we don't have enough information to understand to which
    // extent an object info change may impact the application the only thing we do is to clear all
    // the  persistent storages.
    lds.storeWatch(OBJECT_INFO_PREFIX,entries=>{for(let i=0,len=entries.length;i<len;i++){const entry=entries[i];const isObjectInfoUpdated=entry.inserted===false;if(isObjectInfoUpdated){mark(STORAGE_DROP_MARK_NAME,STORAGE_DROP_MARK_CONTEXT);clearStorages().catch(()=>{/* noop */});break;}}});}const store=new Store();const lds=new LDS(store,networkAdapter);setupInstrumentation(lds,store);setupMetadataWatcher(lds);/** Create a new LDS adapter from an adapter factory. */const createLdsAdapter=(name,factory)=>{return instrumentAdapter(name,factory(lds));};/** Register an LDS adapter to the LWC Wire Service */const registerWireAdapter=adapter=>{return register(lds,wireService,adapter);};/** Create and register an LDS adapter factory. */const setupWireAdapter=(name,factory)=>{const adapter=createLdsAdapter(name,factory);return registerWireAdapter(adapter);};/**
     * UI API
     */ /* TODO W-6568533 - replace this temporary imperative invocation with wire reform */const getObjectInfoLdsAdapter=createLdsAdapter('getObjectInfo',getObjectInfoAdapterFactory);const _getObjectInfo$1=config=>{getObjectInfoLdsAdapter(config);};const getLayoutLdsAdapter=createLdsAdapter('getLayout',factory$2);const _getLayout$1=config=>{getLayoutLdsAdapter(config);};const getRecordLdsAdapter=createLdsAdapter('getRecord',factory$7);const _getRecord$1=config=>{const result=getRecordLdsAdapter(config);if(result===null){return Promise.reject(new Error('Insufficient config'));}else if('then'in result){return result.then(snapshot=>{if(snapshot.state==='Error'){throw snapshot.error;}return snapshot.data;});}else if(result.state==='Fulfilled'){return Promise.resolve(result.data);}return Promise.reject(new Error('isMissingData=true'));};const getRecordActionsLdsAdapter=getRecordActionsAdapterFactory(lds);const _getRecordActions$1=config=>{getRecordActionsLdsAdapter(config);};const getRecordAvatarsLdsAdapter=createLdsAdapter('getRecordAvatars',factory$8);const _getRecordAvatars$1=config=>{getRecordAvatarsLdsAdapter(config);};const getRecordUiLdsAdapter=createLdsAdapter('getRecordUi',factory$6);const _getRecordUi$1=config=>{getRecordUiLdsAdapter(config);};const getLayoutUserStateLdsAdapter=createLdsAdapter('getLayoutUserState',factory$3);const _getLayoutUserState$1=config=>{getLayoutUserStateLdsAdapter(config);};const baseCreateRecord=factory$1(lds);const createRecord$1$1=(...config)=>{return baseCreateRecord(...config).then(snapshot=>snapshot.data);};const deleteRecord$1$1=factory$1$1(lds);const getLayout$1$1=registerWireAdapter(getLayoutLdsAdapter);const getLayoutUserState$1$1=registerWireAdapter(getLayoutUserStateLdsAdapter);const getListUi$1=setupWireAdapter('getListUi',factory$4);const getLookupActions$1$1=setupWireAdapter('getLookupActions',getLookupActionsAdapterFactory);const getLookupRecords$1=setupWireAdapter('getLookupRecords',factory$5);const getObjectInfo$1$1=registerWireAdapter(getObjectInfoLdsAdapter);const getPicklistValues$1$1=setupWireAdapter('getPicklistValues',factory$9);const getPicklistValuesByRecordType$1$1=setupWireAdapter('getPicklistValuesByRecordType',factory$a);const getRecord$2=registerWireAdapter(getRecordLdsAdapter);const getRecordActions$1$1=registerWireAdapter(getRecordActionsLdsAdapter);const getRecordAvatars$1$1=registerWireAdapter(getRecordAvatarsLdsAdapter);const getRecordCreateDefaults$1$1=setupWireAdapter('getRecordCreateDefaults',factory$e);const getRecordUi$1$1=registerWireAdapter(getRecordUiLdsAdapter);const baseUpdateRecord=factory$b(lds);const updateRecord$1$1=(...config)=>{return baseUpdateRecord(...config).then(snapshot=>snapshot.data);};const baseUpdateRecordAvatar=factory$d(lds);const updateRecordAvatar$1$1=(...config)=>{return baseUpdateRecordAvatar(...config).then(snapshot=>snapshot.data);};// updateLayoutUserState adapter should always return undefined
    const baseUpdateLayoutUserState=factory$c(lds);const updateLayoutUserState$2=(apiName,recordTypeId,layoutType,mode,layoutUserStateInput)=>{return baseUpdateLayoutUserState(apiName,recordTypeId,layoutType,mode,layoutUserStateInput).then(()=>undefined);};/**
     * Apex
     */const getApexInvoker$1=function(namespace,classname,method,isContinuation){const identifier=invoker(lds,{namespace,classname,method,isContinuation});return register(lds,wireService,factory(lds,{namespace,classname,method,isContinuation}),identifier);};/**
     * Misc.
     */const refresh$1=bindWireRefresh(lds);const adsBridge$1=new AdsBridge$1(lds);var lds224=/*#__PURE__*/Object.freeze({__proto__:null,_getObjectInfo:_getObjectInfo$1,_getLayout:_getLayout$1,_getRecord:_getRecord$1,_getRecordActions:_getRecordActions$1,_getRecordAvatars:_getRecordAvatars$1,_getRecordUi:_getRecordUi$1,getLayoutUserStateLdsAdapter:getLayoutUserStateLdsAdapter,_getLayoutUserState:_getLayoutUserState$1,createRecord:createRecord$1$1,deleteRecord:deleteRecord$1$1,getLayout:getLayout$1$1,getLayoutUserState:getLayoutUserState$1$1,getListUi:getListUi$1,getLookupActions:getLookupActions$1$1,getLookupRecords:getLookupRecords$1,getObjectInfo:getObjectInfo$1$1,getPicklistValues:getPicklistValues$1$1,getPicklistValuesByRecordType:getPicklistValuesByRecordType$1$1,getRecord:getRecord$2,getRecordActions:getRecordActions$1$1,getRecordAvatars:getRecordAvatars$1$1,getRecordCreateDefaults:getRecordCreateDefaults$1$1,getRecordUi:getRecordUi$1$1,updateRecord:updateRecord$1$1,updateRecordAvatar:updateRecordAvatar$1$1,updateLayoutUserState:updateLayoutUserState$2,MRU:MRU$1,getApexInvoker:getApexInvoker$1,refresh:refresh$1,adsBridge:adsBridge$1,createRecordInputFilteredByEditedFields:createRecordInputFilteredByEditedFields$1,generateRecordInputForCreate:generateRecordInputForCreate$1,generateRecordInputForUpdate:generateRecordInputForUpdate$1,getFieldDisplayValue:getFieldDisplayValue$1,getRecordInput:getRecordInput$1,getFieldValue:getFieldValue$1,getSObjectValue:getSObjectValue$1});/**
     * LDS222 and LDS224 are bundled together. Which is exported and therefore used relies on the
     * following list of rules. The first match wins.
     *    - the URL query string contains "lds224" -> use LDS224
     *    - the URL query string contains "lds222" -> use LDS222
     *    - the "com.salesforce.lds.lds224" gate is enabled -> use LDS224
     *    - else -> use LDS222
     *
     * Note: LEX takes control over the query params and removes query strings from the URL during
     * navigation. Instead of using `?lds224` use `?0.lds224` as the query string, which will not
     * get stripped by LEX.
     */function isLds224Enabled(window){if(window.location.search.includes('lds224')===true){return true;}else if(window.location.search.includes('lds222')===true){return false;}else if(typeof window.$A!=='undefined'){return !!window.$A.get('$Browser.S1Features.isLds224Enabled');}return false;}const IS_LDS_224_ENABLED$1=isLds224Enabled(window);const LDS_MODULE=IS_LDS_224_ENABLED$1?lds224:lds222;/** UI API exports */const createRecord$2=LDS_MODULE.createRecord;const deleteRecord$2=LDS_MODULE.deleteRecord;const getLayout$2=LDS_MODULE.getLayout;const getLayoutUserState$2=LDS_MODULE.getLayoutUserState;const getListUi$1$1=LDS_MODULE.getListUi;const getLookupActions$2=LDS_MODULE.getLookupActions;const getLookupRecords$1$1=LDS_MODULE.getLookupRecords;const getObjectInfo$2=LDS_MODULE.getObjectInfo;const getPicklistValues$2=LDS_MODULE.getPicklistValues;const getPicklistValuesByRecordType$2=LDS_MODULE.getPicklistValuesByRecordType;const getRecord$3=LDS_MODULE.getRecord;const getRecordActions$2=LDS_MODULE.getRecordActions;const getRecordAvatars$2=LDS_MODULE.getRecordAvatars;const getRecordCreateDefaults$2=LDS_MODULE.getRecordCreateDefaults;const getRecordUi$2=LDS_MODULE.getRecordUi;const MRU$1$1=LDS_MODULE.MRU;const refresh$2=LDS_MODULE.refresh;const updateLayoutUserState$3=LDS_MODULE.updateLayoutUserState;const updateRecord$2=LDS_MODULE.updateRecord;const updateRecordAvatar$2=LDS_MODULE.updateRecordAvatar;/** Apex exports */const getApexInvoker$1$1=LDS_MODULE.getApexInvoker;const getSObjectValue$2=LDS_MODULE.getSObjectValue;/** Record Util Pure Functions */const createRecordInputFilteredByEditedFields$2=LDS_MODULE.createRecordInputFilteredByEditedFields;const generateRecordInputForCreate$2=LDS_MODULE.generateRecordInputForCreate;const generateRecordInputForUpdate$2=LDS_MODULE.generateRecordInputForUpdate;const getFieldDisplayValue$2=LDS_MODULE.getFieldDisplayValue;const getFieldValue$2=LDS_MODULE.getFieldValue;const getRecordInput$2=LDS_MODULE.getRecordInput;/** Misc exports */const adsBridge$1$1=LDS_MODULE.adsBridge;// TODO W-6568533 - replace this temporary imperative invocation with wire reform
    const _getLayout$1$1=LDS_MODULE._getLayout;const _getLayoutUserState$1$1=LDS_MODULE._getLayoutUserState;const _getObjectInfo$1$1=LDS_MODULE._getObjectInfo;const _getRecord$1$1=LDS_MODULE._getRecord;const _getRecordActions$1$1=LDS_MODULE._getRecordActions;const _getRecordAvatars$1$1=LDS_MODULE._getRecordAvatars;const _getRecordUi$1$1=LDS_MODULE._getRecordUi;// TODO W-6686144 - remove exposure of version, metrics service usage and display in badge
    // version: 0.1.0-ed123d04

    const apexInvoker = getApexInvoker$1$1("", "Accounts_Controller", "getAccounts", false);

    const apexInvoker$1 = getApexInvoker$1$1("", "Accounts_Controller", "getSearchedContacts", false);

    class ListOfAccounts extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.pageSize = 6;
        this.pageList = [];
        this.orginalData = void 0;
        this.startPage = void 0;
        this.endPage = void 0;
        this.totalNoOfRecs = void 0;
        this.showModal = void 0;
        this.data = void 0;
        this.error = void 0;
        this.columns = [{
          label: 'Name',
          type: 'text',
          fieldName: 'Name'
        }, {
          label: 'Number Of Employees',
          type: 'number',
          fieldName: 'NumberOfEmployees'
        }, {
          label: 'Number of Contacts',
          type: 'number',
          fieldName: 'Number_of_Contacts__c'
        }];
      }

      getAccounts({
        error,
        data
      }) {
        //console.log("lwc accounts data before if"+JSON.stringify(error));
        if (data) {
          console.log("lwc accounts data before" + JSON.stringify(data));
          this.data = data;
          this.orginalData = data;
          this.totalNoOfRecs = data.length;
          this.startPage = 0;
          this.endPage = this.pageSize - 1;
          this.pageList = [];
          console.log("pageList " + this.pageList);
          console.log("data length" + data.length);

          if (data.length > 0) {
            for (var i = 0; i < this.pageSize; i++) {
              if (data.length > i) {
                this.pageList.push(data[i]);
              }
            }
          }

          console.log("lwc accounts data after" + JSON.stringify(this.data));
        } else {
          this.error = error;
        }
      }

      searchAccount(evt) {
        console.log("in side searchAccount");
        this.showModal = false;
        const isEnterKey = evt.keyCode === 13;

        if (isEnterKey) {
          console.log("in side enterkey");
          this.queryTerm = evt.target.value;
          apexInvoker$1({
            searchKey: this.queryTerm
          }).then(result => {
            console.log("in side result" + JSON.stringify(result));
            this.data = result;
            this.orginalData = result;
            this.totalNoOfRecs = result.length;
            this.startPage = 0;
            this.endPage = this.pageSize - 1;
            this.pageList = [];

            if (result.length > 0) {
              for (var i = 0; i < this.pageSize; i++) {
                if (result.length > i) {
                  this.pageList.push(result[i]);
                }
              }
            } //this.data = result;

          }).catch(error => {
            console.log("in side error" + JSON.stringify(error));
            this.error = error;
          });
        }
      }

      previous() {
        console.log("in previous");
        this.pageList = [];
        var counter = 0;

        for (var i = this.startPage - this.pageSize; i < this.startPage; i++) {
          if (i > -1) {
            this.pageList.push(this.data[i]);
            counter++;
          } else {
            this.startPage++;
          }
        }

        this.startPage = this.startPage - counter;
        this.endPage = this.endPage - counter;
      }

      next() {
        console.log("in next");
        this.pageList = [];
        var counter = 0;

        for (var i = this.endPage + 1; i < this.endPage + this.pageSize + 1; i++) {
          if (this.data.length > i) {
            this.pageList.push(this.data[i]);
          }

          counter++;
        }

        this.startPage = this.startPage + counter;
        this.endPage = this.endPage + counter;
      }

      get validPrevious() {
        return this.startPage == 0 ? true : false;
      }

      get validNext() {
        return this.endPage + 1 >= this.totalNoOfRecs ? true : false;
      }

      get showError() {
        return this.pageList.length > 0 ? false : true;
      }

      showAccountModal() {
        this.showModal = !this.showModal;
      }

    }

    lwc.registerDecorators(ListOfAccounts, {
      wire: {
        getAccounts: {
          adapter: apexInvoker,
          method: 1
        }
      },
      fields: ["pageSize", "pageList", "orginalData", "startPage", "endPage", "totalNoOfRecs", "showModal", "data", "error", "columns"]
    });

    var listOfAccounts = lwc.registerComponent(ListOfAccounts, {
      tmpl: _tmpl$J
    });

    return listOfAccounts;

});
